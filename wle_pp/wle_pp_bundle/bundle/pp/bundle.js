var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// dist/pp/index.js
var index_exports = {};
__export(index_exports, {
  AddPPToWindowComponent: () => AddPPToWindowComponent,
  AddWLToWindowComponent: () => AddWLToWindowComponent,
  AdjustHierarchyPhysXScaleComponent: () => AdjustHierarchyPhysXScaleComponent,
  AnalyticsManager: () => AnalyticsManager,
  AnalyticsManagerComponent: () => AnalyticsManagerComponent,
  AnalyticsUtils: () => AnalyticsUtils,
  AnimatedNumber: () => AnimatedNumber,
  AnimatedNumberParams: () => AnimatedNumberParams,
  ArrayExtensionUtils: () => ArrayExtensionUtils,
  ArrayUtils: () => ArrayUtils,
  AudioEvent: () => AudioEvent,
  AudioManager: () => AudioManager,
  AudioManagerComponent: () => AudioManagerComponent,
  AudioPlayer: () => AudioPlayer,
  AudioSetup: () => AudioSetup,
  AudioUtils: () => AudioUtils,
  BaseConditionState: () => BaseConditionState,
  BasePose: () => BasePose,
  BasePoseParams: () => BasePoseParams,
  BenchmarkMaxPhysXComponent: () => BenchmarkMaxPhysXComponent,
  BenchmarkMaxVisibleTrianglesComponent: () => BenchmarkMaxVisibleTrianglesComponent,
  BranchState: () => BranchState,
  BrowserUtils: () => BrowserUtils,
  CADisplayLeaderboardComponent: () => CADisplayLeaderboardComponent,
  CADummyServer: () => CADummyServer,
  CAError: () => CAError,
  CAUtils: () => CAUtils,
  CharacterColliderAdditionalParams: () => CharacterColliderAdditionalParams,
  CharacterColliderDebugParams: () => CharacterColliderDebugParams,
  CharacterColliderHorizontalCheckParams: () => CharacterColliderHorizontalCheckParams,
  CharacterColliderHorizontalPositionVerticalCheckDirection: () => CharacterColliderHorizontalPositionVerticalCheckDirection,
  CharacterColliderSetup: () => CharacterColliderSetup,
  CharacterColliderSetupSimplifiedCreationAccuracyLevel: () => CharacterColliderSetupSimplifiedCreationAccuracyLevel,
  CharacterColliderSetupSimplifiedCreationParams: () => CharacterColliderSetupSimplifiedCreationParams,
  CharacterColliderSetupUtils: () => CharacterColliderSetupUtils,
  CharacterColliderSlideFlickerPreventionMode: () => CharacterColliderSlideFlickerPreventionMode,
  CharacterColliderSplitMovementParams: () => CharacterColliderSplitMovementParams,
  CharacterColliderSurfaceParams: () => CharacterColliderSurfaceParams,
  CharacterColliderVerticalCheckParams: () => CharacterColliderVerticalCheckParams,
  CharacterColliderWallSlideParams: () => CharacterColliderWallSlideParams,
  CharacterCollisionCheckTransformResults: () => CharacterCollisionCheckTransformResults,
  CharacterCollisionCheckType: () => CharacterCollisionCheckType,
  CharacterCollisionDebugResults: () => CharacterCollisionDebugResults,
  CharacterCollisionInternalResults: () => CharacterCollisionInternalResults,
  CharacterCollisionMovementResults: () => CharacterCollisionMovementResults,
  CharacterCollisionResults: () => CharacterCollisionResults,
  CharacterCollisionSplitMovementResults: () => CharacterCollisionSplitMovementResults,
  CharacterCollisionSurfaceInfo: () => CharacterCollisionSurfaceInfo,
  CharacterCollisionSurfaceResults: () => CharacterCollisionSurfaceResults,
  CharacterCollisionSystem: () => CharacterCollisionSystem,
  CharacterCollisionSystemComponent: () => CharacterCollisionSystemComponent,
  CharacterCollisionTeleportResults: () => CharacterCollisionTeleportResults,
  CharacterCollisionTransformResults: () => CharacterCollisionTransformResults,
  CharacterCollisionWallSlideResults: () => CharacterCollisionWallSlideResults,
  CharacterControllerUtils: () => CharacterControllerUtils,
  ClassicGamepadCore: () => ClassicGamepadCore,
  ClearConsoleComponent: () => ClearConsoleComponent,
  CollisionCheck: () => CollisionCheck,
  CollisionCheckBridge: () => CollisionCheckBridge,
  CollisionCheckParams: () => CollisionCheckParams,
  CollisionCheckUtils: () => CollisionCheckUtils,
  CollisionRuntimeParams: () => CollisionRuntimeParams,
  ColorModel: () => ColorModel,
  ColorUtils: () => ColorUtils,
  ComponentCustomCloneParams: () => ComponentCustomCloneParams,
  ComponentDeepCloneParams: () => ComponentDeepCloneParams,
  ComponentUtils: () => ComponentUtils,
  ConditionState: () => ConditionState,
  ConsoleOriginalFunctions: () => ConsoleOriginalFunctions,
  ConsoleVR: () => ConsoleVR,
  ConsoleVRToolComponent: () => ConsoleVRToolComponent,
  ConsoleVRWidget: () => ConsoleVRWidget,
  ConsoleVRWidgetConfig: () => ConsoleVRWidgetConfig,
  ConsoleVRWidgetConsoleFunction: () => ConsoleVRWidgetConsoleFunction,
  ConsoleVRWidgetMessage: () => ConsoleVRWidgetMessage,
  ConsoleVRWidgetMessageType: () => ConsoleVRWidgetMessageType,
  ConsoleVRWidgetParams: () => ConsoleVRWidgetParams,
  ConsoleVRWidgetPulseOnNewMessage: () => ConsoleVRWidgetPulseOnNewMessage,
  ConsoleVRWidgetSender: () => ConsoleVRWidgetSender,
  ConsoleVRWidgetUI: () => ConsoleVRWidgetUI,
  CopyHandTransformComponent: () => CopyHandTransformComponent,
  CopyHeadTransformComponent: () => CopyHeadTransformComponent,
  CopyPlayerTransformComponent: () => CopyPlayerTransformComponent,
  CopyReferenceSpaceTransformComponent: () => CopyReferenceSpaceTransformComponent,
  CursorButtonComponent: () => CursorButtonComponent,
  DebugArrayFunctionsPerformanceAnalyzerComponent: () => DebugArrayFunctionsPerformanceAnalyzerComponent,
  DebugFunctionPerformanceAnalysisResults: () => DebugFunctionPerformanceAnalysisResults,
  DebugFunctionsOverwriter: () => DebugFunctionsOverwriter,
  DebugFunctionsOverwriterParams: () => DebugFunctionsOverwriterParams,
  DebugFunctionsPerformanceAnalysisResultsLogger: () => DebugFunctionsPerformanceAnalysisResultsLogger,
  DebugFunctionsPerformanceAnalysisResultsLoggerParams: () => DebugFunctionsPerformanceAnalysisResultsLoggerParams,
  DebugFunctionsPerformanceAnalyzer: () => DebugFunctionsPerformanceAnalyzer,
  DebugFunctionsPerformanceAnalyzerComponent: () => DebugFunctionsPerformanceAnalyzerComponent,
  DebugFunctionsPerformanceAnalyzerParams: () => DebugFunctionsPerformanceAnalyzerParams,
  DebugFunctionsPerformanceAnalyzerSortOrder: () => DebugFunctionsPerformanceAnalyzerSortOrder,
  DebugManager: () => DebugManager,
  DebugManagerComponent: () => DebugManagerComponent,
  DebugPPArrayCreationPerformanceAnalyzerComponent: () => DebugPPArrayCreationPerformanceAnalyzerComponent,
  DebugPPFunctionsPerformanceAnalyzerComponent: () => DebugPPFunctionsPerformanceAnalyzerComponent,
  DebugTransformComponent: () => DebugTransformComponent,
  DebugVisualManager: () => DebugVisualManager,
  DebugWLComponentsFunctionsPerformanceAnalyzerComponent: () => DebugWLComponentsFunctionsPerformanceAnalyzerComponent,
  DebugWLFunctionsPerformanceAnalyzerComponent: () => DebugWLFunctionsPerformanceAnalyzerComponent,
  DefaultResources: () => DefaultResources,
  DefaultResourcesMaterials: () => DefaultResourcesMaterials,
  DefaultResourcesMeshes: () => DefaultResourcesMeshes,
  DelayState: () => DelayState,
  Direction2DTo3DConverter: () => Direction2DTo3DConverter,
  Direction2DTo3DConverterParams: () => Direction2DTo3DConverterParams,
  EasingFunction: () => EasingFunction,
  EasingFunctionName: () => EasingFunctionName,
  EasyActive: () => EasyActive,
  EasyActiveComponent: () => EasyActiveComponent,
  EasyLightAttenuation: () => EasyLightAttenuation,
  EasyLightAttenuationComponent: () => EasyLightAttenuationComponent,
  EasyLightColor: () => EasyLightColor,
  EasyLightColorComponent: () => EasyLightColorComponent,
  EasyMeshColor: () => EasyMeshColor,
  EasyMeshColorColorType: () => EasyMeshColorColorType,
  EasyMeshColorComponent: () => EasyMeshColorComponent,
  EasyObjectTuner: () => EasyObjectTuner,
  EasyScale: () => EasyScale,
  EasyScaleComponent: () => EasyScaleComponent,
  EasySetTuneTargeetGrabComponent: () => EasySetTuneTargeetGrabComponent,
  EasySetTuneTargetChildNumberComponent: () => EasySetTuneTargetChildNumberComponent,
  EasyTextColor: () => EasyTextColor,
  EasyTextColorColorType: () => EasyTextColorColorType,
  EasyTextColorComponent: () => EasyTextColorComponent,
  EasyTransform: () => EasyTransform,
  EasyTransformComponent: () => EasyTransformComponent,
  EasyTuneBaseArrayWidgetSelector: () => EasyTuneBaseArrayWidgetSelector,
  EasyTuneBaseWidget: () => EasyTuneBaseWidget,
  EasyTuneBaseWidgetConfig: () => EasyTuneBaseWidgetConfig,
  EasyTuneBaseWidgetParams: () => EasyTuneBaseWidgetParams,
  EasyTuneBaseWidgetUI: () => EasyTuneBaseWidgetUI,
  EasyTuneBool: () => EasyTuneBool,
  EasyTuneBoolArray: () => EasyTuneBoolArray,
  EasyTuneBoolArrayWidget: () => EasyTuneBoolArrayWidget,
  EasyTuneBoolArrayWidgetConfig: () => EasyTuneBoolArrayWidgetConfig,
  EasyTuneBoolArrayWidgetSelector: () => EasyTuneBoolArrayWidgetSelector,
  EasyTuneBoolArrayWidgetUI: () => EasyTuneBoolArrayWidgetUI,
  EasyTuneImportVariablesComponent: () => EasyTuneImportVariablesComponent,
  EasyTuneInt: () => EasyTuneInt,
  EasyTuneIntArray: () => EasyTuneIntArray,
  EasyTuneNoneWidget: () => EasyTuneNoneWidget,
  EasyTuneNoneWidgetConfig: () => EasyTuneNoneWidgetConfig,
  EasyTuneNoneWidgetUI: () => EasyTuneNoneWidgetUI,
  EasyTuneNumber: () => EasyTuneNumber,
  EasyTuneNumberArray: () => EasyTuneNumberArray,
  EasyTuneNumberArrayWidget: () => EasyTuneNumberArrayWidget,
  EasyTuneNumberArrayWidgetConfig: () => EasyTuneNumberArrayWidgetConfig,
  EasyTuneNumberArrayWidgetSelector: () => EasyTuneNumberArrayWidgetSelector,
  EasyTuneNumberArrayWidgetUI: () => EasyTuneNumberArrayWidgetUI,
  EasyTuneToolComponent: () => EasyTuneToolComponent,
  EasyTuneTransform: () => EasyTuneTransform,
  EasyTuneTransformWidget: () => EasyTuneTransformWidget,
  EasyTuneTransformWidgetConfig: () => EasyTuneTransformWidgetConfig,
  EasyTuneTransformWidgetUI: () => EasyTuneTransformWidgetUI,
  EasyTuneUtils: () => EasyTuneUtils,
  EasyTuneVariable: () => EasyTuneVariable,
  EasyTuneVariableArray: () => EasyTuneVariableArray,
  EasyTuneVariableExtraParams: () => EasyTuneVariableExtraParams,
  EasyTuneVariableType: () => EasyTuneVariableType,
  EasyTuneVariableTyped: () => EasyTuneVariableTyped,
  EasyTuneVariables: () => EasyTuneVariables,
  EasyTuneWidget: () => EasyTuneWidget,
  EasyTuneWidgetConfig: () => EasyTuneWidgetConfig,
  EasyTuneWidgetParams: () => EasyTuneWidgetParams,
  EnableDebugComponent: () => EnableDebugComponent,
  EnableToolComponent: () => EnableToolComponent,
  FSM: () => FSM,
  FingerCursorComponent: () => FingerCursorComponent,
  FramesCountdownState: () => FramesCountdownState,
  Gamepad: () => Gamepad,
  GamepadAxesEvent: () => GamepadAxesEvent,
  GamepadAxesID: () => GamepadAxesID,
  GamepadAxesInfo: () => GamepadAxesInfo,
  GamepadButtonEvent: () => GamepadButtonEvent,
  GamepadButtonID: () => GamepadButtonID,
  GamepadButtonInfo: () => GamepadButtonInfo,
  GamepadControlSchemeComponent: () => GamepadControlSchemeComponent,
  GamepadCore: () => GamepadCore,
  GamepadMeshAnimatorComponent: () => GamepadMeshAnimatorComponent,
  GamepadPulseInfo: () => GamepadPulseInfo,
  GamepadUtils: () => GamepadUtils,
  GamepadsManager: () => GamepadsManager,
  GetDefaultResourcesComponent: () => GetDefaultResourcesComponent,
  GetSceneObjectsComponent: () => GetSceneObjectsComponent,
  Globals: () => Globals,
  GrabbableComponent: () => GrabbableComponent,
  GrabberHandComponent: () => GrabberHandComponent,
  HandPose: () => HandPose,
  HandPoseParams: () => HandPoseParams,
  HandRayPose: () => HandRayPose,
  HandRayPoseParams: () => HandRayPoseParams,
  Handedness: () => Handedness,
  HandednessIndex: () => HandednessIndex,
  HeadPose: () => HeadPose,
  HowlerAudioPlayer: () => HowlerAudioPlayer,
  InitConsoleVRComponent: () => InitConsoleVRComponent,
  InitEasyTuneVariablesComponent: () => InitEasyTuneVariablesComponent,
  InputManager: () => InputManager,
  InputManagerComponent: () => InputManagerComponent,
  InputSourceType: () => InputSourceType,
  InputUtils: () => InputUtils,
  IntOverFactor: () => IntOverFactor,
  IntRangeOverFactor: () => IntRangeOverFactor,
  JSUtils: () => JSUtils,
  KeyID: () => KeyID,
  Keyboard: () => Keyboard,
  KeyboardGamepadCore: () => KeyboardGamepadCore,
  Mat3Utils: () => Mat3Utils,
  Mat4Utils: () => Mat4Utils,
  MaterialUtils: () => MaterialUtils,
  MathUtils: () => MathUtils,
  MeshCreationParams: () => MeshCreationParams,
  MeshCreationTriangleParams: () => MeshCreationTriangleParams,
  MeshCreationVertexParams: () => MeshCreationVertexParams,
  MeshUtils: () => MeshUtils,
  Mouse: () => Mouse,
  MouseButtonID: () => MouseButtonID,
  MuteEverythingComponent: () => MuteEverythingComponent,
  NonVRReferenceSpaceMode: () => NonVRReferenceSpaceMode,
  NumberOverFactor: () => NumberOverFactor,
  NumberRangeOverFactor: () => NumberRangeOverFactor,
  ObjectCloneParams: () => ObjectCloneParams,
  ObjectPool: () => ObjectPool,
  ObjectPoolManager: () => ObjectPoolManager,
  ObjectPoolManagerComponent: () => ObjectPoolManagerComponent,
  ObjectPoolParams: () => ObjectPoolParams,
  ObjectUtils: () => ObjectUtils,
  OverlapCursorComponent: () => OverlapCursorComponent,
  OverrideBrowserConsoleFunctions: () => OverrideBrowserConsoleFunctions,
  PPGatewayComponent: () => PPGatewayComponent,
  PendingPerform: () => PendingPerform,
  PerformDelayedMode: () => PerformDelayedMode,
  PerformMode: () => PerformMode,
  PhysicsCollisionCollector: () => PhysicsCollisionCollector,
  PhysicsLayerFlags: () => PhysicsLayerFlags,
  PhysicsUtils: () => PhysicsUtils,
  PlayerHeadManager: () => PlayerHeadManager,
  PlayerHeadManagerParams: () => PlayerHeadManagerParams,
  PlayerLocomotion: () => PlayerLocomotion,
  PlayerLocomotionComponent: () => PlayerLocomotionComponent,
  PlayerLocomotionDirectionReferenceType: () => PlayerLocomotionDirectionReferenceType,
  PlayerLocomotionMovement: () => PlayerLocomotionMovement,
  PlayerLocomotionMovementRuntimeParams: () => PlayerLocomotionMovementRuntimeParams,
  PlayerLocomotionParams: () => PlayerLocomotionParams,
  PlayerLocomotionRotate: () => PlayerLocomotionRotate,
  PlayerLocomotionRotateParams: () => PlayerLocomotionRotateParams,
  PlayerLocomotionSmooth: () => PlayerLocomotionSmooth,
  PlayerLocomotionSmoothParams: () => PlayerLocomotionSmoothParams,
  PlayerLocomotionTeleport: () => PlayerLocomotionTeleport,
  PlayerLocomotionTeleportDetectionParams: () => PlayerLocomotionTeleportDetectionParams,
  PlayerLocomotionTeleportDetectionRuntimeParams: () => PlayerLocomotionTeleportDetectionRuntimeParams,
  PlayerLocomotionTeleportDetectionState: () => PlayerLocomotionTeleportDetectionState,
  PlayerLocomotionTeleportDetectionVisualizer: () => PlayerLocomotionTeleportDetectionVisualizer,
  PlayerLocomotionTeleportDetectionVisualizerParams: () => PlayerLocomotionTeleportDetectionVisualizerParams,
  PlayerLocomotionTeleportParable: () => PlayerLocomotionTeleportParable,
  PlayerLocomotionTeleportParams: () => PlayerLocomotionTeleportParams,
  PlayerLocomotionTeleportRuntimeParams: () => PlayerLocomotionTeleportRuntimeParams,
  PlayerLocomotionTeleportState: () => PlayerLocomotionTeleportState,
  PlayerLocomotionTeleportTeleportBlinkState: () => PlayerLocomotionTeleportTeleportBlinkState,
  PlayerLocomotionTeleportTeleportParams: () => PlayerLocomotionTeleportTeleportParams,
  PlayerLocomotionTeleportTeleportShiftState: () => PlayerLocomotionTeleportTeleportShiftState,
  PlayerLocomotionTeleportTeleportState: () => PlayerLocomotionTeleportTeleportState,
  PlayerLocomotionTeleportTeleportType: () => PlayerLocomotionTeleportTeleportType,
  PlayerLocomotionType: () => PlayerLocomotionType,
  PlayerObjects: () => PlayerObjects,
  PlayerObscureManager: () => PlayerObscureManager,
  PlayerObscureManagerParams: () => PlayerObscureManagerParams,
  PlayerTransformManager: () => PlayerTransformManager,
  PlayerTransformManagerParams: () => PlayerTransformManagerParams,
  PlayerTransformManagerSyncFlag: () => PlayerTransformManagerSyncFlag,
  PluginUtils: () => PluginUtils,
  Quat2Utils: () => Quat2Utils,
  QuatUtils: () => QuatUtils,
  RaycastBlockColliderType: () => RaycastBlockColliderType,
  RaycastHit: () => RaycastHit,
  RaycastParams: () => RaycastParams,
  RaycastResults: () => RaycastResults,
  ResetLocalTransformComponent: () => ResetLocalTransformComponent,
  SaveManager: () => SaveManager,
  SaveManagerComponent: () => SaveManagerComponent,
  SaveUtils: () => SaveUtils,
  ScaleOnSpawnComponent: () => ScaleOnSpawnComponent,
  SceneObjects: () => SceneObjects,
  SetActiveComponent: () => SetActiveComponent,
  SetEngineLogLevelComponent: () => SetEngineLogLevelComponent,
  SetHandLocalTransformComponent: () => SetHandLocalTransformComponent,
  SetHandRayLocalTransformComponent: () => SetHandRayLocalTransformComponent,
  SetHeadLocalTransformComponent: () => SetHeadLocalTransformComponent,
  SetPlayerHeightComponent: () => SetPlayerHeightComponent,
  SetTrackedHandJointLocalTransformComponent: () => SetTrackedHandJointLocalTransformComponent,
  ShowFPSComponent: () => ShowFPSComponent,
  ShowXRButtonsComponent: () => ShowXRButtonsComponent,
  SkipStateFunction: () => SkipStateFunction,
  SpatialAudioListenerComponent: () => SpatialAudioListenerComponent,
  StateData: () => StateData,
  SwitchHandObjectComponent: () => SwitchHandObjectComponent,
  TextUtils: () => TextUtils,
  Timer: () => Timer,
  TimerState: () => TimerState,
  ToggleActiveOnButtonPressComponent: () => ToggleActiveOnButtonPressComponent,
  ToolCursorComponent: () => ToolCursorComponent,
  ToolHandedness: () => ToolHandedness,
  ToolInputSourceType: () => ToolInputSourceType,
  TrackedHandDrawAllJointsComponent: () => TrackedHandDrawAllJointsComponent,
  TrackedHandDrawJointComponent: () => TrackedHandDrawJointComponent,
  TrackedHandDrawSkinComponent: () => TrackedHandDrawSkinComponent,
  TrackedHandJointID: () => TrackedHandJointID,
  TrackedHandJointIDIndex: () => TrackedHandJointIDIndex,
  TrackedHandJointPose: () => TrackedHandJointPose,
  TrackedHandPose: () => TrackedHandPose,
  TrackedHandPoseParams: () => TrackedHandPoseParams,
  TransitionData: () => TransitionData,
  UniversalGamepad: () => UniversalGamepad,
  Vec2Utils: () => Vec2Utils,
  Vec3Utils: () => Vec3Utils,
  Vec4Utils: () => Vec4Utils,
  VecAllocationUtils: () => VecAllocationUtils,
  VecUtils: () => VecUtils,
  VirtualGamepad: () => VirtualGamepad,
  VirtualGamepadAxesID: () => VirtualGamepadAxesID,
  VirtualGamepadButtonID: () => VirtualGamepadButtonID,
  VirtualGamepadButtonParams: () => VirtualGamepadButtonParams,
  VirtualGamepadComponent: () => VirtualGamepadComponent,
  VirtualGamepadGamepadCore: () => VirtualGamepadGamepadCore,
  VirtualGamepadIcon: () => VirtualGamepadIcon,
  VirtualGamepadIconParams: () => VirtualGamepadIconParams,
  VirtualGamepadIconType: () => VirtualGamepadIconType,
  VirtualGamepadParams: () => VirtualGamepadParams,
  VirtualGamepadThumbstickParams: () => VirtualGamepadThumbstickParams,
  VirtualGamepadVirtualButton: () => VirtualGamepadVirtualButton,
  VirtualGamepadVirtualThumbstick: () => VirtualGamepadVirtualThumbstick,
  VisualArrow: () => VisualArrow,
  VisualArrowParams: () => VisualArrowParams,
  VisualElementDefaultType: () => VisualElementDefaultType,
  VisualLine: () => VisualLine,
  VisualLineParams: () => VisualLineParams,
  VisualManager: () => VisualManager,
  VisualManagerComponent: () => VisualManagerComponent,
  VisualMesh: () => VisualMesh,
  VisualMeshParams: () => VisualMeshParams,
  VisualPoint: () => VisualPoint,
  VisualPointParams: () => VisualPointParams,
  VisualRaycast: () => VisualRaycast,
  VisualRaycastParams: () => VisualRaycastParams,
  VisualResources: () => VisualResources,
  VisualResourcesMaterials: () => VisualResourcesMaterials,
  VisualText: () => VisualText,
  VisualTextParams: () => VisualTextParams,
  VisualTorus: () => VisualTorus,
  VisualTorusParams: () => VisualTorusParams,
  VisualTransform: () => VisualTransform,
  VisualTransformParams: () => VisualTransformParams,
  WLComponentDefaultCloneCallbacks: () => WLComponentDefaultCloneCallbacks,
  WLCursorTargetWrapperComponent: () => WLCursorTargetWrapperComponent,
  WaveFunction: () => WaveFunction,
  WidgetFrame: () => WidgetFrame,
  WidgetFrameConfig: () => WidgetFrameConfig,
  WidgetFrameUI: () => WidgetFrameUI,
  WidgetParams: () => WidgetParams,
  XRGamepadCore: () => XRGamepadCore,
  XRUtils: () => XRUtils,
  mat3_create: () => mat3_create,
  mat3_getAllocationFunction: () => mat3_getAllocationFunction,
  mat3_setAllocationFunction: () => mat3_setAllocationFunction,
  mat4_create: () => mat4_create,
  mat4_getAllocationFunction: () => mat4_getAllocationFunction,
  mat4_setAllocationFunction: () => mat4_setAllocationFunction,
  quat2_create: () => quat2_create,
  quat2_getAllocationFunction: () => quat2_getAllocationFunction,
  quat2_setAllocationFunction: () => quat2_setAllocationFunction,
  quat_create: () => quat_create,
  quat_getAllocationFunction: () => quat_getAllocationFunction,
  quat_setAllocationFunction: () => quat_setAllocationFunction,
  registerPPComponents: () => registerPPComponents,
  registerWLComponents: () => registerWLComponents,
  vec2_create: () => vec2_create,
  vec2_getAllocationFunction: () => vec2_getAllocationFunction,
  vec2_setAllocationFunction: () => vec2_setAllocationFunction,
  vec3_create: () => vec3_create,
  vec3_getAllocationFunction: () => vec3_getAllocationFunction,
  vec3_setAllocationFunction: () => vec3_setAllocationFunction,
  vec4_create: () => vec4_create,
  vec4_getAllocationFunction: () => vec4_getAllocationFunction,
  vec4_setAllocationFunction: () => vec4_setAllocationFunction,
  vec_create: () => vec_create,
  vec_getAllocationFunction: () => vec_getAllocationFunction,
  vec_setAllocationFunction: () => vec_setAllocationFunction
});

// dist/pp/tool/easy_tune/easy_object_tuners/components/easy_active_component.js
import { Component, property } from "@wonderlandengine/api";

// dist/pp/cauldron/wl/utils/component_utils.js
import { AnimationComponent, CollisionComponent, InputComponent, LightComponent, MeshComponent as MeshComponent2, PhysXComponent, TextComponent as TextComponent2, ViewComponent } from "@wonderlandengine/api";
import { ARCamera8thwall, Anchor, Cursor, CursorTarget, DebugObject, DeviceOrientationLook, FingerCursor, FixedFoveation, HandTracking, HitTestLocation, HowlerAudioListener, HowlerAudioSource, ImageTexture, MouseLookComponent, PlaneDetection, PlayerHeight, TargetFramerate, TeleportComponent, Trail, TwoJointIkSolver, VideoTexture, VrModeActiveSwitch, Vrm, WasdControlsComponent } from "@wonderlandengine/components";

// dist/pp/audio/audio_globals.js
var audio_globals_exports = {};
__export(audio_globals_exports, {
  getAudioManager: () => getAudioManager,
  hasAudioManager: () => hasAudioManager,
  removeAudioManager: () => removeAudioManager,
  setAudioManager: () => setAudioManager
});
var _myAudioManagers = /* @__PURE__ */ new WeakMap();
function getAudioManager(engine = Globals.getMainEngine()) {
  if (engine == null)
    return null;
  const audioManager = _myAudioManagers.get(engine);
  return audioManager != null ? audioManager : null;
}
function setAudioManager(audioManager, engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myAudioManagers.set(engine, audioManager);
  }
}
function removeAudioManager(engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myAudioManagers.delete(engine);
  }
}
function hasAudioManager(engine = Globals.getMainEngine()) {
  return engine != null ? _myAudioManagers.has(engine) : false;
}

// dist/pp/cauldron/cauldron/analytics_globals.js
var analytics_globals_exports = {};
__export(analytics_globals_exports, {
  getAnalyticsManager: () => getAnalyticsManager,
  hasAnalyticsManager: () => hasAnalyticsManager,
  removeAnalyticsManager: () => removeAnalyticsManager,
  setAnalyticsManager: () => setAnalyticsManager
});
var _myAnalyticsManagers = /* @__PURE__ */ new WeakMap();
function getAnalyticsManager(engine = Globals.getMainEngine()) {
  if (engine == null)
    return null;
  const analyticsManager = _myAnalyticsManagers.get(engine);
  return analyticsManager != null ? analyticsManager : null;
}
function setAnalyticsManager(analyticsManager, engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myAnalyticsManagers.set(engine, analyticsManager);
  }
}
function removeAnalyticsManager(engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myAnalyticsManagers.delete(engine);
  }
}
function hasAnalyticsManager(engine = Globals.getMainEngine()) {
  return engine != null ? _myAnalyticsManagers.has(engine) : false;
}

// dist/pp/cauldron/cauldron/save_globals.js
var save_globals_exports = {};
__export(save_globals_exports, {
  getSaveManager: () => getSaveManager,
  hasSaveManager: () => hasSaveManager,
  removeSaveManager: () => removeSaveManager,
  setSaveManager: () => setSaveManager
});
var _mySaveManagers = /* @__PURE__ */ new WeakMap();
function getSaveManager(engine = Globals.getMainEngine()) {
  if (engine == null)
    return null;
  const saveManager = _mySaveManagers.get(engine);
  return saveManager != null ? saveManager : null;
}
function setSaveManager(saveManager, engine = Globals.getMainEngine()) {
  if (engine != null) {
    _mySaveManagers.set(engine, saveManager);
  }
}
function removeSaveManager(engine = Globals.getMainEngine()) {
  if (engine != null) {
    _mySaveManagers.delete(engine);
  }
}
function hasSaveManager(engine = Globals.getMainEngine()) {
  return engine != null ? _mySaveManagers.has(engine) : false;
}

// dist/pp/cauldron/object_pool/object_pool_globals.js
var object_pool_globals_exports = {};
__export(object_pool_globals_exports, {
  getObjectPoolManager: () => getObjectPoolManager,
  hasObjectPoolManager: () => hasObjectPoolManager,
  removeObjectPoolManager: () => removeObjectPoolManager,
  setObjectPoolManager: () => setObjectPoolManager
});
var _myObjectPoolManagers = /* @__PURE__ */ new WeakMap();
function getObjectPoolManager(engine = Globals.getMainEngine()) {
  if (engine == null)
    return null;
  const objectPoolManager = _myObjectPoolManagers.get(engine);
  return objectPoolManager != null ? objectPoolManager : null;
}
function setObjectPoolManager(objectPoolManager, engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myObjectPoolManagers.set(engine, objectPoolManager);
  }
}
function removeObjectPoolManager(engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myObjectPoolManagers.delete(engine);
  }
}
function hasObjectPoolManager(engine = Globals.getMainEngine()) {
  return engine != null ? _myObjectPoolManagers.has(engine) : false;
}

// dist/pp/cauldron/visual/visual_globals.js
var visual_globals_exports = {};
__export(visual_globals_exports, {
  getVisualManager: () => getVisualManager,
  getVisualResources: () => getVisualResources,
  hasVisualManager: () => hasVisualManager,
  hasVisualResources: () => hasVisualResources,
  removeVisualManager: () => removeVisualManager,
  removeVisualResources: () => removeVisualResources,
  setVisualManager: () => setVisualManager,
  setVisualResources: () => setVisualResources
});
var _myVisualManagers = /* @__PURE__ */ new WeakMap();
var _myVisualResourcesMap = /* @__PURE__ */ new WeakMap();
function getVisualManager(engine = Globals.getMainEngine()) {
  if (engine == null)
    return null;
  const visualManager = _myVisualManagers.get(engine);
  return visualManager != null ? visualManager : null;
}
function setVisualManager(visualManager, engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myVisualManagers.set(engine, visualManager);
  }
}
function removeVisualManager(engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myVisualManagers.delete(engine);
  }
}
function hasVisualManager(engine = Globals.getMainEngine()) {
  return engine != null ? _myVisualManagers.has(engine) : false;
}
function getVisualResources(engine = Globals.getMainEngine()) {
  if (engine == null)
    return null;
  const visualResources = _myVisualResourcesMap.get(engine);
  return visualResources != null ? visualResources : null;
}
function setVisualResources(visualResources, engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myVisualResourcesMap.set(engine, visualResources);
  }
}
function removeVisualResources(engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myVisualResourcesMap.delete(engine);
  }
}
function hasVisualResources(engine = Globals.getMainEngine()) {
  return engine != null ? _myVisualResourcesMap.has(engine) : false;
}

// dist/pp/cauldron/wl/engine_globals.js
var engine_globals_exports = {};
__export(engine_globals_exports, {
  addEngine: () => addEngine,
  getCanvas: () => getCanvas,
  getEngines: () => getEngines,
  getMainEngine: () => getMainEngine,
  getPhysics: () => getPhysics,
  getScene: () => getScene,
  getWASM: () => getWASM,
  getXR: () => getXR,
  hasEngine: () => hasEngine,
  removeEngine: () => removeEngine,
  removeMainEngine: () => removeMainEngine,
  setMainEngine: () => setMainEngine
});
var _myMainEngine = null;
var _myEngines = [];
function getMainEngine() {
  return _myMainEngine;
}
function setMainEngine(engine) {
  if (!hasEngine(engine)) {
    addEngine(engine);
  }
  _myMainEngine = engine;
}
function removeMainEngine() {
  _myMainEngine = null;
}
function getEngines() {
  return _myEngines;
}
function addEngine(engine) {
  removeEngine(engine);
  _myEngines.push(engine);
}
function removeEngine(engine) {
  const index = _myEngines.indexOf(engine);
  if (index >= 0) {
    _myEngines.splice(index, 1);
    if (getMainEngine() == engine) {
      removeMainEngine();
    }
  }
}
function hasEngine(engine) {
  return _myEngines.indexOf(engine) >= 0;
}
function getScene(engine = Globals.getMainEngine()) {
  let scene = null;
  if (engine != null) {
    scene = engine.scene;
  }
  return scene;
}
function getPhysics(engine = Globals.getMainEngine()) {
  let physics = null;
  if (engine != null) {
    physics = engine.physics;
  }
  return physics;
}
function getCanvas(engine = Globals.getMainEngine()) {
  let canvas = null;
  if (engine != null) {
    canvas = engine.canvas;
  }
  return canvas;
}
function getWASM(engine = Globals.getMainEngine()) {
  let wasm = null;
  if (engine != null) {
    wasm = engine.wasm;
  }
  return wasm;
}
function getXR(engine = Globals.getMainEngine()) {
  let xr = null;
  if (engine != null) {
    xr = engine.xr;
  }
  return xr;
}

// dist/pp/cauldron/wl/getters/default_resources_globals.js
var default_resources_globals_exports = {};
__export(default_resources_globals_exports, {
  getDefaultMaterials: () => getDefaultMaterials,
  getDefaultMeshes: () => getDefaultMeshes,
  getDefaultResources: () => getDefaultResources,
  hasDefaultResources: () => hasDefaultResources,
  removeDefaultResources: () => removeDefaultResources,
  setDefaultResources: () => setDefaultResources
});
var _myDefaultResourcesContainer = /* @__PURE__ */ new WeakMap();
function getDefaultResources(engine = Globals.getMainEngine()) {
  if (engine == null)
    return null;
  const defaultResources = _myDefaultResourcesContainer.get(engine);
  return defaultResources != null ? defaultResources : null;
}
function setDefaultResources(defaultResources, engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myDefaultResourcesContainer.set(engine, defaultResources);
  }
}
function removeDefaultResources(engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myDefaultResourcesContainer.delete(engine);
  }
}
function hasDefaultResources(engine = Globals.getMainEngine()) {
  return engine != null ? _myDefaultResourcesContainer.has(engine) : false;
}
function getDefaultMeshes(engine = Globals.getMainEngine()) {
  const defaultResources = getDefaultResources(engine);
  if (defaultResources != null) {
    return defaultResources.myMeshes;
  }
  return null;
}
function getDefaultMaterials(engine = Globals.getMainEngine()) {
  const defaultResources = getDefaultResources(engine);
  if (defaultResources != null) {
    return defaultResources.myMaterials;
  }
  return null;
}

// dist/pp/cauldron/wl/getters/scene_objects_globals.js
var scene_objects_globals_exports = {};
__export(scene_objects_globals_exports, {
  getPlayerHeadObject: () => getPlayerHeadObject,
  getPlayerObject: () => getPlayerObject,
  getPlayerObjects: () => getPlayerObjects,
  getPlayerReferenceSpaceObject: () => getPlayerReferenceSpaceObject,
  getRootObject: () => getRootObject,
  getSceneObject: () => getSceneObject,
  getSceneObjects: () => getSceneObjects,
  hasSceneObjects: () => hasSceneObjects,
  removeSceneObjects: () => removeSceneObjects,
  setSceneObjects: () => setSceneObjects
});
var _mySceneObjectsContainer = /* @__PURE__ */ new WeakMap();
function getSceneObjects(engine = Globals.getMainEngine()) {
  if (engine == null)
    return null;
  const sceneObjects = _mySceneObjectsContainer.get(engine);
  return sceneObjects != null ? sceneObjects : null;
}
function setSceneObjects(sceneObjects, engine = Globals.getMainEngine()) {
  if (engine != null) {
    _mySceneObjectsContainer.set(engine, sceneObjects);
  }
}
function removeSceneObjects(engine = Globals.getMainEngine()) {
  if (engine != null) {
    _mySceneObjectsContainer.delete(engine);
  }
}
function hasSceneObjects(engine = Globals.getMainEngine()) {
  return engine != null ? _mySceneObjectsContainer.has(engine) : false;
}
function getRootObject(engine = Globals.getMainEngine()) {
  const sceneObjects = getSceneObjects(engine);
  if (sceneObjects != null) {
    return sceneObjects.myRoot;
  }
  return null;
}
function getSceneObject(engine = Globals.getMainEngine()) {
  const sceneObjects = getSceneObjects(engine);
  if (sceneObjects != null) {
    return sceneObjects.myScene;
  }
  return null;
}
function getPlayerObjects(engine = Globals.getMainEngine()) {
  const sceneObjects = getSceneObjects(engine);
  if (sceneObjects != null) {
    return sceneObjects.myPlayerObjects;
  }
  return null;
}
function getPlayerObject(engine = Globals.getMainEngine()) {
  const sceneObjects = getSceneObjects(engine);
  if (sceneObjects != null) {
    return sceneObjects.myPlayerObjects.myPlayer;
  }
  return null;
}
function getPlayerReferenceSpaceObject(engine = Globals.getMainEngine()) {
  const sceneObjects = getSceneObjects(engine);
  if (sceneObjects != null) {
    return sceneObjects.myPlayerObjects.myReferenceSpace;
  }
  return null;
}
function getPlayerHeadObject(engine = Globals.getMainEngine()) {
  const sceneObjects = getSceneObjects(engine);
  if (sceneObjects != null) {
    return sceneObjects.myPlayerObjects.myHead;
  }
  return null;
}

// dist/pp/debug/debug_globals.js
var debug_globals_exports = {};
__export(debug_globals_exports, {
  getDebugManager: () => getDebugManager,
  getDebugVisualManager: () => getDebugVisualManager,
  hasDebugEnabled: () => hasDebugEnabled,
  hasDebugManager: () => hasDebugManager,
  isDebugEnabled: () => isDebugEnabled,
  removeDebugEnabled: () => removeDebugEnabled,
  removeDebugManager: () => removeDebugManager,
  setDebugEnabled: () => setDebugEnabled,
  setDebugManager: () => setDebugManager
});
var _myDebugManagers = /* @__PURE__ */ new WeakMap();
var _myDebugEnableds = /* @__PURE__ */ new WeakMap();
function getDebugManager(engine = Globals.getMainEngine()) {
  if (engine == null)
    return null;
  const debugManager = _myDebugManagers.get(engine);
  return debugManager != null ? debugManager : null;
}
function setDebugManager(debugManager, engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myDebugManagers.set(engine, debugManager);
  }
}
function removeDebugManager(engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myDebugManagers.delete(engine);
  }
}
function hasDebugManager(engine = Globals.getMainEngine()) {
  return engine != null ? _myDebugManagers.has(engine) : false;
}
function getDebugVisualManager(engine = Globals.getMainEngine()) {
  const debugManager = getDebugManager(engine);
  if (debugManager != null) {
    return debugManager.getDebugVisualManager();
  }
  return null;
}
function isDebugEnabled(engine = Globals.getMainEngine()) {
  return engine != null ? !!_myDebugEnableds.get(engine) : false;
}
function setDebugEnabled(debugEnabled, engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myDebugEnableds.set(engine, debugEnabled);
  }
}
function removeDebugEnabled(engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myDebugEnableds.delete(engine);
  }
}
function hasDebugEnabled(engine = Globals.getMainEngine()) {
  return engine != null ? _myDebugEnableds.has(engine) : false;
}

// dist/pp/gameplay/experimental/character_controller/collision/character_collision_system_globals.js
var character_collision_system_globals_exports = {};
__export(character_collision_system_globals_exports, {
  getCharacterCollisionSystem: () => getCharacterCollisionSystem,
  hasCharacterCollisionSystem: () => hasCharacterCollisionSystem,
  removeCharacterCollisionSystem: () => removeCharacterCollisionSystem,
  setCharacterCollisionSystem: () => setCharacterCollisionSystem
});
var _myCharacterCollisionSystems = /* @__PURE__ */ new WeakMap();
function getCharacterCollisionSystem(engine = Globals.getMainEngine()) {
  if (engine == null)
    return null;
  const characterCollisionSystem = _myCharacterCollisionSystems.get(engine);
  return characterCollisionSystem != null ? characterCollisionSystem : null;
}
function setCharacterCollisionSystem(characterCollisionSystem, engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myCharacterCollisionSystems.set(engine, characterCollisionSystem);
  }
}
function removeCharacterCollisionSystem(engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myCharacterCollisionSystems.delete(engine);
  }
}
function hasCharacterCollisionSystem(engine = Globals.getMainEngine()) {
  return engine != null ? _myCharacterCollisionSystems.has(engine) : false;
}

// dist/pp/gameplay/experimental/locomotion/player_locomotion_globals.js
var player_locomotion_globals_exports = {};
__export(player_locomotion_globals_exports, {
  getPlayerHeadManager: () => getPlayerHeadManager,
  getPlayerLocomotion: () => getPlayerLocomotion,
  getPlayerLocomotionRotate: () => getPlayerLocomotionRotate,
  getPlayerLocomotionSmooth: () => getPlayerLocomotionSmooth,
  getPlayerLocomotionTeleport: () => getPlayerLocomotionTeleport,
  getPlayerObscureManager: () => getPlayerObscureManager,
  getPlayerTransformManager: () => getPlayerTransformManager,
  hasPlayerLocomotion: () => hasPlayerLocomotion,
  removePlayerLocomotion: () => removePlayerLocomotion,
  setPlayerLocomotion: () => setPlayerLocomotion
});
var _myPlayerLocomotions = /* @__PURE__ */ new WeakMap();
function getPlayerLocomotion(engine = Globals.getMainEngine()) {
  if (engine == null)
    return null;
  return _myPlayerLocomotions.get(engine) ?? null;
}
function setPlayerLocomotion(playerLocomotionComponent, engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myPlayerLocomotions.set(engine, playerLocomotionComponent);
  }
}
function removePlayerLocomotion(engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myPlayerLocomotions.delete(engine);
  }
}
function hasPlayerLocomotion(engine = Globals.getMainEngine()) {
  return engine != null ? _myPlayerLocomotions.has(engine) : false;
}
function getPlayerHeadManager(engine = Globals.getMainEngine()) {
  const playerLocomotion = getPlayerLocomotion(engine);
  if (playerLocomotion != null) {
    return playerLocomotion.getPlayerHeadManager();
  }
  return null;
}
function getPlayerTransformManager(engine = Globals.getMainEngine()) {
  const playerLocomotion = getPlayerLocomotion(engine);
  if (playerLocomotion != null) {
    return playerLocomotion.getPlayerTransformManager();
  }
  return null;
}
function getPlayerLocomotionSmooth(engine = Globals.getMainEngine()) {
  const playerLocomotion = getPlayerLocomotion(engine);
  if (playerLocomotion != null) {
    return playerLocomotion.getPlayerLocomotionSmooth();
  }
  return null;
}
function getPlayerLocomotionTeleport(engine = Globals.getMainEngine()) {
  const playerLocomotion = getPlayerLocomotion(engine);
  if (playerLocomotion != null) {
    return playerLocomotion.getPlayerLocomotionTeleport();
  }
  return null;
}
function getPlayerLocomotionRotate(engine = Globals.getMainEngine()) {
  const playerLocomotion = getPlayerLocomotion(engine);
  if (playerLocomotion != null) {
    return playerLocomotion.getPlayerLocomotionRotate();
  }
  return null;
}
function getPlayerObscureManager(engine = Globals.getMainEngine()) {
  const playerLocomotion = getPlayerLocomotion(engine);
  if (playerLocomotion != null) {
    return playerLocomotion.getPlayerObscureManager();
  }
  return null;
}

// dist/pp/input/cauldron/input_globals.js
var input_globals_exports = {};
__export(input_globals_exports, {
  getGamepad: () => getGamepad,
  getGamepads: () => getGamepads,
  getGamepadsManager: () => getGamepadsManager,
  getHandPose: () => getHandPose,
  getHandPoses: () => getHandPoses,
  getHandRayPose: () => getHandRayPose,
  getHandRayPoses: () => getHandRayPoses,
  getHeadPose: () => getHeadPose,
  getInputManager: () => getInputManager,
  getKeyboard: () => getKeyboard,
  getLeftGamepad: () => getLeftGamepad,
  getLeftHandPose: () => getLeftHandPose,
  getLeftHandRayPose: () => getLeftHandRayPose,
  getLeftTrackedHandPose: () => getLeftTrackedHandPose,
  getMouse: () => getMouse,
  getRightGamepad: () => getRightGamepad,
  getRightHandPose: () => getRightHandPose,
  getRightHandRayPose: () => getRightHandRayPose,
  getRightTrackedHandPose: () => getRightTrackedHandPose,
  getTrackedHandPose: () => getTrackedHandPose,
  getTrackedHandPoses: () => getTrackedHandPoses,
  hasInputManager: () => hasInputManager,
  hasPoseForwardFixed: () => hasPoseForwardFixed,
  isPoseForwardFixed: () => isPoseForwardFixed,
  removeInputManager: () => removeInputManager,
  removePoseForwardFixed: () => removePoseForwardFixed,
  setInputManager: () => setInputManager,
  setPoseForwardFixed: () => setPoseForwardFixed
});
var _myInputManagers = /* @__PURE__ */ new WeakMap();
var _myPoseForwardFixeds = /* @__PURE__ */ new WeakMap();
function getInputManager(engine = Globals.getMainEngine()) {
  if (engine == null)
    return null;
  const inputManager = _myInputManagers.get(engine);
  return inputManager != null ? inputManager : null;
}
function setInputManager(inputManager, engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myInputManagers.set(engine, inputManager);
  }
}
function removeInputManager(engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myInputManagers.delete(engine);
  }
}
function hasInputManager(engine = Globals.getMainEngine()) {
  return engine != null ? _myInputManagers.has(engine) : false;
}
function getMouse(engine = Globals.getMainEngine()) {
  const inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getMouse();
  }
  return null;
}
function getKeyboard(engine = Globals.getMainEngine()) {
  const inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getKeyboard();
  }
  return null;
}
function getGamepadsManager(engine = Globals.getMainEngine()) {
  const inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getGamepadsManager();
  }
  return null;
}
function getGamepad(handedness, engine = Globals.getMainEngine()) {
  const inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getGamepadsManager().getGamepad(handedness);
  }
  return null;
}
function getGamepads(engine = Globals.getMainEngine()) {
  const inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getGamepadsManager().getGamepads();
  }
  return null;
}
function getLeftGamepad(engine = Globals.getMainEngine()) {
  const inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getGamepadsManager().getLeftGamepad();
  }
  return null;
}
function getRightGamepad(engine = Globals.getMainEngine()) {
  const inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getGamepadsManager().getRightGamepad();
  }
  return null;
}
function getHeadPose(engine = Globals.getMainEngine()) {
  const inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getHeadPose();
  }
  return null;
}
function getHandPose(handedness, engine = Globals.getMainEngine()) {
  const inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getHandPose(handedness);
  }
  return null;
}
function getHandPoses(engine = Globals.getMainEngine()) {
  const inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getHandPoses();
  }
  return null;
}
function getLeftHandPose(engine = Globals.getMainEngine()) {
  const inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getLeftHandPose();
  }
  return null;
}
function getRightHandPose(engine = Globals.getMainEngine()) {
  const inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getRightHandPose();
  }
  return null;
}
function getHandRayPose(handedness, engine = Globals.getMainEngine()) {
  const inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getHandRayPose(handedness);
  }
  return null;
}
function getHandRayPoses(engine = Globals.getMainEngine()) {
  const inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getHandRayPoses();
  }
  return null;
}
function getLeftHandRayPose(engine = Globals.getMainEngine()) {
  const inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getLeftHandRayPose();
  }
  return null;
}
function getRightHandRayPose(engine = Globals.getMainEngine()) {
  const inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getRightHandRayPose();
  }
  return null;
}
function getTrackedHandPose(handedness, engine = Globals.getMainEngine()) {
  const inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getTrackedHandPose(handedness);
  }
  return null;
}
function getTrackedHandPoses(engine = Globals.getMainEngine()) {
  const inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getTrackedHandPoses();
  }
  return null;
}
function getLeftTrackedHandPose(engine = Globals.getMainEngine()) {
  const inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getLeftTrackedHandPose();
  }
  return null;
}
function getRightTrackedHandPose(engine = Globals.getMainEngine()) {
  const inputManager = getInputManager(engine);
  if (inputManager != null) {
    return inputManager.getRightTrackedHandPose();
  }
  return null;
}
function isPoseForwardFixed(engine = Globals.getMainEngine()) {
  return engine != null ? !!_myPoseForwardFixeds.get(engine) : false;
}
function setPoseForwardFixed(toolEnabled, engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myPoseForwardFixeds.set(engine, toolEnabled);
  }
}
function removePoseForwardFixed(engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myPoseForwardFixeds.delete(engine);
  }
}
function hasPoseForwardFixed(engine = Globals.getMainEngine()) {
  return engine != null ? _myPoseForwardFixeds.has(engine) : false;
}

// dist/pp/tool/cauldron/tool_globals.js
var tool_globals_exports = {};
__export(tool_globals_exports, {
  hasToolEnabled: () => hasToolEnabled,
  isToolEnabled: () => isToolEnabled,
  removeToolEnabled: () => removeToolEnabled,
  setToolEnabled: () => setToolEnabled
});
var _myToolEnableds = /* @__PURE__ */ new WeakMap();
function isToolEnabled(engine = Globals.getMainEngine()) {
  if (engine == null)
    return null;
  const toolEnabled = _myToolEnableds.get(engine);
  return toolEnabled != null ? toolEnabled : null;
}
function setToolEnabled(toolEnabled, engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myToolEnableds.set(engine, toolEnabled);
  }
}
function removeToolEnabled(engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myToolEnableds.delete(engine);
  }
}
function hasToolEnabled(engine = Globals.getMainEngine()) {
  return engine != null ? _myToolEnableds.has(engine) : false;
}

// dist/pp/tool/console_vr/console_vr_globals.js
var console_vr_globals_exports = {};
__export(console_vr_globals_exports, {
  getConsoleVR: () => getConsoleVR,
  getConsoleVRWidget: () => getConsoleVRWidget,
  hasConsoleVR: () => hasConsoleVR,
  hasConsoleVRWidget: () => hasConsoleVRWidget,
  removeConsoleVR: () => removeConsoleVR,
  removeConsoleVRWidget: () => removeConsoleVRWidget,
  setConsoleVR: () => setConsoleVR,
  setConsoleVRWidget: () => setConsoleVRWidget
});
var _myConsoleVRs = /* @__PURE__ */ new WeakMap();
var _myConsoleVRWidgets = /* @__PURE__ */ new WeakMap();
function getConsoleVR(engine = Globals.getMainEngine()) {
  if (engine == null)
    return null;
  const consoleVR = _myConsoleVRs.get(engine);
  return consoleVR != null ? consoleVR : null;
}
function setConsoleVR(consoleVR, engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myConsoleVRs.set(engine, consoleVR);
  }
}
function removeConsoleVR(engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myConsoleVRs.delete(engine);
  }
}
function hasConsoleVR(engine = Globals.getMainEngine()) {
  return engine != null ? _myConsoleVRs.has(engine) : false;
}
function getConsoleVRWidget(engine = Globals.getMainEngine()) {
  if (engine == null)
    return null;
  const consoleVRWidget = _myConsoleVRWidgets.get(engine);
  return consoleVRWidget != null ? consoleVRWidget : null;
}
function setConsoleVRWidget(consoleVRWidget, engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myConsoleVRWidgets.set(engine, consoleVRWidget);
  }
}
function removeConsoleVRWidget(engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myConsoleVRWidgets.delete(engine);
  }
}
function hasConsoleVRWidget(engine = Globals.getMainEngine()) {
  return engine != null ? _myConsoleVRWidgets.has(engine) : false;
}

// dist/pp/tool/easy_tune/easy_tune_globals.js
var easy_tune_globals_exports = {};
__export(easy_tune_globals_exports, {
  getEasyTuneTarget: () => getEasyTuneTarget,
  getEasyTuneVariables: () => getEasyTuneVariables,
  getEasyTuneWidget: () => getEasyTuneWidget,
  hasEasyTuneTarget: () => hasEasyTuneTarget,
  hasEasyTuneVariables: () => hasEasyTuneVariables,
  hasEasyTuneWidget: () => hasEasyTuneWidget,
  removeEasyTuneTarget: () => removeEasyTuneTarget,
  removeEasyTuneVariables: () => removeEasyTuneVariables,
  removeEasyTuneWidget: () => removeEasyTuneWidget,
  setEasyTuneTarget: () => setEasyTuneTarget,
  setEasyTuneVariables: () => setEasyTuneVariables,
  setEasyTuneWidget: () => setEasyTuneWidget
});
var _myEasyTuneVariablesList = /* @__PURE__ */ new WeakMap();
var _myEasyTuneTargets = /* @__PURE__ */ new WeakMap();
var _myEasyTuneWidgets = /* @__PURE__ */ new WeakMap();
function getEasyTuneVariables(engine = Globals.getMainEngine()) {
  if (engine == null)
    return null;
  const easyTuneVariables = _myEasyTuneVariablesList.get(engine);
  return easyTuneVariables != null ? easyTuneVariables : null;
}
function setEasyTuneVariables(easyTuneVariables, engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myEasyTuneVariablesList.set(engine, easyTuneVariables);
  }
}
function removeEasyTuneVariables(engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myEasyTuneVariablesList.delete(engine);
  }
}
function hasEasyTuneVariables(engine = Globals.getMainEngine()) {
  return engine != null ? _myEasyTuneVariablesList.has(engine) : false;
}
function getEasyTuneTarget(engine = Globals.getMainEngine()) {
  if (engine == null)
    return null;
  const easyTuneTarget = _myEasyTuneTargets.get(engine);
  return easyTuneTarget != null ? easyTuneTarget : null;
}
function setEasyTuneTarget(easyTuneTarget, engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myEasyTuneTargets.set(engine, easyTuneTarget);
  }
}
function removeEasyTuneTarget(engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myEasyTuneTargets.delete(engine);
  }
}
function hasEasyTuneTarget(engine = Globals.getMainEngine()) {
  return engine != null ? _myEasyTuneTargets.has(engine) : false;
}
function getEasyTuneWidget(engine = Globals.getMainEngine()) {
  if (engine == null)
    return null;
  const easyTuneWidget = _myEasyTuneWidgets.get(engine);
  return easyTuneWidget != null ? easyTuneWidget : null;
}
function setEasyTuneWidget(easyTuneWidget, engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myEasyTuneWidgets.set(engine, easyTuneWidget);
  }
}
function removeEasyTuneWidget(engine = Globals.getMainEngine()) {
  if (engine != null) {
    _myEasyTuneWidgets.delete(engine);
  }
}
function hasEasyTuneWidget(engine = Globals.getMainEngine()) {
  return engine != null ? _myEasyTuneWidgets.has(engine) : false;
}

// dist/pp/pp/globals.js
var Globals = {
  ...engine_globals_exports,
  ...scene_objects_globals_exports,
  ...default_resources_globals_exports,
  ...audio_globals_exports,
  ...visual_globals_exports,
  ...debug_globals_exports,
  ...object_pool_globals_exports,
  ...character_collision_system_globals_exports,
  ...player_locomotion_globals_exports,
  ...input_globals_exports,
  ...save_globals_exports,
  ...analytics_globals_exports,
  ...tool_globals_exports,
  ...console_vr_globals_exports,
  ...easy_tune_globals_exports
};

// dist/pp/cauldron/utils/array/mat3_utils.js
import { mat3 as gl_mat33, quat as gl_quat4 } from "gl-matrix";

// dist/pp/cauldron/utils/array/quat_utils.js
import { mat3 as gl_mat32, quat as gl_quat3 } from "gl-matrix";

// dist/pp/cauldron/utils/math_utils.js
var EasingFunction = {
  linear: (valueToEase) => valueToEase,
  easeInVeryWeak: (valueToEase) => 1 - Math.cos(valueToEase * Math.PI / 2),
  easeInWeak: (valueToEase) => Math.pow(valueToEase, 2),
  easeIn: (valueToEase) => Math.pow(valueToEase, 3),
  easeInStrong: (valueToEase) => Math.pow(valueToEase, 4),
  easeInVeryStrong: (valueToEase) => Math.pow(valueToEase, 5),
  easeOutVeryWeak: (valueToEase) => Math.sin(valueToEase * Math.PI / 2),
  easeOutWeak: (valueToEase) => 1 - Math.pow(1 - valueToEase, 2),
  easeOut: (valueToEase) => 1 - Math.pow(1 - valueToEase, 3),
  easeOutStrong: (valueToEase) => 1 - Math.pow(1 - valueToEase, 4),
  easeOutVeryStrong: (valueToEase) => 1 - Math.pow(1 - valueToEase, 5),
  easeInOutVeryWeak: (valueToEase) => -(Math.cos(valueToEase * Math.PI) - 1) / 2,
  easeInOutWeak: (valueToEase) => valueToEase < 0.5 ? 2 * Math.pow(valueToEase, 2) : 1 - Math.pow(-2 * valueToEase + 2, 2) / 2,
  easeInOut: (valueToEase) => valueToEase < 0.5 ? 4 * Math.pow(valueToEase, 3) : 1 - Math.pow(-2 * valueToEase + 2, 3) / 2,
  easeInOutStrong: (valueToEase) => valueToEase < 0.5 ? 8 * Math.pow(valueToEase, 4) : 1 - Math.pow(-2 * valueToEase + 2, 4) / 2,
  easeInOutVeryStrong: (valueToEase) => valueToEase < 0.5 ? 16 * Math.pow(valueToEase, 5) : 1 - Math.pow(-2 * valueToEase + 2, 5) / 2
};
var EasingFunctionName;
(function(EasingFunctionName2) {
  EasingFunctionName2["LINEAR"] = "Linear";
  EasingFunctionName2["EASE_IN_VERY_WEAK"] = "Ease In Very Weak";
  EasingFunctionName2["EASE_IN_WEAK"] = "Ease In Weak";
  EasingFunctionName2["EASE_IN"] = "Ease In";
  EasingFunctionName2["EASE_IN_STRONG"] = "Ease In Strong";
  EasingFunctionName2["EASE_IN_VERY_STRONG"] = "Ease In Very Strong";
  EasingFunctionName2["EASE_OUT_VERY_WEAK"] = "Ease Out Very Weak";
  EasingFunctionName2["EASE_OUT_WEAK"] = "Ease Out Weak";
  EasingFunctionName2["EASE_OUT"] = "Ease Out";
  EasingFunctionName2["EASE_OUT_STRONG"] = "Ease Out Strong";
  EasingFunctionName2["EASE_OUT_VERY_STRONG"] = "Ease Out Very Strong";
  EasingFunctionName2["EASE_IN_OUT_VERY_WEAK"] = "Ease In/Out Very Weak";
  EasingFunctionName2["EASE_IN_OUT_WEAK"] = "Ease In/Out Weak";
  EasingFunctionName2["EASE_IN_OUT"] = "Ease In/Out";
  EasingFunctionName2["EASE_IN_OUT_STRONG"] = "Ease In/Out Strong";
  EasingFunctionName2["EASE_IN_OUT_VERY_STRONG"] = "Ease In/Out Very Strong";
})(EasingFunctionName || (EasingFunctionName = {}));
var WaveFunction = {
  triangleWave: (inputValue) => 2 / Math.PI * Math.asin(Math.sin(Math.PI / 2 * inputValue)),
  positiveTriangleWave: (inputValue) => 1 - Math.abs(Math.abs(inputValue) % 2 - 1)
};
var EPSILON = 1e-6;
var EPSILON_SQUARED = EPSILON * EPSILON;
var EPSILON_DEGREES = 1e-5;
function clamp(value, start = -Number.MAX_VALUE, end = Number.MAX_VALUE) {
  const min = Math.min(start, end);
  const max = Math.max(start, end);
  return Math.min(Math.max(value, min), max);
}
function sign(value, zeroSign = 1) {
  let sign2 = Math.sign(value);
  if (sign2 == 0) {
    sign2 = Math.sign(zeroSign);
  }
  return sign2;
}
function toDegrees(angle2) {
  return angle2 * (180 / Math.PI);
}
function toRadians(angle2) {
  return angle2 * (Math.PI / 180);
}
function roundDecimal(number, decimalPlaces) {
  const factor = Math.pow(10, decimalPlaces);
  number = Math.round(number * factor) / factor;
  return number;
}
function mapToRange(value, originRangeStart, originRangeEnd, newRangeStart, newRangeEnd) {
  if (originRangeStart == originRangeEnd) {
    return newRangeStart;
  }
  const clampedValue = MathUtils.clamp(value, originRangeStart, originRangeEnd);
  if (clampedValue == originRangeStart) {
    return newRangeStart;
  } else if (clampedValue == originRangeEnd) {
    return newRangeEnd;
  }
  const newValue = newRangeStart + (newRangeEnd - newRangeStart) / (originRangeEnd - originRangeStart) * (clampedValue - originRangeStart);
  const clampedNewValue = MathUtils.clamp(newValue, newRangeStart, newRangeEnd);
  return clampedNewValue;
}
function random(start = 0, end = 1) {
  return Math.random() * (end - start) + start;
}
function randomInt(start, end) {
  const min = Math.min(start, end);
  const max = Math.max(start, end);
  return Math.floor(Math.random() * (max - min + 1) + min);
}
function randomBool() {
  return MathUtils.randomInt(0, 1) == 0;
}
function randomSign() {
  return Math.random() < 0.5 ? 1 : -1;
}
function randomPick(...args) {
  let random2 = null;
  if (args.length > 0) {
    if (args.length == 1 && args[0].length != null) {
      const arrayArg0 = args[0];
      if (arrayArg0.length > 0) {
        const randomIndex = MathUtils.randomInt(0, arrayArg0.length - 1);
        random2 = arrayArg0[randomIndex];
      }
    } else {
      const randomIndex = MathUtils.randomInt(0, args.length - 1);
      random2 = args[randomIndex];
    }
  }
  return random2;
}
var randomUUID = function() {
  const uuidRandomValues = new Uint8Array(1);
  const uuidSkeleton = "10000000-1000-4000-8000-" + 1e11;
  const replaceUUIDSkeletonRegex = new RegExp("[018]", "g");
  const replaceUUIDSkeletonCallback = function(charString) {
    const digit = parseInt(charString.charAt(0));
    return (digit ^ (crypto.getRandomValues(uuidRandomValues)[0] & 15) >> digit / 4).toString(16);
  };
  return function randomUUID2() {
    let uuid = "";
    if (crypto.randomUUID != null) {
      uuid = crypto.randomUUID();
    } else {
      uuid = uuidSkeleton.replace(replaceUUIDSkeletonRegex, replaceUUIDSkeletonCallback);
    }
    return uuid;
  };
}();
function lerp(from, to, interpolationFactor) {
  if (interpolationFactor <= 0) {
    return from;
  } else if (interpolationFactor >= 1) {
    return to;
  }
  return interpolationFactor * (to - from) + from;
}
function interpolate(from, to, interpolationFactor, easingFunction = EasingFunction.linear) {
  const lerpFactor = easingFunction(interpolationFactor);
  return MathUtils.lerp(from, to, lerpFactor);
}
function interpolatePeriodic(from, to, interpolationFactor, easingFunction = EasingFunction.linear) {
  const adjustedInterpolationFactor = WaveFunction.positiveTriangleWave(interpolationFactor);
  return MathUtils.interpolate(from, to, adjustedInterpolationFactor, easingFunction);
}
function getEasingFunctionByName(easingFunctionName) {
  let easingFunction = EasingFunction.linear;
  switch (easingFunctionName) {
    case EasingFunctionName.LINEAR:
      easingFunction = EasingFunction.linear;
      break;
    case EasingFunctionName.EASE_IN_VERY_WEAK:
      easingFunction = EasingFunction.easeInVeryWeak;
      break;
    case EasingFunctionName.EASE_IN_WEAK:
      easingFunction = EasingFunction.easeInWeak;
      break;
    case EasingFunctionName.EASE_IN:
      easingFunction = EasingFunction.easeIn;
      break;
    case EasingFunctionName.EASE_IN_STRONG:
      easingFunction = EasingFunction.easeInStrong;
      break;
    case EasingFunctionName.EASE_IN_VERY_STRONG:
      easingFunction = EasingFunction.easeInVeryStrong;
      break;
    case EasingFunctionName.EASE_OUT_VERY_WEAK:
      easingFunction = EasingFunction.easeOutVeryWeak;
      break;
    case EasingFunctionName.EASE_OUT_WEAK:
      easingFunction = EasingFunction.easeOutWeak;
      break;
    case EasingFunctionName.EASE_OUT:
      easingFunction = EasingFunction.easeOut;
      break;
    case EasingFunctionName.EASE_OUT_STRONG:
      easingFunction = EasingFunction.easeOutStrong;
      break;
    case EasingFunctionName.EASE_OUT_VERY_STRONG:
      easingFunction = EasingFunction.easeOutVeryStrong;
      break;
    case EasingFunctionName.EASE_IN_OUT_VERY_WEAK:
      easingFunction = EasingFunction.easeInOutVeryWeak;
      break;
    case EasingFunctionName.EASE_IN_OUT_WEAK:
      easingFunction = EasingFunction.easeInOutWeak;
      break;
    case EasingFunctionName.EASE_IN_OUT:
      easingFunction = EasingFunction.easeInOut;
      break;
    case EasingFunctionName.EASE_IN_OUT_STRONG:
      easingFunction = EasingFunction.easeInOutStrong;
      break;
    case EasingFunctionName.EASE_IN_OUT_VERY_STRONG:
      easingFunction = EasingFunction.easeInOutVeryStrong;
      break;
  }
  return easingFunction;
}
function getEasingFunctionNameByIndex(index) {
  let easingFunctionName = null;
  switch (index) {
    case 0:
      easingFunctionName = EasingFunctionName.LINEAR;
      break;
    case 1:
      easingFunctionName = EasingFunctionName.EASE_IN_VERY_WEAK;
      break;
    case 2:
      easingFunctionName = EasingFunctionName.EASE_IN_WEAK;
      break;
    case 3:
      easingFunctionName = EasingFunctionName.EASE_IN;
      break;
    case 4:
      easingFunctionName = EasingFunctionName.EASE_IN_STRONG;
      break;
    case 5:
      easingFunctionName = EasingFunctionName.EASE_IN_VERY_STRONG;
      break;
    case 6:
      easingFunctionName = EasingFunctionName.EASE_OUT_VERY_WEAK;
      break;
    case 7:
      easingFunctionName = EasingFunctionName.EASE_OUT_WEAK;
      break;
    case 8:
      easingFunctionName = EasingFunctionName.EASE_OUT;
      break;
    case 9:
      easingFunctionName = EasingFunctionName.EASE_OUT_STRONG;
      break;
    case 10:
      easingFunctionName = EasingFunctionName.EASE_OUT_VERY_STRONG;
      break;
    case 11:
      easingFunctionName = EasingFunctionName.EASE_IN_OUT_VERY_WEAK;
      break;
    case 12:
      easingFunctionName = EasingFunctionName.EASE_IN_OUT_WEAK;
      break;
    case 13:
      easingFunctionName = EasingFunctionName.EASE_IN_OUT;
      break;
    case 14:
      easingFunctionName = EasingFunctionName.EASE_IN_OUT_STRONG;
      break;
    case 15:
      easingFunctionName = EasingFunctionName.EASE_IN_OUT_VERY_STRONG;
      break;
  }
  return easingFunctionName;
}
function angleDistance(from, to) {
  return MathUtils.angleDistanceDegrees(from, to);
}
function angleDistanceDegrees(from, to) {
  return Math.abs(MathUtils.angleDistanceSignedDegrees(from, to));
}
function angleDistanceRadians(from, to) {
  return Math.abs(MathUtils.angleDistanceSignedRadians(from, to));
}
function angleDistanceSigned(from, to) {
  return MathUtils.angleDistanceSignedDegrees(from, to);
}
function angleDistanceSignedDegrees(from, to) {
  const clampedFrom = MathUtils.angleClampDegrees(from, true);
  const clampedTo = MathUtils.angleClampDegrees(to, true);
  let distance2 = clampedTo - clampedFrom;
  if (clampedTo - clampedFrom > 180) {
    distance2 = clampedTo - clampedFrom - 360;
  } else if (clampedTo - clampedFrom < -180) {
    distance2 = clampedTo - clampedFrom + 360;
  }
  return distance2;
}
function angleDistanceSignedRadians(from, to) {
  return MathUtils.toRadians(MathUtils.angleDistanceSignedDegrees(MathUtils.toDegrees(from), MathUtils.toDegrees(to)));
}
function angleClamp(angle2, usePositiveRange = false) {
  return MathUtils.angleClampDegrees(angle2, usePositiveRange);
}
function angleClampDegrees(angle2, usePositiveRange = false) {
  let clampedAngle = angle2 % 360;
  if (clampedAngle < 0) {
    clampedAngle += 360;
  }
  if (!usePositiveRange) {
    if (clampedAngle > 180) {
      clampedAngle -= 360;
    }
  }
  return clampedAngle;
}
function angleClampRadians(angle2, usePositiveRange = false) {
  return MathUtils.toRadians(MathUtils.angleClampDegrees(MathUtils.toDegrees(angle2), usePositiveRange));
}
function isInsideAngleRange(angle2, start, end, useShortestAngle = false) {
  return MathUtils.isInsideAngleRangeDegrees(angle2, start, end, useShortestAngle);
}
function isInsideAngleRangeDegrees(angle2, start, end, useShortestAngle = false) {
  let insideAngleRange = false;
  const anglePositive = MathUtils.angleClampDegrees(angle2, true);
  let startPositive = MathUtils.angleClampDegrees(start, true);
  let endPositive = MathUtils.angleClampDegrees(end, true);
  if (useShortestAngle) {
    if (MathUtils.angleDistanceSignedDegrees(startPositive, endPositive) < 0) {
      const temp = startPositive;
      startPositive = endPositive;
      endPositive = temp;
    }
  }
  if (startPositive < endPositive) {
    insideAngleRange = anglePositive >= startPositive && anglePositive <= endPositive;
  } else {
    insideAngleRange = anglePositive >= startPositive || anglePositive <= endPositive;
  }
  return insideAngleRange;
}
function isInsideAngleRangeRadians(angle2, start, end, useShortestAngle = false) {
  return MathUtils.isInsideAngleRangeDegrees(MathUtils.toDegrees(angle2), MathUtils.toDegrees(start), MathUtils.toDegrees(end), useShortestAngle);
}
var MathUtils = {
  EPSILON,
  EPSILON_SQUARED,
  EPSILON_DEGREES,
  clamp,
  sign,
  toDegrees,
  toRadians,
  roundDecimal,
  mapToRange,
  random,
  randomInt,
  randomBool,
  randomSign,
  randomPick,
  randomUUID,
  lerp,
  interpolate,
  interpolatePeriodic,
  getEasingFunctionByName,
  getEasingFunctionNameByIndex,
  angleDistance,
  angleDistanceDegrees,
  angleDistanceRadians,
  angleDistanceSigned,
  angleDistanceSignedDegrees,
  angleDistanceSignedRadians,
  angleClamp,
  angleClampDegrees,
  angleClampRadians,
  isInsideAngleRange,
  isInsideAngleRangeDegrees,
  isInsideAngleRangeRadians
};

// dist/pp/cauldron/utils/array/array_utils.js
function copy(from, to, copyCallback) {
  const _to = to;
  if (_to.pop != null) {
    while (to.length > from.length) {
      _to.pop();
    }
  }
  for (let i = 0; i < from.length; i++) {
    if (copyCallback == null) {
      to[i] = from[i];
    } else {
      to[i] = copyCallback(from[i], to[i]);
    }
  }
  return to;
}
function clone(array, cloneCallback) {
  const clonedArray = array.slice(0);
  if (cloneCallback != null) {
    for (let i = 0; i < array.length; i++) {
      clonedArray[i] = cloneCallback(array[i]);
    }
  }
  return clonedArray;
}
function equals(array, other, elementsEqualCallback) {
  let equals10 = true;
  if (other != null && array.length == other.length) {
    for (let i = 0; i < array.length; i++) {
      if (elementsEqualCallback != null && !elementsEqualCallback(array[i], other[i]) || elementsEqualCallback == null && array[i] != other[i]) {
        equals10 = false;
        break;
      }
    }
  } else {
    equals10 = false;
  }
  return equals10;
}
function first(array) {
  return array.length > 0 ? array[0] : void 0;
}
function last(array) {
  return array.length > 0 ? array[array.length - 1] : void 0;
}
function has(array, callback) {
  return ArrayUtils.find(array, callback) != void 0;
}
function hasEqual(array, elementToFind, elementsEqualCallback) {
  return ArrayUtils.findEqual(array, elementToFind, elementsEqualCallback) != void 0;
}
function find(array, callback) {
  let elementFound = void 0;
  const index = ArrayUtils.findIndex(array, callback);
  if (index >= 0) {
    elementFound = array[index];
  }
  return elementFound;
}
function findIndex(array, callback) {
  return array.findIndex(callback);
}
function findAll(array, callback) {
  const elementsFound = [];
  for (let i = 0; i < array.length; i++) {
    const element = array[i];
    if (callback(element, i)) {
      elementsFound.push(element);
    }
  }
  return elementsFound;
}
function findAllIndexes(array, callback) {
  const indexes = [];
  for (let i = 0; i < array.length; i++) {
    const element = array[i];
    if (callback(element, i)) {
      indexes.push(i);
    }
  }
  return indexes;
}
function findEqual(array, elementToFind, elementsEqualCallback) {
  if (elementsEqualCallback == null) {
    const index = ArrayUtils.findIndexEqual(array, elementToFind);
    return index < 0 ? void 0 : array[index];
  }
  let elementFound = void 0;
  for (let i = 0; i < array.length; i++) {
    const currentElement = array[i];
    if (elementsEqualCallback(currentElement, elementToFind)) {
      elementFound = currentElement;
      break;
    }
  }
  return elementFound;
}
function findAllEqual(array, elementToFind, elementsEqualCallback) {
  if (elementsEqualCallback == null) {
    return _findAllEqualOptimized(array, elementToFind);
  }
  const elementsFound = [];
  for (let i = 0; i < array.length; i++) {
    const currentElement = array[i];
    if (elementsEqualCallback(currentElement, elementToFind)) {
      elementsFound.push(currentElement);
    }
  }
  return elementsFound;
}
function findIndexEqual(array, elementToFind, elementsEqualCallback) {
  if (elementsEqualCallback == null) {
    return array.indexOf(elementToFind);
  }
  let indexFound = -1;
  for (let i = 0; i < array.length; i++) {
    const currentElement = array[i];
    if (elementsEqualCallback(currentElement, elementToFind)) {
      indexFound = i;
      break;
    }
  }
  return indexFound;
}
function findAllIndexesEqual(array, elementToFind, elementsEqualCallback) {
  if (elementsEqualCallback == null) {
    return _findAllIndexesEqualOptimized(array, elementToFind);
  }
  const indexesFound = [];
  for (let i = 0; i < array.length; i++) {
    const currentElement = array[i];
    if (elementsEqualCallback(currentElement, elementToFind)) {
      indexesFound.push(i);
    }
  }
  return indexesFound;
}
function remove(array, callback) {
  let elementRemoved = void 0;
  const index = array.findIndex(callback);
  if (index >= 0) {
    elementRemoved = ArrayUtils.removeIndex(array, index);
  }
  return elementRemoved;
}
function removeIndex(array, index) {
  let elementRemoved = void 0;
  if (index >= 0 && index < array.length) {
    const arrayRemoved = array.splice(index, 1);
    if (arrayRemoved.length == 1) {
      elementRemoved = arrayRemoved[0];
    }
  }
  return elementRemoved;
}
function removeAll(array, callback) {
  const elementsRemoved = [];
  let currentElement = void 0;
  do {
    currentElement = ArrayUtils.remove(array, callback);
    if (currentElement !== void 0) {
      elementsRemoved.push(currentElement);
    }
  } while (currentElement !== void 0);
  return elementsRemoved;
}
function removeAllIndexes(array, indexes) {
  const elementsRemoved = [];
  for (const index of indexes) {
    const elementRemoved = ArrayUtils.removeIndex(array, index);
    if (elementRemoved !== void 0) {
      elementsRemoved.push(elementRemoved);
    }
  }
  return elementsRemoved;
}
function removeEqual(array, elementToRemove, elementsEqualCallback) {
  return ArrayUtils.removeIndex(array, ArrayUtils.findIndexEqual(array, elementToRemove, elementsEqualCallback));
}
function removeAllEqual(array, elementToRemove, elementsEqualCallback) {
  return ArrayUtils.removeAllIndexes(array, ArrayUtils.findAllIndexesEqual(array, elementToRemove, elementsEqualCallback));
}
function clear(array) {
  array.length = 0;
  return array;
}
function pushUnique(array, elementToAdd, elementsEqualCallback) {
  let length6 = array.length;
  const hasElement = ArrayUtils.hasEqual(array, elementToAdd, elementsEqualCallback);
  if (!hasElement) {
    length6 = array.push(elementToAdd);
  }
  return length6;
}
function unshiftUnique(array, elementToAdd, elementsEqualCallback) {
  let length6 = array.length;
  const hasElement = ArrayUtils.hasEqual(array, elementToAdd, elementsEqualCallback);
  if (!hasElement) {
    length6 = array.unshift(elementToAdd);
  }
  return length6;
}
var ArrayUtils = {
  copy,
  clone,
  equals,
  first,
  last,
  has,
  hasEqual,
  find,
  findIndex,
  findAll,
  findAllIndexes,
  findEqual,
  findAllEqual,
  findIndexEqual,
  findAllIndexesEqual,
  remove,
  removeIndex,
  removeAll,
  removeAllIndexes,
  removeEqual,
  removeAllEqual,
  clear,
  pushUnique,
  unshiftUnique
};
function _findAllEqualOptimized(array, elementToFind) {
  const elementsFound = [];
  let index = -1;
  while ((index = array.indexOf(elementToFind, index + 1)) >= 0) {
    elementsFound.push(array[index]);
  }
  return elementsFound;
}
function _findAllIndexesEqualOptimized(array, elementToFind) {
  const elementsFound = [];
  let index = -1;
  while ((index = array.indexOf(elementToFind, index + 1)) >= 0) {
    elementsFound.push(index);
  }
  return elementsFound;
}

// dist/pp/cauldron/utils/array/vec3_utils.js
import { vec3 as gl_vec32 } from "gl-matrix";

// dist/pp/cauldron/utils/array/mat4_utils.js
import { mat4 as gl_mat43 } from "gl-matrix";

// dist/pp/cauldron/utils/array/quat2_utils.js
import { mat4 as gl_mat42, quat2 as gl_quat22 } from "gl-matrix";

// dist/pp/cauldron/utils/array/vec_allocation_utils.js
import { mat3 as gl_mat3, mat4 as gl_mat4, quat as gl_quat, quat2 as gl_quat2, vec2 as gl_vec2, vec3 as gl_vec3, vec4 as gl_vec4, glMatrix } from "gl-matrix";
var _myVectorAllocationFunction = () => {
  return new glMatrix.ARRAY_TYPE(length);
};
function setVectorAllocationFunction(allocationFunction) {
  _myVectorAllocationFunction = allocationFunction;
}
function getVectorAllocationFunction() {
  return _myVectorAllocationFunction;
}
var _myVector2AllocationFunction = gl_vec2.create;
function setVector2AllocationFunction(allocationFunction) {
  _myVector2AllocationFunction = allocationFunction;
}
function getVector2AllocationFunction() {
  return _myVector2AllocationFunction;
}
var _myVector3AllocationFunction = gl_vec3.create;
function setVector3AllocationFunction(allocationFunction) {
  _myVector3AllocationFunction = allocationFunction;
}
function getVector3AllocationFunction() {
  return _myVector3AllocationFunction;
}
var _myVector4AllocationFunction = gl_vec4.create;
function setVector4AllocationFunction(allocationFunction) {
  _myVector4AllocationFunction = allocationFunction;
}
function getVector4AllocationFunction() {
  return _myVector4AllocationFunction;
}
var _myQuaternionAllocationFunction = gl_quat.create;
function setQuaternionAllocationFunction(allocationFunction) {
  _myQuaternionAllocationFunction = allocationFunction;
}
function getQuaternionAllocationFunction() {
  return _myQuaternionAllocationFunction;
}
var _myQuaternion2AllocationFunction = gl_quat2.create;
function setQuaternion2AllocationFunction(allocationFunction) {
  _myQuaternion2AllocationFunction = allocationFunction;
}
function getQuaternion2AllocationFunction() {
  return _myQuaternion2AllocationFunction;
}
var _myMatrix3AllocationFunction = gl_mat3.create;
function setMatrix3AllocationFunction(allocationFunction) {
  _myMatrix3AllocationFunction = allocationFunction;
}
function getMatrix3AllocationFunction() {
  return _myMatrix3AllocationFunction;
}
var _myMatrix4AllocationFunction = gl_mat4.create;
function setMatrix4AllocationFunction(allocationFunction) {
  _myMatrix4AllocationFunction = allocationFunction;
}
function getMatrix4AllocationFunction() {
  return _myMatrix4AllocationFunction;
}
var VecAllocationUtils = {
  setVectorAllocationFunction,
  getVectorAllocationFunction,
  setVector2AllocationFunction,
  getVector2AllocationFunction,
  setVector3AllocationFunction,
  getVector3AllocationFunction,
  setVector4AllocationFunction,
  getVector4AllocationFunction,
  setQuaternionAllocationFunction,
  getQuaternionAllocationFunction,
  setQuaternion2AllocationFunction,
  getQuaternion2AllocationFunction,
  setMatrix3AllocationFunction,
  getMatrix3AllocationFunction,
  setMatrix4AllocationFunction,
  getMatrix4AllocationFunction
};

// dist/pp/cauldron/utils/array/quat2_utils.js
function create4(x1, y1, z1, w1, x2, y2, z2, w2) {
  const out = getAllocationFunction()();
  if (x1 != null) {
    Quat2Utils.set(out, x1, y1, z1, w1, x2, y2, z2, w2);
  }
  return out;
}
function getAllocationFunction() {
  return getQuaternion2AllocationFunction();
}
function setAllocationFunction(allocationFunction) {
  setQuaternion2AllocationFunction(allocationFunction);
}
function set(quat, x1, y1, z1, w1, x2, y2, z2, w2) {
  if (y1 == null) {
    gl_quat22.set(quat, x1, x1, x1, x1, x1, x1, x1, x1);
  } else {
    gl_quat22.set(quat, x1, y1, z1, w1, x2, y2, z2, w2);
  }
  return quat;
}
function copy2(from, to) {
  gl_quat22.copy(to, from);
  return to;
}
function clone2(quat) {
  return quat.slice(0);
}
function equals2(first2, second, epsilon = 0) {
  let equals10 = first2.length == second.length;
  if (equals10) {
    equals10 &&= Math.abs(first2[0] - second[0]) <= epsilon;
    equals10 &&= Math.abs(first2[1] - second[1]) <= epsilon;
    equals10 &&= Math.abs(first2[2] - second[2]) <= epsilon;
    equals10 &&= Math.abs(first2[3] - second[3]) <= epsilon;
    equals10 &&= Math.abs(first2[4] - second[4]) <= epsilon;
    equals10 &&= Math.abs(first2[5] - second[5]) <= epsilon;
    equals10 &&= Math.abs(first2[6] - second[6]) <= epsilon;
    equals10 &&= Math.abs(first2[7] - second[7]) <= epsilon;
  }
  return equals10;
}
function isNormalized(quat, epsilon = MathUtils.EPSILON) {
  return Math.abs(Quat2Utils.lengthSquared(quat) - 1) < epsilon;
}
function normalize(quat, out = Quat2Utils.clone(quat)) {
  gl_quat22.normalize(out, quat);
  return out;
}
function length2(quat) {
  return gl_quat22.length(quat);
}
function lengthSquared(quat) {
  return gl_quat22.squaredLength(quat);
}
function identity(quat) {
  gl_quat22.identity(quat);
  return quat;
}
function mul(first2, second, out = Quat2Utils.clone(first2)) {
  gl_quat22.mul(out, first2, second);
  return out;
}
function invert(quat, out = Quat2Utils.clone(quat)) {
  gl_quat22.invert(out, quat);
  return out;
}
function conjugate(quat, out = Quat2Utils.clone(quat)) {
  gl_quat22.conjugate(out, quat);
  return out;
}
function lerp2(from, to, interpolationFactor, out = Quat2Utils.clone(from)) {
  if (interpolationFactor <= 0) {
    Quat2Utils.copy(from, out);
    return out;
  } else if (interpolationFactor >= 1) {
    Quat2Utils.copy(to, out);
    return out;
  }
  gl_quat22.lerp(out, from, to, interpolationFactor);
  return out;
}
function interpolate2(from, to, interpolationFactor, easingFunction = EasingFunction.linear, out = Quat2Utils.clone(from)) {
  const lerpFactor = easingFunction(interpolationFactor);
  return Quat2Utils.lerp(from, to, lerpFactor, out);
}
var slerp = function() {
  const fromPosition = create3();
  const toPosition = create3();
  const interpolatedPosition = create3();
  const fromRotationQuat = create2();
  const toRotationQuat = create2();
  const interpolatedRotationQuat = create2();
  function slerp3(from, to, interpolationFactor, out = Quat2Utils.clone(from)) {
    if (interpolationFactor <= 0) {
      Quat2Utils.copy(from, out);
      return out;
    } else if (interpolationFactor >= 1) {
      Quat2Utils.copy(to, out);
      return out;
    }
    Quat2Utils.getPosition(from, fromPosition);
    Quat2Utils.getPosition(to, toPosition);
    Quat2Utils.getRotationQuat(from, fromRotationQuat);
    Quat2Utils.getRotationQuat(to, toRotationQuat);
    Vec3Utils.lerp(fromPosition, toPosition, interpolationFactor, interpolatedPosition);
    QuatUtils.slerp(fromRotationQuat, toRotationQuat, interpolationFactor, interpolatedRotationQuat);
    Quat2Utils.setPositionRotationQuat(out, interpolatedPosition, interpolatedRotationQuat);
    return out;
  }
  return slerp3;
}();
function interpolateSpherical(from, to, interpolationFactor, easingFunction = EasingFunction.linear, out = Quat2Utils.clone(from)) {
  const lerpFactor = easingFunction(interpolationFactor);
  return Quat2Utils.slerp(from, to, lerpFactor, out);
}
function getPosition(quat, out = Vec3Utils.create()) {
  gl_quat22.getTranslation(out, quat);
  return out;
}
function getRotation(quat, out) {
  return Quat2Utils.getRotationDegrees(quat, out);
}
var getRotationDegrees = function() {
  const rotationQuat = create2();
  function getRotationDegrees4(quat, out = Vec3Utils.create()) {
    QuatUtils.toDegrees(Quat2Utils.getRotationQuat(quat, rotationQuat), out);
    return out;
  }
  return getRotationDegrees4;
}();
var getRotationRadians = function() {
  const rotationQuat = create2();
  function getRotationRadians4(quat, out = Vec3Utils.create()) {
    QuatUtils.toRadians(Quat2Utils.getRotationQuat(quat, rotationQuat), out);
    return out;
  }
  return getRotationRadians4;
}();
function getRotationQuat(quat, out = QuatUtils.create()) {
  QuatUtils.copy(quat, out);
  return out;
}
var setPosition = function() {
  const rotationQuat = create2();
  return function setPosition4(quat, position) {
    Quat2Utils.getRotationQuat(quat, rotationQuat);
    Quat2Utils.setPositionRotationQuat(quat, position, rotationQuat);
    return quat;
  };
}();
function setRotation(quat, rotation) {
  return Quat2Utils.setRotationDegrees(quat, rotation);
}
var setRotationDegrees = function() {
  const position = create3();
  return function setRotationDegrees4(quat, rotation) {
    Quat2Utils.getPosition(quat, position);
    Quat2Utils.setPositionRotationDegrees(quat, position, rotation);
    return quat;
  };
}();
var setRotationRadians = function() {
  const position = create3();
  return function setRotationRadians4(quat, rotation) {
    Quat2Utils.getPosition(quat, position);
    Quat2Utils.setPositionRotationRadians(quat, position, rotation);
    return quat;
  };
}();
var setRotationQuat = function() {
  const position = create3();
  return function setRotationQuat4(quat, rotation) {
    Quat2Utils.getPosition(quat, position);
    Quat2Utils.setPositionRotationQuat(quat, position, rotation);
    return quat;
  };
}();
function setPositionRotation(quat, position, rotation) {
  return Quat2Utils.setPositionRotationDegrees(quat, position, rotation);
}
var setPositionRotationDegrees = function() {
  const rotationQuat = create2();
  return function setPositionRotationDegrees3(quat, position, rotation) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    Quat2Utils.setPositionRotationQuat(quat, position, rotationQuat);
    return quat;
  };
}();
var setPositionRotationRadians = function() {
  const rotationQuat = create2();
  return function setPositionRotationRadians3(quat, position, rotation) {
    Vec3Utils.radiansToQuat(rotation, rotationQuat);
    Quat2Utils.setPositionRotationQuat(quat, position, rotationQuat);
    return quat;
  };
}();
function setPositionRotationQuat(quat, position, rotation) {
  gl_quat22.fromRotationTranslation(quat, rotation, position);
  return quat;
}
function getAxes(quat, out = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
  Quat2Utils.getLeft(quat, out[0]);
  Quat2Utils.getUp(quat, out[1]);
  Quat2Utils.getForward(quat, out[2]);
  return out;
}
var getForward = function() {
  const rotationMatrix = create();
  function getForward5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, rotationMatrix);
    Vec3Utils.set(out, rotationMatrix[6], rotationMatrix[7], rotationMatrix[8]);
    return out;
  }
  return getForward5;
}();
function getBackward(quat, out) {
  out = Quat2Utils.getForward(quat, out);
  Vec3Utils.negate(out, out);
  return out;
}
var getLeft = function() {
  const rotationMatrix = create();
  function getLeft5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, rotationMatrix);
    Vec3Utils.set(out, rotationMatrix[0], rotationMatrix[1], rotationMatrix[2]);
    return out;
  }
  return getLeft5;
}();
function getRight(quat, out) {
  out = Quat2Utils.getLeft(quat, out);
  Vec3Utils.negate(out, out);
  return out;
}
var getUp = function() {
  const rotationMatrix = create();
  function getUp5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, rotationMatrix);
    Vec3Utils.set(out, rotationMatrix[3], rotationMatrix[4], rotationMatrix[5]);
    return out;
  }
  return getUp5;
}();
function getDown(quat, out) {
  out = Quat2Utils.getUp(quat, out);
  Vec3Utils.negate(out, out);
  return out;
}
function rotateAxis(quat, angle2, axis, out) {
  return Quat2Utils.rotateAxisDegrees(quat, angle2, axis, out);
}
function rotateAxisDegrees(quat, angle2, axis, out = Quat2Utils.clone(quat)) {
  return Quat2Utils.rotateAxisRadians(quat, MathUtils.toRadians(angle2), axis, out);
}
var rotateAxisRadians = function() {
  const rotationQuat = create2();
  function rotateAxisRadians5(quat, angle2, axis, out = Quat2Utils.clone(quat)) {
    Quat2Utils.getRotationQuat(quat, rotationQuat);
    QuatUtils.rotateAxisRadians(rotationQuat, angle2, axis, rotationQuat);
    Quat2Utils.copy(quat, out);
    Quat2Utils.setRotationQuat(out, rotationQuat);
    return out;
  }
  return rotateAxisRadians5;
}();
function toWorld(quat, parentTransformQuat, out = Quat2Utils.clone(quat)) {
  Quat2Utils.mul(parentTransformQuat, quat, out);
  return out;
}
var toLocal = function() {
  const invertQuat = create4();
  function toLocal4(quat, parentTransformQuat, out = Quat2Utils.clone(quat)) {
    Quat2Utils.conjugate(parentTransformQuat, invertQuat);
    Quat2Utils.mul(invertQuat, quat, out);
    return out;
  }
  return toLocal4;
}();
function toMatrix(quat, out = Mat4Utils.create()) {
  _customGLMatrixFromQuat2(out, quat);
  return out;
}
function fromMatrix(matrix, out = Quat2Utils.create()) {
  Mat4Utils.toQuat(matrix, out);
  return out;
}
var Quat2Utils = {
  create: create4,
  getAllocationFunction,
  setAllocationFunction,
  set,
  copy: copy2,
  clone: clone2,
  equals: equals2,
  isNormalized,
  normalize,
  length: length2,
  lengthSquared,
  identity,
  mul,
  invert,
  conjugate,
  lerp: lerp2,
  interpolate: interpolate2,
  slerp,
  interpolateSpherical,
  getPosition,
  getRotation,
  getRotationDegrees,
  getRotationRadians,
  getRotationQuat,
  setPosition,
  setRotation,
  setRotationDegrees,
  setRotationRadians,
  setRotationQuat,
  setPositionRotation,
  setPositionRotationDegrees,
  setPositionRotationRadians,
  setPositionRotationQuat,
  getAxes,
  getForward,
  getBackward,
  getLeft,
  getRight,
  getUp,
  getDown,
  rotateAxis,
  rotateAxisDegrees,
  rotateAxisRadians,
  toWorld,
  toLocal,
  toMatrix,
  fromMatrix
};
var _customGLMatrixFromQuat2 = function() {
  const translation = create3();
  return function _customGLMatrixFromQuat22(out, quat) {
    const bx = -quat[0], by = -quat[1], bz = -quat[2], bw = quat[3], ax = quat[4], ay = quat[5], az = quat[6], aw = quat[7];
    const magnitude = bx * bx + by * by + bz * bz + bw * bw;
    if (magnitude > 0) {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }
    gl_mat42.fromRotationTranslation(out, quat, translation);
    return out;
  };
}();

// dist/pp/cauldron/utils/array/mat4_utils.js
function create5(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  const out = getAllocationFunction2()();
  if (m00 != null) {
    Mat4Utils.set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
  }
  return out;
}
function getAllocationFunction2() {
  return getMatrix4AllocationFunction();
}
function setAllocationFunction2(allocationFunction) {
  setMatrix4AllocationFunction(allocationFunction);
}
function set3(matrix, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  if (m01 == null) {
    gl_mat43.set(matrix, m00, m00, m00, m00, m00, m00, m00, m00, m00, m00, m00, m00, m00, m00, m00, m00);
  } else {
    gl_mat43.set(matrix, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
  }
  return matrix;
}
function copy3(from, to) {
  gl_mat43.copy(to, from);
  return to;
}
function clone3(matrix) {
  return matrix.slice(0);
}
function equals3(first2, second, epsilon = 0) {
  let equals10 = first2.length == second.length;
  if (equals10) {
    equals10 &&= Math.abs(first2[0] - second[0]) <= epsilon;
    equals10 &&= Math.abs(first2[1] - second[1]) <= epsilon;
    equals10 &&= Math.abs(first2[2] - second[2]) <= epsilon;
    equals10 &&= Math.abs(first2[3] - second[3]) <= epsilon;
    equals10 &&= Math.abs(first2[4] - second[4]) <= epsilon;
    equals10 &&= Math.abs(first2[5] - second[5]) <= epsilon;
    equals10 &&= Math.abs(first2[6] - second[6]) <= epsilon;
    equals10 &&= Math.abs(first2[7] - second[7]) <= epsilon;
    equals10 &&= Math.abs(first2[8] - second[8]) <= epsilon;
    equals10 &&= Math.abs(first2[9] - second[9]) <= epsilon;
    equals10 &&= Math.abs(first2[10] - second[10]) <= epsilon;
    equals10 &&= Math.abs(first2[11] - second[11]) <= epsilon;
    equals10 &&= Math.abs(first2[12] - second[12]) <= epsilon;
    equals10 &&= Math.abs(first2[13] - second[13]) <= epsilon;
    equals10 &&= Math.abs(first2[14] - second[14]) <= epsilon;
    equals10 &&= Math.abs(first2[15] - second[15]) <= epsilon;
  }
  return equals10;
}
function identity2(matrix) {
  gl_mat43.identity(matrix);
  return matrix;
}
function invert2(matrix, out = Mat4Utils.clone(matrix)) {
  gl_mat43.invert(out, matrix);
  return out;
}
function mul2(first2, second, out = Mat4Utils.clone(first2)) {
  gl_mat43.mul(out, first2, second);
  return out;
}
function scale(matrix, vector, out = Mat4Utils.clone(matrix)) {
  gl_mat43.scale(out, matrix, vector);
  return out;
}
function getPosition2(matrix, out = Vec3Utils.create()) {
  gl_mat43.getTranslation(out, matrix);
  return out;
}
function getRotation2(matrix, out) {
  return Mat4Utils.getRotationDegrees(matrix, out);
}
var getRotationDegrees2 = function() {
  const quat = create2();
  function getRotationDegrees4(matrix, out = Vec3Utils.create()) {
    Mat4Utils.getRotationQuat(matrix, quat);
    QuatUtils.toDegrees(quat, out);
    return out;
  }
  return getRotationDegrees4;
}();
var getRotationRadians2 = function() {
  const quat = create2();
  function getRotationRadians4(matrix, out = Vec3Utils.create()) {
    Mat4Utils.getRotationQuat(matrix, quat);
    QuatUtils.toRadians(quat, out);
    return out;
  }
  return getRotationRadians4;
}();
var getRotationQuat2 = function() {
  const tempScale = create3();
  const transformMatrixNoScale = create5();
  const inverseScale = create3();
  const one = create3();
  set2(one, 1, 1, 1);
  function getRotationQuat4(matrix, out = QuatUtils.create()) {
    Mat4Utils.getScale(matrix, tempScale);
    Vec3Utils.div(one, tempScale, inverseScale);
    Mat4Utils.scale(matrix, inverseScale, transformMatrixNoScale);
    _customGLMatrixGetRotation(out, transformMatrixNoScale);
    return out;
  }
  return getRotationQuat4;
}();
function getScale(matrix, out = Vec3Utils.create()) {
  gl_mat43.getScaling(out, matrix);
  return out;
}
function setPosition2(matrix, position) {
  matrix[12] = position[0];
  matrix[13] = position[1];
  matrix[14] = position[2];
  return matrix;
}
function setRotation2(matrix, rotation) {
  Mat4Utils.setRotationDegrees(matrix, rotation);
  return matrix;
}
var setRotationDegrees2 = function() {
  const quat = create2();
  return function setRotationDegrees4(matrix, rotation) {
    Mat4Utils.setRotationQuat(matrix, Vec3Utils.degreesToQuat(rotation, quat));
    return matrix;
  };
}();
var setRotationRadians2 = function() {
  const vector = create3();
  return function setRotationRadians4(matrix, rotation) {
    Mat4Utils.setRotationDegrees(matrix, Vec3Utils.toDegrees(rotation, vector));
    return matrix;
  };
}();
var setRotationQuat2 = function() {
  const position = create3();
  const scale4 = create3();
  return function setRotationQuat4(matrix, rotation) {
    Mat4Utils.getPosition(matrix, position);
    Mat4Utils.getScale(matrix, scale4);
    Mat4Utils.setPositionRotationQuatScale(matrix, position, rotation, scale4);
    return matrix;
  };
}();
var setScale = function() {
  const tempScale = create3();
  return function setScale3(matrix, scale4) {
    Mat4Utils.getScale(matrix, tempScale);
    Vec3Utils.div(scale4, tempScale, tempScale);
    Mat4Utils.scale(matrix, tempScale, matrix);
    return matrix;
  };
}();
function setPositionRotationScale(matrix, position, rotation, scale4) {
  Mat4Utils.setPositionRotationDegreesScale(matrix, position, rotation, scale4);
  return matrix;
}
var setPositionRotationDegreesScale = function() {
  const quat = create2();
  return function setPositionRotationDegreesScale2(matrix, position, rotation, scale4) {
    Mat4Utils.setPositionRotationQuatScale(matrix, position, Vec3Utils.degreesToQuat(rotation, quat), scale4);
    return matrix;
  };
}();
var setPositionRotationRadiansScale = function() {
  const vector = create3();
  return function setPositionRotationRadiansScale2(matrix, position, rotation, scale4) {
    Mat4Utils.setPositionRotationDegreesScale(matrix, position, Vec3Utils.toDegrees(rotation, vector), scale4);
    return matrix;
  };
}();
function setPositionRotationQuatScale(matrix, position, rotation, scale4) {
  gl_mat43.fromRotationTranslationScale(matrix, rotation, position, scale4);
  return matrix;
}
function setPositionRotation2(matrix, position, rotation) {
  Mat4Utils.setPositionRotationDegrees(matrix, position, rotation);
  return matrix;
}
var setPositionRotationDegrees2 = function() {
  const quat = create2();
  return function setPositionRotationDegrees3(matrix, position, rotation) {
    Mat4Utils.setPositionRotationQuat(matrix, position, Vec3Utils.degreesToQuat(rotation, quat));
    return matrix;
  };
}();
var setPositionRotationRadians2 = function() {
  const vector = create3();
  return function setPositionRotationRadians3(matrix, position, rotation) {
    Mat4Utils.setPositionRotationDegrees(matrix, position, Vec3Utils.toDegrees(rotation, vector));
    return matrix;
  };
}();
function setPositionRotationQuat2(matrix, position, rotation) {
  gl_mat43.fromRotationTranslation(matrix, rotation, position);
  return matrix;
}
function getAxes2(matrix, out = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
  Mat4Utils.getLeft(matrix, out[0]);
  Mat4Utils.getUp(matrix, out[1]);
  Mat4Utils.getForward(matrix, out[2]);
  return out;
}
function getForward2(matrix, out = Vec3Utils.create()) {
  Vec3Utils.set(out, matrix[8], matrix[9], matrix[10]);
  Vec3Utils.normalize(out, out);
  return out;
}
function getBackward2(matrix, out) {
  out = Mat4Utils.getForward(matrix, out);
  Vec3Utils.negate(out, out);
  return out;
}
function getLeft2(matrix, out = Vec3Utils.create()) {
  Vec3Utils.set(out, matrix[0], matrix[1], matrix[2]);
  Vec3Utils.normalize(out, out);
  return out;
}
function getRight2(matrix, out) {
  out = Mat4Utils.getLeft(matrix, out);
  Vec3Utils.negate(out, out);
  return out;
}
function getUp2(matrix, out = Vec3Utils.create()) {
  Vec3Utils.set(out, matrix[4], matrix[5], matrix[6]);
  Vec3Utils.normalize(out, out);
  return out;
}
function getDown2(matrix, out) {
  out = Mat4Utils.getUp(matrix, out);
  Vec3Utils.negate(out, out);
  return out;
}
var hasUniformScale = function() {
  const scale4 = create3();
  return function hasUniformScale3(matrix) {
    Mat4Utils.getScale(matrix, scale4);
    return Math.abs(scale4[0] - scale4[1]) < MathUtils.EPSILON && Math.abs(scale4[1] - scale4[2]) < MathUtils.EPSILON && Math.abs(scale4[0] - scale4[2]) < MathUtils.EPSILON;
  };
}();
var toWorld2 = function() {
  const convertTransform = create5();
  const position = create3();
  const tempScale = create3();
  const inverseScale = create3();
  const one = create3();
  set2(one, 1, 1, 1);
  function toWorld4(matrix, parentTransformMatrix, out = Mat4Utils.clone(matrix)) {
    if (Mat4Utils.hasUniformScale(parentTransformMatrix)) {
      Mat4Utils.mul(parentTransformMatrix, matrix, out);
    } else {
      Vec3Utils.set(position, matrix[12], matrix[13], matrix[14]);
      Vec3Utils.convertPositionToWorldMatrix(position, parentTransformMatrix, position);
      Mat4Utils.getScale(parentTransformMatrix, tempScale);
      Vec3Utils.div(one, tempScale, inverseScale);
      Mat4Utils.scale(parentTransformMatrix, inverseScale, convertTransform);
      Mat4Utils.mul(convertTransform, matrix, out);
      Mat4Utils.scale(out, tempScale, out);
      out[12] = position[0];
      out[13] = position[1];
      out[14] = position[2];
      out[15] = 1;
    }
    return out;
  }
  return toWorld4;
}();
var toLocal2 = function() {
  const convertTransform = create5();
  const position = create3();
  const tempScale = create3();
  const inverseScale = create3();
  const one = create3();
  set2(one, 1, 1, 1);
  function toLocal4(matrix, parentTransformMatrix, out = Mat4Utils.clone(matrix)) {
    if (Mat4Utils.hasUniformScale(parentTransformMatrix)) {
      Mat4Utils.invert(parentTransformMatrix, convertTransform);
      Mat4Utils.mul(convertTransform, matrix, out);
    } else {
      Vec3Utils.set(position, matrix[12], matrix[13], matrix[14]);
      Vec3Utils.convertPositionToLocalMatrix(position, parentTransformMatrix, position);
      Mat4Utils.getScale(parentTransformMatrix, tempScale);
      Vec3Utils.div(one, tempScale, inverseScale);
      Mat4Utils.scale(parentTransformMatrix, inverseScale, convertTransform);
      Mat4Utils.invert(convertTransform, convertTransform);
      Mat4Utils.mul(convertTransform, matrix, out);
      Mat4Utils.scale(out, inverseScale, out);
      out[12] = position[0];
      out[13] = position[1];
      out[14] = position[2];
      out[15] = 1;
    }
    return out;
  }
  return toLocal4;
}();
var toQuat = function() {
  const position = create3();
  const rotation = create2();
  function toQuat4(matrix, out = Quat2Utils.create()) {
    Mat4Utils.getPosition(matrix, position);
    Mat4Utils.getRotationQuat(matrix, rotation);
    Quat2Utils.setPositionRotationQuat(out, position, rotation);
    return out;
  }
  return toQuat4;
}();
function fromQuat(quat, out = Mat4Utils.create()) {
  Quat2Utils.toMatrix(quat, out);
  return out;
}
var Mat4Utils = {
  create: create5,
  getAllocationFunction: getAllocationFunction2,
  setAllocationFunction: setAllocationFunction2,
  set: set3,
  copy: copy3,
  clone: clone3,
  equals: equals3,
  identity: identity2,
  invert: invert2,
  mul: mul2,
  scale,
  getPosition: getPosition2,
  getRotation: getRotation2,
  getRotationDegrees: getRotationDegrees2,
  getRotationRadians: getRotationRadians2,
  getRotationQuat: getRotationQuat2,
  getScale,
  setPosition: setPosition2,
  setRotation: setRotation2,
  setRotationDegrees: setRotationDegrees2,
  setRotationRadians: setRotationRadians2,
  setRotationQuat: setRotationQuat2,
  setScale,
  setPositionRotationScale,
  setPositionRotationDegreesScale,
  setPositionRotationRadiansScale,
  setPositionRotationQuatScale,
  setPositionRotation: setPositionRotation2,
  setPositionRotationDegrees: setPositionRotationDegrees2,
  setPositionRotationRadians: setPositionRotationRadians2,
  setPositionRotationQuat: setPositionRotationQuat2,
  getAxes: getAxes2,
  getForward: getForward2,
  getBackward: getBackward2,
  getLeft: getLeft2,
  getRight: getRight2,
  getUp: getUp2,
  getDown: getDown2,
  hasUniformScale,
  toWorld: toWorld2,
  toLocal: toLocal2,
  toQuat,
  fromQuat
};
var _customGLMatrixGetRotation = function() {
  const scaling = create3();
  return function _customGLMatrixGetRotation2(out, mat) {
    gl_mat43.getScaling(scaling, mat);
    const is1 = 1 / scaling[0];
    const is2 = 1 / scaling[1];
    const is3 = 1 / scaling[2];
    const sm11 = mat[0] * is1;
    const sm12 = mat[1] * is2;
    const sm13 = mat[2] * is3;
    const sm21 = mat[4] * is1;
    const sm22 = mat[5] * is2;
    const sm23 = mat[6] * is3;
    const sm31 = mat[8] * is1;
    const sm32 = mat[9] * is2;
    const sm33 = mat[10] * is3;
    const trace = sm11 + sm22 + sm33;
    if (trace > 0) {
      const s = Math.sqrt(trace + 1) * 2;
      out[3] = 0.25 * s;
      out[0] = (sm23 - sm32) / s;
      out[1] = (sm31 - sm13) / s;
      out[2] = (sm12 - sm21) / s;
    } else if (sm11 > sm22 && sm11 > sm33) {
      const s = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
      out[3] = (sm23 - sm32) / s;
      out[0] = 0.25 * s;
      out[1] = (sm12 + sm21) / s;
      out[2] = (sm31 + sm13) / s;
    } else if (sm22 > sm33) {
      const s = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
      out[3] = (sm31 - sm13) / s;
      out[0] = (sm12 + sm21) / s;
      out[1] = 0.25 * s;
      out[2] = (sm23 + sm32) / s;
    } else {
      const s = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
      out[3] = (sm12 - sm21) / s;
      out[0] = (sm31 + sm13) / s;
      out[1] = (sm23 + sm32) / s;
      out[2] = 0.25 * s;
    }
    return out;
  };
}();

// dist/pp/cauldron/utils/array/vec3_utils.js
function create3(x, y, z) {
  const out = getAllocationFunction3()();
  if (x != null) {
    Vec3Utils.set(out, x, y, z);
  }
  return out;
}
function getAllocationFunction3() {
  return getVector3AllocationFunction();
}
function setAllocationFunction3(allocationFunction) {
  setVector3AllocationFunction(allocationFunction);
}
function set2(vector, x, y, z) {
  if (y == null) {
    gl_vec32.set(vector, x, x, x);
  } else {
    gl_vec32.set(vector, x, y, z);
  }
  return vector;
}
function copy4(from, to) {
  gl_vec32.copy(to, from);
  return to;
}
function clone4(vector) {
  return vector.slice(0);
}
function equals4(first2, second, epsilon = 0) {
  let equals10 = first2.length == second.length;
  if (equals10) {
    equals10 &&= Math.abs(first2[0] - second[0]) <= epsilon;
    equals10 &&= Math.abs(first2[1] - second[1]) <= epsilon;
    equals10 &&= Math.abs(first2[2] - second[2]) <= epsilon;
  }
  return equals10;
}
function isNormalized2(vector, epsilon = MathUtils.EPSILON) {
  return Math.abs(Vec3Utils.lengthSquared(vector) - 1) < epsilon;
}
function normalize2(vector, out = Vec3Utils.clone(vector)) {
  gl_vec32.normalize(out, vector);
  return out;
}
function isZero(vector, epsilon = 0) {
  return Vec3Utils.lengthSquared(vector) <= epsilon * epsilon;
}
function zero(vector) {
  gl_vec32.zero(vector);
  return vector;
}
function length3(vector) {
  return gl_vec32.length(vector);
}
function lengthSquared2(vector) {
  return gl_vec32.squaredLength(vector);
}
function lengthSigned(vector, positiveDirection) {
  let signedLength = Vec3Utils.length(vector);
  if (!Vec3Utils.isConcordant(vector, positiveDirection)) {
    signedLength *= -1;
  }
  return signedLength;
}
function distance(first2, second) {
  return gl_vec32.dist(first2, second);
}
function distanceSquared(first2, second) {
  return gl_vec32.squaredDistance(first2, second);
}
function add(first2, second, out = Vec3Utils.clone(first2)) {
  gl_vec32.add(out, first2, second);
  return out;
}
function sub(first2, second, out = Vec3Utils.clone(first2)) {
  gl_vec32.sub(out, first2, second);
  return out;
}
function mul3(first2, second, out = Vec3Utils.clone(first2)) {
  gl_vec32.mul(out, first2, second);
  return out;
}
function div(first2, second, out = Vec3Utils.clone(first2)) {
  gl_vec32.div(out, first2, second);
  return out;
}
function scale2(vector, value, out = Vec3Utils.clone(vector)) {
  gl_vec32.scale(out, vector, value);
  return out;
}
function negate(vector, out = Vec3Utils.clone(vector)) {
  gl_vec32.negate(out, vector);
  return out;
}
function dot(first2, second) {
  return gl_vec32.dot(first2, second);
}
function cross(first2, second, out = Vec3Utils.clone(first2)) {
  gl_vec32.cross(out, first2, second);
  return out;
}
function transformQuat(vector, quat, out = Vec3Utils.clone(vector)) {
  gl_vec32.transformQuat(out, vector, quat);
  return out;
}
function transformMat3(vector, matrix, out = Vec3Utils.clone(vector)) {
  gl_vec32.transformMat3(out, vector, matrix);
  return out;
}
function transformMat4(vector, matrix, out = Vec3Utils.clone(vector)) {
  gl_vec32.transformMat4(out, vector, matrix);
  return out;
}
function lerp3(from, to, interpolationFactor, out = Vec3Utils.clone(from)) {
  if (interpolationFactor <= 0) {
    Vec3Utils.copy(from, out);
    return out;
  } else if (interpolationFactor >= 1) {
    Vec3Utils.copy(to, out);
    return out;
  }
  gl_vec32.lerp(out, from, to, interpolationFactor);
  return out;
}
function interpolate3(from, to, interpolationFactor, easingFunction = EasingFunction.linear, out = Vec3Utils.clone(from)) {
  const lerpFactor = easingFunction(interpolationFactor);
  return Vec3Utils.lerp(from, to, lerpFactor, out);
}
function angle(first2, second) {
  return Vec3Utils.angleDegrees(first2, second);
}
function angleDegrees(first2, second) {
  return MathUtils.toDegrees(Vec3Utils.angleRadians(first2, second));
}
function angleRadians(first2, second) {
  const firstX = first2[0];
  const firstY = first2[1];
  const firstZ = first2[2];
  const secondX = second[0];
  const secondY = second[1];
  const secondZ = second[2];
  const firstLengthSquared = firstX * firstX + firstY * firstY + firstZ * firstZ;
  const secondLengthSquared = secondX * secondX + secondY * secondY + secondZ * secondZ;
  const lengthSquared4 = firstLengthSquared * secondLengthSquared;
  let angle2 = 0;
  if (lengthSquared4 > MathUtils.EPSILON_SQUARED) {
    const length6 = Math.sqrt(lengthSquared4);
    const cos = Vec3Utils.dot(first2, second) / length6;
    angle2 = Math.acos(MathUtils.clamp(cos, -1, 1));
  }
  return angle2;
}
function angleSigned(first2, second, referenceAxis) {
  return Vec3Utils.angleSignedDegrees(first2, second, referenceAxis);
}
function angleSignedDegrees(first2, second, referenceAxis) {
  return MathUtils.toDegrees(Vec3Utils.angleSignedRadians(first2, second, referenceAxis));
}
var angleSignedRadians = function() {
  const crossAxis = create3();
  return function angleSignedRadians2(first2, second, referenceAxis) {
    Vec3Utils.cross(first2, second, crossAxis);
    let angle2 = Vec3Utils.angleRadians(first2, second);
    if (!Vec3Utils.isConcordant(crossAxis, referenceAxis)) {
      angle2 = -angle2;
    }
    return angle2;
  };
}();
function anglePivoted(first2, second, referenceAxis) {
  return Vec3Utils.anglePivotedDegrees(first2, second, referenceAxis);
}
function anglePivotedDegrees(first2, second, referenceAxis) {
  return MathUtils.toDegrees(Vec3Utils.anglePivotedRadians(first2, second, referenceAxis));
}
var anglePivotedRadians = function() {
  const flatFirst = create3();
  const flatSecond = create3();
  return function anglePivotedRadians2(first2, second, referenceAxis) {
    Vec3Utils.removeComponentAlongAxis(first2, referenceAxis, flatFirst);
    Vec3Utils.removeComponentAlongAxis(second, referenceAxis, flatSecond);
    return Vec3Utils.angleRadians(flatFirst, flatSecond);
  };
}();
function anglePivotedSigned(first2, second, referenceAxis) {
  return Vec3Utils.anglePivotedSignedDegrees(first2, second, referenceAxis);
}
function anglePivotedSignedDegrees(first2, second, referenceAxis) {
  return MathUtils.toDegrees(Vec3Utils.anglePivotedSignedRadians(first2, second, referenceAxis));
}
var anglePivotedSignedRadians = function() {
  const flatFirst = create3();
  const flatSecond = create3();
  return function anglePivotedSignedRadians2(first2, second, referenceAxis) {
    Vec3Utils.removeComponentAlongAxis(first2, referenceAxis, flatFirst);
    Vec3Utils.removeComponentAlongAxis(second, referenceAxis, flatSecond);
    return Vec3Utils.angleSignedRadians(flatFirst, flatSecond, referenceAxis);
  };
}();
function valueAlongAxis(vector, axis) {
  const valueAlongAxis2 = Vec3Utils.dot(vector, axis);
  return valueAlongAxis2;
}
var valueAlongPlane = function() {
  const componentAlong = create3();
  return function valueAlongPlane2(vector, planeNormal) {
    Vec3Utils.removeComponentAlongAxis(vector, planeNormal, componentAlong);
    return Vec3Utils.length(componentAlong);
  };
}();
function componentAlongAxis(vector, axis, out = Vec3Utils.clone(vector)) {
  const valueAlongAxis2 = Vec3Utils.valueAlongAxis(vector, axis);
  Vec3Utils.copy(axis, out);
  Vec3Utils.scale(out, valueAlongAxis2, out);
  return out;
}
var removeComponentAlongAxis = function() {
  const componentAlong = create3();
  function removeComponentAlongAxis2(vector, axis, out = Vec3Utils.clone(vector)) {
    Vec3Utils.componentAlongAxis(vector, axis, componentAlong);
    Vec3Utils.sub(vector, componentAlong, out);
    return out;
  }
  return removeComponentAlongAxis2;
}();
var copyComponentAlongAxis = function() {
  const componentAlong = create3();
  function copyComponentAlongAxis2(from, to, axis, out = Vec3Utils.clone(from)) {
    Vec3Utils.removeComponentAlongAxis(to, axis, out);
    Vec3Utils.componentAlongAxis(from, axis, componentAlong);
    Vec3Utils.add(out, componentAlong, out);
    return out;
  }
  return copyComponentAlongAxis2;
}();
function isConcordant(first2, second) {
  return Vec3Utils.dot(first2, second) >= 0;
}
function isFartherAlongAxis(first2, second, axis) {
  return Vec3Utils.valueAlongAxis(first2, axis) > Vec3Utils.valueAlongAxis(second, axis);
}
function isToTheRight(first2, second, referenceAxis) {
  return Vec3Utils.signTo(first2, second, referenceAxis) >= 0;
}
var signTo = function() {
  const componentAlongThis = create3();
  const componentAlongVector = create3();
  return function signTo2(first2, second, referenceAxis, zeroSign = 1) {
    Vec3Utils.removeComponentAlongAxis(first2, referenceAxis, componentAlongThis);
    Vec3Utils.removeComponentAlongAxis(second, referenceAxis, componentAlongVector);
    const angleSignedResult = Vec3Utils.angleSigned(first2, second, referenceAxis);
    return angleSignedResult > 0 ? 1 : angleSignedResult == 0 ? zeroSign : -1;
  };
}();
function projectOnAxis(vector, axis, out = Vec3Utils.clone(vector)) {
  Vec3Utils.componentAlongAxis(vector, axis, out);
  return out;
}
var projectOnAxisAlongAxis = function() {
  const up = create3();
  const vectorProjectedToAxis = create3();
  const fixedProjectAlongAxis = create3();
  function projectOnAxisAlongAxis2(vector, axis, projectAlongAxis, out = Vec3Utils.clone(vector)) {
    if (Vec3Utils.isOnAxis(vector, axis) || Vec3Utils.isOnAxis(projectAlongAxis, axis)) {
      Vec3Utils.copy(vector, out);
    } else {
      Vec3Utils.cross(projectAlongAxis, axis, up);
      Vec3Utils.normalize(up, up);
      if (Vec3Utils.isZero(up)) {
        Vec3Utils.perpendicularAny(projectAlongAxis, up);
        Vec3Utils.normalize(up, up);
      }
      Vec3Utils.removeComponentAlongAxis(vector, up, out);
      if (!Vec3Utils.isOnAxis(out, axis)) {
        Vec3Utils.projectOnAxis(out, axis, vectorProjectedToAxis);
        Vec3Utils.sub(vectorProjectedToAxis, out, vectorProjectedToAxis);
        if (Vec3Utils.isConcordant(vectorProjectedToAxis, projectAlongAxis)) {
          Vec3Utils.copy(projectAlongAxis, fixedProjectAlongAxis);
        } else {
          Vec3Utils.negate(projectAlongAxis, fixedProjectAlongAxis);
        }
        const angleWithAlongAxis = Vec3Utils.angleRadians(fixedProjectAlongAxis, vectorProjectedToAxis);
        const lengthToRemove = Vec3Utils.length(vectorProjectedToAxis) / Math.cos(angleWithAlongAxis);
        Vec3Utils.scale(fixedProjectAlongAxis, lengthToRemove, fixedProjectAlongAxis);
        Vec3Utils.add(out, fixedProjectAlongAxis, out);
        Vec3Utils.projectOnAxis(out, axis, out);
      }
    }
    return out;
  }
  return projectOnAxisAlongAxis2;
}();
function projectOnPlane(vector, planeNormal, out = Vec3Utils.clone(vector)) {
  Vec3Utils.removeComponentAlongAxis(vector, planeNormal, out);
  return out;
}
var projectOnPlaneAlongAxis = function() {
  const vectorProjectedToPlane = create3();
  const fixedProjectAlongAxis = create3();
  function projectOnPlaneAlongAxis2(vector, planeNormal, projectAlongAxis, out = Vec3Utils.clone(vector)) {
    if (Vec3Utils.isOnPlane(vector, planeNormal) || Vec3Utils.isOnPlane(projectAlongAxis, planeNormal)) {
      Vec3Utils.copy(vector, out);
    } else {
      Vec3Utils.copy(vector, out);
      Vec3Utils.projectOnPlane(out, planeNormal, vectorProjectedToPlane);
      Vec3Utils.sub(vectorProjectedToPlane, out, vectorProjectedToPlane);
      if (Vec3Utils.isConcordant(vectorProjectedToPlane, projectAlongAxis)) {
        Vec3Utils.copy(projectAlongAxis, fixedProjectAlongAxis);
      } else {
        Vec3Utils.negate(projectAlongAxis, fixedProjectAlongAxis);
      }
      const angleWithAlongAxis = Vec3Utils.angleRadians(fixedProjectAlongAxis, vectorProjectedToPlane);
      const lengthToRemove = Vec3Utils.length(vectorProjectedToPlane) / Math.cos(angleWithAlongAxis);
      Vec3Utils.scale(fixedProjectAlongAxis, lengthToRemove, fixedProjectAlongAxis);
      Vec3Utils.add(out, fixedProjectAlongAxis, out);
      Vec3Utils.projectOnPlane(out, planeNormal, out);
    }
    return out;
  }
  return projectOnPlaneAlongAxis2;
}();
function isOnAxis(vector, axis) {
  const angleResult = Vec3Utils.angle(vector, axis);
  return Math.abs(angleResult) < MathUtils.EPSILON_DEGREES || Math.abs(angleResult - 180) < MathUtils.EPSILON_DEGREES;
}
function isOnPlane(vector, planeNormal) {
  const angleResult = Vec3Utils.angle(vector, planeNormal);
  return Math.abs(angleResult - 90) < MathUtils.EPSILON_DEGREES;
}
var perpendicularAny = function() {
  const notVector = create3();
  function perpendicularAny2(vector, out = Vec3Utils.clone(vector)) {
    if (Vec3Utils.isZero(vector)) {
      return Vec3Utils.zero(out);
    }
    Vec3Utils.copy(vector, notVector);
    let zeroAmount = 0;
    for (let i = 0; i < 3; i++) {
      if (vector[i] == 0) {
        zeroAmount++;
      }
    }
    if (zeroAmount == 2) {
      if (notVector[0] == 0) {
        notVector[0] = 1;
      } else if (notVector[1] == 0) {
        notVector[1] = 1;
      } else if (notVector[2] == 0) {
        notVector[2] = 1;
      }
    } else {
      if (notVector[0] != 0) {
        notVector[0] = -notVector[0];
      } else if (notVector[1] != 0) {
        notVector[1] = -notVector[1];
      } else if (notVector[2] != 0) {
        notVector[2] = -notVector[2];
      }
    }
    Vec3Utils.cross(notVector, vector, out);
    return out;
  }
  return perpendicularAny2;
}();
function rotate(vector, rotation, out) {
  return Vec3Utils.rotateDegrees(vector, rotation, out);
}
var rotateDegrees = function() {
  const zero4 = create3();
  function rotateDegrees4(vector, rotation, out) {
    return Vec3Utils.rotateAroundDegrees(vector, rotation, zero4, out);
  }
  return rotateDegrees4;
}();
var rotateRadians = function() {
  const zero4 = create3();
  function rotateRadians4(vector, rotation, out) {
    return Vec3Utils.rotateAroundRadians(vector, rotation, zero4, out);
  }
  return rotateRadians4;
}();
var rotateQuat = function() {
  const zero4 = create3();
  function rotateQuat4(vector, rotation, out) {
    return Vec3Utils.rotateAroundQuat(vector, rotation, zero4, out);
  }
  return rotateQuat4;
}();
function rotateAxis2(vector, angle2, axis, out) {
  return Vec3Utils.rotateAxisDegrees(vector, angle2, axis, out);
}
var rotateAxisDegrees2 = function() {
  const zero4 = create3();
  function rotateAxisDegrees5(vector, angle2, axis, out) {
    return Vec3Utils.rotateAroundAxisDegrees(vector, angle2, axis, zero4, out);
  }
  return rotateAxisDegrees5;
}();
var rotateAxisRadians2 = function() {
  const zero4 = create3();
  function rotateAxisRadians5(vector, angle2, axis, out) {
    return Vec3Utils.rotateAroundAxisRadians(vector, angle2, axis, zero4, out);
  }
  return rotateAxisRadians5;
}();
function rotateAround(vector, rotation, origin, out) {
  return Vec3Utils.rotateAroundDegrees(vector, rotation, origin, out);
}
var rotateAroundDegrees = function() {
  const quat = create2();
  function rotateAroundDegrees3(vector, rotation, origin, out = Vec3Utils.clone(vector)) {
    Vec3Utils.degreesToQuat(rotation, quat);
    return Vec3Utils.rotateAroundQuat(vector, quat, origin, out);
  }
  return rotateAroundDegrees3;
}();
var rotateAroundRadians = function() {
  const quat = create2();
  function rotateAroundRadians3(vector, rotation, origin, out = Vec3Utils.clone(vector)) {
    Vec3Utils.radiansToQuat(rotation, quat);
    return Vec3Utils.rotateAroundQuat(vector, quat, origin, out);
  }
  return rotateAroundRadians3;
}();
function rotateAroundQuat(vector, rotation, origin, out = Vec3Utils.clone(vector)) {
  Vec3Utils.sub(vector, origin, out);
  Vec3Utils.transformQuat(out, rotation, out);
  Vec3Utils.add(out, origin, out);
  return out;
}
function rotateAroundAxis(vector, angle2, axis, origin, out) {
  return Vec3Utils.rotateAroundAxisDegrees(vector, angle2, axis, origin, out);
}
function rotateAroundAxisDegrees(vector, angle2, axis, origin, out) {
  return Vec3Utils.rotateAroundAxisRadians(vector, MathUtils.toRadians(angle2), axis, origin, out);
}
var rotateAroundAxisRadians = function() {
  const quat = create2();
  function rotateAroundAxisRadians3(vector, angle2, axis, origin, out = Vec3Utils.clone(vector)) {
    QuatUtils.fromAxisRadians(angle2, axis, quat);
    return Vec3Utils.rotateAroundQuat(vector, quat, origin, out);
  }
  return rotateAroundAxisRadians3;
}();
function addRotation(vector, rotation, out) {
  return Vec3Utils.degreesAddRotation(vector, rotation, out);
}
function addRotationDegrees(vector, rotation, out) {
  return Vec3Utils.degreesAddRotationDegrees(vector, rotation, out);
}
function addRotationRadians(vector, rotation, out) {
  return Vec3Utils.degreesAddRotationRadians(vector, rotation, out);
}
function addRotationQuat(vector, rotation, out) {
  return Vec3Utils.degreesAddRotationQuat(vector, rotation, out);
}
function degreesAddRotation(vector, rotation, out) {
  return Vec3Utils.degreesAddRotationDegrees(vector, rotation, out);
}
var degreesAddRotationDegrees = function() {
  const quat = create2();
  function degreesAddRotationDegrees2(vector, rotation, out = Vec3Utils.clone(vector)) {
    Vec3Utils.degreesToQuat(vector, quat);
    return QuatUtils.toDegrees(QuatUtils.addRotationDegrees(quat, rotation, quat), out);
  }
  return degreesAddRotationDegrees2;
}();
var degreesAddRotationRadians = function() {
  const quat = create2();
  function degreesAddRotationRadians2(vector, rotation, out = Vec3Utils.clone(vector)) {
    Vec3Utils.degreesToQuat(vector, quat);
    return QuatUtils.toDegrees(QuatUtils.addRotationRadians(quat, rotation, quat), out);
  }
  return degreesAddRotationRadians2;
}();
var degreesAddRotationQuat = function() {
  const quat = create2();
  function degreesAddRotationQuat2(vector, rotation, out = Vec3Utils.clone(vector)) {
    Vec3Utils.degreesToQuat(vector, quat);
    return QuatUtils.toDegrees(QuatUtils.addRotationQuat(quat, rotation, quat), out);
  }
  return degreesAddRotationQuat2;
}();
function radiansAddRotation(vector, rotation, out) {
  return Vec3Utils.radiansAddRotationDegrees(vector, rotation, out);
}
var radiansAddRotationDegrees = function() {
  const quat = create2();
  function radiansAddRotationDegrees2(vector, rotation, out = Vec3Utils.clone(vector)) {
    Vec3Utils.radiansToQuat(vector, quat);
    return QuatUtils.toRadians(QuatUtils.addRotationDegrees(quat, rotation, quat), out);
  }
  return radiansAddRotationDegrees2;
}();
var radiansAddRotationRadians = function() {
  const quat = create2();
  function radiansAddRotationRadians2(vector, rotation, out = Vec3Utils.clone(vector)) {
    Vec3Utils.radiansToQuat(vector, quat);
    return QuatUtils.toRadians(QuatUtils.addRotationRadians(quat, rotation, quat), out);
  }
  return radiansAddRotationRadians2;
}();
var radiansAddRotationQuat = function() {
  const quat = create2();
  function radiansAddRotationQuat2(vector, rotation, out = Vec3Utils.clone(vector)) {
    Vec3Utils.radiansToQuat(vector, quat);
    return QuatUtils.toRadians(QuatUtils.addRotationQuat(quat, rotation, quat), out);
  }
  return radiansAddRotationQuat2;
}();
function rotationTo(from, to, out) {
  return Vec3Utils.rotationToDegrees(from, to, out);
}
var rotationToDegrees = function() {
  const rotationQuat = create2();
  function rotationToDegrees3(from, to, out = Vec3Utils.clone(from)) {
    Vec3Utils.rotationToQuat(from, to, rotationQuat);
    QuatUtils.toDegrees(rotationQuat, out);
    return out;
  }
  return rotationToDegrees3;
}();
var rotationToRadians = function() {
  const rotationQuat = create2();
  function rotationToRadians3(from, to, out = Vec3Utils.clone(from)) {
    Vec3Utils.rotationToQuat(from, to, rotationQuat);
    QuatUtils.toRadians(rotationQuat, out);
    return out;
  }
  return rotationToRadians3;
}();
var rotationToQuat = function() {
  const rotationAxis = create3();
  function rotationToQuat3(from, to, out = QuatUtils.create()) {
    Vec3Utils.cross(from, to, rotationAxis);
    Vec3Utils.normalize(rotationAxis, rotationAxis);
    if (Vec3Utils.isZero(rotationAxis)) {
      Vec3Utils.perpendicularAny(from, rotationAxis);
      Vec3Utils.normalize(rotationAxis, rotationAxis);
    }
    const signedAngle = Vec3Utils.angleSigned(from, to, rotationAxis);
    QuatUtils.fromAxisRadians(signedAngle, rotationAxis, out);
    return out;
  }
  return rotationToQuat3;
}();
function rotationToPivoted(from, to, pivotAxis, out) {
  return Vec3Utils.rotationToPivotedDegrees(from, to, pivotAxis, out);
}
var rotationToPivotedDegrees = function() {
  const rotationQuat = create2();
  function rotationToPivotedDegrees2(from, to, pivotAxis, out = Vec3Utils.clone(from)) {
    Vec3Utils.rotationToPivotedQuat(from, to, pivotAxis, rotationQuat);
    QuatUtils.toDegrees(rotationQuat, out);
    return out;
  }
  return rotationToPivotedDegrees2;
}();
var rotationToPivotedRadians = function() {
  const rotationQuat = create2();
  function rotationToPivotedRadians2(from, to, pivotAxis, out = Vec3Utils.clone(from)) {
    Vec3Utils.rotationToPivotedQuat(from, to, pivotAxis, rotationQuat);
    QuatUtils.toRadians(rotationQuat, out);
    return out;
  }
  return rotationToPivotedRadians2;
}();
var rotationToPivotedQuat = function() {
  const fromFlat = create3();
  const toFlat = create3();
  const rotationAxis = create3();
  function rotationToPivotedQuat2(from, to, pivotAxis, out = QuatUtils.create()) {
    Vec3Utils.removeComponentAlongAxis(from, pivotAxis, fromFlat);
    Vec3Utils.removeComponentAlongAxis(to, pivotAxis, toFlat);
    Vec3Utils.cross(fromFlat, toFlat, rotationAxis);
    Vec3Utils.normalize(rotationAxis, rotationAxis);
    if (Vec3Utils.isZero(rotationAxis)) {
      Vec3Utils.perpendicularAny(fromFlat, rotationAxis);
      Vec3Utils.normalize(rotationAxis, rotationAxis);
    }
    const signedAngle = Vec3Utils.angleSignedRadians(fromFlat, toFlat, rotationAxis);
    QuatUtils.fromAxisRadians(signedAngle, rotationAxis, out);
    return out;
  }
  return rotationToPivotedQuat2;
}();
function convertPositionToWorld(vector, parentTransform, out) {
  return Vec3Utils.convertPositionToWorldMatrix(vector, parentTransform, out);
}
function convertPositionToLocal(vector, parentTransform, out) {
  return Vec3Utils.convertPositionToLocalMatrix(vector, parentTransform, out);
}
function convertPositionToWorldMatrix(vector, parentTransform, out = Vec3Utils.clone(vector)) {
  Vec3Utils.transformMat4(vector, parentTransform, out);
  return out;
}
var convertPositionToLocalMatrix = function() {
  const inverse = create5();
  function convertPositionToLocalMatrix2(vector, parentTransform, out = Vec3Utils.clone(vector)) {
    Mat4Utils.invert(parentTransform, inverse);
    Vec3Utils.transformMat4(vector, inverse, out);
    return out;
  }
  return convertPositionToLocalMatrix2;
}();
var convertPositionToWorldQuat = function() {
  const parentTransformMatrix = create5();
  const position = create3();
  const rotation = create2();
  const one = create3();
  set2(one, 1, 1, 1);
  function convertPositionToWorldQuat2(vector, parentTransform, out = Vec3Utils.clone(vector)) {
    Quat2Utils.getPosition(parentTransform, position);
    Quat2Utils.getRotationQuat(parentTransform, rotation);
    Mat4Utils.setPositionRotationQuatScale(parentTransformMatrix, position, rotation, one);
    return Vec3Utils.convertPositionToWorldMatrix(vector, parentTransformMatrix, out);
  }
  return convertPositionToWorldQuat2;
}();
var convertPositionToLocalQuat = function() {
  const parentTransformMatrix = create5();
  const position = create3();
  const rotation = create2();
  const one = create3();
  set2(one, 1, 1, 1);
  function convertPositionToLocalQuat2(vector, parentTransform, out = Vec3Utils.clone(vector)) {
    Quat2Utils.getPosition(parentTransform, position);
    Quat2Utils.getRotationQuat(parentTransform, rotation);
    Mat4Utils.setPositionRotationQuatScale(parentTransformMatrix, position, rotation, one);
    return Vec3Utils.convertPositionToLocalMatrix(vector, parentTransformMatrix, out);
  }
  return convertPositionToLocalQuat2;
}();
function convertDirectionToWorld(vector, parentTransform, out) {
  return Vec3Utils.convertDirectionToWorldMatrix(vector, parentTransform, out);
}
function convertDirectionToLocal(vector, parentTransform, out) {
  return Vec3Utils.convertDirectionToLocalMatrix(vector, parentTransform, out);
}
var convertDirectionToWorldMatrix = function() {
  const rotation = create2();
  function convertDirectionToWorldMatrix2(vector, parentTransform, out = Vec3Utils.clone(vector)) {
    Mat4Utils.getRotationQuat(parentTransform, rotation);
    Vec3Utils.transformQuat(vector, rotation, out);
    return out;
  }
  return convertDirectionToWorldMatrix2;
}();
var convertDirectionToLocalMatrix = function() {
  const rotation = create2();
  function convertDirectionToLocalMatrix2(vector, parentTransform, out = Vec3Utils.clone(vector)) {
    Mat4Utils.getRotationQuat(parentTransform, rotation);
    QuatUtils.conjugate(rotation, rotation);
    Vec3Utils.transformQuat(vector, rotation, out);
    return out;
  }
  return convertDirectionToLocalMatrix2;
}();
var convertDirectionToWorldQuat = function() {
  const rotation = create2();
  function convertDirectionToWorldQuat2(vector, parentTransform, out = Vec3Utils.clone(vector)) {
    Quat2Utils.getRotationQuat(parentTransform, rotation);
    Vec3Utils.transformQuat(vector, rotation, out);
    return out;
  }
  return convertDirectionToWorldQuat2;
}();
var convertDirectionToLocalQuat = function() {
  const rotation = create2();
  function convertDirectionToLocalQuat2(vector, parentTransform, out = Vec3Utils.clone(vector)) {
    Quat2Utils.getRotationQuat(parentTransform, rotation);
    QuatUtils.conjugate(rotation, rotation);
    Vec3Utils.transformQuat(vector, rotation, out);
    return out;
  }
  return convertDirectionToLocalQuat2;
}();
function toRadians2(vector, out = Vec3Utils.clone(vector)) {
  Vec3Utils.set(out, MathUtils.toRadians(vector[0]), MathUtils.toRadians(vector[1]), MathUtils.toRadians(vector[2]));
  return out;
}
function toDegrees2(vector, out = Vec3Utils.clone(vector)) {
  Vec3Utils.set(out, MathUtils.toDegrees(vector[0]), MathUtils.toDegrees(vector[1]), MathUtils.toDegrees(vector[2]));
  return out;
}
function toQuat2(vector, out = QuatUtils.create()) {
  return Vec3Utils.degreesToQuat(vector, out);
}
function radiansToQuat(vector, out = QuatUtils.create()) {
  QuatUtils.fromRadians(vector, out);
  return out;
}
function degreesToQuat(vector, out = QuatUtils.create()) {
  QuatUtils.fromDegrees(vector, out);
  return out;
}
function toMatrix2(vector, out = Mat3Utils.create()) {
  return Vec3Utils.degreesToMatrix(vector, out);
}
var degreesToMatrix = function() {
  const quat = create2();
  function degreesToMatrix2(vector, out = Mat3Utils.create()) {
    Vec3Utils.degreesToQuat(vector, quat);
    return QuatUtils.toMatrix(quat, out);
  }
  return degreesToMatrix2;
}();
var radiansToMatrix = function() {
  const quat = create2();
  function radiansToMatrix2(vector, out = Mat3Utils.create()) {
    Vec3Utils.radiansToQuat(vector, quat);
    return QuatUtils.toMatrix(quat, out);
  }
  return radiansToMatrix2;
}();
var Vec3Utils = {
  create: create3,
  getAllocationFunction: getAllocationFunction3,
  setAllocationFunction: setAllocationFunction3,
  set: set2,
  copy: copy4,
  clone: clone4,
  equals: equals4,
  isNormalized: isNormalized2,
  normalize: normalize2,
  isZero,
  zero,
  length: length3,
  lengthSquared: lengthSquared2,
  lengthSigned,
  distance,
  distanceSquared,
  add,
  sub,
  mul: mul3,
  div,
  scale: scale2,
  negate,
  dot,
  cross,
  transformQuat,
  transformMat3,
  transformMat4,
  lerp: lerp3,
  interpolate: interpolate3,
  angle,
  angleDegrees,
  angleRadians,
  angleSigned,
  angleSignedDegrees,
  angleSignedRadians,
  anglePivoted,
  anglePivotedDegrees,
  anglePivotedRadians,
  anglePivotedSigned,
  anglePivotedSignedDegrees,
  anglePivotedSignedRadians,
  valueAlongAxis,
  valueAlongPlane,
  componentAlongAxis,
  removeComponentAlongAxis,
  copyComponentAlongAxis,
  isConcordant,
  isFartherAlongAxis,
  isToTheRight,
  signTo,
  projectOnAxis,
  projectOnAxisAlongAxis,
  projectOnPlane,
  projectOnPlaneAlongAxis,
  isOnAxis,
  isOnPlane,
  perpendicularAny,
  rotate,
  rotateDegrees,
  rotateRadians,
  rotateQuat,
  rotateAxis: rotateAxis2,
  rotateAxisDegrees: rotateAxisDegrees2,
  rotateAxisRadians: rotateAxisRadians2,
  rotateAround,
  rotateAroundDegrees,
  rotateAroundRadians,
  rotateAroundQuat,
  rotateAroundAxis,
  rotateAroundAxisDegrees,
  rotateAroundAxisRadians,
  addRotation,
  addRotationDegrees,
  addRotationRadians,
  addRotationQuat,
  degreesAddRotation,
  degreesAddRotationDegrees,
  degreesAddRotationRadians,
  degreesAddRotationQuat,
  radiansAddRotation,
  radiansAddRotationDegrees,
  radiansAddRotationRadians,
  radiansAddRotationQuat,
  rotationTo,
  rotationToDegrees,
  rotationToRadians,
  rotationToQuat,
  rotationToPivoted,
  rotationToPivotedDegrees,
  rotationToPivotedRadians,
  rotationToPivotedQuat,
  convertPositionToWorld,
  convertPositionToLocal,
  convertPositionToWorldMatrix,
  convertPositionToLocalMatrix,
  convertPositionToWorldQuat,
  convertPositionToLocalQuat,
  convertDirectionToWorld,
  convertDirectionToLocal,
  convertDirectionToWorldMatrix,
  convertDirectionToLocalMatrix,
  convertDirectionToWorldQuat,
  convertDirectionToLocalQuat,
  toRadians: toRadians2,
  toDegrees: toDegrees2,
  toQuat: toQuat2,
  radiansToQuat,
  degreesToQuat,
  toMatrix: toMatrix2,
  degreesToMatrix,
  radiansToMatrix
};

// dist/pp/cauldron/utils/array/quat_utils.js
function create2(x, y, z, w) {
  const out = getAllocationFunction4()();
  if (x != null) {
    QuatUtils.set(out, x, y, z, w);
  }
  return out;
}
function getAllocationFunction4() {
  return getQuaternionAllocationFunction();
}
function setAllocationFunction4(allocationFunction) {
  setQuaternionAllocationFunction(allocationFunction);
}
function set4(quat, x, y, z, w) {
  if (y == null) {
    gl_quat3.set(quat, x, x, x, x);
  } else {
    gl_quat3.set(quat, x, y, z, w);
  }
  return quat;
}
function copy5(from, to) {
  gl_quat3.copy(to, from);
  return to;
}
function clone5(quat) {
  return quat.slice(0);
}
function equals5(first2, second, epsilon = 0) {
  let equals10 = first2.length == second.length;
  if (equals10) {
    equals10 &&= Math.abs(first2[0] - second[0]) <= epsilon;
    equals10 &&= Math.abs(first2[1] - second[1]) <= epsilon;
    equals10 &&= Math.abs(first2[2] - second[2]) <= epsilon;
    equals10 &&= Math.abs(first2[3] - second[3]) <= epsilon;
  }
  return equals10;
}
function isNormalized3(quat, epsilon = MathUtils.EPSILON) {
  return Math.abs(QuatUtils.lengthSquared(quat) - 1) < epsilon;
}
function normalize3(quat, out = QuatUtils.clone(quat)) {
  gl_quat3.normalize(out, quat);
  return out;
}
function length4(quat) {
  return gl_quat3.length(quat);
}
function lengthSquared3(quat) {
  return gl_quat3.squaredLength(quat);
}
function identity3(quat) {
  gl_quat3.identity(quat);
  return quat;
}
function mul4(first2, second, out = QuatUtils.clone(first2)) {
  gl_quat3.mul(out, first2, second);
  return out;
}
function invert3(quat, out = QuatUtils.clone(quat)) {
  gl_quat3.invert(out, quat);
  return out;
}
function conjugate2(quat, out = QuatUtils.clone(quat)) {
  gl_quat3.conjugate(out, quat);
  return out;
}
function lerp4(from, to, interpolationFactor, out = QuatUtils.clone(from)) {
  if (interpolationFactor <= 0) {
    QuatUtils.copy(from, out);
    return out;
  } else if (interpolationFactor >= 1) {
    QuatUtils.copy(to, out);
    return out;
  }
  gl_quat3.lerp(out, from, to, interpolationFactor);
  return out;
}
function interpolate4(from, to, interpolationFactor, easingFunction = EasingFunction.linear, out = QuatUtils.clone(from)) {
  const lerpFactor = easingFunction(interpolationFactor);
  return QuatUtils.lerp(from, to, lerpFactor, out);
}
function slerp2(from, to, interpolationFactor, out = QuatUtils.clone(from)) {
  if (interpolationFactor <= 0) {
    QuatUtils.copy(from, out);
    return out;
  } else if (interpolationFactor >= 1) {
    QuatUtils.copy(to, out);
    return out;
  }
  gl_quat3.slerp(out, from, to, interpolationFactor);
  return out;
}
function interpolateSpherical2(from, to, interpolationFactor, easingFunction = EasingFunction.linear, out = QuatUtils.clone(from)) {
  const lerpFactor = easingFunction(interpolationFactor);
  return QuatUtils.slerp(from, to, lerpFactor, out);
}
function getAngle(quat) {
  return QuatUtils.getAngleDegrees(quat);
}
function getAngleDegrees(quat) {
  const angle2 = QuatUtils.getAngleRadians(quat);
  return MathUtils.toDegrees(angle2);
}
var getAngleRadians = function() {
  const vector = create3();
  return function getAngleRadians2(quat) {
    const angle2 = gl_quat3.getAxisAngle(vector, quat);
    return angle2;
  };
}();
var getAxis = function() {
  const zero4 = create3(0, 0, 0);
  function getAxis2(quat, out = Vec3Utils.create()) {
    const angle2 = gl_quat3.getAxisAngle(out, quat);
    if (angle2 <= MathUtils.EPSILON) {
      Vec3Utils.copy(zero4, out);
    }
    return out;
  }
  return getAxis2;
}();
function getAxisScaled(quat, out = Vec3Utils.create()) {
  return QuatUtils.getAxisScaledDegrees(quat, out);
}
function getAxisScaledDegrees(quat, out = Vec3Utils.create()) {
  QuatUtils.getAxis(quat, out);
  const angle2 = QuatUtils.getAngleDegrees(quat);
  Vec3Utils.scale(out, angle2, out);
  return out;
}
var getAxisScaledRadians = function() {
  const zero4 = create3(0, 0, 0);
  function getAxisScaledRadians2(quat, out = Vec3Utils.create()) {
    QuatUtils.getAxis(quat, out);
    const angle2 = QuatUtils.getAngleRadians(quat);
    if (angle2 <= MathUtils.EPSILON) {
      Vec3Utils.copy(zero4, out);
    } else {
      Vec3Utils.scale(out, angle2, out);
    }
    return out;
  }
  return getAxisScaledRadians2;
}();
function getAxes3(quat, out = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
  QuatUtils.getLeft(quat, out[0]);
  QuatUtils.getUp(quat, out[1]);
  QuatUtils.getForward(quat, out[2]);
  return out;
}
var getForward3 = function() {
  const rotationMatrix = create();
  function getForward5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, rotationMatrix);
    Vec3Utils.set(out, rotationMatrix[6], rotationMatrix[7], rotationMatrix[8]);
    return out;
  }
  return getForward5;
}();
function getBackward3(quat, out) {
  out = QuatUtils.getForward(quat, out);
  Vec3Utils.negate(out, out);
  return out;
}
var getLeft3 = function() {
  const rotationMatrix = create();
  function getLeft5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, rotationMatrix);
    Vec3Utils.set(out, rotationMatrix[0], rotationMatrix[1], rotationMatrix[2]);
    return out;
  }
  return getLeft5;
}();
function getRight3(quat, out) {
  out = QuatUtils.getLeft(quat, out);
  Vec3Utils.negate(out, out);
  return out;
}
var getUp3 = function() {
  const rotationMatrix = create();
  function getUp5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, rotationMatrix);
    Vec3Utils.set(out, rotationMatrix[3], rotationMatrix[4], rotationMatrix[5]);
    return out;
  }
  return getUp5;
}();
function getDown3(quat, out) {
  out = QuatUtils.getUp(quat, out);
  Vec3Utils.negate(out, out);
  return out;
}
function setAxes(quat, left, up, forward) {
  if (forward != null) {
    return QuatUtils.setForward(quat, forward, up, left);
  } else if (up != null) {
    return QuatUtils.setUp(quat, up, forward, left);
  } else {
    return QuatUtils.setLeft(quat, left, up, forward);
  }
}
var setForward = /* @__PURE__ */ function() {
  const axes = [null, null, null];
  const priority = [2, 1, 0];
  return function setForward3(quat, forward, up, left) {
    axes[0] = left;
    axes[1] = up;
    axes[2] = forward;
    _setAxes(quat, axes, priority);
    axes[0] = null;
    axes[1] = null;
    axes[2] = null;
    return quat;
  };
}();
var setBackward = function() {
  const forward = create3();
  const axes = [null, null, null];
  const priority = [2, 1, 0];
  return function setBackward3(quat, backward, up, left) {
    Vec3Utils.negate(backward, forward);
    axes[0] = left || null;
    axes[1] = up || null;
    axes[2] = forward;
    _setAxes(quat, axes, priority);
    axes[0] = null;
    axes[1] = null;
    axes[2] = null;
    return quat;
  };
}();
var setUp = /* @__PURE__ */ function() {
  const axes = [null, null, null];
  const priority = [1, 2, 0];
  return function setUp3(quat, up, forward, left) {
    axes[0] = left || null;
    axes[1] = up;
    axes[2] = forward || null;
    _setAxes(quat, axes, priority);
    axes[0] = null;
    axes[1] = null;
    axes[2] = null;
    return quat;
  };
}();
var setDown = function() {
  const up = create3();
  const axes = [null, null, null];
  const priority = [1, 2, 0];
  return function setDown3(quat, down, forward, left) {
    Vec3Utils.negate(down, up);
    axes[0] = left || null;
    axes[1] = up;
    axes[2] = forward || null;
    _setAxes(quat, axes, priority);
    axes[0] = null;
    axes[1] = null;
    axes[2] = null;
    return quat;
  };
}();
var setLeft = /* @__PURE__ */ function() {
  const axes = [null, null, null];
  const priority = [0, 1, 2];
  return function setLeft3(quat, left, up, forward) {
    axes[0] = left;
    axes[1] = up || null;
    axes[2] = forward || null;
    _setAxes(quat, axes, priority);
    axes[0] = null;
    axes[1] = null;
    axes[2] = null;
    return quat;
  };
}();
var setRight = function() {
  const left = create3();
  const axes = [null, null, null];
  const priority = [0, 1, 2];
  return function setRight3(quat, right, up, forward) {
    Vec3Utils.negate(right, left);
    axes[0] = left;
    axes[1] = up || null;
    axes[2] = forward || null;
    _setAxes(quat, axes, priority);
    axes[0] = null;
    axes[1] = null;
    axes[2] = null;
    return quat;
  };
}();
function toWorld3(quat, parentRotationQuat, out = QuatUtils.clone(quat)) {
  QuatUtils.mul(parentRotationQuat, quat, out);
  return out;
}
var toLocal3 = function() {
  const invertQuat = create2();
  function toLocal4(quat, parentRotationQuat, out = QuatUtils.clone(quat)) {
    QuatUtils.conjugate(parentRotationQuat, invertQuat);
    QuatUtils.mul(invertQuat, quat, out);
    return out;
  }
  return toLocal4;
}();
function fromDegrees(rotation, out = QuatUtils.create()) {
  gl_quat3.fromEuler(out, rotation[0], rotation[1], rotation[2]);
  return out;
}
var fromRadians = function() {
  const vector = create3();
  function fromRadians2(rotation, out = QuatUtils.create()) {
    Vec3Utils.toDegrees(rotation, vector);
    return QuatUtils.fromDegrees(vector, out);
  }
  return fromRadians2;
}();
function fromAxis(angle2, axis, out = QuatUtils.create()) {
  return QuatUtils.fromAxisDegrees(angle2, axis, out);
}
function fromAxisDegrees(angle2, axis, out = QuatUtils.create()) {
  QuatUtils.fromAxisRadians(MathUtils.toRadians(angle2), axis, out);
  return out;
}
function fromAxisRadians(angle2, axis, out = QuatUtils.create()) {
  gl_quat3.setAxisAngle(out, axis, angle2);
  return out;
}
var fromAxes = function() {
  const matrix = create();
  function fromAxes3(left, up, forward, out = QuatUtils.create()) {
    Mat3Utils.fromAxes(left, up, forward, matrix);
    return Mat3Utils.toQuat(matrix, out);
  }
  return fromAxes3;
}();
function toDegrees3(quat, out = Vec3Utils.create()) {
  QuatUtils.toRadians(quat, out);
  Vec3Utils.toDegrees(out, out);
  return out;
}
var toRadians3 = function() {
  const matrix = create();
  function toRadians5(quat, out = Vec3Utils.create()) {
    QuatUtils.toMatrix(quat, matrix);
    out[1] = Math.asin(-MathUtils.clamp(matrix[2], -1, 1));
    if (Math.abs(matrix[2]) < 1 - MathUtils.EPSILON) {
      out[0] = Math.atan2(matrix[5], matrix[8]);
      out[2] = Math.atan2(matrix[1], matrix[0]);
    } else {
      out[0] = 0;
      out[2] = Math.atan2(-matrix[3], matrix[4]);
    }
    return out;
  }
  return toRadians5;
}();
function toMatrix3(quat, out = Mat3Utils.create()) {
  gl_mat32.fromQuat(out, quat);
  return out;
}
function addRotation2(first2, second, out) {
  return QuatUtils.addRotationDegrees(first2, second, out);
}
var addRotationDegrees2 = function() {
  const secondQuat = create2();
  function addRotationDegrees3(first2, second, out) {
    Vec3Utils.degreesToQuat(second, secondQuat);
    return QuatUtils.addRotationQuat(first2, secondQuat, out);
  }
  return addRotationDegrees3;
}();
var addRotationRadians2 = function() {
  const secondQuat = create2();
  function addRotationRadians3(first2, second, out) {
    Vec3Utils.radiansToQuat(second, secondQuat);
    return QuatUtils.addRotationQuat(first2, secondQuat, out);
  }
  return addRotationRadians3;
}();
function addRotationQuat2(first2, second, out = QuatUtils.clone(first2)) {
  QuatUtils.mul(second, first2, out);
  return out;
}
function subRotation(first2, second, out) {
  return QuatUtils.subRotationDegrees(first2, second, out);
}
var subRotationDegrees = function() {
  const secondQuat = create2();
  function subRotationDegrees2(first2, second, out) {
    Vec3Utils.degreesToQuat(second, secondQuat);
    return QuatUtils.subRotationQuat(first2, secondQuat, out);
  }
  return subRotationDegrees2;
}();
var subRotationRadians = function() {
  const secondQuat = create2();
  function subRotationRadians2(first2, second, out) {
    Vec3Utils.radiansToQuat(second, secondQuat);
    return QuatUtils.subRotationQuat(first2, secondQuat, out);
  }
  return subRotationRadians2;
}();
var subRotationQuat = function() {
  const inverse = create2();
  function subRotationQuat2(first2, second, out = QuatUtils.clone(first2)) {
    QuatUtils.invert(second, inverse);
    QuatUtils.mul(first2, inverse, out);
    return out;
  }
  return subRotationQuat2;
}();
function rotationTo2(from, to, out) {
  return QuatUtils.rotationToDegrees(from, to, out);
}
var rotationToDegrees2 = function() {
  const toQuat4 = create2();
  function rotationToDegrees3(from, to, out) {
    Vec3Utils.degreesToQuat(to, toQuat4);
    return QuatUtils.rotationToQuat(from, toQuat4, out);
  }
  return rotationToDegrees3;
}();
var rotationToRadians2 = function() {
  const toQuat4 = create2();
  function rotationToRadians3(from, to, out) {
    Vec3Utils.radiansToQuat(to, toQuat4);
    return QuatUtils.rotationToQuat(from, toQuat4, out);
  }
  return rotationToRadians3;
}();
function rotationToQuat2(from, to, out) {
  return QuatUtils.normalize(QuatUtils.subRotationQuat(to, from, out), out);
}
function rotationAroundAxis(quat, axis, out) {
  return QuatUtils.rotationAroundAxisDegrees(quat, axis, out);
}
var rotationAroundAxisDegrees = function() {
  const rotationAroundQuat = create2();
  function rotationAroundAxisDegrees2(quat, axis, out = Vec3Utils.clone(axis)) {
    QuatUtils.rotationAroundAxisQuat(quat, axis, rotationAroundQuat);
    return QuatUtils.toDegrees(rotationAroundQuat, out);
  }
  return rotationAroundAxisDegrees2;
}();
var rotationAroundAxisRadians = function() {
  const rotationAroundQuat = create2();
  function rotationAroundAxisRadians2(quat, axis, out = Vec3Utils.clone(axis)) {
    QuatUtils.rotationAroundAxisQuat(quat, axis, rotationAroundQuat);
    return QuatUtils.toRadians(rotationAroundQuat, out);
  }
  return rotationAroundAxisRadians2;
}();
function rotationAroundAxisQuat(quat, axis, out = QuatUtils.clone(quat)) {
  return QuatUtils.getTwist(quat, axis, out);
}
var getTwist = function() {
  const rotationAxis = create3();
  const projection = create3();
  const rotationAlongAxis = create2();
  function getTwist2(quat, axis, out = QuatUtils.clone(quat)) {
    rotationAxis[0] = quat[0];
    rotationAxis[1] = quat[1];
    rotationAxis[2] = quat[2];
    const dotProd = Vec3Utils.dot(axis, rotationAxis);
    Vec3Utils.scale(axis, dotProd, projection);
    rotationAlongAxis[0] = projection[0];
    rotationAlongAxis[1] = projection[1];
    rotationAlongAxis[2] = projection[2];
    rotationAlongAxis[3] = quat[3];
    QuatUtils.normalize(rotationAlongAxis, rotationAlongAxis);
    if (dotProd < 0) {
      rotationAlongAxis[0] = -rotationAlongAxis[0];
      rotationAlongAxis[1] = -rotationAlongAxis[1];
      rotationAlongAxis[2] = -rotationAlongAxis[2];
      rotationAlongAxis[3] = -rotationAlongAxis[3];
    }
    return QuatUtils.copy(rotationAlongAxis, out);
  }
  return getTwist2;
}();
var getSwing = function() {
  const twist = create2();
  function getSwing2(quat, axis, out = QuatUtils.clone(quat)) {
    QuatUtils.getTwist(quat, axis, twist);
    QuatUtils.getSwingFromTwist(quat, twist, out);
    return out;
  }
  return getSwing2;
}();
function getSwingFromTwist(quat, twist, out = QuatUtils.clone(quat)) {
  return QuatUtils.subRotationQuat(quat, twist, out);
}
var getTwistFromSwing = function() {
  const inverse = create2();
  function getTwistFromSwing2(quat, swing, out = QuatUtils.clone(quat)) {
    QuatUtils.conjugate(swing, inverse);
    QuatUtils.addRotationQuat(quat, inverse, out);
    return out;
  }
  return getTwistFromSwing2;
}();
function fromTwistSwing(twist, swing, out = QuatUtils.clone(twist)) {
  return QuatUtils.addRotationQuat(twist, swing, out);
}
function rotate2(first2, second, out) {
  return QuatUtils.rotateDegrees(first2, second, out);
}
function rotateDegrees2(first2, second, out) {
  return QuatUtils.addRotationDegrees(first2, second, out);
}
function rotateRadians2(first2, second, out) {
  return QuatUtils.addRotationRadians(first2, second, out);
}
function rotateQuat2(first2, second, out) {
  return QuatUtils.addRotationQuat(first2, second, out);
}
function rotateAxis3(quat, angle2, axis, out) {
  return QuatUtils.rotateAxisDegrees(quat, angle2, axis, out);
}
var rotateAxisDegrees3 = function() {
  const secondQuat = create2();
  function rotateAxisDegrees5(quat, angle2, axis, out) {
    QuatUtils.fromAxisDegrees(angle2, axis, secondQuat);
    return QuatUtils.rotateQuat(quat, secondQuat, out);
  }
  return rotateAxisDegrees5;
}();
var rotateAxisRadians3 = function() {
  const secondQuat = create2();
  function rotateAxisRadians5(quat, angle2, axis, out) {
    QuatUtils.fromAxisRadians(angle2, axis, secondQuat);
    return QuatUtils.rotateQuat(quat, secondQuat, out);
  }
  return rotateAxisRadians5;
}();
var QuatUtils = {
  create: create2,
  getAllocationFunction: getAllocationFunction4,
  setAllocationFunction: setAllocationFunction4,
  set: set4,
  copy: copy5,
  clone: clone5,
  equals: equals5,
  isNormalized: isNormalized3,
  normalize: normalize3,
  length: length4,
  lengthSquared: lengthSquared3,
  identity: identity3,
  mul: mul4,
  invert: invert3,
  conjugate: conjugate2,
  lerp: lerp4,
  interpolate: interpolate4,
  slerp: slerp2,
  interpolateSpherical: interpolateSpherical2,
  getAngle,
  getAngleDegrees,
  getAngleRadians,
  getAxis,
  getAxisScaled,
  getAxisScaledDegrees,
  getAxisScaledRadians,
  getAxes: getAxes3,
  getForward: getForward3,
  getBackward: getBackward3,
  getLeft: getLeft3,
  getRight: getRight3,
  getUp: getUp3,
  getDown: getDown3,
  setAxes,
  setForward,
  setBackward,
  setUp,
  setDown,
  setLeft,
  setRight,
  toWorld: toWorld3,
  toLocal: toLocal3,
  addRotation: addRotation2,
  addRotationDegrees: addRotationDegrees2,
  addRotationRadians: addRotationRadians2,
  addRotationQuat: addRotationQuat2,
  subRotation,
  subRotationDegrees,
  subRotationRadians,
  subRotationQuat,
  rotationTo: rotationTo2,
  rotationToDegrees: rotationToDegrees2,
  rotationToRadians: rotationToRadians2,
  rotationToQuat: rotationToQuat2,
  rotationAroundAxis,
  rotationAroundAxisDegrees,
  rotationAroundAxisRadians,
  rotationAroundAxisQuat,
  getTwist,
  getSwing,
  getSwingFromTwist,
  getTwistFromSwing,
  fromTwistSwing,
  rotate: rotate2,
  rotateDegrees: rotateDegrees2,
  rotateRadians: rotateRadians2,
  rotateQuat: rotateQuat2,
  rotateAxis: rotateAxis3,
  rotateAxisDegrees: rotateAxisDegrees3,
  rotateAxisRadians: rotateAxisRadians3,
  fromDegrees,
  fromRadians,
  fromAxis,
  fromAxisDegrees,
  fromAxisRadians,
  fromAxes,
  toDegrees: toDegrees3,
  toRadians: toRadians3,
  toMatrix: toMatrix3
};
var _setAxes = function() {
  const fixedAxes = [create3(), create3(), create3()];
  const fixedAxesFixSignMap = [
    [1, -1, 1],
    [1, 1, -1],
    [-1, 1, -1]
  ];
  const fixedLeft = create3();
  const fixedUp = create3();
  const fixedForward = create3();
  const currentAxis = create3();
  const rotationAxis = create3();
  const rotationMat = create();
  const rotationQuat = create2();
  return function _setAxes2(quat, axes, priority) {
    const firstAxis = axes[priority[0]];
    const secondAxis = axes[priority[1]];
    const thirdAxis = axes[priority[2]];
    if (firstAxis == null || Vec3Utils.isZero(firstAxis, MathUtils.EPSILON)) {
      return quat;
    }
    let secondAxisValid = false;
    if (secondAxis != null) {
      const angleBetween = Vec3Utils.angleRadians(firstAxis, secondAxis);
      if (angleBetween > MathUtils.EPSILON) {
        secondAxisValid = true;
      }
    }
    let thirdAxisValid = false;
    if (thirdAxis != null) {
      const angleBetween = Vec3Utils.angleRadians(firstAxis, thirdAxis);
      if (angleBetween > MathUtils.EPSILON) {
        thirdAxisValid = true;
      }
    }
    if (secondAxisValid || thirdAxisValid) {
      let crossAxis = null;
      let secondAxisIndex = null;
      let thirdAxisIndex = null;
      if (secondAxisValid) {
        crossAxis = secondAxis;
        secondAxisIndex = 1;
        thirdAxisIndex = 2;
      } else {
        crossAxis = thirdAxis;
        secondAxisIndex = 2;
        thirdAxisIndex = 1;
      }
      const fixSignMap = fixedAxesFixSignMap[priority[0]];
      Vec3Utils.cross(firstAxis, crossAxis, fixedAxes[thirdAxisIndex]);
      Vec3Utils.scale(fixedAxes[thirdAxisIndex], fixSignMap[priority[thirdAxisIndex]], fixedAxes[thirdAxisIndex]);
      Vec3Utils.cross(firstAxis, fixedAxes[thirdAxisIndex], fixedAxes[secondAxisIndex]);
      Vec3Utils.scale(fixedAxes[secondAxisIndex], fixSignMap[priority[secondAxisIndex]], fixedAxes[secondAxisIndex]);
      Vec3Utils.cross(fixedAxes[1], fixedAxes[2], fixedAxes[0]);
      Vec3Utils.scale(fixedAxes[0], fixSignMap[priority[0]], fixedAxes[0]);
      Vec3Utils.normalize(fixedAxes[ArrayUtils.findIndexEqual(priority, 0)], fixedLeft);
      Vec3Utils.normalize(fixedAxes[ArrayUtils.findIndexEqual(priority, 1)], fixedUp);
      Vec3Utils.normalize(fixedAxes[ArrayUtils.findIndexEqual(priority, 2)], fixedForward);
      Mat3Utils.set(rotationMat, fixedLeft[0], fixedLeft[1], fixedLeft[2], fixedUp[0], fixedUp[1], fixedUp[2], fixedForward[0], fixedForward[1], fixedForward[2]);
      Mat3Utils.toQuat(rotationMat, rotationQuat);
      QuatUtils.copy(rotationQuat, quat);
    } else {
      if (priority[0] == 0) {
        QuatUtils.getLeft(quat, currentAxis);
      } else if (priority[0] == 1) {
        QuatUtils.getUp(quat, currentAxis);
      } else {
        QuatUtils.getForward(quat, currentAxis);
      }
      const angleBetween = Vec3Utils.angleRadians(firstAxis, currentAxis);
      if (angleBetween > Math.PI - MathUtils.EPSILON) {
        if (priority[1] == 0) {
          QuatUtils.getLeft(quat, rotationAxis);
        } else if (priority[1] == 1) {
          QuatUtils.getUp(quat, rotationAxis);
        } else {
          QuatUtils.getForward(quat, rotationAxis);
        }
        QuatUtils.fromAxisRadians(Math.PI, rotationAxis, rotationQuat);
        QuatUtils.rotateQuat(quat, rotationQuat, quat);
      } else if (angleBetween > MathUtils.EPSILON) {
        Vec3Utils.cross(currentAxis, firstAxis, rotationAxis);
        Vec3Utils.normalize(rotationAxis, rotationAxis);
        if (Vec3Utils.isZero(rotationAxis)) {
          Vec3Utils.perpendicularAny(currentAxis, rotationAxis);
          Vec3Utils.normalize(rotationAxis, rotationAxis);
        }
        QuatUtils.fromAxisRadians(angleBetween, rotationAxis, rotationQuat);
        QuatUtils.rotateQuat(quat, rotationQuat, quat);
      }
    }
    return quat;
  };
}();

// dist/pp/cauldron/utils/array/mat3_utils.js
function create(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  const out = getAllocationFunction5()();
  if (m00 != null) {
    Mat3Utils.set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22);
  }
  return out;
}
function getAllocationFunction5() {
  return getMatrix3AllocationFunction();
}
function setAllocationFunction5(allocationFunction) {
  setMatrix3AllocationFunction(allocationFunction);
}
function set5(matrix, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  if (m01 == null) {
    gl_mat33.set(matrix, m00, m00, m00, m00, m00, m00, m00, m00, m00);
  } else {
    gl_mat33.set(matrix, m00, m01, m02, m10, m11, m12, m20, m21, m22);
  }
  return matrix;
}
function copy6(from, to) {
  gl_mat33.copy(to, from);
  return to;
}
function clone6(matrix) {
  return matrix.slice(0);
}
function equals6(first2, second, epsilon = 0) {
  let equals10 = first2.length == second.length;
  if (equals10) {
    equals10 &&= Math.abs(first2[0] - second[0]) <= epsilon;
    equals10 &&= Math.abs(first2[1] - second[1]) <= epsilon;
    equals10 &&= Math.abs(first2[2] - second[2]) <= epsilon;
    equals10 &&= Math.abs(first2[3] - second[3]) <= epsilon;
    equals10 &&= Math.abs(first2[4] - second[4]) <= epsilon;
    equals10 &&= Math.abs(first2[5] - second[5]) <= epsilon;
    equals10 &&= Math.abs(first2[6] - second[6]) <= epsilon;
    equals10 &&= Math.abs(first2[7] - second[7]) <= epsilon;
    equals10 &&= Math.abs(first2[8] - second[8]) <= epsilon;
  }
  return equals10;
}
var toDegrees4 = function() {
  const quat = create2();
  function toDegrees5(matrix, out = Vec3Utils.create()) {
    Mat3Utils.toQuat(matrix, quat);
    QuatUtils.toDegrees(quat, out);
    return out;
  }
  return toDegrees5;
}();
var toRadians4 = function() {
  const quat = create2();
  function toRadians5(matrix, out = Vec3Utils.create()) {
    Mat3Utils.toQuat(matrix, quat);
    QuatUtils.toRadians(quat, out);
    return out;
  }
  return toRadians5;
}();
function toQuat3(matrix, out = QuatUtils.create()) {
  gl_quat4.fromMat3(out, matrix);
  return out;
}
function fromAxes2(left, up, forward, out = Mat3Utils.create()) {
  Mat3Utils.set(out, left[0], left[1], left[2], up[0], up[1], up[2], forward[0], forward[1], forward[2]);
  return out;
}
var Mat3Utils = {
  create,
  getAllocationFunction: getAllocationFunction5,
  setAllocationFunction: setAllocationFunction5,
  set: set5,
  copy: copy6,
  clone: clone6,
  equals: equals6,
  toDegrees: toDegrees4,
  toRadians: toRadians4,
  toQuat: toQuat3,
  fromAxes: fromAxes2
};

// dist/pp/cauldron/wl/utils/object_utils.js
var ObjectCloneParams = class {
  /** Defaults to the object to clone parent, null can be used to specify u want the scene root as the parent */
  myCloneParent = void 0;
  /** Ignores components that are not clonable */
  myIgnoreNonCloneable = false;
  /** All components are ignored, cloning only the object hierarchy */
  myIgnoreComponents = false;
  /** Clones only the given object without the descendants */
  myIgnoreDescendants = false;
  /** Ignores all component types in this list (example: `["mesh"]`), has lower priority over `myComponentsToInclude` */
  myComponentsToIgnore = [];
  /** Clones only the component types in this list (example: `["mesh"]`), has higher priority over `myComponentsToIgnore`, if empty it's ignored */
  myComponentsToInclude = [];
  /** Returns true if the component must be ignored. It's called after the previous filters */
  myIgnoreComponentCallback = null;
  /** Ignores all the objects in this list, has lower priority over `myDescendantsToInclude` */
  myDescendantsToIgnore = [];
  /** Clones only the objects in this list, has higher priority over `myDescendantsToIgnore`, if empty it's ignored */
  myDescendantsToInclude = [];
  /** Returns true if the object must be ignored. It's called after the previous filters */
  myIgnoreDescendantCallback = null;
  /** Uses the default component clone function */
  myUseDefaultComponentClone = false;
  /** Uses the default component clone function only as fallback, that is if there is no custom component clone */
  myUseDefaultComponentCloneAsFallback = false;
  /** Automatically starts the component even if it's cloned not activated, keeping it not active. This also triggers `onActivate` and `onDeactivate` once */
  myDefaultComponentCloneAutoStartIfNotActive = true;
  /** Uses the default object clone function, ignoring all the other clone settings but `myCloneParent` and `myDefaultComponentCloneAutoStartIfNotActive` */
  myUseDefaultObjectClone = false;
  /** Uses the default object clone function only as fallback, that is if the object is not PP cloneable */
  myUseDefaultObjectCloneAsFallback = false;
  /** Used to specify if the object components must be deep cloned or not, you can also override the behavior for specific components and variables */
  myComponentDeepCloneParams = new ComponentDeepCloneParams();
  /** This class can be filled with whatever custom paramater the component clone functions could need */
  myComponentCustomCloneParams = new ComponentCustomCloneParams();
};
function getPosition3(object, outPosition) {
  return ObjectUtils.getPositionWorld(object, outPosition);
}
function getPositionWorld(object, outPosition = Vec3Utils.create()) {
  object.getPositionWorld(outPosition);
  return outPosition;
}
function getPositionLocal(object, outPosition = Vec3Utils.create()) {
  object.getPositionLocal(outPosition);
  return outPosition;
}
function getRotation3(object, outRotation) {
  return ObjectUtils.getRotationWorld(object, outRotation);
}
function getRotationDegrees3(object, outRotation) {
  return ObjectUtils.getRotationWorldDegrees(object, outRotation);
}
function getRotationRadians3(object, outRotation) {
  return ObjectUtils.getRotationWorldRadians(object, outRotation);
}
function getRotationMatrix(object, outRotation) {
  return ObjectUtils.getRotationWorldMatrix(object, outRotation);
}
function getRotationQuat3(object, outRotation) {
  return ObjectUtils.getRotationWorldQuat(object, outRotation);
}
function getRotationWorld(object, outRotation) {
  return ObjectUtils.getRotationWorldDegrees(object, outRotation);
}
function getRotationWorldDegrees(object, outRotation) {
  outRotation = ObjectUtils.getRotationWorldRadians(object, outRotation);
  Vec3Utils.toDegrees(outRotation, outRotation);
  return outRotation;
}
var getRotationWorldRadians = function() {
  const quat = QuatUtils.create();
  function getRotationWorldRadians2(object, outRotation = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.toRadians(quat, outRotation);
    return outRotation;
  }
  return getRotationWorldRadians2;
}();
var getRotationWorldMatrix = function() {
  const quat = QuatUtils.create();
  function getRotationWorldMatrix2(object, outRotation = Mat3Utils.create()) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.toMatrix(quat, outRotation);
    return outRotation;
  }
  return getRotationWorldMatrix2;
}();
function getRotationWorldQuat(object, outRotation = QuatUtils.create()) {
  object.getRotationWorld(outRotation);
  return outRotation;
}
function getRotationLocal(object, outRotation) {
  return ObjectUtils.getRotationLocalDegrees(object, outRotation);
}
function getRotationLocalDegrees(object, outRotation) {
  outRotation = ObjectUtils.getRotationLocalRadians(object, outRotation);
  Vec3Utils.toDegrees(outRotation, outRotation);
  return outRotation;
}
var getRotationLocalRadians = function() {
  const quat = QuatUtils.create();
  function getRotationLocalRadians2(object, outRotation = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.toRadians(quat, outRotation);
    return outRotation;
  }
  return getRotationLocalRadians2;
}();
var getRotationLocalMatrix = function() {
  const quat = QuatUtils.create();
  function getRotationLocalMatrix2(object, outRotation = Mat3Utils.create()) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.toMatrix(quat, outRotation);
    return outRotation;
  }
  return getRotationLocalMatrix2;
}();
function getRotationLocalQuat(object, outRotation = QuatUtils.create()) {
  object.getRotationLocal(outRotation);
  return outRotation;
}
function getScale2(object, outScale) {
  return ObjectUtils.getScaleWorld(object, outScale);
}
function getScaleWorld(object, outScale = Vec3Utils.create()) {
  object.getScalingWorld(outScale);
  return outScale;
}
function getScaleLocal(object, outScale = Vec3Utils.create()) {
  object.getScalingLocal(outScale);
  return outScale;
}
function getTransform(object, outTransform) {
  return ObjectUtils.getTransformWorld(object, outTransform);
}
function getTransformMatrix(object, outTransform) {
  return ObjectUtils.getTransformWorldMatrix(object, outTransform);
}
function getTransformQuat(object, outTransform) {
  return ObjectUtils.getTransformWorldQuat(object, outTransform);
}
function getTransformWorld(object, outTransform) {
  return ObjectUtils.getTransformWorldMatrix(object, outTransform);
}
var getTransformWorldMatrix = function() {
  const transformQuat2 = Quat2Utils.create();
  const scale4 = Vec3Utils.create();
  function getTransformWorldMatrix2(object, outTransform = Mat4Utils.create()) {
    ObjectUtils.getTransformWorldQuat(object, transformQuat2);
    ObjectUtils.getScaleWorld(object, scale4);
    Mat4Utils.fromQuat(transformQuat2, outTransform);
    Mat4Utils.scale(outTransform, scale4, outTransform);
    return outTransform;
  }
  return getTransformWorldMatrix2;
}();
function getTransformWorldQuat(object, outTransform = Quat2Utils.create()) {
  object.getTransformWorld(outTransform);
  return outTransform;
}
function getTransformLocal(object, outTransform) {
  return ObjectUtils.getTransformLocalMatrix(object, outTransform);
}
var getTransformLocalMatrix = function() {
  const transformQuat2 = Quat2Utils.create();
  const scale4 = Vec3Utils.create();
  function getTransformLocalMatrix2(object, outTransform = Mat4Utils.create()) {
    ObjectUtils.getTransformLocalQuat(object, transformQuat2);
    ObjectUtils.getScaleLocal(object, scale4);
    Mat4Utils.fromQuat(transformQuat2, outTransform);
    Mat4Utils.scale(outTransform, scale4, outTransform);
    return outTransform;
  }
  return getTransformLocalMatrix2;
}();
function getTransformLocalQuat(object, outTransform = Quat2Utils.create()) {
  object.getTransformLocal(outTransform);
  return outTransform;
}
function getAxes4(object, outAxes = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
  return ObjectUtils.getAxesWorld(object, outAxes);
}
function getAxesWorld(object, outAxes = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
  ObjectUtils.getLeftWorld(object, outAxes[0]);
  ObjectUtils.getUpWorld(object, outAxes[1]);
  ObjectUtils.getForwardWorld(object, outAxes[2]);
  return outAxes;
}
function getAxesLocal(object, outAxes = [Vec3Utils.create(), Vec3Utils.create(), Vec3Utils.create()]) {
  ObjectUtils.getLeftLocal(object, outAxes[0]);
  ObjectUtils.getUpLocal(object, outAxes[1]);
  ObjectUtils.getForwardLocal(object, outAxes[2]);
  return outAxes;
}
function getForward4(object, outForward) {
  return ObjectUtils.getForwardWorld(object, outForward);
}
var getForwardWorld = function() {
  const rotation = Mat3Utils.create();
  function getForwardWorld2(object, outForward = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldMatrix(object, rotation);
    outForward[0] = rotation[6];
    outForward[1] = rotation[7];
    outForward[2] = rotation[8];
    return outForward;
  }
  return getForwardWorld2;
}();
var getForwardLocal = function() {
  const rotation = Mat3Utils.create();
  function getForwardLocal2(object, outForward = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalMatrix(object, rotation);
    outForward[0] = rotation[6];
    outForward[1] = rotation[7];
    outForward[2] = rotation[8];
    return outForward;
  }
  return getForwardLocal2;
}();
function getBackward4(object, outBackward) {
  return ObjectUtils.getBackwardWorld(object, outBackward);
}
var getBackwardWorld = function() {
  const rotation = Mat3Utils.create();
  function getBackwardWorld2(object, outBackward = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldMatrix(object, rotation);
    outBackward[0] = -rotation[6];
    outBackward[1] = -rotation[7];
    outBackward[2] = -rotation[8];
    return outBackward;
  }
  return getBackwardWorld2;
}();
var getBackwardLocal = function() {
  const rotation = Mat3Utils.create();
  function getBackwardLocal2(object, outBackward = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalMatrix(object, rotation);
    outBackward[0] = -rotation[6];
    outBackward[1] = -rotation[7];
    outBackward[2] = -rotation[8];
    return outBackward;
  }
  return getBackwardLocal2;
}();
function getUp4(object, outUp) {
  return ObjectUtils.getUpWorld(object, outUp);
}
var getUpWorld = function() {
  const rotation = Mat3Utils.create();
  function getUpWorld2(object, outUp = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldMatrix(object, rotation);
    outUp[0] = rotation[3];
    outUp[1] = rotation[4];
    outUp[2] = rotation[5];
    return outUp;
  }
  return getUpWorld2;
}();
var getUpLocal = function() {
  const rotation = Mat3Utils.create();
  function getUpLocal2(object, outUp = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalMatrix(object, rotation);
    outUp[0] = rotation[3];
    outUp[1] = rotation[4];
    outUp[2] = rotation[5];
    return outUp;
  }
  return getUpLocal2;
}();
function getDown4(object, outDown) {
  return ObjectUtils.getDownWorld(object, outDown);
}
var getDownWorld = function() {
  const rotation = Mat3Utils.create();
  function getDownWorld2(object, outDown = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldMatrix(object, rotation);
    outDown[0] = -rotation[3];
    outDown[1] = -rotation[4];
    outDown[2] = -rotation[5];
    return outDown;
  }
  return getDownWorld2;
}();
var getDownLocal = function() {
  const rotation = Mat3Utils.create();
  function getDownLocal2(object, outDown = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalMatrix(object, rotation);
    outDown[0] = -rotation[3];
    outDown[1] = -rotation[4];
    outDown[2] = -rotation[5];
    return outDown;
  }
  return getDownLocal2;
}();
function getLeft4(object, outLeft) {
  return ObjectUtils.getLeftWorld(object, outLeft);
}
var getLeftWorld = function() {
  const rotation = Mat3Utils.create();
  function getLeftWorld2(object, outLeft = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldMatrix(object, rotation);
    outLeft[0] = rotation[0];
    outLeft[1] = rotation[1];
    outLeft[2] = rotation[2];
    return outLeft;
  }
  return getLeftWorld2;
}();
var getLeftLocal = function() {
  const rotation = Mat3Utils.create();
  function getLeftLocal2(object, outLeft = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalMatrix(object, rotation);
    outLeft[0] = rotation[0];
    outLeft[1] = rotation[1];
    outLeft[2] = rotation[2];
    return outLeft;
  }
  return getLeftLocal2;
}();
function getRight4(object, outRight) {
  return ObjectUtils.getRightWorld(object, outRight);
}
var getRightWorld = function() {
  const rotation = Mat3Utils.create();
  function getRightWorld2(object, outRight = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldMatrix(object, rotation);
    outRight[0] = -rotation[0];
    outRight[1] = -rotation[1];
    outRight[2] = -rotation[2];
    return outRight;
  }
  return getRightWorld2;
}();
var getRightLocal = function() {
  const rotation = Mat3Utils.create();
  function getRightLocal2(object, outRight = Vec3Utils.create()) {
    ObjectUtils.getRotationLocalMatrix(object, rotation);
    outRight[0] = -rotation[0];
    outRight[1] = -rotation[1];
    outRight[2] = -rotation[2];
    return outRight;
  }
  return getRightLocal2;
}();
function setPosition3(object, position) {
  return ObjectUtils.setPositionWorld(object, position);
}
function setPositionWorld(object, position) {
  return object.setPositionWorld(position);
}
function setPositionLocal(object, position) {
  return object.setPositionLocal(position);
}
function setRotation3(object, rotation) {
  return ObjectUtils.setRotationWorld(object, rotation);
}
function setRotationDegrees3(object, rotation) {
  return ObjectUtils.setRotationWorldDegrees(object, rotation);
}
function setRotationRadians3(object, rotation) {
  return ObjectUtils.setRotationWorldRadians(object, rotation);
}
function setRotationMatrix(object, rotation) {
  return ObjectUtils.setRotationWorldMatrix(object, rotation);
}
function setRotationQuat3(object, rotation) {
  return ObjectUtils.setRotationWorldQuat(object, rotation);
}
function setRotationWorld(object, rotation) {
  return ObjectUtils.setRotationWorldDegrees(object, rotation);
}
var setRotationWorldDegrees = function() {
  const quat = QuatUtils.create();
  return function setRotationWorldDegrees2(object, rotation) {
    Vec3Utils.degreesToQuat(rotation, quat);
    return ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setRotationWorldRadians = function() {
  const degreesRotation = Vec3Utils.create();
  return function setRotationWorldRadians2(object, rotation) {
    Vec3Utils.toDegrees(rotation, degreesRotation);
    return ObjectUtils.setRotationWorldDegrees(object, degreesRotation);
  };
}();
var setRotationWorldMatrix = function() {
  const quat = QuatUtils.create();
  return function setRotationWorldMatrix2(object, rotation) {
    Mat3Utils.toQuat(rotation, quat);
    return ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
function setRotationWorldQuat(object, rotation) {
  return object.setRotationWorld(rotation);
}
function setRotationLocal(object, rotation) {
  return ObjectUtils.setRotationLocalDegrees(object, rotation);
}
var setRotationLocalDegrees = function() {
  const quat = QuatUtils.create();
  return function setRotationLocalDegrees2(object, rotation) {
    Vec3Utils.degreesToQuat(rotation, quat);
    return ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
var setRotationLocalRadians = function() {
  const degreesRotation = Vec3Utils.create();
  return function setRotationLocalRadians2(object, rotation) {
    Vec3Utils.toDegrees(rotation, degreesRotation);
    return ObjectUtils.setRotationLocalDegrees(object, degreesRotation);
  };
}();
var setRotationLocalMatrix = function() {
  const quat = QuatUtils.create();
  return function setRotationLocalMatrix2(object, rotation) {
    Mat3Utils.toQuat(rotation, quat);
    return ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setRotationLocalQuat(object, rotation) {
  return object.setRotationLocal(rotation);
}
function setScale2(object, scale4) {
  return ObjectUtils.setScaleWorld(object, scale4);
}
var setScaleWorld = function() {
  const vector = Vec3Utils.create();
  function setScaleWorld2(object, scale4) {
    if (isNaN(scale4)) {
      return object.setScalingWorld(scale4);
    } else {
      Vec3Utils.set(vector, scale4);
      return object.setScalingWorld(vector);
    }
  }
  return setScaleWorld2;
}();
var setScaleLocal = function() {
  const vector = Vec3Utils.create();
  function setScaleLocal2(object, scale4) {
    if (isNaN(scale4)) {
      return object.setScalingLocal(scale4);
    } else {
      Vec3Utils.set(vector, scale4);
      return object.setScalingLocal(vector);
    }
  }
  return setScaleLocal2;
}();
function setAxes2(object, left, up, forward) {
  return ObjectUtils.setAxesWorld(object, left, up, forward);
}
function setAxesWorld(object, left, up, forward) {
  if (forward != null) {
    return ObjectUtils.setForwardWorld(object, forward, up, left);
  } else if (up != null) {
    return ObjectUtils.setUpWorld(object, up, forward, left);
  } else if (left != null) {
    return ObjectUtils.setLeftWorld(object, left, up, forward);
  }
  return object;
}
function setAxesLocal(object, left, up, forward) {
  if (forward != null) {
    return ObjectUtils.setForwardLocal(object, forward, up, left);
  } else if (up != null) {
    return ObjectUtils.setUpLocal(object, up, forward, left);
  } else if (left != null) {
    return ObjectUtils.setLeftLocal(object, left, up, forward);
  }
  return object;
}
function setForward2(object, forward, up, left) {
  return ObjectUtils.setForwardWorld(object, forward, up, left);
}
var setForwardWorld = function() {
  const quat = QuatUtils.create();
  return function setForwardWorld2(object, forward, up, left) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.setForward(quat, forward, up, left);
    return ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setForwardLocal = function() {
  const quat = QuatUtils.create();
  return function setForwardLocal2(object, forward, up, left) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.setForward(quat, forward, up, left);
    return ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setBackward2(object, backward, up, left) {
  return ObjectUtils.setBackwardWorld(object, backward, up, left);
}
var setBackwardWorld = function() {
  const quat = QuatUtils.create();
  return function setBackwardWorld2(object, backward, up, left) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.setBackward(quat, backward, up, left);
    return ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setBackwardLocal = function() {
  const quat = QuatUtils.create();
  return function setBackwardLocal2(object, backward, up, left) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.setBackward(quat, backward, up, left);
    return ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setUp2(object, up, forward, left) {
  return ObjectUtils.setUpWorld(object, up, forward, left);
}
var setUpWorld = function() {
  const quat = QuatUtils.create();
  return function setUpWorld2(object, up, forward, left) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.setUp(quat, up, forward, left);
    return ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setUpLocal = function() {
  const quat = QuatUtils.create();
  return function setUpLocal2(object, up, forward, left) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.setUp(quat, up, forward, left);
    return ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setDown2(object, down, forward, left) {
  return ObjectUtils.setDownWorld(object, down, forward, left);
}
var setDownWorld = function() {
  const quat = QuatUtils.create();
  return function setDownWorld2(object, down, forward, left) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.setDown(quat, down, forward, left);
    return ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setDownLocal = function() {
  const quat = QuatUtils.create();
  return function setDownLocal2(object, down, forward, left) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.setDown(quat, down, forward, left);
    return ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setLeft2(object, left, up, forward) {
  return ObjectUtils.setLeftWorld(object, left, up, forward);
}
var setLeftWorld = function() {
  const quat = QuatUtils.create();
  return function setLeftWorld2(object, left, up, forward) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.setLeft(quat, left, up, forward);
    return ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setLeftLocal = function() {
  const quat = QuatUtils.create();
  return function setLeftLocal2(object, left, up, forward) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.setLeft(quat, left, up, forward);
    return ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setRight2(object, right, up, forward) {
  return ObjectUtils.setRightWorld(object, right, up, forward);
}
var setRightWorld = function() {
  const quat = QuatUtils.create();
  return function setRightWorld2(object, right, up, forward) {
    ObjectUtils.getRotationWorldQuat(object, quat);
    QuatUtils.setRight(quat, right, up, forward);
    return ObjectUtils.setRotationWorldQuat(object, quat);
  };
}();
var setRightLocal = function() {
  const quat = QuatUtils.create();
  return function setRightLocal2(object, right, up, forward) {
    ObjectUtils.getRotationLocalQuat(object, quat);
    QuatUtils.setRight(quat, right, up, forward);
    return ObjectUtils.setRotationLocalQuat(object, quat);
  };
}();
function setTransform(object, transform) {
  return ObjectUtils.setTransformWorld(object, transform);
}
function setTransformMatrix(object, transform) {
  return ObjectUtils.setTransformWorldMatrix(object, transform);
}
function setTransformQuat(object, transform) {
  return ObjectUtils.setTransformWorldQuat(object, transform);
}
function setTransformWorld(object, transform) {
  return ObjectUtils.setTransformWorldMatrix(object, transform);
}
var setTransformWorldMatrix = function() {
  const position = Vec3Utils.create();
  const rotation = QuatUtils.create();
  const scale4 = Vec3Utils.create();
  const transformMatrixNoScale = Mat4Utils.create();
  const inverseScale = Vec3Utils.create();
  const one = Vec3Utils.create(1);
  return function setTransformWorldMatrix2(object, transform) {
    Mat4Utils.getPosition(transform, position);
    Mat4Utils.getScale(transform, scale4);
    Vec3Utils.div(one, scale4, inverseScale);
    Mat4Utils.scale(transform, inverseScale, transformMatrixNoScale);
    Mat4Utils.getRotationQuat(transformMatrixNoScale, rotation);
    QuatUtils.normalize(rotation, rotation);
    ObjectUtils.setScaleWorld(object, scale4);
    ObjectUtils.setRotationWorldQuat(object, rotation);
    ObjectUtils.setPositionWorld(object, position);
    return object;
  };
}();
function setTransformWorldQuat(object, transform) {
  return object.setTransformWorld(transform);
}
function setTransformLocal(object, transform) {
  return ObjectUtils.setTransformLocalMatrix(object, transform);
}
var setTransformLocalMatrix = function() {
  const position = Vec3Utils.create();
  const rotation = QuatUtils.create();
  const scale4 = Vec3Utils.create();
  const transformMatrixNoScale = Mat4Utils.create();
  const inverseScale = Vec3Utils.create();
  const one = Vec3Utils.create(1);
  return function setTransformLocalMatrix2(object, transform) {
    Mat4Utils.getPosition(transform, position);
    Mat4Utils.getScale(transform, scale4);
    Vec3Utils.div(one, scale4, inverseScale);
    Mat4Utils.scale(transform, inverseScale, transformMatrixNoScale);
    Mat4Utils.getRotationQuat(transformMatrixNoScale, rotation);
    QuatUtils.normalize(rotation, rotation);
    ObjectUtils.setScaleLocal(object, scale4);
    ObjectUtils.setRotationLocalQuat(object, rotation);
    ObjectUtils.setPositionLocal(object, position);
    return object;
  };
}();
function setTransformLocalQuat(object, transform) {
  return object.setTransformLocal(transform);
}
function resetPosition(object) {
  return ObjectUtils.resetPositionWorld(object);
}
var resetPositionWorld = function() {
  const zero4 = Vec3Utils.create();
  return function resetPositionWorld2(object) {
    return ObjectUtils.setPositionWorld(object, zero4);
  };
}();
var resetPositionLocal = function() {
  const zero4 = Vec3Utils.create();
  return function resetPositionLocal2(object) {
    return ObjectUtils.setPositionLocal(object, zero4);
  };
}();
function resetRotation(object) {
  return ObjectUtils.resetRotationWorld(object);
}
var resetRotationWorld = function() {
  const identity4 = QuatUtils.create();
  return function resetRotationWorld2(object) {
    return ObjectUtils.setRotationWorldQuat(object, identity4);
  };
}();
var resetRotationLocal = function() {
  const identity4 = QuatUtils.create();
  return function resetRotationLocal2(object) {
    return ObjectUtils.setRotationLocalQuat(object, identity4);
  };
}();
function resetScale(object) {
  return ObjectUtils.resetScaleWorld(object);
}
var resetScaleWorld = function() {
  const one = Vec3Utils.create(1);
  return function resetScaleWorld2(object) {
    return ObjectUtils.setScaleWorld(object, one);
  };
}();
var resetScaleLocal = function() {
  const one = Vec3Utils.create(1);
  return function resetScaleLocal2(object) {
    return ObjectUtils.setScaleLocal(object, one);
  };
}();
function resetTransform(object) {
  return ObjectUtils.resetTransformWorld(object);
}
function resetTransformWorld(object) {
  ObjectUtils.resetScaleWorld(object);
  ObjectUtils.resetRotationWorld(object);
  ObjectUtils.resetPositionWorld(object);
  return object;
}
function resetTransformLocal(object) {
  ObjectUtils.resetScaleLocal(object);
  ObjectUtils.resetRotationLocal(object);
  ObjectUtils.resetPositionLocal(object);
  return object;
}
function translate(object, translation) {
  return ObjectUtils.translateWorld(object, translation);
}
function translateWorld(object, translation) {
  return object.translateWorld(translation);
}
function translateLocal(object, translation) {
  return object.translateLocal(translation);
}
function translateObject(object, translation) {
  return object.translateObject(translation);
}
function translateAxis(object, amount, direction) {
  return ObjectUtils.translateAxisWorld(object, amount, direction);
}
var translateAxisWorld = function() {
  const translation = Vec3Utils.create();
  return function translateAxisWorld2(object, amount, direction) {
    Vec3Utils.scale(direction, amount, translation);
    return ObjectUtils.translateWorld(object, translation);
  };
}();
var translateAxisLocal = function() {
  const translation = Vec3Utils.create();
  return function translateAxisLocal2(object, amount, direction) {
    Vec3Utils.scale(direction, amount, translation);
    return ObjectUtils.translateLocal(object, translation);
  };
}();
var translateAxisObject = function() {
  const translation = Vec3Utils.create();
  return function translateAxisObject2(object, amount, direction) {
    Vec3Utils.scale(direction, amount, translation);
    return ObjectUtils.translateObject(object, translation);
  };
}();
function rotate3(object, rotation) {
  return ObjectUtils.rotateWorld(object, rotation);
}
function rotateDegrees3(object, rotation) {
  return ObjectUtils.rotateWorldDegrees(object, rotation);
}
function rotateRadians3(object, rotation) {
  return ObjectUtils.rotateWorldRadians(object, rotation);
}
function rotateMatrix(object, rotation) {
  return ObjectUtils.rotateWorldMatrix(object, rotation);
}
function rotateQuat3(object, rotation) {
  return ObjectUtils.rotateWorldQuat(object, rotation);
}
function rotateWorld(object, rotation) {
  return ObjectUtils.rotateWorldDegrees(object, rotation);
}
var rotateWorldDegrees = function() {
  const rotationQuat = QuatUtils.create();
  return function rotateWorldDegrees2(object, rotation) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    return ObjectUtils.rotateWorldQuat(object, rotationQuat);
  };
}();
var rotateWorldRadians = function() {
  const degreesRotation = Vec3Utils.create();
  return function rotateWorldRadians2(object, rotation) {
    Vec3Utils.toDegrees(rotation, degreesRotation);
    return ObjectUtils.rotateWorldDegrees(object, degreesRotation);
  };
}();
var rotateWorldMatrix = function() {
  const rotationQuat = QuatUtils.create();
  return function rotateWorldMatrix2(object, rotation) {
    Mat3Utils.toQuat(rotation, rotationQuat);
    QuatUtils.normalize(rotationQuat, rotationQuat);
    return ObjectUtils.rotateWorldQuat(object, rotationQuat);
  };
}();
var rotateWorldQuat = function() {
  const currentRotationQuat = QuatUtils.create();
  return function rotateWorldQuat2(object, rotation) {
    ObjectUtils.getRotationWorldQuat(object, currentRotationQuat);
    QuatUtils.mul(rotation, currentRotationQuat, currentRotationQuat);
    QuatUtils.normalize(currentRotationQuat, currentRotationQuat);
    return ObjectUtils.setRotationWorldQuat(object, currentRotationQuat);
  };
}();
function rotateLocal(object, rotation) {
  return ObjectUtils.rotateLocalDegrees(object, rotation);
}
var rotateLocalDegrees = function() {
  const rotationQuat = QuatUtils.create();
  return function rotateLocalDegrees2(object, rotation) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    return ObjectUtils.rotateLocalQuat(object, rotationQuat);
  };
}();
var rotateLocalRadians = function() {
  const degreesRotation = Vec3Utils.create();
  return function rotateLocalRadians2(object, rotation) {
    Vec3Utils.toDegrees(rotation, degreesRotation);
    return ObjectUtils.rotateLocalDegrees(object, degreesRotation);
  };
}();
var rotateLocalMatrix = function() {
  const rotationQuat = QuatUtils.create();
  return function rotateLocalMatrix2(object, rotation) {
    Mat3Utils.toQuat(rotation, rotationQuat);
    QuatUtils.normalize(rotationQuat, rotationQuat);
    return ObjectUtils.rotateLocalQuat(object, rotationQuat);
  };
}();
var rotateLocalQuat = function() {
  const currentRotationQuat = QuatUtils.create();
  return function rotateLocalQuat2(object, rotation) {
    ObjectUtils.getRotationLocalQuat(object, currentRotationQuat);
    QuatUtils.mul(rotation, currentRotationQuat, currentRotationQuat);
    QuatUtils.normalize(currentRotationQuat, currentRotationQuat);
    return ObjectUtils.setRotationLocalQuat(object, currentRotationQuat);
  };
}();
function rotateObject(object, rotation) {
  return ObjectUtils.rotateObjectDegrees(object, rotation);
}
var rotateObjectDegrees = function() {
  const rotationQuat = QuatUtils.create();
  return function rotateObjectDegrees2(object, rotation) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    return ObjectUtils.rotateObjectQuat(object, rotationQuat);
  };
}();
var rotateObjectRadians = function() {
  const degreesRotation = Vec3Utils.create();
  return function rotateObjectRadians2(object, rotation) {
    Vec3Utils.toDegrees(rotation, degreesRotation);
    return ObjectUtils.rotateObjectDegrees(object, degreesRotation);
  };
}();
var rotateObjectMatrix = function() {
  const rotationQuat = QuatUtils.create();
  return function rotateObjectMatrix2(object, rotation) {
    Mat3Utils.toQuat(rotation, rotationQuat);
    QuatUtils.normalize(rotationQuat, rotationQuat);
    return ObjectUtils.rotateObjectQuat(object, rotationQuat);
  };
}();
function rotateObjectQuat(object, rotation) {
  return object.rotateObject(rotation);
}
function rotateAxis4(object, angle2, axis) {
  return ObjectUtils.rotateAxisWorld(object, angle2, axis);
}
function rotateAxisDegrees4(object, angle2, axis) {
  return ObjectUtils.rotateAxisWorldDegrees(object, angle2, axis);
}
function rotateAxisRadians4(object, angle2, axis) {
  return ObjectUtils.rotateAxisWorldRadians(object, angle2, axis);
}
function rotateAxisWorld(object, angle2, axis) {
  return ObjectUtils.rotateAxisWorldDegrees(object, angle2, axis);
}
function rotateAxisWorldDegrees(object, angle2, axis) {
  return ObjectUtils.rotateAxisWorldRadians(object, MathUtils.toRadians(angle2), axis);
}
var rotateAxisWorldRadians = function() {
  const rotation = QuatUtils.create();
  return function rotateAxisWorldRadians2(object, angle2, axis) {
    QuatUtils.fromAxisRadians(angle2, axis, rotation);
    return ObjectUtils.rotateWorldQuat(object, rotation);
  };
}();
function rotateAxisLocal(object, angle2, axis) {
  return ObjectUtils.rotateAxisLocalDegrees(object, angle2, axis);
}
function rotateAxisLocalDegrees(object, angle2, axis) {
  return ObjectUtils.rotateAxisLocalRadians(object, MathUtils.toRadians(angle2), axis);
}
var rotateAxisLocalRadians = function() {
  const rotation = QuatUtils.create();
  return function rotateAxisLocalRadians2(object, angle2, axis) {
    QuatUtils.fromAxisRadians(angle2, axis, rotation);
    return ObjectUtils.rotateLocalQuat(object, rotation);
  };
}();
function rotateAxisObject(object, angle2, axis) {
  return ObjectUtils.rotateAxisObjectDegrees(object, angle2, axis);
}
function rotateAxisObjectDegrees(object, angle2, axis) {
  return ObjectUtils.rotateAxisObjectRadians(object, MathUtils.toRadians(angle2), axis);
}
var rotateAxisObjectRadians = function() {
  const rotation = QuatUtils.create();
  return function rotateAxisObjectRadians2(object, angle2, axis) {
    QuatUtils.fromAxisRadians(angle2, axis, rotation);
    return ObjectUtils.rotateObjectQuat(object, rotation);
  };
}();
function rotateAround2(object, rotation, origin) {
  return ObjectUtils.rotateAroundWorld(object, rotation, origin);
}
function rotateAroundDegrees2(object, rotation, origin) {
  return ObjectUtils.rotateAroundWorldDegrees(object, rotation, origin);
}
function rotateAroundRadians2(object, rotation, origin) {
  return ObjectUtils.rotateAroundWorldRadians(object, rotation, origin);
}
function rotateAroundMatrix(object, rotation, origin) {
  return ObjectUtils.rotateAroundWorldMatrix(object, rotation, origin);
}
function rotateAroundQuat2(object, rotation, origin) {
  return ObjectUtils.rotateAroundWorldQuat(object, rotation, origin);
}
function rotateAroundWorld(object, rotation, origin) {
  return ObjectUtils.rotateAroundWorldDegrees(object, rotation, origin);
}
var rotateAroundWorldDegrees = function() {
  const rotationQuat = QuatUtils.create();
  return function rotateAroundWorldDegrees2(object, rotation, origin) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    return ObjectUtils.rotateAroundWorldQuat(object, rotationQuat, origin);
  };
}();
var rotateAroundWorldRadians = function() {
  const degreesRotation = Vec3Utils.create();
  return function rotateAroundWorldRadians2(object, rotation, origin) {
    Vec3Utils.toDegrees(rotation, degreesRotation);
    return ObjectUtils.rotateAroundWorldDegrees(object, degreesRotation, origin);
  };
}();
var rotateAroundWorldMatrix = function() {
  const rotationQuat = QuatUtils.create();
  return function rotateAroundWorldMatrix2(object, rotation, origin) {
    Mat3Utils.toQuat(rotation, rotationQuat);
    QuatUtils.normalize(rotationQuat, rotationQuat);
    return ObjectUtils.rotateAroundWorldQuat(object, rotationQuat, origin);
  };
}();
var rotateAroundWorldQuat = function() {
  const axis = Vec3Utils.create();
  return function rotateAroundWorldQuat2(object, rotation, origin) {
    QuatUtils.getAxis(rotation, axis);
    const angle2 = QuatUtils.getAngleRadians(rotation);
    return ObjectUtils.rotateAroundAxisWorldRadians(object, angle2, axis, origin);
  };
}();
function rotateAroundLocal(object, rotation, origin) {
  return ObjectUtils.rotateAroundLocalDegrees(object, rotation, origin);
}
var rotateAroundLocalDegrees = function() {
  const rotationQuat = QuatUtils.create();
  return function rotateAroundLocalDegrees2(object, rotation, origin) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    return ObjectUtils.rotateAroundLocalQuat(object, rotationQuat, origin);
  };
}();
var rotateAroundLocalRadians = function() {
  const degreesRotation = Vec3Utils.create();
  return function rotateAroundLocalRadians2(object, rotation, origin) {
    Vec3Utils.toDegrees(rotation, degreesRotation);
    return ObjectUtils.rotateAroundLocalDegrees(object, degreesRotation, origin);
  };
}();
var rotateAroundLocalMatrix = function() {
  const rotationQuat = QuatUtils.create();
  return function rotateAroundLocalMatrix2(object, rotation, origin) {
    Mat3Utils.toQuat(rotation, rotationQuat);
    QuatUtils.normalize(rotationQuat, rotationQuat);
    return ObjectUtils.rotateAroundLocalQuat(object, rotationQuat, origin);
  };
}();
var rotateAroundLocalQuat = function() {
  const axis = Vec3Utils.create();
  return function rotateAroundLocalQuat2(object, rotation, origin) {
    QuatUtils.getAxis(rotation, axis);
    const angle2 = QuatUtils.getAngleRadians(rotation);
    return ObjectUtils.rotateAroundAxisLocalRadians(object, angle2, axis, origin);
  };
}();
function rotateAroundObject(object, rotation, origin) {
  return ObjectUtils.rotateAroundObjectDegrees(object, rotation, origin);
}
var rotateAroundObjectDegrees = function() {
  const rotationQuat = QuatUtils.create();
  return function rotateAroundObjectDegrees2(object, rotation, origin) {
    Vec3Utils.degreesToQuat(rotation, rotationQuat);
    return ObjectUtils.rotateAroundObjectQuat(object, rotationQuat, origin);
  };
}();
var rotateAroundObjectRadians = function() {
  const degreesRotation = Vec3Utils.create();
  return function rotateAroundObjectRadians2(object, rotation, origin) {
    Vec3Utils.toDegrees(rotation, degreesRotation);
    return ObjectUtils.rotateAroundObjectDegrees(object, degreesRotation, origin);
  };
}();
var rotateAroundObjectMatrix = function() {
  const rotationQuat = QuatUtils.create();
  return function rotateAroundObjectMatrix2(object, rotation, origin) {
    Mat3Utils.toQuat(rotation, rotationQuat);
    QuatUtils.normalize(rotationQuat, rotationQuat);
    return ObjectUtils.rotateAroundObjectQuat(object, rotationQuat, origin);
  };
}();
var rotateAroundObjectQuat = function() {
  const axis = Vec3Utils.create();
  return function rotateAroundObjectQuat2(object, rotation, origin) {
    QuatUtils.getAxis(rotation, axis);
    const angle2 = QuatUtils.getAngleRadians(rotation);
    return ObjectUtils.rotateAroundAxisObjectRadians(object, angle2, axis, origin);
  };
}();
function rotateAroundAxis2(object, angle2, axis, origin) {
  return ObjectUtils.rotateAroundAxisWorld(object, angle2, axis, origin);
}
function rotateAroundAxisDegrees2(object, angle2, axis, origin) {
  return ObjectUtils.rotateAroundAxisWorldDegrees(object, angle2, axis, origin);
}
function rotateAroundAxisRadians2(object, angle2, axis, origin) {
  return ObjectUtils.rotateAroundAxisWorldRadians(object, angle2, axis, origin);
}
function rotateAroundAxisWorld(object, angle2, axis, origin) {
  return ObjectUtils.rotateAroundAxisWorldDegrees(object, angle2, axis, origin);
}
function rotateAroundAxisWorldDegrees(object, angle2, axis, origin) {
  return ObjectUtils.rotateAroundAxisWorldRadians(object, MathUtils.toRadians(angle2), axis, origin);
}
var rotateAroundAxisWorldRadians = function() {
  const transformToRotate = Quat2Utils.create();
  const transformToRotateConjugate = Quat2Utils.create();
  const transformQuat2 = Quat2Utils.create();
  const defaultQuat = QuatUtils.create();
  return function rotateAroundAxisWorldRadians2(object, angle2, axis, origin) {
    Quat2Utils.setPositionRotationQuat(transformToRotate, origin, defaultQuat);
    ObjectUtils.getTransformWorldQuat(object, transformQuat2);
    Quat2Utils.conjugate(transformToRotate, transformToRotateConjugate);
    Quat2Utils.mul(transformToRotateConjugate, transformQuat2, transformQuat2);
    Quat2Utils.rotateAxisRadians(transformToRotate, angle2, axis, transformToRotate);
    Quat2Utils.mul(transformToRotate, transformQuat2, transformQuat2);
    return ObjectUtils.setTransformWorldQuat(object, transformQuat2);
  };
}();
function rotateAroundAxisLocal(object, angle2, axis, origin) {
  return ObjectUtils.rotateAroundAxisLocalDegrees(object, angle2, axis, origin);
}
function rotateAroundAxisLocalDegrees(object, angle2, axis, origin) {
  return ObjectUtils.rotateAroundAxisLocalRadians(object, MathUtils.toRadians(angle2), axis, origin);
}
var rotateAroundAxisLocalRadians = function() {
  const convertedPosition = Vec3Utils.create();
  const convertedAxis = Vec3Utils.create();
  return function rotateAroundAxisLocalRadians2(object, angle2, axis, origin) {
    ObjectUtils.convertPositionLocalToWorld(object, origin, convertedPosition);
    ObjectUtils.convertDirectionLocalToWorld(object, axis, convertedAxis);
    return ObjectUtils.rotateAroundAxisWorldRadians(object, angle2, convertedAxis, convertedPosition);
  };
}();
function rotateAroundAxisObject(object, angle2, axis, origin) {
  return ObjectUtils.rotateAroundAxisObjectDegrees(object, angle2, axis, origin);
}
function rotateAroundAxisObjectDegrees(object, angle2, axis, origin) {
  return ObjectUtils.rotateAroundAxisObjectRadians(object, MathUtils.toRadians(angle2), axis, origin);
}
var rotateAroundAxisObjectRadians = function() {
  const convertedPosition = Vec3Utils.create();
  const convertedAxis = Vec3Utils.create();
  return function rotateAroundAxisObjectRadians2(object, angle2, axis, origin) {
    ObjectUtils.convertPositionObjectToWorld(object, origin, convertedPosition);
    ObjectUtils.convertDirectionObjectToWorld(object, axis, convertedAxis);
    return ObjectUtils.rotateAroundAxisWorldRadians(object, angle2, convertedAxis, convertedPosition);
  };
}();
var scaleObject = function() {
  const vector = Vec3Utils.create();
  function scaleObject2(object, scale4) {
    if (isNaN(scale4)) {
      return object.scaleLocal(scale4);
    } else {
      Vec3Utils.set(vector, scale4);
      return object.scaleLocal(vector);
    }
  }
  return scaleObject2;
}();
function lookAt(object, position, up) {
  return ObjectUtils.lookAtWorld(object, position, up);
}
var lookAtWorld = function() {
  const direction = Vec3Utils.create();
  return function lookAtWorld2(object, position, up) {
    ObjectUtils.getPositionWorld(object, direction);
    Vec3Utils.sub(position, direction, direction);
    return ObjectUtils.lookToWorld(object, direction, up);
  };
}();
var lookAtLocal = function() {
  const direction = Vec3Utils.create();
  return function lookAtLocal2(object, position, up) {
    ObjectUtils.getPositionLocal(object, direction);
    Vec3Utils.sub(position, direction, direction);
    return ObjectUtils.lookToLocal(object, direction, up);
  };
}();
function lookTo(object, direction, up) {
  return ObjectUtils.lookToWorld(object, direction, up);
}
var lookToWorld = function() {
  const internalUp = Vec3Utils.create();
  return function lookToWorld2(object, direction, up = ObjectUtils.getUpWorld(object, internalUp)) {
    return ObjectUtils.setForwardWorld(object, direction, up);
  };
}();
var lookToLocal = function() {
  const internalUp = Vec3Utils.create();
  return function lookToLocal2(object, direction, up = ObjectUtils.getUpLocal(object, internalUp)) {
    return ObjectUtils.setForwardLocal(object, direction, up);
  };
}();
var convertPositionObjectToWorld = function() {
  const matrix = Mat4Utils.create();
  function convertPositionObjectToWorld2(object, position, outPosition = Vec3Utils.create()) {
    ObjectUtils.getTransformWorldMatrix(object, matrix);
    Vec3Utils.transformMat4(position, matrix, outPosition);
    return outPosition;
  }
  return convertPositionObjectToWorld2;
}();
var convertDirectionObjectToWorld = function() {
  const rotation = QuatUtils.create();
  function convertDirectionObjectToWorld2(object, direction, outDirection = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldQuat(object, rotation);
    Vec3Utils.transformQuat(direction, rotation, outDirection);
    return outDirection;
  }
  return convertDirectionObjectToWorld2;
}();
var convertPositionWorldToObject = function() {
  const matrix = Mat4Utils.create();
  function convertPositionWorldToObject2(object, position, outPosition = Vec3Utils.create()) {
    ObjectUtils.getTransformWorldMatrix(object, matrix);
    Mat4Utils.invert(matrix, matrix);
    Vec3Utils.transformMat4(position, matrix, outPosition);
    return outPosition;
  }
  return convertPositionWorldToObject2;
}();
var convertDirectionWorldToObject = function() {
  const rotation = QuatUtils.create();
  function convertDirectionWorldToObject2(object, direction, outDirection = Vec3Utils.create()) {
    ObjectUtils.getRotationWorldQuat(object, rotation);
    QuatUtils.conjugate(rotation, rotation);
    Vec3Utils.transformQuat(direction, rotation, outDirection);
    return outDirection;
  }
  return convertDirectionWorldToObject2;
}();
function convertPositionLocalToWorld(object, position, outPosition = Vec3Utils.create()) {
  if (ObjectUtils.getParent(object) != null) {
    ObjectUtils.convertPositionObjectToWorld(ObjectUtils.getParent(object), position, outPosition);
  } else {
    Vec3Utils.copy(position, outPosition);
  }
  return outPosition;
}
function convertDirectionLocalToWorld(object, direction, outDirection = Vec3Utils.create()) {
  if (ObjectUtils.getParent(object) != null) {
    ObjectUtils.convertDirectionObjectToWorld(ObjectUtils.getParent(object), direction, outDirection);
  } else {
    Vec3Utils.copy(direction, outDirection);
  }
  return outDirection;
}
function convertPositionWorldToLocal(object, position, outPosition = Vec3Utils.create()) {
  if (ObjectUtils.getParent(object) != null) {
    ObjectUtils.convertPositionWorldToObject(ObjectUtils.getParent(object), position, outPosition);
  } else {
    Vec3Utils.copy(position, outPosition);
  }
  return outPosition;
}
function convertDirectionWorldToLocal(object, direction, outDirection = Vec3Utils.create()) {
  if (ObjectUtils.getParent(object) != null) {
    ObjectUtils.convertDirectionWorldToObject(ObjectUtils.getParent(object), direction, outDirection);
  } else {
    Vec3Utils.copy(direction, outDirection);
  }
  return outDirection;
}
function convertPositionObjectToLocal(object, position, outPosition = Vec3Utils.create()) {
  ObjectUtils.convertPositionObjectToWorld(object, position, outPosition);
  ObjectUtils.convertPositionWorldToLocal(object, outPosition, outPosition);
  return outPosition;
}
function convertDirectionObjectToLocal(object, direction, outDirection = Vec3Utils.create()) {
  ObjectUtils.convertDirectionObjectToWorld(object, direction, outDirection);
  ObjectUtils.convertDirectionWorldToLocal(object, outDirection, outDirection);
  return outDirection;
}
function convertPositionLocalToObject(object, position, outPosition = Vec3Utils.create()) {
  ObjectUtils.convertPositionLocalToWorld(object, position, outPosition);
  ObjectUtils.convertPositionWorldToObject(object, outPosition, outPosition);
  return outPosition;
}
function convertDirectionLocalToObject(object, direction, outDirection = Vec3Utils.create()) {
  ObjectUtils.convertDirectionLocalToWorld(object, direction, outDirection);
  ObjectUtils.convertDirectionWorldToObject(object, outDirection, outDirection);
  return outDirection;
}
function convertTransformObjectToWorld(object, transform, outTransform) {
  return ObjectUtils.convertTransformObjectToWorldMatrix(object, transform, outTransform);
}
var convertTransformObjectToWorldMatrix = function() {
  const convertTransform = Mat4Utils.create();
  const position = Vec3Utils.create();
  const scale4 = Vec3Utils.create();
  const inverseScale = Vec3Utils.create();
  const one = Vec3Utils.create(1);
  function convertTransformObjectToWorldMatrix2(object, transform, outTransform = Mat4Utils.clone(transform)) {
    ObjectUtils.getTransformWorldMatrix(object, convertTransform);
    if (ObjectUtils.hasUniformScaleWorld(object)) {
      Mat4Utils.mul(convertTransform, transform, outTransform);
    } else {
      Vec3Utils.set(position, transform[12], transform[13], transform[14]);
      ObjectUtils.convertPositionObjectToWorld(object, position, position);
      Mat4Utils.getScale(convertTransform, scale4);
      Vec3Utils.div(one, scale4, inverseScale);
      Mat4Utils.scale(convertTransform, inverseScale, convertTransform);
      Mat4Utils.mul(convertTransform, transform, outTransform);
      Mat4Utils.scale(outTransform, scale4, outTransform);
      outTransform[12] = position[0];
      outTransform[13] = position[1];
      outTransform[14] = position[2];
      outTransform[15] = 1;
    }
    return outTransform;
  }
  return convertTransformObjectToWorldMatrix2;
}();
var convertTransformObjectToWorldQuat = function() {
  const position = Vec3Utils.create();
  const rotation = QuatUtils.create();
  function convertTransformObjectToWorldQuat2(object, transform, outTransform = Quat2Utils.clone(transform)) {
    ObjectUtils.getRotationWorldQuat(object, rotation);
    QuatUtils.mul(rotation, transform, rotation);
    Quat2Utils.getPosition(transform, position);
    ObjectUtils.convertPositionObjectToWorld(object, position, position);
    Quat2Utils.setPositionRotationQuat(outTransform, position, rotation);
    return outTransform;
  }
  return convertTransformObjectToWorldQuat2;
}();
function convertTransformWorldToObject(object, transform, outTransform) {
  return ObjectUtils.convertTransformWorldToObjectMatrix(object, transform, outTransform);
}
var convertTransformWorldToObjectMatrix = function() {
  const convertTransform = Mat4Utils.create();
  const position = Vec3Utils.create();
  const scale4 = Vec3Utils.create();
  const inverseScale = Vec3Utils.create();
  const one = Vec3Utils.create(1);
  function convertTransformWorldToObjectMatrix2(object, transform, outTransform = Mat4Utils.clone(transform)) {
    ObjectUtils.getTransformWorldMatrix(object, convertTransform);
    if (ObjectUtils.hasUniformScaleWorld(object)) {
      Mat4Utils.invert(convertTransform, convertTransform);
      Mat4Utils.mul(convertTransform, transform, outTransform);
    } else {
      Vec3Utils.set(position, transform[12], transform[13], transform[14]);
      ObjectUtils.convertPositionWorldToObject(object, position, position);
      Mat4Utils.getScale(convertTransform, scale4);
      Vec3Utils.div(one, scale4, inverseScale);
      Mat4Utils.scale(convertTransform, inverseScale, convertTransform);
      Mat4Utils.invert(convertTransform, convertTransform);
      Mat4Utils.mul(convertTransform, transform, outTransform);
      Mat4Utils.scale(outTransform, inverseScale, outTransform);
      outTransform[12] = position[0];
      outTransform[13] = position[1];
      outTransform[14] = position[2];
      outTransform[15] = 1;
    }
    return outTransform;
  }
  return convertTransformWorldToObjectMatrix2;
}();
var convertTransformWorldToObjectQuat = function() {
  const position = Vec3Utils.create();
  const rotation = QuatUtils.create();
  function convertTransformWorldToObjectQuat2(object, transform, outTransform = Quat2Utils.clone(transform)) {
    ObjectUtils.getRotationWorldQuat(object, rotation);
    QuatUtils.conjugate(rotation, rotation);
    QuatUtils.mul(rotation, transform, rotation);
    Quat2Utils.getPosition(transform, position);
    ObjectUtils.convertPositionWorldToObject(object, position, position);
    Quat2Utils.setPositionRotationQuat(outTransform, position, rotation);
    return outTransform;
  }
  return convertTransformWorldToObjectQuat2;
}();
function convertTransformLocalToWorld(object, transform, outTransform) {
  return ObjectUtils.convertTransformLocalToWorldMatrix(object, transform, outTransform);
}
function convertTransformLocalToWorldMatrix(object, transform, outTransform = Mat4Utils.clone(transform)) {
  if (ObjectUtils.getParent(object) != null) {
    ObjectUtils.convertTransformObjectToWorldMatrix(ObjectUtils.getParent(object), transform, outTransform);
  } else {
    Mat4Utils.copy(transform, outTransform);
  }
  return outTransform;
}
function convertTransformLocalToWorldQuat(object, transform, outTransform = Quat2Utils.clone(transform)) {
  if (ObjectUtils.getParent(object) != null) {
    ObjectUtils.convertTransformObjectToWorldQuat(ObjectUtils.getParent(object), transform, outTransform);
  } else {
    Quat2Utils.copy(transform, outTransform);
  }
  return outTransform;
}
function convertTransformWorldToLocal(object, transform, outTransform) {
  return ObjectUtils.convertTransformWorldToLocalMatrix(object, transform, outTransform);
}
function convertTransformWorldToLocalMatrix(object, transform, outTransform = Mat4Utils.clone(transform)) {
  if (ObjectUtils.getParent(object) != null) {
    ObjectUtils.convertTransformWorldToObjectMatrix(ObjectUtils.getParent(object), transform, outTransform);
  } else {
    Mat4Utils.copy(transform, outTransform);
  }
  return outTransform;
}
function convertTransformWorldToLocalQuat(object, transform, outTransform = Quat2Utils.clone(transform)) {
  if (ObjectUtils.getParent(object) != null) {
    ObjectUtils.convertTransformWorldToObjectQuat(ObjectUtils.getParent(object), transform, outTransform);
  } else {
    Quat2Utils.copy(transform, outTransform);
  }
  return outTransform;
}
function convertTransformObjectToLocal(object, transform, outTransform) {
  return ObjectUtils.convertTransformObjectToLocalMatrix(object, transform, outTransform);
}
function convertTransformObjectToLocalMatrix(object, transform, outTransform) {
  outTransform = ObjectUtils.convertTransformObjectToWorldMatrix(object, transform, outTransform);
  ObjectUtils.convertTransformWorldToLocalMatrix(object, outTransform, outTransform);
  return outTransform;
}
function convertTransformObjectToLocalQuat(object, transform, outTransform) {
  outTransform = ObjectUtils.convertTransformObjectToWorldQuat(object, transform, outTransform);
  ObjectUtils.convertTransformWorldToLocalQuat(object, outTransform, outTransform);
  return outTransform;
}
function convertTransformLocalToObject(object, transform, outTransform) {
  return ObjectUtils.convertTransformLocalToObjectMatrix(object, transform, outTransform);
}
function convertTransformLocalToObjectMatrix(object, transform, outTransform) {
  outTransform = ObjectUtils.convertTransformLocalToWorldMatrix(object, transform, outTransform);
  ObjectUtils.convertTransformWorldToObjectMatrix(object, outTransform, outTransform);
  return outTransform;
}
function convertTransformLocalToObjectQuat(object, transform, outTransform) {
  outTransform = ObjectUtils.convertTransformLocalToWorldQuat(object, transform, outTransform);
  ObjectUtils.convertTransformWorldToObjectQuat(object, outTransform, outTransform);
  return outTransform;
}
var setParent = function() {
  const position = Vec3Utils.create();
  const rotation = QuatUtils.create();
  const scale4 = Vec3Utils.create();
  return function setParent2(object, newParent, keepTransformWorld = true) {
    if (!keepTransformWorld) {
      object.parent = newParent;
    } else {
      ObjectUtils.getPositionWorld(object, position);
      ObjectUtils.getRotationWorldQuat(object, rotation);
      ObjectUtils.getScaleWorld(object, scale4);
      object.parent = newParent;
      ObjectUtils.setScaleWorld(object, scale4);
      ObjectUtils.setRotationWorldQuat(object, rotation);
      ObjectUtils.setPositionWorld(object, position);
    }
    return object;
  };
}();
function getParent(object) {
  return object.parent;
}
function addComponent(object, classOrType, paramsOrActive, active) {
  let params = void 0;
  if (typeof paramsOrActive == "boolean") {
    params = {};
    params["active"] = paramsOrActive;
  } else {
    if (paramsOrActive != null) {
      params = paramsOrActive;
    }
    if (active != null) {
      if (params == null) {
        params = {};
      }
      params["active"] = active;
    }
  }
  return object.addComponent(classOrType, params);
}
function getComponent(object, classOrType, index = 0) {
  return ObjectUtils.getComponentHierarchy(object, classOrType, index);
}
function getComponentSelf(object, classOrType, index = 0) {
  return object.getComponent(classOrType, index);
}
function getComponentHierarchy(object, classOrType, index = 0) {
  return ObjectUtils.getComponentHierarchyBreadth(object, classOrType, index);
}
function getComponentHierarchyBreadth(object, classOrType, index = 0) {
  const objects = ObjectUtils.getHierarchyBreadth(object);
  return ObjectUtils.getComponentObjects(objects, classOrType, index);
}
function getComponentHierarchyDepth(object, classOrType, index = 0) {
  const objects = ObjectUtils.getHierarchyDepth(object);
  return ObjectUtils.getComponentObjects(objects, classOrType, index);
}
function getComponentDescendants(object, classOrType, index = 0) {
  return ObjectUtils.getComponentDescendantsBreadth(object, classOrType, index);
}
function getComponentDescendantsBreadth(object, classOrType, index = 0) {
  const objects = ObjectUtils.getDescendantsBreadth(object);
  return ObjectUtils.getComponentObjects(objects, classOrType, index);
}
function getComponentDescendantsDepth(object, classOrType, index = 0) {
  const objects = ObjectUtils.getDescendantsDepth(object);
  return ObjectUtils.getComponentObjects(objects, classOrType, index);
}
function getComponentChildren(object, classOrType, index = 0) {
  const objects = ObjectUtils.getChildren(object);
  return ObjectUtils.getComponentObjects(objects, classOrType, index);
}
function getComponents(object, classOrType) {
  return ObjectUtils.getComponentsHierarchy(object, classOrType);
}
function getComponentsSelf(object, classOrType) {
  return object.getComponents(classOrType);
}
function getComponentsHierarchy(object, classOrType) {
  return ObjectUtils.getComponentsHierarchyBreadth(object, classOrType);
}
function getComponentsHierarchyBreadth(object, classOrType) {
  const objects = ObjectUtils.getHierarchyBreadth(object);
  return ObjectUtils.getComponentsObjects(objects, classOrType);
}
function getComponentsHierarchyDepth(object, classOrType) {
  const objects = ObjectUtils.getHierarchyDepth(object);
  return ObjectUtils.getComponentsObjects(objects, classOrType);
}
function getComponentsDescendants(object, classOrType) {
  return ObjectUtils.getComponentsDescendantsBreadth(object, classOrType);
}
function getComponentsDescendantsBreadth(object, classOrType) {
  const objects = ObjectUtils.getDescendantsBreadth(object);
  return ObjectUtils.getComponentsObjects(objects, classOrType);
}
function getComponentsDescendantsDepth(object, classOrType) {
  const objects = ObjectUtils.getDescendantsDepth(object);
  return ObjectUtils.getComponentsObjects(objects, classOrType);
}
function getComponentsChildren(object, classOrType) {
  const objects = ObjectUtils.getChildren(object);
  return ObjectUtils.getComponentsObjects(objects, classOrType);
}
function setActive(object, active) {
  return ObjectUtils.setActiveHierarchy(object, active);
}
function setActiveSelf(object, active) {
  object.active = active;
  return object;
}
function setActiveHierarchy(object, active) {
  return ObjectUtils.setActiveHierarchyBreadth(object, active);
}
function setActiveHierarchyBreadth(object, active) {
  const objects = ObjectUtils.getHierarchyBreadth(object);
  ObjectUtils.setActiveObjects(objects, active);
  return object;
}
function setActiveHierarchyDepth(object, active) {
  const objects = ObjectUtils.getHierarchyDepth(object);
  ObjectUtils.setActiveObjects(objects, active);
  return object;
}
function setActiveDescendants(object, active) {
  return ObjectUtils.setActiveDescendantsBreadth(object, active);
}
function setActiveDescendantsBreadth(object, active) {
  const objects = ObjectUtils.getDescendantsBreadth(object);
  ObjectUtils.setActiveObjects(objects, active);
  return object;
}
function setActiveDescendantsDepth(object, active) {
  const objects = ObjectUtils.getDescendantsDepth(object);
  ObjectUtils.setActiveObjects(objects, active);
  return object;
}
function setActiveChildren(object, active) {
  const objects = ObjectUtils.getChildren(object);
  ObjectUtils.setActiveObjects(objects, active);
  return object;
}
function hasUniformScale2(object) {
  return ObjectUtils.hasUniformScaleWorld(object);
}
var hasUniformScaleWorld = function() {
  const scale4 = Vec3Utils.create();
  return function hasUniformScaleWorld2(object) {
    ObjectUtils.getScaleWorld(object, scale4);
    return Math.abs(scale4[0] - scale4[1]) < MathUtils.EPSILON && Math.abs(scale4[1] - scale4[2]) < MathUtils.EPSILON && Math.abs(scale4[0] - scale4[2]) < MathUtils.EPSILON;
  };
}();
var hasUniformScaleLocal = function() {
  const scale4 = Vec3Utils.create();
  return function hasUniformScaleLocal2(object) {
    ObjectUtils.getScaleLocal(object, scale4);
    return Math.abs(scale4[0] - scale4[1]) < MathUtils.EPSILON && Math.abs(scale4[1] - scale4[2]) < MathUtils.EPSILON && Math.abs(scale4[0] - scale4[2]) < MathUtils.EPSILON;
  };
}();
var clone7 = function() {
  const scale4 = Vec3Utils.create();
  const transformQuat2 = Quat2Utils.create();
  return function clone13(object, cloneParams = new ObjectCloneParams()) {
    let clonedObject = null;
    const cloneParent = cloneParams.myCloneParent === void 0 ? ObjectUtils.getParent(object) : cloneParams.myCloneParent;
    if (cloneParams.myUseDefaultObjectClone) {
      clonedObject = object.clone(cloneParent);
      if (cloneParams.myDefaultComponentCloneAutoStartIfNotActive) {
        const clonedComponents = ObjectUtils.getComponents(clonedObject);
        for (const clonedComponent of clonedComponents) {
          if (cloneParams.myDefaultComponentCloneAutoStartIfNotActive && !clonedComponent.active) {
            clonedComponent.active = true;
            clonedComponent.active = false;
          }
        }
      }
    } else if (ObjectUtils.isCloneable(object, cloneParams)) {
      const objectsToCloneData = [];
      objectsToCloneData.push([cloneParent, object]);
      const objectsToCloneComponentsData = [];
      while (objectsToCloneData.length > 0) {
        const cloneData = objectsToCloneData.shift();
        const parent = cloneData[0];
        const objectToClone = cloneData[1];
        const currentClonedObject = parent != null ? ObjectUtils.addChild(parent) : ObjectUtils.addChild(Globals.getRootObject(ObjectUtils.getEngine(object)));
        ObjectUtils.setName(currentClonedObject, ObjectUtils.getName(objectToClone));
        ObjectUtils.setScaleLocal(currentClonedObject, ObjectUtils.getScaleLocal(objectToClone, scale4));
        ObjectUtils.setTransformLocalQuat(currentClonedObject, ObjectUtils.getTransformLocalQuat(objectToClone, transformQuat2));
        if (!cloneParams.myIgnoreComponents) {
          objectsToCloneComponentsData.push([objectToClone, currentClonedObject]);
        }
        if (!cloneParams.myIgnoreDescendants) {
          for (const child of ObjectUtils.getChildren(objectToClone)) {
            let cloneDescendant = false;
            if (cloneParams.myDescendantsToInclude.length > 0) {
              cloneDescendant = cloneParams.myDescendantsToInclude.find((descendantToInclude) => descendantToInclude == child) != null;
            } else {
              cloneDescendant = cloneParams.myDescendantsToIgnore.find((descendantToIgnore) => descendantToIgnore == child) == null;
            }
            if (cloneDescendant && cloneParams.myIgnoreDescendantCallback != null) {
              cloneDescendant = !cloneParams.myIgnoreDescendantCallback(child);
            }
            if (cloneDescendant) {
              objectsToCloneData.push([currentClonedObject, child]);
            }
          }
        }
        if (clonedObject == null) {
          clonedObject = currentClonedObject;
        }
      }
      const componentsToCloneData = [];
      while (objectsToCloneComponentsData.length > 0) {
        const cloneData = objectsToCloneComponentsData.shift();
        const objectToClone = cloneData[0];
        const currentClonedObject = cloneData[1];
        const components = ObjectUtils.getComponentsSelf(objectToClone);
        for (const component of components) {
          if (ComponentUtils.isCloneable(component.type, cloneParams.myUseDefaultComponentClone || cloneParams.myUseDefaultComponentCloneAsFallback, ObjectUtils.getEngine(object))) {
            let cloneComponent = false;
            if (cloneParams.myComponentsToInclude.length > 0) {
              cloneComponent = cloneParams.myComponentsToInclude.indexOf(component.type) != -1;
            } else {
              cloneComponent = cloneParams.myComponentsToIgnore.indexOf(component.type) == -1;
            }
            if (cloneComponent && cloneParams.myIgnoreComponentCallback != null) {
              cloneComponent = !cloneParams.myIgnoreComponentCallback(component);
            }
            if (cloneComponent) {
              componentsToCloneData.push([component, currentClonedObject]);
            }
          }
        }
      }
      const componentsToPostProcessData = [];
      while (componentsToCloneData.length > 0) {
        const cloneData = componentsToCloneData.shift();
        const componentToClone = cloneData[0];
        const currentClonedObject = cloneData[1];
        let clonedComponent = null;
        if (!cloneParams.myUseDefaultComponentClone) {
          clonedComponent = ComponentUtils.clone(componentToClone, currentClonedObject, cloneParams.myComponentDeepCloneParams, cloneParams.myComponentCustomCloneParams, cloneParams.myUseDefaultComponentCloneAsFallback, cloneParams.myDefaultComponentCloneAutoStartIfNotActive);
        } else {
          clonedComponent = ComponentUtils.cloneDefault(componentToClone, currentClonedObject, cloneParams.myDefaultComponentCloneAutoStartIfNotActive);
        }
        if (clonedComponent != null) {
          if (ComponentUtils.hasClonePostProcess(componentToClone.type, ObjectUtils.getEngine(object))) {
            componentsToPostProcessData.push([componentToClone, clonedComponent]);
          }
        }
      }
      while (componentsToPostProcessData.length > 0) {
        const cloneData = componentsToPostProcessData.shift();
        const componentToClone = cloneData[0];
        const currentClonedComponent = cloneData[1];
        ComponentUtils.clonePostProcess(componentToClone, currentClonedComponent, cloneParams.myComponentDeepCloneParams, cloneParams.myComponentCustomCloneParams);
      }
    } else if (cloneParams.myUseDefaultObjectCloneAsFallback) {
      clonedObject = object.clone(cloneParent);
      if (cloneParams.myDefaultComponentCloneAutoStartIfNotActive) {
        const clonedComponents = ObjectUtils.getComponents(clonedObject);
        for (const clonedComponent of clonedComponents) {
          if (cloneParams.myDefaultComponentCloneAutoStartIfNotActive && !clonedComponent.active) {
            clonedComponent.active = true;
            clonedComponent.active = false;
          }
        }
      }
    }
    return clonedObject;
  };
}();
function isCloneable(object, cloneParams = new ObjectCloneParams()) {
  if (cloneParams.myIgnoreNonCloneable || cloneParams.myIgnoreComponents || cloneParams.myUseDefaultComponentClone || cloneParams.myUseDefaultComponentCloneAsFallback) {
    return true;
  }
  let cloneable = true;
  const objectsToClone = [];
  objectsToClone.push(object);
  while (cloneable && objectsToClone.length > 0) {
    const objectToClone = objectsToClone.shift();
    const components = ObjectUtils.getComponentsSelf(objectToClone);
    for (const component of components) {
      let cloneComponent = false;
      if (cloneParams.myComponentsToInclude.length > 0) {
        cloneComponent = cloneParams.myComponentsToInclude.indexOf(component.type) != -1;
      } else {
        cloneComponent = cloneParams.myComponentsToIgnore.indexOf(component.type) == -1;
      }
      if (cloneComponent && cloneParams.myIgnoreComponentCallback != null) {
        cloneComponent = !cloneParams.myIgnoreComponentCallback(component);
      }
      if (cloneComponent && !ComponentUtils.isCloneable(component.type, false, ObjectUtils.getEngine(object))) {
        cloneable = false;
        break;
      }
    }
    if (cloneable && !cloneParams.myIgnoreDescendants) {
      for (const child of ObjectUtils.getChildren(objectToClone)) {
        let cloneDescendant = false;
        if (cloneParams.myDescendantsToInclude.length > 0) {
          cloneDescendant = cloneParams.myDescendantsToInclude.find((descendantToInclude) => descendantToInclude == child) != null;
        } else {
          cloneDescendant = cloneParams.myDescendantsToIgnore.find((descendantToIgnore) => descendantToIgnore == child) == null;
        }
        if (cloneDescendant && cloneParams.myIgnoreDescendantCallback != null) {
          cloneDescendant = !cloneParams.myIgnoreDescendantCallback(child);
        }
        if (cloneDescendant) {
          objectsToClone.push(child);
        }
      }
    }
  }
  return cloneable;
}
function toString(object) {
  return ObjectUtils.toStringCompact(object);
}
var toStringExtended = function() {
  const tab = "    ";
  const newLine = "\n";
  const startObject = "{";
  const endObject = "}";
  const nameLabel = "name: ";
  const idLabel = "id: ";
  const componentsLabel = "components: ";
  const typeLabel = "type: ";
  const childrenLabel = "children: ";
  const startComponents = "[";
  const endComponents = "]";
  const startChildren = startComponents;
  const endChildren = endComponents;
  const separator = ",";
  const newLineTab = newLine.concat(tab, tab);
  return function toStringExtended2(object) {
    let objectString = "";
    objectString = objectString.concat(startObject, newLine);
    const components = ObjectUtils.getComponentsSelf(object);
    const children = ObjectUtils.getChildren(object);
    const name = ObjectUtils.getName(object);
    if (components.length > 0 || children.length > 0 || name.length > 0) {
      objectString = objectString.concat(tab, idLabel, ObjectUtils.getID(object).toString(), separator, newLine);
    } else {
      objectString = objectString.concat(tab, idLabel, ObjectUtils.getID(object).toString(), newLine);
    }
    if (name.length > 0) {
      if (components.length > 0 || children.length > 0) {
        objectString = objectString.concat(tab, nameLabel, ObjectUtils.getName(object), separator, newLine);
      } else {
        objectString = objectString.concat(tab, nameLabel, ObjectUtils.getName(object), newLine);
      }
    }
    if (components.length > 0) {
      objectString = objectString.concat(tab, componentsLabel, newLine, tab, startComponents, newLine);
      for (let i = 0; i < components.length; i++) {
        const component = components[i];
        objectString = objectString.concat(tab, tab, startObject, newLine);
        objectString = objectString.concat(tab, tab, tab, typeLabel, component.type, separator, newLine);
        objectString = objectString.concat(tab, tab, tab, idLabel, component._id.toString(), separator, newLine);
        objectString = objectString.concat(tab, tab, endObject);
        if (i != components.length - 1) {
          objectString = objectString.concat(separator, newLine);
        } else {
          objectString = objectString.concat(newLine);
        }
      }
      if (children.length > 0) {
        objectString = objectString.concat(tab, endComponents, separator, newLine);
      } else {
        objectString = objectString.concat(tab, endComponents, newLine);
      }
    }
    if (children.length > 0) {
      objectString = objectString.concat(tab, childrenLabel, newLine, tab, startChildren, newLine);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        let childString = ObjectUtils.toStringExtended(child);
        childString = childString.replaceAll(newLine, newLineTab);
        childString = tab.concat(tab, childString);
        objectString = objectString.concat(childString);
        if (i != children.length - 1) {
          objectString = objectString.concat(separator, newLine);
        } else {
          objectString = objectString.concat(newLine);
        }
      }
      objectString = objectString.concat(tab, endChildren, newLine);
    }
    objectString = objectString.concat(endObject);
    return objectString;
  };
}();
var toStringCompact = function() {
  const tab = "    ";
  const newLine = "\n";
  const emptyName = "<none>";
  const nameLabel = "name: ";
  const componentsLabel = "components: ";
  const separator = ", ";
  const newLineTab = newLine.concat(tab);
  return function toStringCompact2(object) {
    let objectString = "";
    const name = ObjectUtils.getName(object);
    if (name.length > 0) {
      objectString = objectString.concat(nameLabel, name);
    } else {
      objectString = objectString.concat(nameLabel, emptyName);
    }
    const components = ObjectUtils.getComponentsSelf(object);
    if (components.length > 0) {
      objectString = objectString.concat(separator, componentsLabel);
      for (let i = 0; i < components.length; i++) {
        const component = components[i];
        objectString = objectString.concat(component.type);
        if (i != components.length - 1) {
          objectString = objectString.concat(separator);
        }
      }
    }
    const children = ObjectUtils.getChildren(object);
    if (children.length > 0) {
      objectString = objectString.concat(newLine);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        let childString = ObjectUtils.toStringCompact(child);
        childString = childString.replaceAll(newLine, newLineTab);
        childString = tab.concat(childString);
        objectString = objectString.concat(childString);
        if (i != children.length - 1) {
          objectString = objectString.concat(newLine);
        }
      }
    }
    return objectString;
  };
}();
function log(object) {
  return ObjectUtils.logCompact(object);
}
function logExtended(object) {
  console.log(ObjectUtils.toStringExtended(object));
  return object;
}
function logCompact(object) {
  console.log(ObjectUtils.toStringCompact(object));
  return object;
}
function warn(object) {
  return ObjectUtils.warnCompact(object);
}
function warnExtended(object) {
  console.warn(ObjectUtils.toStringExtended(object));
  return object;
}
function warnCompact(object) {
  console.warn(ObjectUtils.toStringCompact(object));
  return object;
}
function error(object) {
  return ObjectUtils.errorCompact(object);
}
function errorExtended(object) {
  console.error(ObjectUtils.toStringExtended(object));
  return object;
}
function errorCompact(object) {
  console.error(ObjectUtils.toStringCompact(object));
  return object;
}
function getObjectByName(object, name, isRegex = false, index = 0) {
  return ObjectUtils.getObjectByNameHierarchy(object, name, isRegex, index);
}
function getObjectByNameHierarchy(object, name, isRegex = false, index = 0) {
  return ObjectUtils.getObjectByNameHierarchyBreadth(object, name, isRegex, index);
}
function getObjectByNameHierarchyBreadth(object, name, isRegex = false, index = 0) {
  const objects = ObjectUtils.getHierarchyBreadth(object);
  return ObjectUtils.getObjectByNameObjects(objects, name, isRegex, index);
}
function getObjectByNameHierarchyDepth(object, name, isRegex = false, index = 0) {
  const objects = ObjectUtils.getHierarchyDepth(object);
  return ObjectUtils.getObjectByNameObjects(objects, name, isRegex, index);
}
function getObjectByNameDescendants(object, name, isRegex = false, index = 0) {
  return ObjectUtils.getObjectByNameDescendantsBreadth(object, name, isRegex, index);
}
function getObjectByNameDescendantsBreadth(object, name, isRegex = false, index = 0) {
  const objects = ObjectUtils.getDescendantsBreadth(object);
  return ObjectUtils.getObjectByNameObjects(objects, name, isRegex, index);
}
function getObjectByNameDescendantsDepth(object, name, isRegex = false, index = 0) {
  const objects = ObjectUtils.getDescendantsDepth(object);
  return ObjectUtils.getObjectByNameObjects(objects, name, isRegex, index);
}
function getObjectByNameChildren(object, name, isRegex = false, index = 0) {
  const objects = ObjectUtils.getChildren(object);
  return ObjectUtils.getObjectByNameObjects(objects, name, isRegex, index);
}
function getObjectsByName(object, name, isRegex = false) {
  return ObjectUtils.getObjectsByNameHierarchy(object, name, isRegex);
}
function getObjectsByNameHierarchy(object, name, isRegex = false) {
  return ObjectUtils.getObjectsByNameHierarchyBreadth(object, name, isRegex);
}
function getObjectsByNameHierarchyBreadth(object, name, isRegex = false) {
  const objects = ObjectUtils.getHierarchyBreadth(object);
  return ObjectUtils.getObjectsByNameObjects(objects, name, isRegex);
}
function getObjectsByNameHierarchyDepth(object, name, isRegex = false) {
  const objects = ObjectUtils.getHierarchyDepth(object);
  return ObjectUtils.getObjectsByNameObjects(objects, name, isRegex);
}
function getObjectsByNameDescendants(object, name, isRegex = false) {
  return ObjectUtils.getObjectsByNameDescendantsBreadth(object, name, isRegex);
}
function getObjectsByNameDescendantsBreadth(object, name, isRegex = false) {
  const objects = ObjectUtils.getDescendantsBreadth(object);
  return ObjectUtils.getObjectsByNameObjects(objects, name, isRegex);
}
function getObjectsByNameDescendantsDepth(object, name, isRegex = false) {
  const objects = ObjectUtils.getDescendantsDepth(object);
  return ObjectUtils.getObjectsByNameObjects(objects, name, isRegex);
}
function getObjectsByNameChildren(object, name, isRegex = false) {
  const objects = ObjectUtils.getChildren(object);
  return ObjectUtils.getObjectsByNameObjects(objects, name, isRegex);
}
function getObjectByID(object, id) {
  return ObjectUtils.getObjectByIDHierarchy(object, id);
}
function getObjectByIDHierarchy(object, id) {
  return ObjectUtils.getObjectByIDHierarchyBreadth(object, id);
}
function getObjectByIDHierarchyBreadth(object, id) {
  const objects = ObjectUtils.getHierarchyBreadth(object);
  return ObjectUtils.getObjectByIDObjects(objects, id);
}
function getObjectByIDHierarchyDepth(object, id) {
  const objects = ObjectUtils.getHierarchyDepth(object);
  return ObjectUtils.getObjectByIDObjects(objects, id);
}
function getObjectByIDDescendants(object, id) {
  return ObjectUtils.getObjectByIDDescendantsBreadth(object, id);
}
function getObjectByIDDescendantsBreadth(object, id) {
  const objects = ObjectUtils.getDescendantsBreadth(object);
  return ObjectUtils.getObjectByIDObjects(objects, id);
}
function getObjectByIDDescendantsDepth(object, id) {
  const objects = ObjectUtils.getDescendantsDepth(object);
  return ObjectUtils.getObjectByIDObjects(objects, id);
}
function getObjectByIDChildren(object, id) {
  const objects = ObjectUtils.getChildren(object);
  return ObjectUtils.getObjectByIDObjects(objects, id);
}
function getHierarchy(object) {
  return ObjectUtils.getHierarchyBreadth(object);
}
function getHierarchyBreadth(object) {
  const hierarchy = ObjectUtils.getDescendantsBreadth(object);
  hierarchy.unshift(object);
  return hierarchy;
}
function getHierarchyDepth(object) {
  const hierarchy = ObjectUtils.getDescendantsDepth(object);
  hierarchy.unshift(object);
  return hierarchy;
}
function getDescendants(object) {
  return ObjectUtils.getDescendantsBreadth(object);
}
function getDescendantsBreadth(object) {
  const descendants = [];
  const descendantsQueue = ObjectUtils.getChildren(object);
  while (descendantsQueue.length > 0) {
    const descendant = descendantsQueue.shift();
    descendants.push(descendant);
    for (const child of ObjectUtils.getChildren(descendant)) {
      descendantsQueue.push(child);
    }
  }
  return descendants;
}
function getDescendantsDepth(object) {
  const descendants = [];
  const children = ObjectUtils.getChildren(object);
  for (const child of children) {
    descendants.push(child);
    const childDescendants = ObjectUtils.getDescendantsDepth(child);
    for (let i = 0; i < childDescendants.length; i++) {
      descendants.push(childDescendants[i]);
    }
  }
  return descendants;
}
function getChildren(object) {
  return object.children;
}
function getSelf(object) {
  return object;
}
function addChild(object) {
  return object.addChild();
}
function getName(object) {
  return object.name;
}
function setName(object, name) {
  object.name = name;
  return object;
}
function getEngine(object) {
  return object.engine;
}
function getID(object) {
  return object.objectId;
}
function markDirty(object) {
  object.setDirty();
  return object;
}
function isTransformChanged(object) {
  return object.changed;
}
function destroy(object) {
  object.destroy();
}
function reserveObjects(object, count) {
  return ObjectUtils.reserveObjectsHierarchy(object, count);
}
function reserveObjectsSelf(object, count) {
  const componentsAmountMap = ObjectUtils.getComponentsAmountMapSelf(object);
  _reserveObjects(count, componentsAmountMap, Globals.getScene(ObjectUtils.getEngine(object)));
  return object;
}
function reserveObjectsHierarchy(object, count) {
  const componentsAmountMap = ObjectUtils.getComponentsAmountMapHierarchy(object);
  _reserveObjects(count, componentsAmountMap, Globals.getScene(ObjectUtils.getEngine(object)));
  return object;
}
function reserveObjectsDescendants(object, count) {
  const componentsAmountMap = ObjectUtils.getComponentsAmountMapDescendants(object);
  _reserveObjects(count, componentsAmountMap, Globals.getScene(ObjectUtils.getEngine(object)));
  return object;
}
function reserveObjectsChildren(object, count) {
  const componentsAmountMap = ObjectUtils.getComponentsAmountMapChildren(object);
  _reserveObjects(count, componentsAmountMap, Globals.getScene(ObjectUtils.getEngine(object)));
  return object;
}
function getComponentsAmountMap(object, outComponentsAmountMap = /* @__PURE__ */ new Map()) {
  return ObjectUtils.getComponentsAmountMapHierarchy(object, outComponentsAmountMap);
}
function getComponentsAmountMapSelf(object, outComponentsAmountMap = /* @__PURE__ */ new Map()) {
  let objectsAmount = outComponentsAmountMap.get("object");
  if (objectsAmount == null) {
    objectsAmount = 0;
  }
  objectsAmount += 1;
  outComponentsAmountMap.set("object", objectsAmount);
  const components = ObjectUtils.getComponentsSelf(object);
  for (const component of components) {
    const type = component.type;
    let typeAmount = outComponentsAmountMap.get(type);
    if (typeAmount == null) {
      typeAmount = 0;
    }
    typeAmount += 1;
    outComponentsAmountMap.set(type, typeAmount);
  }
  return outComponentsAmountMap;
}
function getComponentsAmountMapHierarchy(object, outComponentsAmountMap = /* @__PURE__ */ new Map()) {
  const hierarchy = ObjectUtils.getHierarchy(object);
  for (const hierarchyObject of hierarchy) {
    ObjectUtils.getComponentsAmountMapSelf(hierarchyObject, outComponentsAmountMap);
  }
  return outComponentsAmountMap;
}
function getComponentsAmountMapDescendants(object, outComponentsAmountMap = /* @__PURE__ */ new Map()) {
  const descendants = ObjectUtils.getDescendants(object);
  for (const descendant of descendants) {
    ObjectUtils.getComponentsAmountMapSelf(descendant, outComponentsAmountMap);
  }
  return outComponentsAmountMap;
}
function getComponentsAmountMapChildren(object, outComponentsAmountMap = /* @__PURE__ */ new Map()) {
  const children = ObjectUtils.getChildren(object);
  for (const child of children) {
    ObjectUtils.getComponentsAmountMapSelf(child, outComponentsAmountMap);
  }
  return outComponentsAmountMap;
}
function getComponentObjects(objects, classOrType, index = 0) {
  let component = null;
  for (const object of objects) {
    component = object.getComponent(classOrType, index);
    if (component != null) {
      break;
    }
  }
  return component;
}
function getComponentsObjects(objects, classOrType) {
  const components = [];
  for (const currentObject of objects) {
    const currentObjectComponents = currentObject.getComponents(classOrType);
    for (let i = 0; i < currentObjectComponents.length; i++) {
      components.push(currentObjectComponents[i]);
    }
  }
  return components;
}
function setActiveObjects(objects, active) {
  for (const currentObject of objects) {
    currentObject.active = active;
  }
}
function getObjectByNameObjects(objects, name, isRegex = false, index = 0) {
  let objectFound = null;
  let currentIndex = index;
  for (const currentObject of objects) {
    const objectName = ObjectUtils.getName(currentObject);
    if (!isRegex && objectName == name || isRegex && objectName.match(name) != null) {
      if (currentIndex == 0) {
        objectFound = currentObject;
        break;
      }
      currentIndex--;
    }
  }
  return objectFound;
}
function getObjectsByNameObjects(objects, name, isRegex = false) {
  const objectsFound = [];
  for (const currentObject of objects) {
    const objectName = ObjectUtils.getName(currentObject);
    if (!isRegex && objectName == name || isRegex && objectName.match(name) != null) {
      objectsFound.push(currentObject);
    }
  }
  return objectsFound;
}
function getObjectByIDObjects(objects, id, index = 0) {
  let objectFound = null;
  let currentIndex = index;
  for (const currentObject of objects) {
    if (ObjectUtils.getID(currentObject) == id) {
      if (currentIndex == 0) {
        objectFound = currentObject;
        break;
      }
      currentIndex--;
    }
  }
  return objectFound;
}
function getObjectsByIDObjects(objects, id) {
  const objectsFound = [];
  for (const currentObject of objects) {
    if (ObjectUtils.getID(currentObject) == id) {
      objectsFound.push(currentObject);
    }
  }
  return objectsFound;
}
function wrapObject(id, engine = Globals.getMainEngine()) {
  return engine != null ? Globals.getScene(engine).wrap(id) : null;
}
var ObjectUtils = {
  getPosition: getPosition3,
  getPositionWorld,
  getPositionLocal,
  getRotation: getRotation3,
  getRotationDegrees: getRotationDegrees3,
  getRotationRadians: getRotationRadians3,
  getRotationMatrix,
  getRotationQuat: getRotationQuat3,
  getRotationWorld,
  getRotationWorldDegrees,
  getRotationWorldRadians,
  getRotationWorldMatrix,
  getRotationWorldQuat,
  getRotationLocal,
  getRotationLocalDegrees,
  getRotationLocalRadians,
  getRotationLocalMatrix,
  getRotationLocalQuat,
  getScale: getScale2,
  getScaleWorld,
  getScaleLocal,
  getTransform,
  getTransformMatrix,
  getTransformQuat,
  getTransformWorld,
  getTransformWorldMatrix,
  getTransformWorldQuat,
  getTransformLocal,
  getTransformLocalMatrix,
  getTransformLocalQuat,
  getAxes: getAxes4,
  getAxesWorld,
  getAxesLocal,
  getForward: getForward4,
  getForwardWorld,
  getForwardLocal,
  getBackward: getBackward4,
  getBackwardWorld,
  getBackwardLocal,
  getUp: getUp4,
  getUpWorld,
  getUpLocal,
  getDown: getDown4,
  getDownWorld,
  getDownLocal,
  getLeft: getLeft4,
  getLeftWorld,
  getLeftLocal,
  getRight: getRight4,
  getRightWorld,
  getRightLocal,
  setPosition: setPosition3,
  setPositionWorld,
  setPositionLocal,
  setRotation: setRotation3,
  setRotationDegrees: setRotationDegrees3,
  setRotationRadians: setRotationRadians3,
  setRotationMatrix,
  setRotationQuat: setRotationQuat3,
  setRotationWorld,
  setRotationWorldDegrees,
  setRotationWorldRadians,
  setRotationWorldMatrix,
  setRotationWorldQuat,
  setRotationLocal,
  setRotationLocalDegrees,
  setRotationLocalRadians,
  setRotationLocalMatrix,
  setRotationLocalQuat,
  setScale: setScale2,
  setScaleWorld,
  setScaleLocal,
  setAxes: setAxes2,
  setAxesWorld,
  setAxesLocal,
  setForward: setForward2,
  setForwardWorld,
  setForwardLocal,
  setBackward: setBackward2,
  setBackwardWorld,
  setBackwardLocal,
  setUp: setUp2,
  setUpWorld,
  setUpLocal,
  setDown: setDown2,
  setDownWorld,
  setDownLocal,
  setLeft: setLeft2,
  setLeftWorld,
  setLeftLocal,
  setRight: setRight2,
  setRightWorld,
  setRightLocal,
  setTransform,
  setTransformMatrix,
  setTransformQuat,
  setTransformWorld,
  setTransformWorldMatrix,
  setTransformWorldQuat,
  setTransformLocal,
  setTransformLocalMatrix,
  setTransformLocalQuat,
  resetPosition,
  resetPositionWorld,
  resetPositionLocal,
  resetRotation,
  resetRotationWorld,
  resetRotationLocal,
  resetScale,
  resetScaleWorld,
  resetScaleLocal,
  resetTransform,
  resetTransformWorld,
  resetTransformLocal,
  translate,
  translateWorld,
  translateLocal,
  translateObject,
  translateAxis,
  translateAxisWorld,
  translateAxisLocal,
  translateAxisObject,
  rotate: rotate3,
  rotateDegrees: rotateDegrees3,
  rotateRadians: rotateRadians3,
  rotateMatrix,
  rotateQuat: rotateQuat3,
  rotateWorld,
  rotateWorldDegrees,
  rotateWorldRadians,
  rotateWorldMatrix,
  rotateWorldQuat,
  rotateLocal,
  rotateLocalDegrees,
  rotateLocalRadians,
  rotateLocalMatrix,
  rotateLocalQuat,
  rotateObject,
  rotateObjectDegrees,
  rotateObjectRadians,
  rotateObjectMatrix,
  rotateObjectQuat,
  rotateAxis: rotateAxis4,
  rotateAxisDegrees: rotateAxisDegrees4,
  rotateAxisRadians: rotateAxisRadians4,
  rotateAxisWorld,
  rotateAxisWorldDegrees,
  rotateAxisWorldRadians,
  rotateAxisLocal,
  rotateAxisLocalDegrees,
  rotateAxisLocalRadians,
  rotateAxisObject,
  rotateAxisObjectDegrees,
  rotateAxisObjectRadians,
  rotateAround: rotateAround2,
  rotateAroundDegrees: rotateAroundDegrees2,
  rotateAroundRadians: rotateAroundRadians2,
  rotateAroundMatrix,
  rotateAroundQuat: rotateAroundQuat2,
  rotateAroundWorld,
  rotateAroundWorldDegrees,
  rotateAroundWorldRadians,
  rotateAroundWorldMatrix,
  rotateAroundWorldQuat,
  rotateAroundLocal,
  rotateAroundLocalDegrees,
  rotateAroundLocalRadians,
  rotateAroundLocalMatrix,
  rotateAroundLocalQuat,
  rotateAroundObject,
  rotateAroundObjectDegrees,
  rotateAroundObjectRadians,
  rotateAroundObjectMatrix,
  rotateAroundObjectQuat,
  rotateAroundAxis: rotateAroundAxis2,
  rotateAroundAxisDegrees: rotateAroundAxisDegrees2,
  rotateAroundAxisRadians: rotateAroundAxisRadians2,
  rotateAroundAxisWorld,
  rotateAroundAxisWorldDegrees,
  rotateAroundAxisWorldRadians,
  rotateAroundAxisLocal,
  rotateAroundAxisLocalDegrees,
  rotateAroundAxisLocalRadians,
  rotateAroundAxisObject,
  rotateAroundAxisObjectDegrees,
  rotateAroundAxisObjectRadians,
  scaleObject,
  lookAt,
  lookAtWorld,
  lookAtLocal,
  lookTo,
  lookToWorld,
  lookToLocal,
  convertPositionObjectToWorld,
  convertDirectionObjectToWorld,
  convertPositionWorldToObject,
  convertDirectionWorldToObject,
  convertPositionLocalToWorld,
  convertDirectionLocalToWorld,
  convertPositionWorldToLocal,
  convertDirectionWorldToLocal,
  convertPositionObjectToLocal,
  convertDirectionObjectToLocal,
  convertPositionLocalToObject,
  convertDirectionLocalToObject,
  convertTransformObjectToWorld,
  convertTransformObjectToWorldMatrix,
  convertTransformObjectToWorldQuat,
  convertTransformWorldToObject,
  convertTransformWorldToObjectMatrix,
  convertTransformWorldToObjectQuat,
  convertTransformLocalToWorld,
  convertTransformLocalToWorldMatrix,
  convertTransformLocalToWorldQuat,
  convertTransformWorldToLocal,
  convertTransformWorldToLocalMatrix,
  convertTransformWorldToLocalQuat,
  convertTransformObjectToLocal,
  convertTransformObjectToLocalMatrix,
  convertTransformObjectToLocalQuat,
  convertTransformLocalToObject,
  convertTransformLocalToObjectMatrix,
  convertTransformLocalToObjectQuat,
  setParent,
  getParent,
  addComponent,
  getComponent,
  getComponentSelf,
  getComponentHierarchy,
  getComponentHierarchyBreadth,
  getComponentHierarchyDepth,
  getComponentDescendants,
  getComponentDescendantsBreadth,
  getComponentDescendantsDepth,
  getComponentChildren,
  getComponents,
  getComponentsSelf,
  getComponentsHierarchy,
  getComponentsHierarchyBreadth,
  getComponentsHierarchyDepth,
  getComponentsDescendants,
  getComponentsDescendantsBreadth,
  getComponentsDescendantsDepth,
  getComponentsChildren,
  setActive,
  setActiveSelf,
  setActiveHierarchy,
  setActiveHierarchyBreadth,
  setActiveHierarchyDepth,
  setActiveDescendants,
  setActiveDescendantsBreadth,
  setActiveDescendantsDepth,
  setActiveChildren,
  hasUniformScale: hasUniformScale2,
  hasUniformScaleWorld,
  hasUniformScaleLocal,
  clone: clone7,
  isCloneable,
  toString,
  toStringExtended,
  toStringCompact,
  log,
  logExtended,
  logCompact,
  warn,
  warnExtended,
  warnCompact,
  error,
  errorExtended,
  errorCompact,
  getObjectByName,
  getObjectByNameHierarchy,
  getObjectByNameHierarchyBreadth,
  getObjectByNameHierarchyDepth,
  getObjectByNameDescendants,
  getObjectByNameDescendantsBreadth,
  getObjectByNameDescendantsDepth,
  getObjectByNameChildren,
  getObjectsByName,
  getObjectsByNameHierarchy,
  getObjectsByNameHierarchyBreadth,
  getObjectsByNameHierarchyDepth,
  getObjectsByNameDescendants,
  getObjectsByNameDescendantsBreadth,
  getObjectsByNameDescendantsDepth,
  getObjectsByNameChildren,
  getObjectByID,
  getObjectByIDHierarchy,
  getObjectByIDHierarchyBreadth,
  getObjectByIDHierarchyDepth,
  getObjectByIDDescendants,
  getObjectByIDDescendantsBreadth,
  getObjectByIDDescendantsDepth,
  getObjectByIDChildren,
  getHierarchy,
  getHierarchyBreadth,
  getHierarchyDepth,
  getDescendants,
  getDescendantsBreadth,
  getDescendantsDepth,
  getChildren,
  getSelf,
  addChild,
  getName,
  setName,
  getEngine,
  getID,
  markDirty,
  isTransformChanged,
  destroy,
  reserveObjects,
  reserveObjectsSelf,
  reserveObjectsHierarchy,
  reserveObjectsDescendants,
  reserveObjectsChildren,
  getComponentsAmountMap,
  getComponentsAmountMapSelf,
  getComponentsAmountMapHierarchy,
  getComponentsAmountMapDescendants,
  getComponentsAmountMapChildren,
  getComponentObjects,
  getComponentsObjects,
  setActiveObjects,
  getObjectByNameObjects,
  getObjectsByNameObjects,
  getObjectByIDObjects,
  getObjectsByIDObjects,
  wrapObject
};
function _reserveObjects(count, componentsAmountMap, scene) {
  if (componentsAmountMap.has("object")) {
    const objectsToReserve = componentsAmountMap.get("object") * count;
    const componentsToReserve = {};
    for (const [componentName, componentCount] of componentsAmountMap.entries()) {
      if (componentName != "object") {
        componentsToReserve[componentName] = componentCount * count;
      }
    }
    scene.reserveObjects(objectsToReserve, componentsToReserve);
  }
}

// dist/pp/cauldron/wl/utils/wl_component_default_clone_callbacks.js
import { MeshComponent, TextComponent } from "@wonderlandengine/api";

// dist/pp/cauldron/wl/utils/mesh_utils.js
import { MeshAttribute, MeshIndexType } from "@wonderlandengine/api";

// dist/pp/cauldron/utils/array/vec2_utils.js
import { vec2 as gl_vec22 } from "gl-matrix";
function create6(x, y) {
  const out = getAllocationFunction6()();
  if (x != null) {
    Vec2Utils.set(out, x, y);
  }
  return out;
}
function getAllocationFunction6() {
  return getVector2AllocationFunction();
}
function setAllocationFunction6(allocationFunction) {
  setVector2AllocationFunction(allocationFunction);
}
function set6(vector, x, y) {
  if (y == null) {
    gl_vec22.set(vector, x, x);
  } else {
    gl_vec22.set(vector, x, y);
  }
  return vector;
}
function copy7(from, to) {
  gl_vec22.copy(to, from);
  return to;
}
function clone8(vector) {
  return vector.slice(0);
}
function equals7(first2, second, epsilon = 0) {
  let equals10 = first2.length == second.length;
  if (equals10) {
    equals10 &&= Math.abs(first2[0] - second[0]) <= epsilon;
    equals10 &&= Math.abs(first2[1] - second[1]) <= epsilon;
  }
  return equals10;
}
function length5(vector) {
  return gl_vec22.length(vector);
}
function normalize4(vector, out = Vec2Utils.clone(vector)) {
  gl_vec22.normalize(out, vector);
  return out;
}
function zero2(vector) {
  gl_vec22.zero(vector);
  return vector;
}
function isZero2(vector, epsilon = 0) {
  return Vec2Utils.length(vector) <= epsilon;
}
function lerp5(from, to, interpolationFactor, out = Vec2Utils.clone(from)) {
  if (interpolationFactor <= 0) {
    Vec2Utils.copy(from, out);
    return out;
  } else if (interpolationFactor >= 1) {
    Vec2Utils.copy(to, out);
    return out;
  }
  gl_vec22.lerp(out, from, to, interpolationFactor);
  return out;
}
function interpolate5(from, to, interpolationFactor, easingFunction = EasingFunction.linear, out = Vec2Utils.clone(from)) {
  const lerpFactor = easingFunction(interpolationFactor);
  return Vec2Utils.lerp(from, to, lerpFactor, out);
}
var Vec2Utils = {
  create: create6,
  getAllocationFunction: getAllocationFunction6,
  setAllocationFunction: setAllocationFunction6,
  set: set6,
  copy: copy7,
  clone: clone8,
  equals: equals7,
  length: length5,
  normalize: normalize4,
  zero: zero2,
  isZero: isZero2,
  lerp: lerp5,
  interpolate: interpolate5
};

// dist/pp/cauldron/utils/array/vec4_utils.js
import { vec4 as gl_vec42 } from "gl-matrix";
function create7(x, y, z, w) {
  const out = getAllocationFunction7()();
  if (x != null) {
    Vec4Utils.set(out, x, y, z, w);
  }
  return out;
}
function getAllocationFunction7() {
  return getVector4AllocationFunction();
}
function setAllocationFunction7(allocationFunction) {
  setVector4AllocationFunction(allocationFunction);
}
function set7(vector, x, y, z, w) {
  if (y == null) {
    gl_vec42.set(vector, x, x, x, x);
  } else {
    gl_vec42.set(vector, x, y, z, w);
  }
  return vector;
}
function copy8(from, to) {
  gl_vec42.copy(to, from);
  return to;
}
function clone9(vector) {
  return vector.slice(0);
}
function equals8(first2, second, epsilon = 0) {
  let equals10 = first2.length == second.length;
  if (equals10) {
    equals10 &&= Math.abs(first2[0] - second[0]) <= epsilon;
    equals10 &&= Math.abs(first2[1] - second[1]) <= epsilon;
    equals10 &&= Math.abs(first2[2] - second[2]) <= epsilon;
    equals10 &&= Math.abs(first2[3] - second[3]) <= epsilon;
  }
  return equals10;
}
function lerp6(from, to, interpolationFactor, out = Vec4Utils.clone(from)) {
  if (interpolationFactor <= 0) {
    Vec4Utils.copy(from, out);
    return out;
  } else if (interpolationFactor >= 1) {
    Vec4Utils.copy(to, out);
    return out;
  }
  gl_vec42.lerp(out, from, to, interpolationFactor);
  return out;
}
function interpolate6(from, to, interpolationFactor, easingFunction = EasingFunction.linear, out = Vec4Utils.clone(from)) {
  const lerpFactor = easingFunction(interpolationFactor);
  return Vec4Utils.lerp(from, to, lerpFactor, out);
}
var Vec4Utils = {
  create: create7,
  getAllocationFunction: getAllocationFunction7,
  setAllocationFunction: setAllocationFunction7,
  set: set7,
  copy: copy8,
  clone: clone9,
  equals: equals8,
  lerp: lerp6,
  interpolate: interpolate6
};

// dist/pp/cauldron/utils/array/vec_utils.js
function create8(firstValue, ...remainingValues) {
  let out = null;
  if (remainingValues.length == 0) {
    const length6 = firstValue;
    out = getAllocationFunction8()(length6);
    for (let i = 0; i < length6; i++) {
      out[i] = 0;
    }
  } else {
    out = getAllocationFunction8()(remainingValues.length + 1);
    out[0] = firstValue;
    for (let i = 0; i < remainingValues.length; i++) {
      out[i + 1] = remainingValues[i];
    }
  }
  return out;
}
function getAllocationFunction8() {
  return getVectorAllocationFunction();
}
function setAllocationFunction8(allocationFunction) {
  setVectorAllocationFunction(allocationFunction);
}
function set8(vector, firstValue, ...remainingValues) {
  if (remainingValues.length == 0) {
    for (let i = 0; i < vector.length; i++) {
      vector[i] = firstValue;
    }
  } else {
    vector[0] = firstValue;
    for (let i = 0; i < remainingValues.length && i < vector.length - 1; i++) {
      vector[i + 1] = remainingValues[i];
    }
  }
  return vector;
}
function copy9(from, to) {
  const minLength = Math.min(from.length, to.length);
  for (let i = 0; i < minLength; i++) {
    to[i] = from[i];
  }
  return to;
}
function clone10(vector) {
  return vector.slice(0);
}
function equals9(vector, other, epsilon = 0) {
  let equals10 = vector.length == other.length;
  for (let i = 0; i < vector.length && equals10; i++) {
    equals10 = equals10 && Math.abs(vector[i] - other[i]) <= epsilon;
  }
  return equals10;
}
function zero3(vector) {
  for (let i = 0; i < vector.length; i++) {
    vector[i] = 0;
  }
  return vector;
}
function isZero3(vector, epsilon = 0) {
  let zero4 = true;
  for (let i = 0; i < vector.length && zero4; i++) {
    zero4 = zero4 && Math.abs(vector[i]) <= epsilon;
  }
  return zero4;
}
function scale3(vector, value, out = VecUtils.clone(vector)) {
  for (let i = 0; i < vector.length; i++) {
    out[i] = vector[i] * value;
  }
  return out;
}
function round(vector, out = VecUtils.clone(vector)) {
  for (let i = 0; i < vector.length; i++) {
    out[i] = Math.round(vector[i]);
  }
  return out;
}
function floor(vector, out = VecUtils.clone(vector)) {
  for (let i = 0; i < vector.length; i++) {
    out[i] = Math.floor(vector[i]);
  }
  return out;
}
function ceil(vector, out = VecUtils.clone(vector)) {
  for (let i = 0; i < vector.length; i++) {
    out[i] = Math.ceil(vector[i]);
  }
  return out;
}
function clamp2(vector, start = -Number.MAX_VALUE, end = Number.MAX_VALUE, out = VecUtils.clone(vector)) {
  const min = Math.min(start, end);
  const max = Math.max(start, end);
  for (let i = 0; i < vector.length; i++) {
    out[i] = MathUtils.clamp(vector[i], min, max);
  }
  return out;
}
function lerp7(from, to, interpolationFactor, out = VecUtils.clone(from)) {
  if (interpolationFactor <= 0) {
    VecUtils.copy(from, out);
    return out;
  } else if (interpolationFactor >= 1) {
    VecUtils.copy(to, out);
    return out;
  }
  const minLength = Math.min(from.length, to.length, out.length);
  for (let i = 0; i < minLength; i++) {
    const fromCurrentValue = from[i];
    const toCurrentValue = to[i];
    out[i] = fromCurrentValue + interpolationFactor * (toCurrentValue - fromCurrentValue);
  }
  return out;
}
function interpolate7(from, to, interpolationFactor, easingFunction = EasingFunction.linear, out = VecUtils.clone(from)) {
  const lerpFactor = easingFunction(interpolationFactor);
  return VecUtils.lerp(from, to, lerpFactor, out);
}
function toString2(vector, decimalPlaces = 4) {
  const message = _buildConsoleMessage(vector, decimalPlaces);
  return message;
}
function log2(vector, decimalPlaces = 4) {
  const message = _buildConsoleMessage(vector, decimalPlaces);
  console.log(message);
  return vector;
}
function error2(vector, decimalPlaces = 4) {
  const message = _buildConsoleMessage(vector, decimalPlaces);
  console.error(message);
  return vector;
}
function warn2(vector, decimalPlaces = 4) {
  const message = _buildConsoleMessage(vector, decimalPlaces);
  console.warn(message);
  return vector;
}
var VecUtils = {
  create: create8,
  getAllocationFunction: getAllocationFunction8,
  setAllocationFunction: setAllocationFunction8,
  set: set8,
  copy: copy9,
  clone: clone10,
  equals: equals9,
  zero: zero3,
  isZero: isZero3,
  scale: scale3,
  round,
  floor,
  ceil,
  clamp: clamp2,
  lerp: lerp7,
  interpolate: interpolate7,
  toString: toString2,
  log: log2,
  error: error2,
  warn: warn2
};
function _buildConsoleMessage(vector, decimalPlaces) {
  let message = "[";
  for (let i = 0; i < vector.length; i++) {
    if (i != 0) {
      message = message.concat(", ");
    }
    if (decimalPlaces != null) {
      message = message.concat(vector[i].toFixed(decimalPlaces));
    } else {
      message = message.concat(vector[i].toString());
    }
  }
  message = message.concat("]");
  return message;
}

// dist/pp/plugin/js/extensions/array/vec_create_extension.js
function vec_create(firstValue, ...remainingValues) {
  return VecUtils.create(firstValue, ...remainingValues);
}
function vec_getAllocationFunction() {
  return VecUtils.getAllocationFunction();
}
function vec_setAllocationFunction(allocationFunction) {
  VecUtils.setAllocationFunction(allocationFunction);
}
function vec2_create(x, y) {
  return Vec2Utils.create(x, y);
}
function vec2_getAllocationFunction() {
  return Vec2Utils.getAllocationFunction();
}
function vec2_setAllocationFunction(allocationFunction) {
  Vec2Utils.setAllocationFunction(allocationFunction);
}
function vec3_create(x, y, z) {
  return Vec3Utils.create(x, y, z);
}
function vec3_getAllocationFunction() {
  return Vec3Utils.getAllocationFunction();
}
function vec3_setAllocationFunction(allocationFunction) {
  Vec3Utils.setAllocationFunction(allocationFunction);
}
function vec4_create(x, y, z, w) {
  return Vec4Utils.create(x, y, z, w);
}
function vec4_getAllocationFunction() {
  return Vec4Utils.getAllocationFunction();
}
function vec4_setAllocationFunction(allocationFunction) {
  Vec4Utils.setAllocationFunction(allocationFunction);
}
function quat_create(x, y, z, w) {
  return QuatUtils.create(x, y, z, w);
}
function quat_getAllocationFunction() {
  return QuatUtils.getAllocationFunction();
}
function quat_setAllocationFunction(allocationFunction) {
  QuatUtils.setAllocationFunction(allocationFunction);
}
function quat2_create(x1, y1, z1, w1, x2, y2, z2, w2) {
  return Quat2Utils.create(x1, y1, z1, w1, x2, y2, z2, w2);
}
function quat2_getAllocationFunction() {
  return Quat2Utils.getAllocationFunction();
}
function quat2_setAllocationFunction(allocationFunction) {
  Quat2Utils.setAllocationFunction(allocationFunction);
}
function mat3_create(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  return Mat3Utils.create(m00, m01, m02, m10, m11, m12, m20, m21, m22);
}
function mat3_getAllocationFunction() {
  return Mat3Utils.getAllocationFunction();
}
function mat3_setAllocationFunction(allocationFunction) {
  Mat3Utils.setAllocationFunction(allocationFunction);
}
function mat4_create(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  return Mat4Utils.create(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
}
function mat4_getAllocationFunction() {
  return Mat4Utils.getAllocationFunction();
}
function mat4_setAllocationFunction(allocationFunction) {
  Mat4Utils.setAllocationFunction(allocationFunction);
}

// dist/pp/cauldron/wl/utils/mesh_utils.js
var MeshCreationVertexParams = class {
  constructor() {
    this.myPosition = null;
    this.myTextureCoordinates = null;
    this.myNormal = null;
    this.myColor = null;
  }
};
var MeshCreationTriangleParams = class {
  constructor() {
    this.myIndexes = new Uint32Array(3);
  }
};
var MeshCreationParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myVertexes = [];
    this.myTriangles = [];
    this.myEngine = engine;
  }
};
function create9(meshCreationParams) {
  let indexData = [];
  for (let triangle of meshCreationParams.myTriangles) {
    indexData.push(triangle.myIndexes[0]);
    indexData.push(triangle.myIndexes[1]);
    indexData.push(triangle.myIndexes[2]);
  }
  let indexDataUnsignedInt = new Uint32Array(indexData.length);
  indexDataUnsignedInt.pp_copy(indexData);
  let vertexCount = meshCreationParams.myVertexes.length;
  let mesh = meshCreationParams.myEngine.meshes.create({
    vertexCount,
    indexData: indexDataUnsignedInt,
    indexType: MeshIndexType.UnsignedInt
  });
  let positionAttribute = null;
  let textureCoordinatesAttribute = null;
  let normalAttribute = null;
  let colorAttribute = null;
  try {
    positionAttribute = mesh.attribute(MeshAttribute.Position);
  } catch (error4) {
    positionAttribute = null;
  }
  try {
    textureCoordinatesAttribute = mesh.attribute(MeshAttribute.TextureCoordinate);
  } catch (error4) {
    textureCoordinatesAttribute = null;
  }
  try {
    normalAttribute = mesh.attribute(MeshAttribute.Normal);
  } catch (error4) {
    normalAttribute = null;
  }
  try {
    colorAttribute = mesh.attribute(MeshAttribute.Color);
  } catch (error4) {
    colorAttribute = null;
  }
  for (let i = 0; i < meshCreationParams.myVertexes.length; i++) {
    let vertex = meshCreationParams.myVertexes[i];
    if (positionAttribute != null && vertex.myPosition) {
      positionAttribute.set(i, vertex.myPosition);
    }
    if (textureCoordinatesAttribute != null && vertex.myTextureCoordinates) {
      textureCoordinatesAttribute.set(i, vertex.myTextureCoordinates);
    }
    if (normalAttribute != null && vertex.myNormal) {
      normalAttribute.set(i, vertex.myNormal);
    }
    if (colorAttribute != null && vertex.myColor) {
      colorAttribute.set(i, vertex.myColor);
    }
  }
  return mesh;
}
var clone11 = function() {
  let position = vec3_create();
  let textureCoordinates = vec2_create();
  let normal = vec3_create();
  let color = vec4_create();
  return function clone13(mesh) {
    if (mesh == null) {
      return null;
    }
    let clonedIndexData = mesh.indexData.pp_clone();
    let clonedMesh = mesh.engine.meshes.create({
      vertexCount: mesh.vertexCount,
      indexData: clonedIndexData,
      indexType: MeshIndexType.UnsignedInt
    });
    let positionAttribute = null;
    let textureCoordinatesAttribute = null;
    let normalAttribute = null;
    let colorAttribute = null;
    let clonedPositionAttribute = null;
    let clonedTextureCoordinatesAttribute = null;
    let clonedNormalAttribute = null;
    let clonedColorAttribute = null;
    try {
      positionAttribute = mesh.attribute(MeshAttribute.Position);
      clonedPositionAttribute = clonedMesh.attribute(MeshAttribute.Position);
    } catch (error4) {
      positionAttribute = null;
      clonedPositionAttribute = null;
    }
    try {
      textureCoordinatesAttribute = mesh.attribute(MeshAttribute.TextureCoordinate);
      clonedTextureCoordinatesAttribute = clonedMesh.attribute(MeshAttribute.TextureCoordinate);
    } catch (error4) {
      textureCoordinatesAttribute = null;
      clonedTextureCoordinatesAttribute = null;
    }
    try {
      normalAttribute = mesh.attribute(MeshAttribute.Normal);
      clonedNormalAttribute = clonedMesh.attribute(MeshAttribute.Normal);
    } catch (error4) {
      normalAttribute = null;
      clonedNormalAttribute = null;
    }
    try {
      colorAttribute = mesh.attribute(MeshAttribute.Color);
      clonedColorAttribute = clonedMesh.attribute(MeshAttribute.Color);
    } catch (error4) {
      colorAttribute = null;
      clonedColorAttribute = null;
    }
    for (let i = 0; i < mesh.vertexCount; i++) {
      if (positionAttribute != null && clonedPositionAttribute != null) {
        clonedPositionAttribute.set(i, positionAttribute.get(i, position));
      }
      if (textureCoordinatesAttribute != null && clonedTextureCoordinatesAttribute != null) {
        clonedTextureCoordinatesAttribute.set(i, textureCoordinatesAttribute.get(i, textureCoordinates));
      }
      if (normalAttribute != null && clonedNormalAttribute != null) {
        clonedNormalAttribute.set(i, normalAttribute.get(i, normal));
      }
      if (colorAttribute != null && clonedColorAttribute != null) {
        clonedColorAttribute.set(i, colorAttribute.get(i, color));
      }
    }
    return clonedMesh;
  };
}();
var invert4 = function() {
  let position = vec3_create();
  let textureCoordinates = vec2_create();
  let normal = vec3_create();
  let color = vec4_create();
  return function invert5(mesh) {
    if (mesh == null) {
      return null;
    }
    let invertedIndexData = new Uint32Array(mesh.indexData.length);
    for (let i = 0; i < mesh.indexData.length / 3; i++) {
      invertedIndexData[i * 3 + 0] = mesh.indexData[i * 3 + 2];
      invertedIndexData[i * 3 + 1] = mesh.indexData[i * 3 + 1];
      invertedIndexData[i * 3 + 2] = mesh.indexData[i * 3 + 0];
    }
    let invertedMesh = mesh.engine.meshes.create({
      vertexCount: mesh.vertexCount,
      indexData: invertedIndexData,
      indexType: MeshIndexType.UnsignedInt
    });
    let positionAttribute = null;
    let textureCoordinatesAttribute = null;
    let normalAttribute = null;
    let colorAttribute = null;
    let invertedPositionAttribute = null;
    let invertedTextureCoordinatesAttribute = null;
    let invertedNormalAttribute = null;
    let invertedColorAttribute = null;
    try {
      positionAttribute = mesh.attribute(MeshAttribute.Position);
      invertedPositionAttribute = invertedMesh.attribute(MeshAttribute.Position);
    } catch (error4) {
      positionAttribute = null;
      invertedPositionAttribute = null;
    }
    try {
      textureCoordinatesAttribute = mesh.attribute(MeshAttribute.TextureCoordinate);
      invertedTextureCoordinatesAttribute = invertedMesh.attribute(MeshAttribute.TextureCoordinate);
    } catch (error4) {
      textureCoordinatesAttribute = null;
      invertedTextureCoordinatesAttribute = null;
    }
    try {
      normalAttribute = mesh.attribute(MeshAttribute.Normal);
      invertedNormalAttribute = invertedMesh.attribute(MeshAttribute.Normal);
    } catch (error4) {
      normalAttribute = null;
      invertedNormalAttribute = null;
    }
    try {
      colorAttribute = mesh.attribute(MeshAttribute.Color);
      invertedColorAttribute = invertedMesh.attribute(MeshAttribute.Color);
    } catch (error4) {
      colorAttribute = null;
      invertedColorAttribute = null;
    }
    for (let i = 0; i < mesh.vertexCount; i++) {
      if (positionAttribute != null && invertedPositionAttribute != null) {
        invertedPositionAttribute.set(i, positionAttribute.get(i, position));
      }
      if (textureCoordinatesAttribute != null && invertedTextureCoordinatesAttribute != null) {
        invertedTextureCoordinatesAttribute.set(i, textureCoordinatesAttribute.get(i, textureCoordinates));
      }
      if (normalAttribute != null && invertedNormalAttribute != null) {
        normalAttribute.get(i, normal);
        normal.vec3_negate(normal);
        invertedNormalAttribute.set(i, normal);
      }
      if (colorAttribute != null && invertedColorAttribute != null) {
        invertedColorAttribute.set(i, colorAttribute.get(i, color));
      }
    }
    return invertedMesh;
  };
}();
var makeDoubleSided = function() {
  let position = vec3_create();
  let textureCoordinates = vec2_create();
  let normal = vec3_create();
  let color = vec4_create();
  return function makeDoubleSided2(mesh) {
    if (mesh == null) {
      return null;
    }
    let doubleSidedIndexData = new Uint32Array(mesh.indexData.length * 2);
    for (let i = 0; i < doubleSidedIndexData.length / 3; i++) {
      doubleSidedIndexData[i * 3 * 2 + 0] = mesh.indexData[i * 3 + 0] * 2;
      doubleSidedIndexData[i * 3 * 2 + 1] = mesh.indexData[i * 3 + 1] * 2;
      doubleSidedIndexData[i * 3 * 2 + 2] = mesh.indexData[i * 3 + 2] * 2;
      doubleSidedIndexData[i * 3 * 2 + 3] = mesh.indexData[i * 3 + 2] * 2 + 1;
      doubleSidedIndexData[i * 3 * 2 + 4] = mesh.indexData[i * 3 + 1] * 2 + 1;
      doubleSidedIndexData[i * 3 * 2 + 5] = mesh.indexData[i * 3 + 0] * 2 + 1;
    }
    let doubleSidedMesh = mesh.engine.meshes.create({
      vertexCount: mesh.vertexCount * 2,
      indexData: doubleSidedIndexData,
      indexType: MeshIndexType.UnsignedInt
    });
    let positionAttribute = null;
    let textureCoordinatesAttribute = null;
    let normalAttribute = null;
    let colorAttribute = null;
    let doubleSidedPositionAttribute = null;
    let doubleSidedTextureCoordinatesAttribute = null;
    let doubleSidedNormalAttribute = null;
    let doubleSidedColorAttribute = null;
    try {
      positionAttribute = mesh.attribute(MeshAttribute.Position);
      doubleSidedPositionAttribute = doubleSidedMesh.attribute(MeshAttribute.Position);
    } catch (error4) {
      positionAttribute = null;
      doubleSidedPositionAttribute = null;
    }
    try {
      textureCoordinatesAttribute = mesh.attribute(MeshAttribute.TextureCoordinate);
      doubleSidedTextureCoordinatesAttribute = doubleSidedMesh.attribute(MeshAttribute.TextureCoordinate);
    } catch (error4) {
      textureCoordinatesAttribute = null;
      doubleSidedTextureCoordinatesAttribute = null;
    }
    try {
      normalAttribute = mesh.attribute(MeshAttribute.Normal);
      doubleSidedNormalAttribute = doubleSidedMesh.attribute(MeshAttribute.Normal);
    } catch (error4) {
      normalAttribute = null;
      doubleSidedNormalAttribute = null;
    }
    try {
      colorAttribute = mesh.attribute(MeshAttribute.Color);
      doubleSidedColorAttribute = doubleSidedMesh.attribute(MeshAttribute.Color);
    } catch (error4) {
      colorAttribute = null;
      doubleSidedColorAttribute = null;
    }
    for (let i = 0; i < mesh.vertexCount; i++) {
      if (positionAttribute != null && doubleSidedPositionAttribute != null) {
        doubleSidedPositionAttribute.set(i * 2, positionAttribute.get(i, position));
        doubleSidedPositionAttribute.set(i * 2 + 1, positionAttribute.get(i, position));
      }
      if (textureCoordinatesAttribute != null && doubleSidedTextureCoordinatesAttribute != null) {
        doubleSidedTextureCoordinatesAttribute.set(i * 2, textureCoordinatesAttribute.get(i, textureCoordinates));
        doubleSidedTextureCoordinatesAttribute.set(i * 2 + 1, textureCoordinatesAttribute.get(i, textureCoordinates));
      }
      if (normalAttribute != null && doubleSidedNormalAttribute != null) {
        normalAttribute.get(i, normal);
        doubleSidedNormalAttribute.set(i * 2, normal);
        let invertedNormal = normal.vec3_negate();
        doubleSidedNormalAttribute.set(i * 2 + 1, invertedNormal);
      }
      if (colorAttribute != null && doubleSidedColorAttribute != null) {
        doubleSidedColorAttribute.set(i * 2, colorAttribute.get(i, color));
        doubleSidedColorAttribute.set(i * 2 + 1, colorAttribute.get(i, color));
      }
    }
    return doubleSidedMesh;
  };
}();
function createPlane(engine = Globals.getMainEngine()) {
  let vertexCount = 4;
  let meshCreationParams = new MeshCreationParams(engine);
  for (let i = 0; i < vertexCount; ++i) {
    let vertexCreationParams = new MeshCreationVertexParams();
    vertexCreationParams.myPosition = new vec3_create();
    vertexCreationParams.myPosition[0] = -1 + (i & 1) * 2;
    vertexCreationParams.myPosition[1] = -1 + ((i & 2) >> 1) * 2;
    vertexCreationParams.myPosition[2] = 0;
    vertexCreationParams.myTextureCoordinates = new vec2_create();
    vertexCreationParams.myTextureCoordinates[0] = i & 1;
    vertexCreationParams.myTextureCoordinates[1] = (i & 2) >> 1;
    vertexCreationParams.myNormal = new vec3_create();
    vertexCreationParams.myNormal[0] = 0;
    vertexCreationParams.myNormal[1] = 0;
    vertexCreationParams.myNormal[2] = 1;
    meshCreationParams.myVertexes.push(vertexCreationParams);
  }
  let firstTriangle = new MeshCreationTriangleParams();
  firstTriangle.myIndexes[0] = 0;
  firstTriangle.myIndexes[1] = 1;
  firstTriangle.myIndexes[2] = 2;
  let secondTriangle = new MeshCreationTriangleParams();
  secondTriangle.myIndexes[0] = 2;
  secondTriangle.myIndexes[1] = 1;
  secondTriangle.myIndexes[2] = 3;
  meshCreationParams.myTriangles.push(firstTriangle);
  meshCreationParams.myTriangles.push(secondTriangle);
  let mesh = MeshUtils.create(meshCreationParams);
  return mesh;
}
var MeshUtils = {
  create: create9,
  clone: clone11,
  invert: invert4,
  makeDoubleSided,
  createPlane
};

// dist/pp/cauldron/wl/utils/wl_component_default_clone_callbacks.js
function cloneMesh(componentToClone, targetObject, deepCloneParams = new ComponentDeepCloneParams(), customCloneParams = null) {
  let clonedComponent = ComponentUtils.cloneDefault(componentToClone, targetObject, true);
  if (deepCloneParams.isDeepCloneComponentVariable(MeshComponent.TypeName, "material")) {
    if (componentToClone.material != null) {
      clonedComponent.material = componentToClone.material.clone();
    }
  }
  if (deepCloneParams.isDeepCloneComponentVariable(MeshComponent.TypeName, "mesh")) {
    clonedComponent.mesh = MeshUtils.clone(componentToClone.mesh);
  }
  return clonedComponent;
}
function cloneCollision(componentToClone, targetObject, deepCloneParams = new ComponentDeepCloneParams(), customCloneParams = null) {
  let clonedComponent = ComponentUtils.cloneDefault(componentToClone, targetObject);
  return clonedComponent;
}
function cloneText(componentToClone, targetObject, deepCloneParams = new ComponentDeepCloneParams(), customCloneParams = null) {
  let clonedComponent = ComponentUtils.cloneDefault(componentToClone, targetObject);
  if (deepCloneParams.isDeepCloneComponentVariable(TextComponent.TypeName, "material")) {
    if (componentToClone.material != null) {
      clonedComponent.material = componentToClone.material.clone();
    }
  }
  return clonedComponent;
}
function clonePhysX(componentToClone, targetObject, deepCloneParams = new ComponentDeepCloneParams(), customCloneParams = null) {
  let clonedComponent = ComponentUtils.cloneDefault(componentToClone, targetObject);
  return clonedComponent;
}
var WLComponentDefaultCloneCallbacks = {
  cloneMesh,
  cloneCollision,
  cloneText,
  clonePhysX
};

// dist/pp/cauldron/wl/utils/component_utils.js
var _myCloneCallbacks = /* @__PURE__ */ new WeakMap();
var _myClonePostProcessCallbacks = /* @__PURE__ */ new WeakMap();
var ComponentDeepCloneParams = class {
  constructor() {
    this._myDeepCloneComponents = false;
    this._myDeepCloneOverrideComponentsMap = /* @__PURE__ */ new Map();
    this._myDeepCloneOverrideComponentsVariablesMap = /* @__PURE__ */ new Map();
  }
  // The implementation is component dependant, not every component implements the deep clone
  setDeepCloneComponents(deepClone) {
    this._myDeepCloneComponents = deepClone;
  }
  // This value override the deep clone components value
  // The implementation is component dependant, not every component implements the deep clone
  setDeepCloneComponent(componentName, deepClone) {
    this._myDeepCloneOverrideComponentsMap.set(componentName, deepClone);
  }
  // This value override both the deep clone components value and the deep clone component override one
  // The implementation is component dependant, not every component variable override is taken into consideration
  setDeepCloneComponentVariable(componentName, variableName, deepClone) {
    let componentsVariablesMap = null;
    if (!this._myDeepCloneOverrideComponentsVariablesMap.has(componentName)) {
      this._myDeepCloneOverrideComponentsVariablesMap.set(componentName, /* @__PURE__ */ new Map());
    }
    componentsVariablesMap = this._myDeepCloneOverrideComponentsVariablesMap.get(componentName);
    componentsVariablesMap.set(variableName, deepClone);
  }
  isDeepCloneComponent(componentName) {
    let deepCloneOverride = this._myDeepCloneOverrideComponentsMap.get(componentName);
    if (deepCloneOverride != null) {
      return deepCloneOverride;
    }
    return this._myDeepCloneComponents;
  }
  isDeepCloneComponentVariable(componentName, variableName) {
    let componentsVariablesMap = this._myDeepCloneOverrideComponentsVariablesMap.get(componentName);
    if (componentsVariablesMap != null) {
      let deepCloneOverride = componentsVariablesMap.get(variableName);
      if (deepCloneOverride != null) {
        return deepCloneOverride;
      }
    }
    return this.isDeepCloneComponent(componentName);
  }
};
var ComponentCustomCloneParams = class {
  constructor() {
    this._myParams = /* @__PURE__ */ new Map();
  }
  addParam(name, value) {
    this._myParams.set(name, value);
  }
  removeParam(name) {
    this._myParams.delete(name);
  }
  getParam(name) {
    this._myParams.get(name);
  }
  hasParam(name) {
    this._myParams.has(name);
  }
};
function isWLComponent(classOrType) {
  return ComponentUtils.isWLNativeComponent(classOrType) || ComponentUtils.isWLJavascriptComponent(classOrType);
}
function isWLNativeComponent(classOrType) {
  let wlNative = false;
  let type = ComponentUtils.getTypeFromClassOrType(classOrType);
  if (ComponentUtils.getWLNativeComponentTypes().includes(type)) {
    wlNative = true;
  }
  return wlNative;
}
function isWLJavascriptComponent(classOrType) {
  let wlJavascript = false;
  let type = ComponentUtils.getTypeFromClassOrType(classOrType);
  if (ComponentUtils.getWLJavascriptComponentTypes().includes(type)) {
    wlJavascript = true;
  }
  return wlJavascript;
}
function getWLNativeComponentTypes() {
  return _myWLNativeComponentTypes;
}
function getWLJavascriptComponentTypes() {
  return _myWLJavascriptComponentTypes;
}
function getTypeFromClassOrType(classOrType) {
  if (classOrType == null)
    return;
  let type = classOrType;
  if (classOrType.TypeName != null) {
    type = classOrType.TypeName;
  }
  return type;
}
function getClassFromType(type, engine = Globals.getMainEngine()) {
  let classToReturn = null;
  if (ComponentUtils.isWLNativeComponent(type)) {
    if (ComponentUtils.isWLNativeComponentRegistered(type, engine)) {
      switch (type) {
        case AnimationComponent.TypeName:
          classToReturn = AnimationComponent;
          break;
        case CollisionComponent.TypeName:
          classToReturn = CollisionComponent;
          break;
        case InputComponent.TypeName:
          classToReturn = InputComponent;
          break;
        case LightComponent.TypeName:
          classToReturn = LightComponent;
          break;
        case MeshComponent2.TypeName:
          classToReturn = MeshComponent2;
          break;
        case PhysXComponent.TypeName:
          classToReturn = PhysXComponent;
          break;
        case TextComponent2.TypeName:
          classToReturn = TextComponent2;
          break;
        case ViewComponent.TypeName:
          classToReturn = ViewComponent;
          break;
        default:
          classToReturn = null;
      }
    }
  } else {
    classToReturn = ComponentUtils.getJavascriptComponentClass(type, engine);
  }
  return classToReturn;
}
function isRegistered(classOrType, engine = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromClassOrType(classOrType);
  return ComponentUtils.getClassFromType(type, engine) != null;
}
function getJavascriptComponentInstances(currentSceneOnly = true, engine = Globals.getMainEngine()) {
  if (currentSceneOnly) {
    return Globals.getScene(engine)._jsComponents;
  }
  return Globals.getWASM(engine)._components;
}
function getJavascriptComponentClass(type, engine = Globals.getMainEngine()) {
  return ComponentUtils.getJavascriptComponentClassesByIndex(engine)[ComponentUtils.getJavascriptComponentTypeIndex(type, engine)];
}
function getJavascriptComponentClassesByIndex(engine = Globals.getMainEngine()) {
  return Globals.getWASM(engine)._componentTypes;
}
function getJavascriptComponentTypeIndex(classOrType, engine = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromClassOrType(classOrType);
  return ComponentUtils.getJavascriptComponentTypeIndexes(engine)[type];
}
function getJavascriptComponentTypeIndexes(engine = Globals.getMainEngine()) {
  return Globals.getWASM(engine)._componentTypeIndices;
}
function getJavascriptComponentTypeFromIndex(typeIndex, engine = Globals.getMainEngine()) {
  let type = null;
  let componentClass = ComponentUtils.getJavascriptComponentClassesByIndex(engine)[typeIndex];
  if (componentClass != null) {
    type = componentClass.TypeName;
  }
  return type;
}
function isWLNativeComponentRegistered(classOrType, engine = Globals.getMainEngine()) {
  let scene = Globals.getScene(engine);
  let type = ComponentUtils.getTypeFromClassOrType(classOrType);
  return scene._components.getNativeManager(type) != null;
}
function isCloneable2(classOrType, defaultCloneValid = false, engine = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromClassOrType(classOrType);
  return defaultCloneValid || ComponentUtils.hasCloneCallback(type, engine) || ComponentUtils.getClassFromType(type, engine)?.prototype.pp_clone != null;
}
function hasClonePostProcess(classOrType, engine = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromClassOrType(classOrType);
  return ComponentUtils.hasClonePostProcessCallback(type, engine) || ComponentUtils.getClassFromType(type, engine)?.prototype.pp_clonePostProcess != null;
}
function clone12(componentToClone, targetObject, deeCloneParams, customCloneParams, useDefaultCloneAsFallback = false, defaultCloneAutoStartIfNotActive = true) {
  let clonedComponent = null;
  let cloneCallback = ComponentUtils.getCloneCallback(componentToClone.type, ObjectUtils.getEngine(componentToClone.object));
  if (cloneCallback != null) {
    clonedComponent = cloneCallback(componentToClone, targetObject, deeCloneParams, customCloneParams);
  } else if (componentToClone.pp_clone != null) {
    clonedComponent = componentToClone.pp_clone(targetObject, deeCloneParams, customCloneParams);
  } else if (useDefaultCloneAsFallback) {
    clonedComponent = ComponentUtils.cloneDefault(componentToClone, targetObject, defaultCloneAutoStartIfNotActive);
  }
  return clonedComponent;
}
function clonePostProcess(componentToClone, clonedComponent, deeCloneParams, customCloneParams) {
  let clonePostProcessCallback = ComponentUtils.getClonePostProcessCallback(componentToClone.type, ObjectUtils.getEngine(componentToClone.object));
  if (clonePostProcessCallback != null) {
    clonePostProcessCallback(componentToClone, clonedComponent, deeCloneParams, customCloneParams);
  } else if (componentToClone.pp_clonePostProcess != null) {
    componentToClone.pp_clonePostProcess(clonedComponent, deeCloneParams, customCloneParams);
  }
  return clonedComponent;
}
function cloneDefault(componentToClone, targetObject, autoStartIfNotActive = true) {
  let clonedComponent = ObjectUtils.addComponent(targetObject, componentToClone.type, componentToClone);
  if (autoStartIfNotActive && !clonedComponent.active) {
    clonedComponent.active = true;
    clonedComponent.active = false;
  }
  return clonedComponent;
}
function setCloneCallback(classOrType, callback, engine = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromClassOrType(classOrType);
  if (!_myCloneCallbacks.has(engine)) {
    _myCloneCallbacks.set(engine, /* @__PURE__ */ new Map());
  }
  _myCloneCallbacks.get(engine).set(type, callback);
}
function removeCloneCallback(classOrType, engine = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromClassOrType(classOrType);
  if (_myCloneCallbacks.has(engine)) {
    _myCloneCallbacks.get(engine).delete(type);
  }
}
function getCloneCallback(classOrType, engine = Globals.getMainEngine()) {
  let callback = null;
  let type = ComponentUtils.getTypeFromClassOrType(classOrType);
  if (_myCloneCallbacks.has(engine)) {
    callback = _myCloneCallbacks.get(engine).get(type);
  }
  return callback;
}
function hasCloneCallback(classOrType, engine = Globals.getMainEngine()) {
  let hasCallback = false;
  let type = ComponentUtils.getTypeFromClassOrType(classOrType);
  if (_myCloneCallbacks.has(engine)) {
    hasCallback = _myCloneCallbacks.get(engine).has(type);
  }
  return hasCallback;
}
function setClonePostProcessCallback(classOrType, callback, engine = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromClassOrType(classOrType);
  if (!_myClonePostProcessCallbacks.has(engine)) {
    _myClonePostProcessCallbacks.set(engine, /* @__PURE__ */ new Map());
  }
  _myClonePostProcessCallbacks.get(engine).set(type, callback);
}
function removeClonePostProcessCallback(classOrType, engine = Globals.getMainEngine()) {
  let type = ComponentUtils.getTypeFromClassOrType(classOrType);
  if (_myClonePostProcessCallbacks.has(engine)) {
    _myClonePostProcessCallbacks.get(engine).delete(type);
  }
}
function getClonePostProcessCallback(classOrType, engine = Globals.getMainEngine()) {
  let callback = null;
  let type = ComponentUtils.getTypeFromClassOrType(classOrType);
  if (_myClonePostProcessCallbacks.has(engine)) {
    callback = _myClonePostProcessCallbacks.get(engine).get(type);
  }
  return callback;
}
function hasClonePostProcessCallback(classOrType, engine = Globals.getMainEngine()) {
  let hasCallback = false;
  let type = ComponentUtils.getTypeFromClassOrType(classOrType);
  if (_myClonePostProcessCallbacks.has(engine)) {
    hasCallback = _myClonePostProcessCallbacks.get(engine).has(type);
  }
  return hasCallback;
}
function getDefaultWLComponentCloneCallback(classOrType) {
  let callback = null;
  let type = ComponentUtils.getTypeFromClassOrType(classOrType);
  switch (type) {
    case MeshComponent2.TypeName:
      callback = WLComponentDefaultCloneCallbacks.cloneMesh;
      break;
    case CollisionComponent.TypeName:
      callback = WLComponentDefaultCloneCallbacks.cloneCollision;
      break;
    case TextComponent2.TypeName:
      callback = WLComponentDefaultCloneCallbacks.cloneText;
      break;
    case PhysXComponent.TypeName:
      callback = WLComponentDefaultCloneCallbacks.clonePhysX;
      break;
    default:
      callback = null;
  }
  return callback;
}
function hasDefaultWLComponentCloneCallback(classOrType) {
  return ComponentUtils.getDefaultWLComponentCloneCallback(classOrType) != null;
}
function setWLComponentDefaultCloneCallbacks(engine = Globals.getMainEngine()) {
  for (let nativeType of ComponentUtils.getWLNativeComponentTypes()) {
    let cloneCallback = ComponentUtils.getDefaultWLComponentCloneCallback(nativeType);
    if (cloneCallback != null) {
      ComponentUtils.setCloneCallback(nativeType, cloneCallback, engine);
    }
  }
  for (let javascriptType of ComponentUtils.getWLJavascriptComponentTypes()) {
    let cloneCallback = ComponentUtils.getDefaultWLComponentCloneCallback(javascriptType);
    if (cloneCallback != null) {
      ComponentUtils.setCloneCallback(javascriptType, cloneCallback, engine);
    }
  }
}
function removeWLComponentDefaultCloneCallbacks(engine = Globals.getMainEngine()) {
  for (let nativeType of ComponentUtils.getWLNativeComponentTypes()) {
    let cloneCallback = ComponentUtils.getDefaultWLComponentCloneCallback(nativeType);
    if (cloneCallback != null) {
      if (ComponentUtils.getCloneCallback(nativeType, engine) == cloneCallback) {
        ComponentUtils.removeCloneCallback(nativeType, engine);
      }
    }
  }
  for (let javascriptType of ComponentUtils.getWLNativeComponentTypes()) {
    let cloneCallback = ComponentUtils.getDefaultWLComponentCloneCallback(javascriptType);
    if (cloneCallback != null) {
      if (ComponentUtils.getCloneCallback(javascriptType, engine) == cloneCallback) {
        ComponentUtils.removeCloneCallback(javascriptType, engine);
      }
    }
  }
}
var ComponentUtils = {
  isWLComponent,
  isWLNativeComponent,
  isWLJavascriptComponent,
  getWLNativeComponentTypes,
  getWLJavascriptComponentTypes,
  getTypeFromClassOrType,
  getClassFromType,
  isRegistered,
  getJavascriptComponentInstances,
  getJavascriptComponentClass,
  getJavascriptComponentClassesByIndex,
  getJavascriptComponentTypeIndex,
  getJavascriptComponentTypeIndexes,
  getJavascriptComponentTypeFromIndex,
  isWLNativeComponentRegistered,
  isCloneable: isCloneable2,
  hasClonePostProcess,
  clone: clone12,
  clonePostProcess,
  cloneDefault,
  setCloneCallback,
  removeCloneCallback,
  getCloneCallback,
  hasCloneCallback,
  setClonePostProcessCallback,
  removeClonePostProcessCallback,
  getClonePostProcessCallback,
  hasClonePostProcessCallback,
  setWLComponentDefaultCloneCallbacks,
  removeWLComponentDefaultCloneCallbacks,
  getDefaultWLComponentCloneCallback,
  hasDefaultWLComponentCloneCallback
};
var _myWLNativeComponentTypes = [
  AnimationComponent.TypeName,
  CollisionComponent.TypeName,
  InputComponent.TypeName,
  LightComponent.TypeName,
  MeshComponent2.TypeName,
  PhysXComponent.TypeName,
  TextComponent2.TypeName,
  ViewComponent.TypeName
];
var _myWLJavascriptComponentTypes = [
  ARCamera8thwall.TypeName,
  Anchor.TypeName,
  Cursor.TypeName,
  CursorTarget.TypeName,
  DebugObject.TypeName,
  DeviceOrientationLook.TypeName,
  FingerCursor.TypeName,
  FixedFoveation.TypeName,
  HandTracking.TypeName,
  HitTestLocation.TypeName,
  HowlerAudioListener.TypeName,
  HowlerAudioSource.TypeName,
  ImageTexture.TypeName,
  MouseLookComponent.TypeName,
  PlaneDetection.TypeName,
  PlayerHeight.TypeName,
  TargetFramerate.TypeName,
  TeleportComponent.TypeName,
  Trail.TypeName,
  TwoJointIkSolver.TypeName,
  VideoTexture.TypeName,
  VrModeActiveSwitch.TypeName,
  Vrm.TypeName,
  WasdControlsComponent.TypeName
];

// dist/pp/tool/easy_tune/easy_tune_variable_types.js
import { Emitter } from "@wonderlandengine/api";

// dist/pp/tool/easy_tune/easy_tune_utils.js
var _mySetWidgetCurrentVariableCallbacks = /* @__PURE__ */ new WeakMap();
var _myRefreshWidgetCallbacks = /* @__PURE__ */ new WeakMap();
var _myAutoImportEnabledDefaultValues = /* @__PURE__ */ new WeakMap();
var _myManualImportEnabledDefaultValues = /* @__PURE__ */ new WeakMap();
var _myExportEnabledDefaultValues = /* @__PURE__ */ new WeakMap();
function setWidgetCurrentVariable(variableName, engine = Globals.getMainEngine()) {
  if (_mySetWidgetCurrentVariableCallbacks.has(engine)) {
    for (const callback of _mySetWidgetCurrentVariableCallbacks.get(engine).values()) {
      callback(variableName);
    }
  }
}
function refreshWidget(engine = Globals.getMainEngine()) {
  if (_myRefreshWidgetCallbacks.has(engine)) {
    for (const callback of _myRefreshWidgetCallbacks.get(engine).values()) {
      callback();
    }
  }
}
function importVariables(fileURL = null, resetVariablesDefaultValueOnImport = false, skipValueChangedNotifyOnImport = false, manualImport = false, onSuccessCallback, onFailureCallback, engine = Globals.getMainEngine()) {
  if (fileURL == null || fileURL.length == 0) {
    if (navigator.clipboard) {
      navigator.clipboard.readText().then(function(clipboard) {
        Globals.getEasyTuneVariables(engine).fromJSON(clipboard, resetVariablesDefaultValueOnImport, skipValueChangedNotifyOnImport, manualImport);
        EasyTuneUtils.refreshWidget(engine);
        if (onSuccessCallback != null) {
          onSuccessCallback();
        }
        console.log("Easy Tune Variables Imported from: clipboard");
        console.log(clipboard);
      }).catch(function(reason) {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
        console.error("An error occurred while importing the easy tune variables from: clipboard");
        console.error(reason);
      });
    }
  } else {
    const replacedFileURL = _importExportVariablesReplaceFileURLParams(fileURL);
    fetch(replacedFileURL).then(function(response) {
      if (response.ok) {
        response.text().then(function(text) {
          Globals.getEasyTuneVariables(engine).fromJSON(text, resetVariablesDefaultValueOnImport, skipValueChangedNotifyOnImport, manualImport);
          EasyTuneUtils.refreshWidget(engine);
          if (onSuccessCallback != null) {
            onSuccessCallback();
          }
          console.log("Easy Tune Variables Imported from:", replacedFileURL);
          console.log(text);
        }).catch(function(reason) {
          if (onFailureCallback != null) {
            onFailureCallback();
          }
          console.error("An error occurred while importing the easy tune variables from:", replacedFileURL);
          console.error(reason);
        });
      } else {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
        console.error("An error occurred while importing the easy tune variables from:", replacedFileURL);
        console.error(response);
      }
    }).catch(function(reason) {
      if (onFailureCallback != null) {
        onFailureCallback();
      }
      console.error("An error occurred while importing the easy tune variables from:", replacedFileURL);
      console.error(reason);
    });
  }
  EasyTuneUtils.refreshWidget(engine);
}
function getImportVariablesJSON(fileURL = null, onSuccessCallback, onFailureCallback, engine = Globals.getMainEngine()) {
  if (fileURL == null || fileURL.length == 0) {
    if (navigator.clipboard) {
      navigator.clipboard.readText().then(function(clipboard) {
        if (onSuccessCallback != null) {
          onSuccessCallback(clipboard);
        }
      }).catch(function(reason) {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
      });
    }
  } else {
    const replacedFileURL = _importExportVariablesReplaceFileURLParams(fileURL);
    fetch(replacedFileURL).then(function(response) {
      if (response.ok) {
        response.text().then(function(text) {
          if (onSuccessCallback != null) {
            onSuccessCallback(text);
          }
        }).catch(function(reason) {
          if (onFailureCallback != null) {
            onFailureCallback();
          }
        });
      } else {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
      }
    }).catch(function(reason) {
      if (onFailureCallback != null) {
        onFailureCallback();
      }
    });
  }
}
function exportVariables(fileURL = null, excludeVariablesWithValueAsDefault, variablesToKeep, onSuccessCallback, onFailureCallback, engine = Globals.getMainEngine()) {
  const variablesJSONToExport = Globals.getEasyTuneVariables(engine).toJSON(excludeVariablesWithValueAsDefault);
  EasyTuneUtils.exportVariablesJSON(variablesJSONToExport, fileURL, variablesToKeep, onSuccessCallback, onFailureCallback, engine);
}
function exportVariablesByName(variableNamesToExport, fileURL = null, excludeVariablesWithValueAsDefault, variablesToKeep, onSuccessCallback, onFailureCallback, engine = Globals.getMainEngine()) {
  const objectJSON = {};
  const easyTuneVariables = Globals.getEasyTuneVariables(engine);
  for (const variableName of variableNamesToExport) {
    const variable = easyTuneVariables.getEasyTuneVariable(variableName);
    if (variable != null && variable.isExportEnabled()) {
      if (!excludeVariablesWithValueAsDefault || !variable.isValueEqual(variable.getDefaultValue())) {
        objectJSON[variable.getName()] = variable.toJSON();
      }
    }
  }
  const variablesJSONToExport = JSON.stringify(objectJSON);
  EasyTuneUtils.exportVariablesJSON(variablesJSONToExport, fileURL, variablesToKeep, onSuccessCallback, onFailureCallback, engine);
}
function exportVariablesJSON(variablesJSONToExport, fileURL = null, variablesToKeep, onSuccessCallback, onFailureCallback, engine = Globals.getMainEngine()) {
  if (variablesToKeep != null) {
    try {
      const variablesToExport = JSON.parse(variablesJSONToExport);
      for (const variableName in variablesToKeep) {
        if (!(variableName in variablesToExport)) {
          variablesToExport[variableName] = variablesToKeep[variableName];
        }
      }
      variablesJSONToExport = JSON.stringify(variablesToExport);
    } catch (error4) {
    }
  }
  if (fileURL == null || fileURL.length == 0) {
    if (navigator.clipboard) {
      navigator.clipboard.writeText(variablesJSONToExport).then(function() {
        if (onSuccessCallback != null) {
          onSuccessCallback();
        }
        console.log("Easy Tune Variables Exported to: clipboard");
        console.log(variablesJSONToExport);
      }, function() {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
        console.error("An error occurred while exporting the easy tune variables to: clipboard");
      }).catch(function(reason) {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
        console.error("An error occurred while exporting the easy tune variables to: clipboard");
        console.error(reason);
      });
    }
  } else {
    const replacedFileURL = _importExportVariablesReplaceFileURLParams(fileURL);
    fetch(replacedFileURL, {
      headers: {
        "Accept": "application/json",
        "Content-Type": "application/json"
      },
      method: "POST",
      body: variablesJSONToExport
    }).then(function(response) {
      if (response.ok) {
        if (onSuccessCallback != null) {
          onSuccessCallback();
        }
        console.log("Easy Tune Variables Exported to:", replacedFileURL);
        console.log(variablesJSONToExport);
      } else {
        if (onFailureCallback != null) {
          onFailureCallback();
        }
        console.error("An error occurred while exporting the easy tune variables to:", replacedFileURL);
        console.error(response);
      }
    }, function(response) {
      if (onFailureCallback != null) {
        onFailureCallback();
      }
      console.error("An error occurred while exporting the easy tune variables to:", replacedFileURL);
      console.error(response);
    }).catch(function(reason) {
      if (onFailureCallback != null) {
        onFailureCallback();
      }
      console.error("An error occurred while exporting the easy tune variables to:", replacedFileURL);
      console.error(reason);
    });
  }
}
function clearExportedVariables(fileURL = null, onSuccessCallback, onFailureCallback, engine = Globals.getMainEngine()) {
  EasyTuneUtils.exportVariablesJSON("", fileURL, void 0, onSuccessCallback, onFailureCallback, engine);
}
function setAutoImportEnabledDefaultValue(defaultValue, engine = Globals.getMainEngine()) {
  _myAutoImportEnabledDefaultValues.set(engine, defaultValue);
}
function setManualImportEnabledDefaultValue(defaultValue, engine = Globals.getMainEngine()) {
  _myManualImportEnabledDefaultValues.set(engine, defaultValue);
}
function setExportEnabledDefaultValue(defaultValue, engine = Globals.getMainEngine()) {
  _myExportEnabledDefaultValues.set(engine, defaultValue);
}
function getAutoImportEnabledDefaultValue(engine = Globals.getMainEngine()) {
  let defaultValue = true;
  if (_myAutoImportEnabledDefaultValues.has(engine)) {
    defaultValue = _myAutoImportEnabledDefaultValues.get(engine) ?? false;
  }
  return defaultValue;
}
function getManualImportEnabledDefaultValue(engine = Globals.getMainEngine()) {
  let defaultValue = true;
  if (_myManualImportEnabledDefaultValues.has(engine)) {
    defaultValue = _myManualImportEnabledDefaultValues.get(engine) ?? false;
  }
  return defaultValue;
}
function getExportEnabledDefaultValue(engine = Globals.getMainEngine()) {
  let defaultValue = true;
  if (_myExportEnabledDefaultValues.has(engine)) {
    defaultValue = _myExportEnabledDefaultValues.get(engine) ?? false;
  }
  return defaultValue;
}
function addSetWidgetCurrentVariableCallback(id, callback, engine = Globals.getMainEngine()) {
  if (!_mySetWidgetCurrentVariableCallbacks.has(engine)) {
    _mySetWidgetCurrentVariableCallbacks.set(engine, /* @__PURE__ */ new Map());
  }
  _mySetWidgetCurrentVariableCallbacks.get(engine).set(id, callback);
}
function removeSetWidgetCurrentVariableCallback(id, engine = Globals.getMainEngine()) {
  if (_mySetWidgetCurrentVariableCallbacks.has(engine)) {
    _mySetWidgetCurrentVariableCallbacks.get(engine).delete(id);
  }
}
function addRefreshWidgetCallback(id, callback, engine = Globals.getMainEngine()) {
  if (!_myRefreshWidgetCallbacks.has(engine)) {
    _myRefreshWidgetCallbacks.set(engine, /* @__PURE__ */ new Map());
  }
  _myRefreshWidgetCallbacks.get(engine).set(id, callback);
}
function removeRefreshWidgetCallback(id, engine = Globals.getMainEngine()) {
  if (_myRefreshWidgetCallbacks.has(engine)) {
    _myRefreshWidgetCallbacks.get(engine).delete(id);
  }
}
var EasyTuneUtils = {
  setWidgetCurrentVariable,
  refreshWidget,
  importVariables,
  getImportVariablesJSON,
  exportVariables,
  exportVariablesByName,
  exportVariablesJSON,
  clearExportedVariables,
  setAutoImportEnabledDefaultValue,
  setManualImportEnabledDefaultValue,
  setExportEnabledDefaultValue,
  getAutoImportEnabledDefaultValue,
  getManualImportEnabledDefaultValue,
  getExportEnabledDefaultValue,
  addSetWidgetCurrentVariableCallback,
  removeSetWidgetCurrentVariableCallback,
  addRefreshWidgetCallback,
  removeRefreshWidgetCallback
};
var _importExportVariablesReplaceFileURLParams = function() {
  const matchEasyTuneURLParamsRegex = new RegExp("\\{.+?\\}", "g");
  return function _importExportVariablesReplaceFileURLParams2(fileURL) {
    const params = fileURL.match(matchEasyTuneURLParamsRegex);
    if (params == null || params.length == 0) {
      return fileURL;
    }
    for (let i = 0; i < params.length; i++) {
      params[i] = params[i].replace("{", "");
      params[i] = params[i].replace("}", "");
    }
    const urlQuery = window.location.search;
    const urlSearchParams = new URLSearchParams(urlQuery);
    let replacedFileURL = fileURL;
    for (const param of params) {
      const searchParamValue = urlSearchParams.get(param);
      if (searchParamValue != null) {
        replacedFileURL = replacedFileURL.replace("{" + param + "}", searchParamValue);
      }
    }
    return replacedFileURL;
  };
}();

// dist/pp/tool/easy_tune/easy_tune_variable_types.js
var EasyTuneVariableType;
(function(EasyTuneVariableType2) {
  EasyTuneVariableType2[EasyTuneVariableType2["NONE"] = 0] = "NONE";
  EasyTuneVariableType2[EasyTuneVariableType2["NUMBER"] = 1] = "NUMBER";
  EasyTuneVariableType2[EasyTuneVariableType2["BOOL"] = 2] = "BOOL";
  EasyTuneVariableType2[EasyTuneVariableType2["TRANSFORM"] = 3] = "TRANSFORM";
})(EasyTuneVariableType || (EasyTuneVariableType = {}));
var EasyTuneVariableExtraParams = class {
  myAutoImportEnabled = null;
  myManualImportEnabled = null;
  myExportEnabled = null;
  constructor(autoimportEnabled = null, manualImportEnabled = null, exportEnabled = null) {
    this.myAutoImportEnabled = autoimportEnabled;
    this.myManualImportEnabled = manualImportEnabled;
    this.myExportEnabled = exportEnabled;
  }
};
var EasyTuneVariable = class {
  _myType;
  _myName;
  _myShowOnWidget;
  _myAutoImportEnabled;
  _myManualImportEnabled;
  _myExportEnabled;
  _myWidgetCurrentVariable = false;
  _myValueChangedEmitter = new Emitter();
  _myEngine;
  constructor(type, name, valueChangedEventListener = null, showOnWidget = true, extraParams = new EasyTuneVariableExtraParams(), engine = Globals.getMainEngine()) {
    this._myType = type;
    this._myName = name;
    this._myShowOnWidget = showOnWidget;
    this._myAutoImportEnabled = extraParams.myAutoImportEnabled ?? EasyTuneUtils.getAutoImportEnabledDefaultValue(engine);
    this._myManualImportEnabled = extraParams.myManualImportEnabled ?? EasyTuneUtils.getManualImportEnabledDefaultValue(engine);
    this._myExportEnabled = extraParams.myExportEnabled ?? EasyTuneUtils.getExportEnabledDefaultValue(engine);
    this._myWidgetCurrentVariable = false;
    this._myValueChangedEmitter = new Emitter();
    this._myEngine = engine;
    if (valueChangedEventListener != null) {
      this.registerValueChangedEventListener(this, valueChangedEventListener);
    }
  }
  getName() {
    return this._myName;
  }
  setName(name) {
    if (this._myName != name) {
      this._myName = name;
      EasyTuneUtils.refreshWidget(this._myEngine);
    }
    return this;
  }
  getType() {
    return this._myType;
  }
  isWidgetCurrentVariable() {
    return this._myWidgetCurrentVariable;
  }
  setWidgetCurrentVariable(widgetCurrentVariable) {
    this._myWidgetCurrentVariable = widgetCurrentVariable;
    return this;
  }
  getValue() {
    return this._myValue;
  }
  setValue(value, resetDefaultValue = false, skipValueChangedNotify = false) {
    const valueChanged = this._myValue != null && this._myValue != value;
    this._myValue = value;
    if (resetDefaultValue) {
      this.setDefaultValue(value);
    }
    EasyTuneUtils.refreshWidget(this._myEngine);
    if (valueChanged && !skipValueChangedNotify) {
      this._notifyValueChanged();
    }
    return this;
  }
  getDefaultValue() {
    return this._myDefaultValue;
  }
  isValueEqual(otherValue) {
    return this._myValue == otherValue;
  }
  setDefaultValue(value) {
    this._myDefaultValue = value;
    return this;
  }
  isShownOnWidget() {
    return this._myShowOnWidget;
  }
  setShowOnWidget(showOnWidget) {
    this._myShowOnWidget = showOnWidget;
    return this;
  }
  isManualImportEnabled() {
    return this._myManualImportEnabled;
  }
  isAutoImportEnabled() {
    return this._myAutoImportEnabled;
  }
  isExportEnabled() {
    return this._myExportEnabled;
  }
  setManualImportEnabled(enabled) {
    this._myManualImportEnabled = enabled;
    return this;
  }
  setAutoImportEnabled(enabled) {
    this._myAutoImportEnabled = enabled;
    return this;
  }
  setExportEnabled(enabled) {
    this._myExportEnabled = enabled;
    return this;
  }
  setEasyTuneVariableExtraParams(extraParams) {
    this.setAutoImportEnabled(extraParams.myAutoImportEnabled ?? EasyTuneUtils.getAutoImportEnabledDefaultValue(this._myEngine));
    this.setManualImportEnabled(extraParams.myManualImportEnabled ?? EasyTuneUtils.getManualImportEnabledDefaultValue(this._myEngine));
    this.setExportEnabled(extraParams.myExportEnabled ?? EasyTuneUtils.getExportEnabledDefaultValue(this._myEngine));
    return this;
  }
  fromJSON(valueJSON, resetDefaultValue = false, skipValueChangedNotify = false) {
    this.setValue(JSON.parse(valueJSON), resetDefaultValue, skipValueChangedNotify);
    return this;
  }
  toJSON() {
    return JSON.stringify(this.getValue());
  }
  /**
   * @param id if `undefined` is used as id, it will overwrite the default variable listener
   */
  registerValueChangedEventListener(id, listener) {
    if (id !== void 0) {
      this._myValueChangedEmitter.add(listener, { id });
    } else {
      this._myValueChangedEmitter.add(listener, { id: this });
    }
    return this;
  }
  /**
   * @param id if `undefined` is used as id, it will unregister the default variable listener
   */
  unregisterValueChangedEventListener(id) {
    if (id !== void 0) {
      this._myValueChangedEmitter.remove(id);
    } else {
      this._myValueChangedEmitter.remove(this);
    }
    return this;
  }
  _notifyValueChanged() {
    this._myValueChangedEmitter.notify(this.getValue(), this);
  }
};
var EasyTuneVariableTyped = class extends EasyTuneVariable {
  constructor(type, name, valueChangedEventListener, showOnWidget, extraParams, engine) {
    super(type, name, valueChangedEventListener, showOnWidget, extraParams, engine);
  }
  getValue() {
    return super.getValue();
  }
  setValue(value, resetDefaultValue, skipValueChangedNotify) {
    return super.setValue(value, resetDefaultValue, skipValueChangedNotify);
  }
  isValueEqual(otherValue) {
    return this._myValue == otherValue;
  }
  getDefaultValue() {
    return super.getDefaultValue();
  }
  setDefaultValue(value) {
    return super.setDefaultValue(value);
  }
  registerValueChangedEventListener(id, listener) {
    return super.registerValueChangedEventListener(id, listener);
  }
  unregisterValueChangedEventListener(id) {
    return super.unregisterValueChangedEventListener(id);
  }
};
var EasyTuneVariableArray = class extends EasyTuneVariableTyped {
  _myValue;
  _myDefaultValue;
  constructor(type, name, value, valueChangedEventListener, showOnWidget, extraParams, engine) {
    super(type, name, valueChangedEventListener, showOnWidget, extraParams, engine);
    this.setValue(value, true, true);
  }
  setValue(value, resetDefaultValue = false, skipValueChangedNotify = false) {
    const valueChanged = this._myValue != null && !this._myValue.pp_equals(value);
    if (this._myValue == null) {
      this._myValue = value.pp_clone();
    } else {
      this._myValue.pp_copy(value);
    }
    if (resetDefaultValue) {
      this.setDefaultValue(value);
    }
    EasyTuneUtils.refreshWidget(this._myEngine);
    if (valueChanged && !skipValueChangedNotify) {
      this._notifyValueChanged();
    }
    return this;
  }
  setDefaultValue(value) {
    if (this._myDefaultValue == null) {
      this._myDefaultValue = value.pp_clone();
    } else {
      this._myDefaultValue.pp_copy(value);
    }
    return this;
  }
};
var EasyTuneNumberArray = class extends EasyTuneVariableArray {
  _myDecimalPlaces;
  _myStepPerSecond;
  _myDefaultStepPerSecond;
  _myMin;
  _myMax;
  _myEditAllValuesTogether;
  constructor(name, value, valueChangedEventListener, showOnWidget, decimalPlaces = 3, stepPerSecond = 1, min = -Number.MAX_VALUE, max = Number.MAX_VALUE, editAllValuesTogether = false, extraParams, engine) {
    super(EasyTuneVariableType.NUMBER, name, value, valueChangedEventListener, showOnWidget, extraParams, engine);
    this._myDecimalPlaces = decimalPlaces;
    this._myStepPerSecond = stepPerSecond;
    this._myDefaultStepPerSecond = this._myStepPerSecond;
    this._myMin = min;
    this._myMax = max;
    this._myEditAllValuesTogether = editAllValuesTogether;
    this._clampValue(true, true);
  }
  isValueEqual(otherValue, epsilon = MathUtils.EPSILON) {
    return this._myValue.vec_equals(otherValue, epsilon);
  }
  setMax(max) {
    this._myMax = max;
    this._clampValue(false);
    return this;
  }
  setMin(min) {
    this._myMin = min;
    this._clampValue(false);
    return this;
  }
  toJSON() {
    return this.getValue().vec_toString();
  }
  _clampValue(resetDefaultValue, skipValueChangedNotify = false) {
    const clampedValue = this._myValue.vec_clamp(this._myMin, this._myMax);
    if (!resetDefaultValue) {
      const clampedDefaultValue = this.getDefaultValue().vec_clamp(this._myMin, this._myMax);
      this.setDefaultValue(clampedDefaultValue);
    }
    this.setValue(clampedValue, resetDefaultValue, skipValueChangedNotify);
  }
};
var EasyTuneIntArray = class extends EasyTuneNumberArray {
  constructor(name, value, valueChangedEventListener, showOnWidget, stepPerSecond, min = -Number.MAX_VALUE, max = Number.MAX_VALUE, editAllValuesTogether, extraParams, engine) {
    const roundedValue = value.pp_clone();
    for (let i = 0; i < value.length; i++) {
      roundedValue[i] = Math.round(roundedValue[i]);
    }
    super(name, roundedValue, valueChangedEventListener, showOnWidget, 0, stepPerSecond, Math.round(min), Math.round(max), editAllValuesTogether, extraParams, engine);
  }
};
var EasyTuneNumber = class extends EasyTuneVariableTyped {
  _myValue;
  _myDefaultValue;
  _myDecimalPlaces;
  _myStepPerSecond;
  _myDefaultStepPerSecond;
  _myMin;
  _myMax;
  constructor(name, value, valueChangedEventListener, showOnWidget, decimalPlaces = 3, stepPerSecond = 1, min = -Number.MAX_VALUE, max = Number.MAX_VALUE, extraParams, engine) {
    super(EasyTuneVariableType.NUMBER, name, valueChangedEventListener, showOnWidget, extraParams, engine);
    this.setValue(value, true, true);
    this._myDecimalPlaces = decimalPlaces;
    this._myStepPerSecond = stepPerSecond;
    this._myDefaultStepPerSecond = this._myStepPerSecond;
    this._myMin = min;
    this._myMax = max;
    this._clampValue(true, true);
  }
  isValueEqual(otherValue, epsilon = MathUtils.EPSILON) {
    return Math.abs(this._myValue - otherValue) < epsilon;
  }
  setMax(max) {
    this._myMax = max;
    this._clampValue(false);
    return this;
  }
  setMin(min) {
    this._myMin = min;
    this._clampValue(false);
    return this;
  }
  toJSON() {
    return JSON.stringify(this.getValue());
  }
  _clampValue(resetDefaultValue, skipValueChangedNotify = false) {
    const clampedValue = MathUtils.clamp(this._myValue, this._myMin, this._myMax);
    if (!resetDefaultValue) {
      const clampedDefaultValue = MathUtils.clamp(this.getDefaultValue(), this._myMin, this._myMax);
      this.setDefaultValue(clampedDefaultValue);
    }
    this.setValue(clampedValue, resetDefaultValue, skipValueChangedNotify);
  }
};
var EasyTuneInt = class extends EasyTuneNumber {
  constructor(name, value, valueChangedEventListener, showOnWidget, stepPerSecond, min, max, extraParams, engine) {
    super(name, value, valueChangedEventListener, showOnWidget, 0, stepPerSecond, min, max, extraParams, engine);
  }
};
var EasyTuneBoolArray = class extends EasyTuneVariableArray {
  constructor(name, value, valueChangedEventListener, showOnWidget, extraParams, engine) {
    super(EasyTuneVariableType.BOOL, name, value, valueChangedEventListener, showOnWidget, extraParams, engine);
  }
};
var EasyTuneBool = class extends EasyTuneVariableTyped {
  _myValue;
  _myDefaultValue;
  constructor(name, value, valueChangedEventListener, showOnWidget, extraParams, engine) {
    super(EasyTuneVariableType.BOOL, name, valueChangedEventListener, showOnWidget, extraParams, engine);
    this.setValue(value, true, true);
  }
};
var EasyTuneTransform = class _EasyTuneTransform extends EasyTuneVariableTyped {
  _myValue = mat4_create();
  _myDefaultValue = mat4_create();
  _myDecimalPlaces;
  _myPosition = vec3_create();
  _myRotation = vec3_create();
  _myScale = vec3_create();
  _myScaleAsOne;
  _myPositionStepPerSecond;
  _myRotationStepPerSecond;
  _myScaleStepPerSecond;
  _myDefaultPosition = vec3_create();
  _myDefaultRotation = vec3_create();
  _myDefaultScale = vec3_create();
  _myDefaultPositionStepPerSecond;
  _myDefaultRotationStepPerSecond;
  _myDefaultScaleStepPerSecond;
  constructor(name, value, valueChangedEventListener, showOnWidget, scaleAsOne = true, decimalPlaces = 3, positionStepPerSecond = 1, rotationStepPerSecond = 50, scaleStepPerSecond = 1, extraParams, engine) {
    super(EasyTuneVariableType.TRANSFORM, name, valueChangedEventListener, showOnWidget, extraParams, engine);
    this._myDecimalPlaces = decimalPlaces;
    this.setValue(value, true, true);
    const decimalPlacesMultiplier = Math.pow(10, this._myDecimalPlaces);
    for (let i = 0; i < 3; i++) {
      this._myScale[i] = Math.max(this._myScale[i], 1 / decimalPlacesMultiplier);
    }
    this._myValue.mat4_setPosition(this._myPosition);
    this._myValue.mat4_setRotationDegrees(this._myRotation);
    this._myValue.mat4_setScale(this._myScale);
    this.setValue(this._myValue, true, true);
    this._myScaleAsOne = scaleAsOne;
    this._myPositionStepPerSecond = positionStepPerSecond;
    this._myRotationStepPerSecond = rotationStepPerSecond;
    this._myScaleStepPerSecond = scaleStepPerSecond;
    this._myDefaultPositionStepPerSecond = this._myPositionStepPerSecond;
    this._myDefaultRotationStepPerSecond = this._myRotationStepPerSecond;
    this._myDefaultScaleStepPerSecond = this._myScaleStepPerSecond;
  }
  static _setValueSV = {
    oldValue: mat4_create()
  };
  setValue(value, resetDefaultValue = false, skipValueChangedNotify = false) {
    const oldValue = _EasyTuneTransform._setValueSV.oldValue;
    oldValue.mat4_copy(this._myValue);
    this._myValue.mat4_copy(value);
    this._myValue.mat4_getPosition(this._myPosition);
    this._myValue.mat4_getRotationDegrees(this._myRotation);
    this._myValue.mat4_getScale(this._myScale);
    const valueChanged = !oldValue.pp_equals(this._myValue);
    if (resetDefaultValue) {
      this.setDefaultValue(value);
    }
    EasyTuneUtils.refreshWidget(this._myEngine);
    if (valueChanged && !skipValueChangedNotify) {
      this._notifyValueChanged();
    }
    return this;
  }
  isValueEqual(otherValue, epsilon = MathUtils.EPSILON) {
    return this._myValue.vec_equals(otherValue, epsilon);
  }
  setDefaultValue(value) {
    this._myDefaultValue.mat4_copy(value);
    this._myDefaultValue.mat4_getPosition(this._myDefaultPosition);
    this._myDefaultValue.mat4_getRotationDegrees(this._myDefaultRotation);
    this._myDefaultValue.mat4_getScale(this._myDefaultScale);
    return this;
  }
  toJSON() {
    return this.getValue().vec_toString();
  }
};

// dist/pp/tool/easy_tune/easy_object_tuners/easy_object_tuner.js
var EasyObjectTuner = class {
  _myObject;
  _myEasyTuneVariable = null;
  _myUseTuneTarget;
  _mySetAsWidgetCurrentVariable;
  _myInitialEasyTuneVariableName;
  _myPrevObject = null;
  _myManualVariableUpdate = false;
  _myActive = true;
  _mySetupDone = false;
  _myEngine;
  constructor(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine = Globals.getMainEngine()) {
    this._myObject = object;
    this._myUseTuneTarget = useTuneTarget;
    this._mySetAsWidgetCurrentVariable = setAsWidgetCurrentVariable;
    let easyObject = this._myObject;
    if (this._myUseTuneTarget) {
      easyObject = Globals.getEasyTuneTarget(engine);
    }
    const variableNamePrefix = this._getVariableNamePrefix();
    if (variableName == "") {
      const objectName = easyObject != null ? easyObject.pp_getName() : "";
      if (objectName != "") {
        this._myInitialEasyTuneVariableName = variableNamePrefix.concat(objectName);
      } else {
        this._myInitialEasyTuneVariableName = variableNamePrefix.concat(easyObject != null ? easyObject.pp_getID().toFixed() : "");
      }
    } else {
      this._myInitialEasyTuneVariableName = variableName;
    }
    this._myEngine = engine;
  }
  getEasyTuneVariable() {
    return this._myEasyTuneVariable;
  }
  start() {
    this._myEasyTuneVariable = this._createEasyTuneVariable(this._myInitialEasyTuneVariableName);
    Globals.getEasyTuneVariables(this._myEngine).add(this._myEasyTuneVariable);
    let easyObject = this._myObject;
    if (this._myUseTuneTarget) {
      easyObject = Globals.getEasyTuneTarget(this._myEngine);
    }
    this._myPrevObject = easyObject;
    if (easyObject != null) {
      const value = this._getObjectValue(easyObject);
      this._myEasyTuneVariable.setValue(value, true);
    }
    this._myActive = false;
    this.setActive(true);
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      if (this._myEasyTuneVariable != null) {
        if (this._myActive) {
          this._myEasyTuneVariable.registerValueChangedEventListener(this, function(newValue) {
            if (this._myManualVariableUpdate)
              return;
            let easyObject = this._myObject;
            if (this._myUseTuneTarget) {
              easyObject = Globals.getEasyTuneTarget(this._myEngine);
            }
            if (easyObject != null) {
              this._updateObjectValue(easyObject, newValue);
            }
          }.bind(this));
        } else {
          this._myEasyTuneVariable.unregisterValueChangedEventListener(this);
        }
      }
    }
  }
  isActive() {
    return this._myActive;
  }
  update(dt) {
    if (!this._mySetupDone) {
      if (Globals.hasEasyTuneWidget()) {
        if (this._mySetAsWidgetCurrentVariable) {
          EasyTuneUtils.setWidgetCurrentVariable(this._myInitialEasyTuneVariableName, this._myEngine);
        }
        this._mySetupDone = true;
      }
    }
    if (this._myEasyTuneVariable == null || !this._myActive || !this.canUpdate())
      return;
    let easyObject = this._myObject;
    if (this._myUseTuneTarget) {
      easyObject = Globals.getEasyTuneTarget(this._myEngine);
    }
    let value = null;
    if (easyObject != null) {
      value = this._getObjectValue(easyObject);
    } else {
      value = this._getDefaultValue();
    }
    if (value != null) {
      const currentValue = this._myEasyTuneVariable.getValue();
      if (!this._areValueEqual(currentValue, value)) {
        this._myManualVariableUpdate = true;
        this._myEasyTuneVariable.setValue(value, this._myPrevObject != easyObject);
        this._myPrevObject = easyObject;
        this._myManualVariableUpdate = false;
      }
    }
  }
  canUpdate() {
    return true;
  }
};

// dist/pp/tool/easy_tune/easy_object_tuners/easy_active.js
var EasyActive = class extends EasyObjectTuner {
  _myComponentsToIgnore;
  constructor(componentsToIgnore, object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine);
    this._myComponentsToIgnore = componentsToIgnore;
  }
  _getVariableNamePrefix() {
    return "Active ";
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneBool(variableName, this._getDefaultValue(), null, true, void 0, this._myEngine);
  }
  _getObjectValue(object) {
    let active = false;
    const components = object.pp_getComponents();
    for (const component of components) {
      if (!this._myComponentsToIgnore.pp_hasEqual(component) && component.active) {
        active = true;
        break;
      }
    }
    return active;
  }
  _getDefaultValue() {
    return true;
  }
  _areValueEqual(first2, second) {
    return first2 == second;
  }
  _updateObjectValue(object, value) {
    const componentToIgnoreState = /* @__PURE__ */ new Map();
    for (const componentToIgnore of this._myComponentsToIgnore) {
      componentToIgnoreState.set(componentToIgnore, componentToIgnore.active);
    }
    object.pp_setActive(value);
    for (const [componentToIgnore, active] of componentToIgnoreState.entries()) {
      componentToIgnore.active = active;
    }
  }
  canUpdate() {
    const easyTuneVariable = this.getEasyTuneVariable();
    return easyTuneVariable == null || easyTuneVariable.isWidgetCurrentVariable();
  }
};

// dist/pp/tool/easy_tune/easy_object_tuners/components/easy_active_component.js
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EasyActiveComponent = class extends Component {
  static TypeName = "pp-easy-active";
  _myVariableName;
  _mySetAsWidgetCurrentVariable;
  _myUseTuneTarget;
  _myEasyObjectTuner = null;
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      } else {
        this._myEasyObjectTuner = new EasyActive([this], this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget, this.engine);
        this._myEasyObjectTuner.start();
      }
    }
  }
  onActivate() {
    if (this._myEasyObjectTuner != null) {
      this._myEasyObjectTuner.setActive(true);
    }
  }
  onDeactivate() {
    if (this._myEasyObjectTuner != null) {
      this._myEasyObjectTuner.setActive(false);
    }
  }
  getEasyObjectTuner() {
    return this._myEasyObjectTuner;
  }
  pp_clone(targetObject) {
    const clonedComponent = ComponentUtils.cloneDefault(this, targetObject);
    return clonedComponent;
  }
};
__decorate([
  property.string("")
], EasyActiveComponent.prototype, "_myVariableName", void 0);
__decorate([
  property.bool(false)
], EasyActiveComponent.prototype, "_mySetAsWidgetCurrentVariable", void 0);
__decorate([
  property.bool(false)
], EasyActiveComponent.prototype, "_myUseTuneTarget", void 0);

// dist/pp/pp/register_pp_components.js
function registerPPComponents(engine) {
  engine.registerComponent(AddPPToWindowComponent, AddWLToWindowComponent, AdjustHierarchyPhysXScaleComponent, AnalyticsManagerComponent, AudioManagerComponent, BenchmarkMaxPhysXComponent, BenchmarkMaxVisibleTrianglesComponent, CADisplayLeaderboardComponent, CharacterCollisionSystemComponent, ClearConsoleComponent, ConsoleVRToolComponent, CopyHandTransformComponent, CopyHeadTransformComponent, CopyReferenceSpaceTransformComponent, CopyPlayerTransformComponent, DebugPPArrayCreationPerformanceAnalyzerComponent, DebugArrayFunctionsPerformanceAnalyzerComponent, DebugFunctionsPerformanceAnalyzerComponent, DebugManagerComponent, DebugPPFunctionsPerformanceAnalyzerComponent, DebugTransformComponent, DebugWLComponentsFunctionsPerformanceAnalyzerComponent, DebugWLFunctionsPerformanceAnalyzerComponent, EasyLightAttenuationComponent, EasyLightColorComponent, EasyMeshColorComponent, EasyScaleComponent, EasySetTuneTargeetGrabComponent, EasySetTuneTargetChildNumberComponent, EasyTextColorComponent, EasyTransformComponent, EasyTuneImportVariablesComponent, EasyTuneToolComponent, EasyActiveComponent, EnableDebugComponent, EnableToolComponent, OverlapCursorComponent, FingerCursorComponent, GamepadControlSchemeComponent, GamepadMeshAnimatorComponent, GetDefaultResourcesComponent, GetSceneObjectsComponent, GrabbableComponent, GrabberHandComponent, InitConsoleVRComponent, InitEasyTuneVariablesComponent, InputManagerComponent, MuteEverythingComponent, ObjectPoolManagerComponent, PPGatewayComponent, PlayerLocomotionComponent, SaveManagerComponent, ScaleOnSpawnComponent, SetActiveComponent, SetEngineLogLevelComponent, SetHandLocalTransformComponent, SetHandRayLocalTransformComponent, SetHeadLocalTransformComponent, SetPlayerHeightComponent, SetTrackedHandJointLocalTransformComponent, ShowFPSComponent, ShowXRButtonsComponent, SpatialAudioListenerComponent, SwitchHandObjectComponent, ToggleActiveOnButtonPressComponent, ToolCursorComponent, TrackedHandDrawAllJointsComponent, TrackedHandDrawJointComponent, TrackedHandDrawSkinComponent, VirtualGamepadComponent, VisualManagerComponent);
}

// dist/pp/pp/components/pp_gateway_component.js
import { Component as Component19, Property as Property13 } from "@wonderlandengine/api";

// dist/pp/audio/components/audio_manager_component.js
import { Component as Component2, Property } from "@wonderlandengine/api";

// dist/pp/audio/audio_manager.js
import { Howler as Howler2 } from "howler";

// dist/pp/audio/audio_player.js
import { RetainEmitter } from "@wonderlandengine/api";
import { Howl, Howler } from "howler";

// dist/pp/audio/audio_setup.js
var AudioSetup = class _AudioSetup {
  myAudioFilePath = null;
  myLoop = false;
  myAutoPlay = false;
  myVolume = 1;
  /** From `0.5` to `4.0` */
  _myRate = 1;
  myPool = 5;
  myPreload = true;
  myPreventPlayWhenAudioContextNotRunning = false;
  // Spatial Params
  myPosition = null;
  mySpatial = true;
  /** At this distance (and closer) the volume is not reduced */
  myReferenceDistance = 1;
  // End Spatial Params
  constructor(audioFilePath) {
    if (audioFilePath != null) {
      this.myAudioFilePath = audioFilePath;
    }
  }
  clone() {
    const audioSetup = new _AudioSetup();
    audioSetup.myAudioFilePath = this.myAudioFilePath;
    audioSetup.myLoop = this.myLoop;
    audioSetup.myAutoPlay = this.myAutoPlay;
    audioSetup.myVolume = this.myVolume;
    audioSetup.myPitch = this.myPitch;
    audioSetup.myRate = this.myRate;
    audioSetup.myPool = this.myPool;
    audioSetup.myPreload = this.myPreload;
    audioSetup.myPreventPlayWhenAudioContextNotRunning = this.myPreventPlayWhenAudioContextNotRunning;
    if (this.myPosition != null) {
      audioSetup.myPosition = this.myPosition.vec3_clone();
    } else {
      audioSetup.myPosition = null;
    }
    audioSetup.mySpatial = this.mySpatial;
    audioSetup.myReferenceDistance = this.myReferenceDistance;
    return audioSetup;
  }
  get myPitch() {
    return this._myRate;
  }
  get myRate() {
    return this._myRate;
  }
  set myPitch(pitch) {
    this._myRate = pitch;
  }
  set myRate(rate) {
    this._myRate = rate;
  }
};

// dist/pp/audio/audio_player.js
var AudioEvent = {
  END: "end",
  STOP: "stop",
  LOAD: "load",
  LOAD_ERROR: "loaderror",
  PLAY: "play",
  PLAY_ERROR: "playerror",
  PAUSE: "pause",
  MUTE: "mute",
  VOLUME: "volume",
  RATE: "rate",
  SEEK: "seek",
  FADE: "fade",
  UNLOCK: "unlock"
};
var AudioPlayer = class {
  /**
   * TS type inference helper
   *
   * @param {any} audioInstance
   */
  constructor(audioSetupOrAudioFilePath, audioInstance = null) {
    if (audioSetupOrAudioFilePath == null) {
      this._myAudioSetup = new AudioSetup();
    } else if (typeof audioSetupOrAudioFilePath == "string") {
      this._myAudioSetup = new AudioSetup(audioSetupOrAudioFilePath);
    } else {
      this._myAudioSetup = audioSetupOrAudioFilePath.clone();
    }
    this._myAudio = null;
    if (audioInstance == null) {
      this._myAudio = new Howl({
        src: [this._myAudioSetup.myAudioFilePath],
        loop: this._myAudioSetup.myLoop,
        volume: this._myAudioSetup.myVolume,
        autoplay: false,
        rate: this._myAudioSetup.myRate,
        pool: this._myAudioSetup.myPool,
        pos: this._myAudioSetup.mySpatial ? this._myAudioSetup.myPosition : null,
        refDistance: this._myAudioSetup.myReferenceDistance,
        preload: this._myAudioSetup.myPreload
      });
      this._myAudio._pannerAttr.refDistance = this._myAudioSetup.myReferenceDistance;
    } else {
      this._myAudio = audioInstance;
    }
    this._myLastAudioID = null;
    this._myAudioEventEmitters = /* @__PURE__ */ new Map();
    for (let eventKey in AudioEvent) {
      this._myAudioEventEmitters.set(AudioEvent[eventKey], new RetainEmitter());
    }
    this._addListeners();
    if (this._myAudioSetup.myAutoPlay) {
      this.play();
    }
    this._myDestroyed = false;
  }
  isValid() {
    return this._myAudio != null;
  }
  play() {
    if (Howler.state != "running" && this._myAudioSetup.myPreventPlayWhenAudioContextNotRunning) {
      return false;
    }
    let audioID = this._myAudio.play();
    if (audioID != null) {
      this._myLastAudioID = audioID;
      this.updatePosition(this._myAudioSetup.myPosition, true);
      this.updatePitch(this._myAudioSetup.myPitch, true);
      this.updateVolume(this._myAudioSetup.myVolume, true);
    }
    return audioID != null;
  }
  stop() {
    this._myAudio.stop();
  }
  pause() {
    this._myAudio.pause();
  }
  resume() {
    this._myAudio.play();
  }
  isPlaying(checkOnlyLast = false) {
    let playing = false;
    if (checkOnlyLast) {
      playing = this._myAudio.playing(this._myLastAudioID);
    } else {
      playing = this._myAudio.playing();
    }
    return playing;
  }
  isLoaded() {
    return this._myAudio.state() == "loaded";
  }
  fade(fromVolume, toVolume, duration, updateOnlyLast = true, setValueOnPlayer = true) {
    if (setValueOnPlayer) {
      this.setVolume(toVolume);
    }
    if (updateOnlyLast) {
      this._myAudio.fade(fromVolume, toVolume, duration * 1e3, this._myLastAudioID);
    } else {
      this._myAudio.fade(fromVolume, toVolume, duration * 1e3);
    }
  }
  isFading(checkOnlyLast = true) {
    let fading = false;
    if (checkOnlyLast) {
      let lastSound = this._myAudio._soundById(this._myLastAudioID);
      if (lastSound != null) {
        fading = lastSound._fadeTo != null;
      }
    } else {
      for (let sound of this._myAudio._sounds) {
        if (sound._fadeTo != null) {
          fading = true;
          break;
        }
      }
    }
    return fading;
  }
  updatePosition(position, updateOnlyLast = true, setValueOnPlayer = true) {
    if (setValueOnPlayer) {
      this.setPosition(position);
    }
    if (this._myAudioSetup.mySpatial && position) {
      if (updateOnlyLast) {
        this._myAudio.pos(position[0], position[1], position[2], this._myLastAudioID);
      } else {
        this._myAudio.pos(position[0], position[1], position[2]);
      }
    }
  }
  updatePitch(pitch, updateOnlyLast = true, setValueOnPlayer = true) {
    this.updateRate(pitch, updateOnlyLast, setValueOnPlayer);
  }
  updateRate(rate, updateOnlyLast = true, setValueOnPlayer = true) {
    if (setValueOnPlayer) {
      this.setRate(rate);
    }
    if (rate != null) {
      if (updateOnlyLast) {
        this._myAudio.rate(rate, this._myLastAudioID);
      } else {
        this._myAudio.rate(rate);
      }
    }
  }
  updateVolume(volume, updateOnlyLast = true, setValueOnPlayer = true) {
    if (setValueOnPlayer) {
      this.setVolume(volume);
    }
    if (volume != null) {
      if (updateOnlyLast) {
        this._myAudio.volume(volume, this._myLastAudioID);
      } else {
        this._myAudio.volume(volume);
      }
    }
  }
  setSpatial(spatial) {
    this._myAudioSetup.mySpatial = spatial;
  }
  setPosition(position) {
    this._myAudioSetup.myPosition = position;
  }
  setPitch(pitch) {
    this._myAudioSetup.myPitch = pitch;
  }
  setRate(rate) {
    this._myAudioSetup.myRate = rate;
  }
  setVolume(volume) {
    this._myAudioSetup.myVolume = volume;
  }
  getDuration() {
    return this._myAudio.duration();
  }
  getVolume() {
    return this._myAudioSetup.myVolume;
  }
  getPitch() {
    return this._myAudioSetup.myPitch;
  }
  getRate() {
    return this._myAudioSetup.myRate;
  }
  registerAudioEventListener(audioEvent, id, listener, notifyOnce = false, notifyIfAlreadyHappened = false) {
    this._myAudioEventEmitters.get(audioEvent).add(listener, { id, once: notifyOnce, immediate: notifyIfAlreadyHappened });
  }
  unregisterAudioEventListener(audioEvent, id) {
    this._myAudioEventEmitters.get(audioEvent).remove(id);
  }
  _addListeners() {
    if (this._myAudio != null) {
      for (let eventKey in AudioEvent) {
        let event = AudioEvent[eventKey];
        this._myAudio.on(event, function(audioID) {
          let emitter = this._myAudioEventEmitters.get(event);
          emitter.notify(audioID);
        }.bind(this));
      }
    }
  }
  destroy() {
    this._myDestroyed = true;
    this._myAudio.unload();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/audio/audio_manager.js
var AudioManager = class {
  constructor(preloadAudio = true, engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myPreloadAudio = preloadAudio;
    this._myAudioSetups = /* @__PURE__ */ new Map();
    this._myAudioPlayersCreatedForPreload = [];
  }
  createAudioPlayer(audioSetupID) {
    let audioSetup = this.getAudioSetup(audioSetupID);
    if (audioSetup != null) {
      return new AudioPlayer(this.getAudioSetup(audioSetupID));
    }
    return null;
  }
  getAudioSetup(id) {
    return this._myAudioSetups.get(id);
  }
  addAudioSetup(id, audioSetup, preloadAudioOverride = null) {
    this._myAudioSetups.set(id, audioSetup);
    if (this._myPreloadAudio && preloadAudioOverride == null || preloadAudioOverride != null && preloadAudioOverride) {
      this._myAudioPlayersCreatedForPreload.push(this.createAudioPlayer(id));
    }
  }
  removeAudioSetup(id) {
    this._myAudioSetups.delete(id);
  }
  /**
   * Actually changes the volume of Howler, which means it changes it even for a new scene if you switch it
   * and use a different audio manager
   */
  setVolume(volume) {
    Howler2.volume(volume);
  }
  /**
   * Actually mute Howler, which means it changes it even for a new scene if you switch it
   * and use a different audio manager
   */
  setMute(mute) {
    Howler2.mute(mute);
  }
  /**
   * Actually stops Howler, which means it stops every audio, even for a new scene if you switch it
   * and use a different audio manager
   */
  stop() {
    Howler2.stop();
  }
  /**
   * Actually unload all audio sources in Howler, which means it unloads them even for other scenes
   *
   * Use this with caution
   */
  unloadAllAudioSources() {
    Howler2.unload();
  }
};

// dist/pp/audio/components/audio_manager_component.js
var AudioManagerComponent = class extends Component2 {
  static TypeName = "pp-audio-manager";
  static Properties = {
    _myPreloadAudio: Property.bool(false),
    _myStopAudioOnDeactivate: Property.bool(false)
  };
  start() {
    this._myAudioManager = new AudioManager(this._myPreloadAudio, this.engine);
  }
  onActivate() {
    if (!Globals.hasAudioManager(this.engine)) {
      Globals.setAudioManager(this._myAudioManager, this.engine);
    }
  }
  onDeactivate() {
    if (this._myAudioManager != null && Globals.getAudioManager(this.engine) == this._myAudioManager) {
      Globals.removeAudioManager(this.engine);
      if (this._myStopAudioOnDeactivate) {
        this._myAudioManager.stop();
      }
    }
  }
};

// dist/pp/cauldron/cauldron/components/analytics_manager_component.js
import { Component as Component3, Property as Property2 } from "@wonderlandengine/api";

// dist/pp/cauldron/utils/xr_utils.js
function getSession(engine = Globals.getMainEngine()) {
  const xr = Globals.getXR(engine);
  return xr != null ? xr.session : null;
}
function getSessionMode(engine = Globals.getMainEngine()) {
  const xr = Globals.getXR(engine);
  return xr != null ? xr.sessionMode : null;
}
function getReferenceSpace(engine = Globals.getMainEngine()) {
  const xr = Globals.getXR(engine);
  return xr != null ? xr.currentReferenceSpace : null;
}
function getReferenceSpaceType(engine = Globals.getMainEngine()) {
  let type = "local";
  try {
    const xr = Globals.getXR(engine);
    type = xr != null ? xr.currentReferenceSpaceType : null;
  } catch (error4) {
  }
  return type;
}
function getFrame(engine = Globals.getMainEngine()) {
  const xr = Globals.getXR(engine);
  return xr != null ? xr.frame : null;
}
function isSessionActive(engine = Globals.getMainEngine()) {
  return XRUtils.getSession(engine) != null;
}
function isReferenceSpaceFloorBased(engine = Globals.getMainEngine()) {
  const referenceSpaceType = XRUtils.getReferenceSpaceType(engine);
  return referenceSpaceType != null ? referenceSpaceType.includes("floor") : false;
}
function exitSession(engine = Globals.getMainEngine()) {
  const xrSession = XRUtils.getSession(engine);
  if (xrSession != null) {
    xrSession.end();
  }
}
function registerSessionStartEventListener(id, listener, manuallyCallSessionStartIfSessionAlreadyActive = true, addManualCallFlagToStartListener = false, engine = Globals.getMainEngine()) {
  if (listener != null) {
    if (addManualCallFlagToStartListener) {
      const manualStartListener = listener;
      engine.onXRSessionStart.add(manualStartListener.bind(void 0, false), { id, immediate: false });
    } else {
      const standardListener = listener;
      engine.onXRSessionStart.add(standardListener, { id, immediate: false });
    }
    if (manuallyCallSessionStartIfSessionAlreadyActive && XRUtils.isSessionActive(engine)) {
      if (addManualCallFlagToStartListener) {
        const manualStartListener = listener;
        manualStartListener(true, XRUtils.getSession(engine), XRUtils.getSessionMode(engine));
      } else {
        const standardListener = listener;
        standardListener(XRUtils.getSession(engine), XRUtils.getSessionMode(engine));
      }
    }
  }
}
function unregisterSessionStartEventListener(id, engine = Globals.getMainEngine()) {
  engine.onXRSessionStart.remove(id);
}
function registerSessionEndEventListener(id, listener, engine = Globals.getMainEngine()) {
  if (listener != null) {
    engine.onXRSessionEnd.add(listener, { id });
  }
}
function unregisterSessionEndEventListener(id, engine = Globals.getMainEngine()) {
  engine.onXRSessionEnd.remove(id);
}
function registerSessionStartEndEventListeners(id, startListener, endListener, manuallyCallSessionStartIfSessionAlreadyActive = true, addManualCallFlagToStartListener = false, engine = Globals.getMainEngine()) {
  XRUtils.registerSessionEndEventListener(id, endListener, engine);
  XRUtils.registerSessionStartEventListener(id, startListener, manuallyCallSessionStartIfSessionAlreadyActive, addManualCallFlagToStartListener, engine);
}
function unregisterSessionStartEndEventListeners(id, engine = Globals.getMainEngine()) {
  XRUtils.unregisterSessionEndEventListener(id, engine);
  XRUtils.unregisterSessionStartEventListener(id, engine);
}
function isXRSupported(engine = Globals.getMainEngine()) {
  return XRUtils.isVRSupported(engine) || XRUtils.isARSupported(engine);
}
function isVRSupported(engine = Globals.getMainEngine()) {
  return engine.vrSupported;
}
function isARSupported(engine = Globals.getMainEngine()) {
  return engine.arSupported;
}
function isDeviceEmulated(onlyOnLocalhost = true) {
  const emulated = window.CustomWebXRPolyfill != null && (!onlyOnLocalhost || BrowserUtils.isLocalhost());
  return emulated;
}
var XRUtils = {
  getSession,
  getSessionMode,
  getReferenceSpace,
  getReferenceSpaceType,
  getFrame,
  isSessionActive,
  exitSession,
  registerSessionStartEventListener,
  unregisterSessionStartEventListener,
  registerSessionEndEventListener,
  unregisterSessionEndEventListener,
  registerSessionStartEndEventListeners,
  unregisterSessionStartEndEventListeners,
  isReferenceSpaceFloorBased,
  isXRSupported,
  isVRSupported,
  isARSupported,
  isDeviceEmulated
};

// dist/pp/cauldron/utils/browser_utils.js
var isMobile = function() {
  let checkMobileRegex = new RegExp("Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini", "i");
  return function isMobile2() {
    let userAgent = navigator.userAgent;
    return userAgent != null && userAgent.match(checkMobileRegex) != null;
  };
}();
function isDesktop() {
  return !BrowserUtils.isMobile();
}
var isLocalhost = function() {
  let localhostRegex = new RegExp("(localhost|127\\.0\\.0\\.1)(:(\\d{4}))?");
  return function isLocalhost2(port = null, isRegex = false) {
    let isLocalhost3 = false;
    let localhostMatch = window.location.origin.match(localhostRegex);
    if (localhostMatch != null) {
      if (port == null) {
        isLocalhost3 = true;
      } else if (localhostMatch.length >= 4 && localhostMatch[3] != null) {
        let portMatch = localhostMatch[3];
        if (isRegex) {
          isLocalhost3 = portMatch.match(port) != null;
        } else {
          isLocalhost3 = portMatch == port;
        }
      }
    }
    return isLocalhost3;
  };
}();
function openLink(url, newTab = true, exitXRSessionBeforeOpen = true, exitXRSessionOnSuccess = true, tryOpenLinkOnClickOnFailure = false, onSuccessCallback = null, onFailureCallback = null, engine = Globals.getMainEngine()) {
  let element = document.createElement("a");
  element.style.display = "none";
  document.body.appendChild(element);
  element.addEventListener("click", function() {
    let targetPage = void 0;
    if (newTab) {
      targetPage = "_blank";
    } else {
      targetPage = "_top";
    }
    let result = window.open(url, targetPage);
    if (result != null) {
      if (!exitXRSessionBeforeOpen && exitXRSessionOnSuccess) {
        XRUtils.exitSession(engine);
      }
      if (onSuccessCallback != null) {
        onSuccessCallback();
      }
    } else {
      if (tryOpenLinkOnClickOnFailure) {
        setTimeout(function() {
          BrowserUtils.openLinkOnClick(url, newTab, exitXRSessionOnSuccess, onSuccessCallback, onFailureCallback);
        }, 100);
      } else if (onFailureCallback != null) {
        onFailureCallback();
      }
    }
  });
  if (exitXRSessionBeforeOpen) {
    XRUtils.exitSession(engine);
  }
  element.click();
  document.body.removeChild(element);
}
function openLinkOnClick(url, newTab = true, exitXRSessionOnSuccess = true, onSuccessCallback = null, onFailureCallback = null, engine = Globals.getMainEngine()) {
  document.addEventListener("click", function() {
    let targetPage = void 0;
    if (newTab) {
      targetPage = "_blank";
    } else {
      targetPage = "_top";
    }
    let result = window.open(url, targetPage);
    if (result != null) {
      if (exitXRSessionOnSuccess) {
        XRUtils.exitSession(engine);
      }
      if (onSuccessCallback != null) {
        onSuccessCallback();
      }
    } else {
      if (onFailureCallback != null) {
        onFailureCallback();
      }
    }
  }, { once: true });
}
var BrowserUtils = {
  isMobile,
  isDesktop,
  isLocalhost,
  openLink,
  openLinkOnClick
};

// dist/pp/cauldron/cauldron/analytics_manager.js
var AnalyticsManager = class {
  _myAnalyticsEnabled = true;
  _mySendDataCallback = null;
  _myDefaultEventCooldown = 0;
  _myEventCooldowns = /* @__PURE__ */ new Map();
  _myEventsSentOnce = [];
  _myDataLogEnabled = false;
  _myEventsLogEnabled = false;
  _myErrorsLogEnabled = false;
  update(dt) {
    if (this._myEventCooldowns.size > 0) {
      for (const [eventName, eventCooldown] of this._myEventCooldowns.entries()) {
        const newCooldown = eventCooldown - dt;
        if (newCooldown <= 0) {
          this._myEventCooldowns.delete(eventName);
        } else {
          this._myEventCooldowns.set(eventName, newCooldown);
        }
      }
    }
  }
  setAnalyticsEnabled(enabled) {
    this._myAnalyticsEnabled = enabled;
  }
  isAnalyticsEnabled() {
    return this._myAnalyticsEnabled;
  }
  setSendDataCallback(callback) {
    this._mySendDataCallback = callback;
  }
  sendData(...args) {
    let dataSent = false;
    try {
      if (this._myAnalyticsEnabled) {
        if (this._myDataLogEnabled) {
          console.log("Analytics Data: " + args);
        }
        if (this._mySendDataCallback != null) {
          this._mySendDataCallback(...args);
          dataSent = true;
        } else if (this._myErrorsLogEnabled) {
          console.error("Analytics Error: You need to set the send data callback");
        } else {
          console.warn("Analytics Error: You need to set the send data callback");
        }
      }
    } catch (error4) {
      if (this._myErrorsLogEnabled) {
        console.error(error4);
      }
      dataSent = false;
    }
    return dataSent;
  }
  sendEvent(eventName, params) {
    let eventSent = false;
    try {
      if (this._myAnalyticsEnabled) {
        if (this._myEventsLogEnabled) {
          if (params != null) {
            console.log("Analytics Event: " + eventName + " - Params:", params);
          } else {
            console.log("Analytics Event: " + eventName);
          }
        }
        if (this._mySendDataCallback != null) {
          if (params != null) {
            this._mySendDataCallback("event", eventName, params);
          } else {
            this._mySendDataCallback("event", eventName);
          }
          eventSent = true;
        } else if (this._myErrorsLogEnabled) {
          console.error("Analytics Error: You need to set the send data callback");
        } else {
          console.warn("Analytics Error: You need to set the send data callback");
        }
      }
    } catch (error4) {
      if (this._myErrorsLogEnabled) {
        console.error(error4);
      }
      eventSent = false;
    }
    return eventSent;
  }
  sendEventOnce(eventName, params) {
    let eventSent = false;
    if (this._myAnalyticsEnabled) {
      if (!this.hasEventAlreadyBeenSent(eventName)) {
        eventSent = this.sendEvent(eventName, params);
        if (eventSent) {
          this._myEventsSentOnce.pp_pushUnique(eventName);
        }
      }
    }
    return eventSent;
  }
  sendEventWithValue(eventName, value) {
    return this.sendEvent(eventName, { "value": value });
  }
  sendEventOnceWithValue(eventName, value) {
    return this.sendEventOnce(eventName, { "value": value });
  }
  clearEventSentOnceState(eventName) {
    this._myEventsSentOnce.pp_removeEqual(eventName);
  }
  clearAllEventsSentOnceState() {
    this._myEventsSentOnce.pp_clear();
  }
  hasEventAlreadyBeenSent(eventName) {
    return this._myEventsSentOnce.pp_hasEqual(eventName);
  }
  getEventsAlreadyBeenSent() {
    return this._myEventsSentOnce;
  }
  sendEventWithCooldown(eventName, cooldownSeconds = this._myDefaultEventCooldown, params) {
    let eventSent = false;
    if (this._myAnalyticsEnabled) {
      if (this.getEventCooldown(eventName) <= 0) {
        eventSent = this.sendEvent(eventName, params);
        if (eventSent) {
          this._myEventCooldowns.set(eventName, cooldownSeconds);
        }
      }
    }
    return eventSent;
  }
  getDefaultEventCooldown() {
    return this._myDefaultEventCooldown;
  }
  setDefaultEventCooldown(cooldownSeconds) {
    this._myDefaultEventCooldown = cooldownSeconds;
  }
  clearEventCooldown(eventName) {
    this._myEventCooldowns.delete(eventName);
  }
  clearAllEventCooldowns() {
    this._myEventCooldowns.clear();
  }
  getEventCooldown(eventName) {
    const eventCooldown = this._myEventCooldowns.get(eventName);
    if (eventCooldown != null) {
      return eventCooldown;
    }
    return 0;
  }
  getEventCooldowns() {
    return this._myEventCooldowns;
  }
  setDataLogEnabled(enabled) {
    this._myDataLogEnabled = enabled;
  }
  isDataLogEnabled() {
    return this._myDataLogEnabled;
  }
  setEventsLogEnabled(enabled) {
    this._myEventsLogEnabled = enabled;
  }
  isEventsLogEnabled() {
    return this._myEventsLogEnabled;
  }
  setErrorsLogEnabled(enabled) {
    this._myErrorsLogEnabled = enabled;
  }
  isErrorsLogEnabled() {
    return this._myErrorsLogEnabled;
  }
};

// dist/pp/cauldron/cauldron/components/analytics_manager_component.js
var AnalyticsManagerComponent = class extends Component3 {
  static TypeName = "pp-analytics-manager";
  static Properties = {
    _myDisableAnalyticsOnLocalhost: Property2.bool(true)
  };
  start() {
    this._myAnalyticsManager = new AnalyticsManager();
  }
  update(dt) {
    if (Globals.getAnalyticsManager(this.engine) == this._myAnalyticsManager) {
      this._myAnalyticsManager.update(dt);
    }
  }
  onActivate() {
    if (!Globals.hasAnalyticsManager(this.engine)) {
      if (BrowserUtils.isLocalhost() && this._myDisableAnalyticsOnLocalhost) {
        this._myAnalyticsManager.setAnalyticsEnabled(false);
      }
      Globals.setAnalyticsManager(this._myAnalyticsManager, this.engine);
    }
  }
  onDeactivate() {
    if (this._myAnalyticsManager != null) {
      this._myAnalyticsManager.clearAllEventCooldowns();
      if (Globals.getAnalyticsManager(this.engine) == this._myAnalyticsManager) {
        Globals.removeAnalyticsManager(this.engine);
      }
    }
  }
};

// dist/pp/cauldron/cauldron/components/clear_console_component.js
import { Component as Component4, property as property2 } from "@wonderlandengine/api";
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ClearConsoleComponent = class extends Component4 {
  static TypeName = "pp-clear-console";
  _myWhen;
  _myFirstTimeOnly;
  _myFirstTimeDone = false;
  init() {
    if (this.markedActive && this._myWhen == 0) {
      this._clearConsole();
    }
  }
  start() {
    if (this._myWhen == 1) {
      this._clearConsole();
    }
  }
  update(dt) {
    if (this._myWhen == 2) {
      this._clearConsole();
    }
  }
  _onXRSessionStart() {
    if (this._myWhen == 3) {
      this._clearConsole();
    }
  }
  _onXRSessionEnd() {
    if (this._myWhen == 4) {
      this._clearConsole();
    }
  }
  _clearConsole() {
    if (!this._myFirstTimeOnly || !this._myFirstTimeDone) {
      console.clear();
      this._myFirstTimeDone = true;
    }
    if (this._myFirstTimeOnly && this._myFirstTimeDone) {
      this.active = false;
    }
  }
  onActivate() {
    if (this._myWhen == 3) {
      XRUtils.registerSessionStartEventListener(this, this._onXRSessionStart.bind(this), true, true, this.engine);
    }
    if (this._myWhen == 4) {
      XRUtils.registerSessionEndEventListener(this, this._onXRSessionEnd.bind(this), this.engine);
    }
  }
  onDeactivate() {
    XRUtils.unregisterSessionStartEndEventListeners(this, this.engine);
  }
};
__decorate2([
  property2.enum(["Init", "Start", "Update", "Enter XR", "Exit XR"], "Init")
], ClearConsoleComponent.prototype, "_myWhen", void 0);
__decorate2([
  property2.bool(true)
], ClearConsoleComponent.prototype, "_myFirstTimeOnly", void 0);

// dist/pp/cauldron/cauldron/components/save_manager_component.js
import { Component as Component5, Property as Property3 } from "@wonderlandengine/api";

// dist/pp/cauldron/cauldron/save_manager.js
import { Emitter as Emitter3 } from "@wonderlandengine/api";

// dist/pp/cauldron/utils/save_utils.js
function save(id, value) {
  if (value != null) {
    localStorage.setItem(id, value);
  }
}
function has2(id) {
  return SaveUtils.loadString(id) != null;
}
function remove2(id) {
  return localStorage.removeItem(id);
}
function clear2() {
  return localStorage.clear();
}
function load(id, defaultValue = null) {
  return SaveUtils.loadString(id, defaultValue);
}
function loadString(id, defaultValue = null) {
  const item = localStorage.getItem(id);
  if (item != null) {
    return item;
  }
  return defaultValue;
}
function loadNumber(id, defaultValue = null) {
  const item = SaveUtils.loadString(id);
  if (item != null && item.trim() != "" && (item == "NaN" || !isNaN(Number(item)))) {
    return Number(item);
  }
  return defaultValue;
}
function loadBool(id, defaultValue = null) {
  const item = SaveUtils.loadString(id);
  if (item == "true") {
    return true;
  } else if (item == "false") {
    return false;
  }
  return defaultValue;
}
function loadObject(id, defaultValue = null) {
  const item = SaveUtils.loadString(id);
  if (item != null) {
    try {
      const parsedObject = JSON.parse(item);
      if (parsedObject.constructor == Object) {
        return parsedObject;
      }
    } catch (error4) {
    }
  }
  return defaultValue;
}
function loadArray(id, defaultValue = null) {
  const item = SaveUtils.loadString(id);
  if (item != null) {
    try {
      const parsedArray = JSON.parse(item);
      if (Array.isArray(parsedArray)) {
        return parsedArray;
      }
    } catch (error4) {
    }
  }
  return defaultValue;
}
function loadVector(id, defaultValue = null) {
  const item = SaveUtils.loadString(id);
  if (item != null) {
    try {
      const parsedVector = JSON.parse(item);
      if (Array.isArray(parsedVector)) {
        let areAllNumbers = true;
        for (const value of parsedVector) {
          if (typeof value != "number") {
            areAllNumbers = false;
            break;
          }
        }
        if (areAllNumbers) {
          return parsedVector;
        }
      }
    } catch (error4) {
    }
  }
  return defaultValue;
}
var SaveUtils = {
  save,
  has: has2,
  remove: remove2,
  clear: clear2,
  load,
  loadString,
  loadNumber,
  loadBool,
  loadObject,
  loadArray,
  loadVector
};

// dist/pp/cauldron/cauldron/timer.js
import { Emitter as Emitter2 } from "@wonderlandengine/api";
var Timer = class {
  _myDuration = 0;
  _myTimeLeft = 0;
  _myDone = false;
  _myJustDone = false;
  _myStarted = false;
  _myOnEndEmitter = new Emitter2();
  constructor(duration, autoStart = true) {
    this._myDuration = duration;
    if (autoStart) {
      this.start();
    } else {
      this.reset();
    }
  }
  start(duration) {
    this.reset(duration);
    this._myStarted = true;
  }
  end() {
    this._done();
  }
  reset(duration) {
    if (duration != null) {
      this._myDuration = Math.max(0, duration);
    }
    this._myTimeLeft = this._myDuration;
    this._myDone = false;
    this._myJustDone = false;
    this._myStarted = false;
  }
  update(dt) {
    this._myJustDone = false;
    if (this.isRunning()) {
      this._myTimeLeft = Math.max(0, this._myTimeLeft - dt);
      if (this._myTimeLeft == 0) {
        this._done();
      }
    }
  }
  isDone() {
    return this._myDone;
  }
  isJustDone() {
    return this._myJustDone;
  }
  isStarted() {
    return this._myStarted;
  }
  isRunning() {
    return this.isStarted() && !this.isDone();
  }
  getDuration() {
    return this._myDuration;
  }
  setDuration(duration) {
    const newDuration = Math.max(0, duration);
    if (this.isRunning()) {
      const timeElapsed = Math.max(0, this._myDuration - this._myTimeLeft);
      this._myTimeLeft = Math.max(0, newDuration - timeElapsed);
    }
    this._myDuration = newDuration;
  }
  getTimeLeft() {
    return this._myTimeLeft;
  }
  setTimeLeft(timeLeft, keepPercentage = false) {
    if (this.isRunning()) {
      const currentPercentage = this.getPercentage();
      this._myTimeLeft = Math.max(0, timeLeft);
      if (this._myTimeLeft > this._myDuration) {
        this._myDuration = this._myTimeLeft;
      }
      if (keepPercentage && this._myTimeLeft > MathUtils.EPSILON) {
        this._myDuration = this._myTimeLeft / Math.max(MathUtils.EPSILON, 1 - currentPercentage);
      }
    }
  }
  getTimeElapsed() {
    let timeElapsed = 0;
    if (this.isRunning()) {
      timeElapsed = this._myDuration - this._myTimeLeft;
    }
    return Math.max(0, timeElapsed);
  }
  setTimeElapsed(timeElapsed) {
    this.setTimeLeft(this._myDuration - Math.max(0, timeElapsed));
  }
  getPercentage() {
    let percentage = 1;
    if (this._myTimeLeft > 0 && this._myDuration > 0) {
      percentage = (this._myDuration - this._myTimeLeft) / this._myDuration;
    }
    return Math.pp_clamp(percentage, 0, 1);
  }
  setPercentage(percentage) {
    if (this.isRunning()) {
      const durationPercentage = Math.pp_clamp(1 - percentage, 0, 1);
      this._myTimeLeft = this._myDuration * durationPercentage;
    }
  }
  onEnd(listener, id) {
    this._myOnEndEmitter.add(listener, { id });
  }
  unregisterOnEnd(id) {
    this._myOnEndEmitter.remove(id);
  }
  _done() {
    this._myTimeLeft = 0;
    this._myDone = true;
    this._myJustDone = true;
    this._myOnEndEmitter.notify();
  }
};

// dist/pp/cauldron/cauldron/save_manager.js
var SaveManager = class {
  constructor(saveID, autoLoadSaves = true, engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._mySaveID = saveID;
    this._myCommitSavesDelayTimer = new Timer(0, false);
    this._myDelaySavesCommit = true;
    this._myCommitSavesDirty = false;
    this._myCommitSavesDirtyClearOnFail = true;
    this._myCommitSavesOnInterrupt = true;
    this._myCommitSavesWhenLoadSavesFailed = false;
    this._myResetSaveObjectOnLoadSavesFail = false;
    this._mySaveObject = {};
    this._myLoadSavesSucceded = false;
    this._mySaveObjectLoadedOnce = false;
    this._myAtLeastOneValueSavedOnce = false;
    this._myClearEmitter = new Emitter3();
    this._myDeleteEmitter = new Emitter3();
    this._myDeleteIDEmitters = /* @__PURE__ */ new Map();
    this._mySaveEmitter = new Emitter3();
    this._mySaveValueChangedEmitter = new Emitter3();
    this._mySaveIDEmitters = /* @__PURE__ */ new Map();
    this._mySaveValueChangedIDEmitters = /* @__PURE__ */ new Map();
    this._myCommitSavesEmitter = new Emitter3();
    this._myLoadEmitter = new Emitter3();
    this._myLoadIDEmitters = /* @__PURE__ */ new Map();
    this._myLoadSavesEmitter = new Emitter3();
    if (autoLoadSaves) {
      this.loadSaves();
    }
    this._myXRVisibilityChangeEventListener = null;
    this._myWindowVisibilityChangeEventListener = function() {
      if (document.visibilityState != "visible") {
        this._onInterrupt();
      }
    }.bind(this);
    this._myActive = false;
    this.setActive(true);
    this._myDestroyed = false;
  }
  setCommitSavesDelay(delay) {
    this._myCommitSavesDelayTimer.start(delay);
  }
  setDelaySavesCommit(delayed) {
    this._myDelaySavesCommit = delayed;
  }
  setCommitSavesDirty(dirty, startDelayTimer = true) {
    this._myCommitSavesDirty = dirty;
    if (dirty && startDelayTimer) {
      if (!this.startDelayTimer.isRunning()) {
        this._myCommitSavesDelayTimer.start();
      }
    } else {
      this._myCommitSavesDelayTimer.reset();
    }
  }
  setCommitSavesDirtyClearOnFail(clearOnFail) {
    this._myCommitSavesDirtyClearOnFail = clearOnFail;
  }
  setCommitSavesOnInterrupt(commitSavesOnInterrupt) {
    this._myCommitSavesOnInterrupt = commitSavesOnInterrupt;
  }
  setCommitSavesWhenLoadSavesFailed(commitSavesWhenLoadSavesFailed) {
    this._myCommitSavesWhenLoadSavesFailed = commitSavesWhenLoadSavesFailed;
  }
  setResetSaveObjectOnLoadSavesFail(resetSaveObjectOnLoadSavesFail) {
    this._myResetSaveObjectOnLoadSavesFail = resetSaveObjectOnLoadSavesFail;
  }
  getCommitSavesDelay() {
    return this._myCommitSavesDelayTimer.getDuration();
  }
  isDelaySavesCommit() {
    return this._myDelaySavesCommit;
  }
  isCommitSavesDirty() {
    return this._myCommitSavesDirty;
  }
  isCommitSavesDirtyClearOnFail() {
    return this._myCommitSavesDirtyClearOnFail;
  }
  isCommitSavesOnInterrupt() {
    return this._myCommitSavesOnInterrupt;
  }
  isCommitSavesWhenLoadSavesFailed() {
    return this._myCommitSavesWhenLoadSavesFailed;
  }
  isResetSaveObjectOnLoadSavesFail() {
    return this._myResetSaveObjectOnLoadSavesFail;
  }
  hasLoadSavesSucceded() {
    return this._myLoadSavesSucceded;
  }
  update(dt) {
    if (this._myCommitSavesDelayTimer.isRunning()) {
      this._myCommitSavesDelayTimer.update(dt);
      if (this._myCommitSavesDelayTimer.isDone()) {
        if (this._myCommitSavesDirty) {
          this._commitSaves();
        }
      }
    } else {
      if (this._myCommitSavesDirty) {
        this._commitSaves();
      }
    }
  }
  has(id) {
    return id in this._mySaveObject;
  }
  save(id, value, delaySavesCommitOverride = null) {
    let sameValue = false;
    if (this.has(id)) {
      sameValue = this._mySaveObject[id] === value;
    }
    if (!sameValue) {
      this._mySaveObject[id] = value;
      if (this._myDelaySavesCommit && delaySavesCommitOverride == null || delaySavesCommitOverride != null && delaySavesCommitOverride) {
        this._myCommitSavesDirty = true;
        if (!this._myCommitSavesDelayTimer.isRunning()) {
          this._myCommitSavesDelayTimer.start();
        }
      } else {
        this._commitSaves();
      }
    }
    this._myAtLeastOneValueSavedOnce = true;
    this._mySaveEmitter.notify(id, value);
    if (this._mySaveIDEmitters.size > 0) {
      let emitter = this._mySaveIDEmitters.get(id);
      if (emitter != null) {
        emitter.notify(id, value);
      }
    }
    if (!sameValue) {
      this._mySaveValueChangedEmitter.notify(id, value);
      if (this._mySaveValueChangedIDEmitters.size > 0) {
        let emitter = this._mySaveValueChangedIDEmitters.get(id);
        if (emitter != null) {
          emitter.notify(id, value);
        }
      }
    }
  }
  delete(id, delaySavesCommitOverride = null) {
    if (this.has(id)) {
      delete this._mySaveObject[id];
      if (this._myDelaySavesCommit && delaySavesCommitOverride == null || delaySavesCommitOverride != null && delaySavesCommitOverride) {
        this._myCommitSavesDirty = true;
        if (!this._myCommitSavesDelayTimer.isRunning()) {
          this._myCommitSavesDelayTimer.start();
        }
      } else {
        this._commitSaves();
      }
    }
    this._myAtLeastOneValueSavedOnce = true;
    this._myDeleteEmitter.notify(id);
    if (this._myDeleteIDEmitters.size > 0) {
      let emitter = this._myDeleteIDEmitters.get(id);
      if (emitter != null) {
        emitter.notify(id);
      }
    }
  }
  clear(delaySavesCommitOverride = null) {
    if (Object.keys(this._mySaveObject).length > 0) {
      this._mySaveObject = {};
      if (this._myDelaySavesCommit && delaySavesCommitOverride == null || delaySavesCommitOverride != null && delaySavesCommitOverride) {
        this._myCommitSavesDirty = true;
        if (!this._myCommitSavesDelayTimer.isRunning()) {
          this._myCommitSavesDelayTimer.start();
        }
      } else {
        this._commitSaves();
      }
    }
    this._myAtLeastOneValueSavedOnce = true;
    this._myClearEmitter.notify();
  }
  load(id, defaultValue) {
    let value = this._mySaveObject[id];
    if (value == null && defaultValue != null) {
      value = defaultValue;
    }
    this._myLoadEmitter.notify(id, value);
    if (this._myLoadIDEmitters.size > 0) {
      let emitter = this._myLoadIDEmitters.get(id);
      if (emitter != null) {
        emitter.notify(id, value);
      }
    }
    return value;
  }
  commitSaves(commitSavesOnlyIfDirty = true) {
    if (this._myCommitSavesDirty || !commitSavesOnlyIfDirty) {
      this._commitSaves();
    }
  }
  _commitSaves() {
    let succeded = true;
    if (this._myLoadSavesSucceded || this._myCommitSavesWhenLoadSavesFailed) {
      try {
        let saveObjectStringified = JSON.stringify(this._mySaveObject);
        SaveUtils.save(this._mySaveID, saveObjectStringified);
      } catch (error4) {
        succeded = false;
      }
    }
    if (succeded || this._myCommitSavesDirtyClearOnFail) {
      this._myCommitSavesDirty = false;
      this._myCommitSavesDelayTimer.reset();
    }
    this._myCommitSavesEmitter.notify(succeded);
    return succeded;
  }
  loadSaves() {
    let saveObject = {};
    let loadSavesSucceded = false;
    let saveObjectReset = false;
    let maxLoadObjectAttempts = 3;
    do {
      try {
        saveObject = SaveUtils.loadObject(this._mySaveID, {});
        loadSavesSucceded = true;
      } catch (error4) {
        maxLoadObjectAttempts--;
      }
    } while (maxLoadObjectAttempts > 0 && !loadSavesSucceded);
    if (loadSavesSucceded) {
      this._mySaveObject = saveObject;
      this._myLoadSavesSucceded = true;
    } else if (this._myResetSaveObjectOnLoadSavesFail) {
      this._mySaveObject = {};
      this._myLoadSavesSucceded = false;
      saveObjectReset = true;
    }
    this._mySaveObjectLoadedOnce = true;
    this._myLoadSavesEmitter.notify(loadSavesSucceded, saveObjectReset);
    return loadSavesSucceded;
  }
  _onXRSessionStart(session) {
    this._myXRVisibilityChangeEventListener = function(event) {
      if (event.session.visibilityState != "visible") {
        this._onInterrupt();
      }
    }.bind(this);
    session.addEventListener("visibilitychange", this._myXRVisibilityChangeEventListener);
  }
  _onXRSessionEnd() {
    this._myXRVisibilityChangeEventListener = null;
    this._onInterrupt();
  }
  _onInterrupt() {
    if (this._myCommitSavesOnInterrupt && this._myCommitSavesDirty && (this._mySaveObjectLoadedOnce || this._myAtLeastOneValueSavedOnce)) {
      this.commitSaves();
    }
  }
  registerClearEventListener(listenerID, listener) {
    this._myClearEmitter.add(listener, { id: listenerID });
  }
  unregisterClearEventListener(listenerID) {
    this._myClearEmitter.remove(listenerID);
  }
  registerDeleteEventListener(listenerID, listener) {
    this._myDeleteEmitter.add(listener, { id: listenerID });
  }
  unregisterDeleteEventListener(listenerID) {
    this._myDeleteEmitter.remove(listenerID);
  }
  registerDeleteIDEventListener(valueID, listenerID, listener) {
    let valueIDEmitter = this._myDeleteIDEmitters.get(valueID);
    if (valueIDEmitter == null) {
      this._myDeleteIDEmitters.set(valueID, /* @__PURE__ */ new Map());
      valueIDEmitter = this._myDeleteIDEmitters.get(valueID);
    }
    valueIDEmitter.add(listener, { id: listenerID });
  }
  unregisterDeleteIDEventListener(valueID, listenerID) {
    let valueIDEmitter = this._myDeleteIDEmitters.get(valueID);
    if (valueIDEmitter != null) {
      valueIDEmitter.remove(listenerID);
      if (valueIDEmitter.size <= 0) {
        this._myDeleteIDEmitters.delete(valueID);
      }
    }
  }
  registerSaveEventListener(listenerID, listener) {
    this._mySaveEmitter.add(listener, { id: listenerID });
  }
  unregisterSaveEventListener(listenerID) {
    this._mySaveEmitter.remove(listenerID);
  }
  registerSaveIDEventListener(valueID, listenerID, listener) {
    let valueIDEmitter = this._mySaveIDEmitters.get(valueID);
    if (valueIDEmitter == null) {
      this._mySaveIDEmitters.set(valueID, /* @__PURE__ */ new Map());
      valueIDEmitter = this._mySaveIDEmitters.get(valueID);
    }
    valueIDEmitter.add(listener, { id: listenerID });
  }
  unregisterSaveIDEventListener(valueID, listenerID) {
    let valueIDEmitter = this._mySaveIDEmitters.get(valueID);
    if (valueIDEmitter != null) {
      valueIDEmitter.remove(listenerID);
      if (valueIDEmitter.size <= 0) {
        this._mySaveIDEmitters.delete(valueID);
      }
    }
  }
  registerSaveValueChangedEventListener(listenerID, listener) {
    this._mySaveValueChangedEmitter.add(listener, { id: listenerID });
  }
  unregisterSaveValueChangedEventListener(listenerID) {
    this._mySaveValueChangedEmitter.remove(listenerID);
  }
  registerSaveValueChangedIDEventListener(valueID, listenerID, listener) {
    let valueIDEmitter = this._mySaveValueChangedIDEmitters.get(valueID);
    if (valueIDEmitter == null) {
      this._mySaveValueChangedIDEmitters.set(valueID, /* @__PURE__ */ new Map());
      valueIDEmitter = this._mySaveValueChangedIDEmitters.get(valueID);
    }
    valueIDEmitter.add(listener, { id: listenerID });
  }
  unregisterSaveValueChangedIDEventListener(valueID, listenerID) {
    let valueIDEmitter = this._mySaveValueChangedIDEmitters.get(valueID);
    if (valueIDEmitter != null) {
      valueIDEmitter.remove(listenerID);
      if (valueIDEmitter.size <= 0) {
        this._mySaveValueChangedIDEmitters.delete(valueID);
      }
    }
  }
  registerCommitSavesEventListener(listenerID, listener) {
    this._myCommitSavesEmitter.add(listener, { id: listenerID });
  }
  unregisterCommitSavesEventListener(listenerID) {
    this._myCommitSavesEmitter.remove(listenerID);
  }
  registerLoadEventListener(listenerID, listener) {
    this._myLoadEmitter.add(listener, { id: listenerID });
  }
  unregisterLoadEventListener(listenerID) {
    this._myLoadEmitter.remove(listenerID);
  }
  registerLoadIDEventListener(valueID, listenerID, listener) {
    let valueIDEmitter = this._myLoadIDEmitters.get(valueID);
    if (valueIDEmitter == null) {
      this._myLoadIDEmitters.set(valueID, /* @__PURE__ */ new Map());
      valueIDEmitter = this._myLoadIDEmitters.get(valueID);
    }
    valueIDEmitter.add(listener, { id: listenerID });
  }
  unregisterLoadIDEventListener(valueID, listenerID) {
    let valueIDEmitter = this._myLoadIDEmitters.get(valueID);
    if (valueIDEmitter != null) {
      valueIDEmitter.remove(listenerID);
      if (valueIDEmitter.size <= 0) {
        this._myLoadIDEmitters.delete(valueID);
      }
    }
  }
  registerLoadSavesEventListener(listenerID, listener) {
    this._myLoadSavesEmitter.add(listener, { id: listenerID });
  }
  unregisterLoadSavesEventListener(listenerID) {
    this._myLoadSavesEmitter.remove(listenerID);
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      if (active) {
        XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myEngine);
        window.addEventListener("visibilitychange", this._myWindowVisibilityChangeEventListener);
      } else {
        XRUtils.getSession(this._myEngine)?.removeEventListener("visibilitychange", this._myXRVisibilityChangeEventListener);
        XRUtils.unregisterSessionStartEndEventListeners(this, this._myEngine);
        window.removeEventListener("visibilitychange", this._myWindowVisibilityChangeEventListener);
      }
    }
  }
  isActive() {
    return this._myActive;
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/cauldron/cauldron/components/save_manager_component.js
var SaveManagerComponent = class extends Component5 {
  static TypeName = "pp-save-manager";
  static Properties = {
    _mySaveID: Property3.string(""),
    _myAutoLoadSaves: Property3.bool(true)
  };
  start() {
    this._mySaveManager = null;
    if (this._mySaveID.length > 0) {
      this._mySaveManager = new SaveManager(this._mySaveID, this._myAutoLoadSaves, this.engine);
    }
  }
  update(dt) {
    if (this._mySaveManager != null && Globals.getSaveManager(this.engine) == this._mySaveManager) {
      this._mySaveManager.update(dt);
    }
  }
  onActivate() {
    if (this._mySaveManager != null && !Globals.hasSaveManager(this.engine)) {
      this._mySaveManager.setActive(true);
      Globals.setSaveManager(this._mySaveManager, this.engine);
    }
  }
  onDeactivate() {
    if (this._mySaveManager != null) {
      this._mySaveManager.setActive(false);
      if (Globals.getSaveManager(this.engine) == this._mySaveManager) {
        Globals.removeSaveManager(this.engine);
      }
    }
  }
  onDestroy() {
    if (this._mySaveManager != null) {
      this._mySaveManager.destroy();
    }
  }
};

// dist/pp/cauldron/object_pool/components/object_pool_manager_component.js
import { Component as Component6 } from "@wonderlandengine/api";

// dist/pp/cauldron/object_pool/object_pool_manager.js
var ObjectPoolManager = class {
  _myPools = /* @__PURE__ */ new Map();
  _myDestroyed = false;
  constructor() {
    this._myPools = /* @__PURE__ */ new Map();
    this._myDestroyed = false;
  }
  addPool(poolID, pool) {
    if (!this._myPools.has(poolID)) {
      this._myPools.set(poolID, pool);
    } else {
      console.warn("Trying to add a Pool with an ID that has been already used:", poolID);
    }
  }
  destroyPool(poolID) {
    const poolToRemove = this._myPools.get(poolID);
    if (poolToRemove != null) {
      this._myPools.delete(poolID);
      poolToRemove.destroy();
    }
  }
  getPool(poolID) {
    const objectPool = this._myPools.get(poolID);
    return objectPool != null ? objectPool : null;
  }
  hasPool(poolID) {
    return this._myPools.has(poolID);
  }
  get(poolID) {
    if (this._myPools.has(poolID)) {
      return this._myPools.get(poolID).get();
    }
    return null;
  }
  has(poolIDOrObject, object) {
    let hasObject = false;
    if (object == null) {
      for (const pool of this._myPools.values()) {
        if (pool.has(poolIDOrObject)) {
          hasObject = true;
          break;
        }
      }
    } else if (this._myPools.has(poolIDOrObject)) {
      hasObject = this._myPools.get(poolIDOrObject).has(object);
    }
    return hasObject;
  }
  isBusy(poolIDOrObject, object) {
    let busy = false;
    if (object == null) {
      for (const pool of this._myPools.values()) {
        if (pool.isBusy(poolIDOrObject)) {
          busy = true;
          break;
        }
      }
    } else if (this._myPools.has(poolIDOrObject)) {
      busy = this._myPools.get(poolIDOrObject).isBusy(object);
    }
    return busy;
  }
  isAvailable(poolIDOrObject, object) {
    let available = false;
    if (object == null) {
      for (const pool of this._myPools.values()) {
        if (pool.isAvailable(poolIDOrObject)) {
          available = true;
          break;
        }
      }
    } else if (this._myPools.has(poolIDOrObject)) {
      available = this._myPools.get(poolIDOrObject).isAvailable(object);
    }
    return available;
  }
  release(poolIDOrObject, object) {
    if (object == null) {
      for (const pool of this._myPools.values()) {
        pool.release(poolIDOrObject);
      }
    } else if (this._myPools.has(poolIDOrObject)) {
      this._myPools.get(poolIDOrObject).release(object);
    }
  }
  releaseAll(poolID) {
    if (poolID == null) {
      for (const pool of this._myPools.values()) {
        pool.releaseAll();
      }
    } else if (this._myPools.has(poolID)) {
      this._myPools.get(poolID).releaseAll();
    }
  }
  increase(poolID, amount) {
    const pool = this._myPools.get(poolID);
    if (pool) {
      pool.increase(amount);
    }
  }
  increasePercentage(poolID, percentage) {
    const pool = this._myPools.get(poolID);
    if (pool) {
      pool.increasePercentage(percentage);
    }
  }
  getSize(poolID) {
    if (this._myPools.has(poolID)) {
      return this._myPools.get(poolID).getSize();
    }
    return 0;
  }
  getAvailableSize(poolID) {
    if (this._myPools.has(poolID)) {
      return this._myPools.get(poolID).getAvailableSize();
    }
    return 0;
  }
  getBusySize(poolID) {
    if (this._myPools.has(poolID)) {
      return this._myPools.get(poolID).getBusySize();
    }
    return 0;
  }
  destroy() {
    this._myDestroyed = true;
    for (const pool of this._myPools.values()) {
      pool.destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/cauldron/object_pool/components/object_pool_manager_component.js
var ObjectPoolManagerComponent = class extends Component6 {
  static TypeName = "pp-object-pools-manager";
  start() {
    this._myObjectPoolManager = new ObjectPoolManager();
  }
  onActivate() {
    if (!Globals.hasObjectPoolManager(this.engine)) {
      Globals.setObjectPoolManager(this._myObjectPoolManager, this.engine);
    }
  }
  onDeactivate() {
    if (this._myObjectPoolManager != null) {
      this._myObjectPoolManager.releaseAll();
      if (Globals.getObjectPoolManager(this.engine) == this._myObjectPoolManager) {
        Globals.removeObjectPoolManager(this.engine);
      }
    }
  }
  onDestroy() {
    if (this._myObjectPoolManager != null) {
      this._myObjectPoolManager.destroy();
    }
  }
};

// dist/pp/cauldron/visual/components/visual_manager_component.js
import { Component as Component7 } from "@wonderlandengine/api";

// dist/pp/cauldron/object_pool/object_pool.js
import { Object3D } from "@wonderlandengine/api";
var ObjectPoolParams = class {
  myInitialPoolSize = 0;
  /** If all the objects are busy, this amount will be added to the pool */
  myAmountToAddWhenEmpty = 0;
  /** If all the objects are busy, this percentage of the current pool size will be added to the pool */
  myPercentageToAddWhenEmpty = 0;
  myCloneParams = null;
  /** For the Wonderland Engine `Object3D` you can omit this, since it's already handled directly as a speciale case */
  myCloneCallback = null;
  /** For the Wonderland Engine `Object3D` you can omit this, since it's already handled directly as a speciale case */
  mySetActiveCallback = null;
  /** For the Wonderland Engine `Object3D` you can omit this, since it's already handled directly as a speciale case */
  myEqualCallback = null;
  /** For the Wonderland Engine `Object3D` you can omit this, since it's already handled directly as a speciale case */
  myDestroyCallback = null;
  /** For the Wonderland Engine `Object3D` you can omit this, since it's already handled directly as a speciale case */
  myOptimizeObjectsAllocationCallback = null;
  myLogEnabled = false;
};
var ObjectPool = class {
  _myObjectPrototype;
  _myObjectPoolParams;
  _myAvailableObjects = [];
  _myBusyObjects = [];
  _myDestroyed = false;
  _myIsObject3D = false;
  _myIsObject3DCloneParams = false;
  constructor(objectPrototype, objectPoolParams) {
    this._myObjectPrototype = objectPrototype;
    this._myObjectPoolParams = objectPoolParams;
    if (objectPrototype instanceof Object3D) {
      this._myIsObject3D = true;
      if (this._myObjectPoolParams.myCloneParams == null || this._myObjectPoolParams.myCloneParams instanceof ObjectCloneParams) {
        this._myIsObject3DCloneParams = true;
      }
    }
    this._addToPool(objectPoolParams.myInitialPoolSize, false);
  }
  get() {
    let object = this._myAvailableObjects.shift();
    if (object == null) {
      let amountToAdd = Math.ceil(this._myBusyObjects.length * this._myObjectPoolParams.myPercentageToAddWhenEmpty);
      amountToAdd += this._myObjectPoolParams.myAmountToAddWhenEmpty;
      this._addToPool(amountToAdd, this._myObjectPoolParams.myLogEnabled);
      object = this._myAvailableObjects.shift();
    }
    if (object != null) {
      this._myBusyObjects.push(object);
    }
    return object != null ? object : null;
  }
  has(object) {
    let hasObject = false;
    if (this.isBusy(object) || this.isAvailable(object)) {
      hasObject = true;
    }
    return hasObject;
  }
  isBusy(object) {
    return this._myBusyObjects.pp_has(this._equals.bind(this, object));
  }
  isAvailable(object) {
    return this._myAvailableObjects.pp_has(this._equals.bind(this, object));
  }
  release(object) {
    const released = this._myBusyObjects.pp_remove(this._equals.bind(this, object));
    if (released != null) {
      this._setActive(released, false);
      this._myAvailableObjects.push(released);
    }
  }
  releaseAll() {
    for (const busyObject of this._myBusyObjects) {
      this._setActive(busyObject, false);
      this._myAvailableObjects.push(busyObject);
    }
    this._myBusyObjects.pp_clear();
  }
  increase(amount) {
    this._addToPool(amount, false);
  }
  increasePercentage(percentage) {
    const amount = Math.ceil(this.getSize() * percentage);
    this._addToPool(amount, false);
  }
  getObjects() {
    const objects = [];
    objects.push(...this._myAvailableObjects);
    objects.push(...this._myBusyObjects);
    return objects;
  }
  getSize() {
    return this._myBusyObjects.length + this._myAvailableObjects.length;
  }
  getAvailableObjects() {
    return this._myAvailableObjects;
  }
  getAvailableSize() {
    return this._myAvailableObjects.length;
  }
  getBusyObjects() {
    return this._myBusyObjects;
  }
  getBusySize() {
    return this._myBusyObjects.length;
  }
  _addToPool(size, logEnabled) {
    if (size <= 0) {
      return;
    }
    if (this._myObjectPoolParams.myOptimizeObjectsAllocationCallback != null) {
      this._myObjectPoolParams.myOptimizeObjectsAllocationCallback(this._myObjectPrototype, size);
    } else if (this._myIsObject3D) {
      const object3DPrototype = this._myObjectPrototype;
      ObjectUtils.reserveObjects(object3DPrototype, size);
    }
    for (let i = 0; i < size; i++) {
      const clonedObject = this._clonePrototype();
      if (clonedObject != null) {
        this._myAvailableObjects.push(clonedObject);
      }
    }
    if (logEnabled) {
      console.warn("Added new elements to the pool:", size);
    }
  }
  _clonePrototype() {
    let clone13 = null;
    const cloneParams = this._myObjectPoolParams.myCloneParams != null ? this._myObjectPoolParams.myCloneParams : void 0;
    if (this._myObjectPoolParams.myCloneCallback != null) {
      clone13 = this._myObjectPoolParams.myCloneCallback(this._myObjectPrototype, cloneParams);
    } else if (this._myIsObject3D && this._myIsObject3DCloneParams) {
      const object3DPrototype = this._myObjectPrototype;
      clone13 = ObjectUtils.clone(object3DPrototype, cloneParams);
    } else {
      console.error("No way have been provided to clone the object");
    }
    if (clone13 != null) {
      this._setActive(clone13, false);
    }
    return clone13;
  }
  _setActive(object, active) {
    if (this._myObjectPoolParams.mySetActiveCallback != null) {
      this._myObjectPoolParams.mySetActiveCallback(object, active);
    } else if (this._myIsObject3D) {
      const object3D = object;
      ObjectUtils.setActive(object3D, active);
    } else {
      console.error("No way have been provided to set the active state of the object");
    }
  }
  _equals(first2, second) {
    let equals10 = false;
    if (this._myObjectPoolParams.myEqualCallback != null) {
      equals10 = this._myObjectPoolParams.myEqualCallback(first2, second);
    } else if (this._myIsObject3D) {
      const firstObject3D = first2;
      const secondObject3D = second;
      equals10 = firstObject3D == secondObject3D;
    } else {
      equals10 = first2 == second;
    }
    return equals10;
  }
  destroy() {
    this._myDestroyed = true;
    for (const object of this._myAvailableObjects) {
      this._destroyObject(object);
    }
    for (const object of this._myBusyObjects) {
      this._destroyObject(object);
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
  _destroyObject(object) {
    if (this._myObjectPoolParams.myDestroyCallback != null) {
      this._myObjectPoolParams.myDestroyCallback(object);
    } else if (this._myIsObject3D) {
      const object3D = object;
      ObjectUtils.destroy(object3D);
    } else {
      console.error("No way have been provided to destroy the object");
    }
  }
};

// dist/pp/cauldron/visual/elements/visual_arrow.js
import { MeshComponent as MeshComponent4 } from "@wonderlandengine/api";

// dist/pp/cauldron/visual/elements/visual_element.js
var AbstractVisualElementParams = class {
  myParent;
  constructor(engine = Globals.getMainEngine()) {
    this.myParent = Globals.getSceneObjects(engine).myVisualElements;
  }
  copy(other, deepCopy = true) {
    this.myParent = other.myParent;
    this._copyHook(other, deepCopy);
  }
  clone(deepClone = true) {
    const clonedParams = this._new();
    clonedParams.copyGeneric(this, deepClone);
    return clonedParams;
  }
  equals(other) {
    if (this == other)
      return true;
    if (this.myParent != other.myParent)
      return false;
    return this._equalsHook(other);
  }
  copyGeneric(other, deepCopy = true) {
    if (other.myType != this.myType) {
      throw new Error("Trying to copy from params with a different type - From Type: " + other.myType + " - To Type: " + this.myType);
    }
    this.copy(other, deepCopy);
  }
  cloneGeneric(deepClone = true) {
    return this.clone(deepClone);
  }
  equalsGeneric(other) {
    return this.equals(other);
  }
};
var AbstractVisualElement = class {
  _myParams;
  _myPrevParams;
  _myVisible = false;
  _myAutoRefresh = true;
  _myDirty = false;
  _myDestroyed = false;
  constructor(params) {
    this._myParams = params;
    this._myPrevParams = this._myParams.clone();
  }
  update(dt) {
    if (this._myDirty) {
      this._refresh();
      this._myDirty = false;
    }
    this._updateHook(dt);
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      this._visibleChanged();
    }
  }
  refresh() {
    this.update(0);
  }
  setAutoRefresh(autoRefresh) {
    this._myAutoRefresh = autoRefresh;
  }
  getParams() {
    return this._myParams;
  }
  setParams(params) {
    this._myParams = params;
    this.paramsUpdated();
  }
  copyParams(params) {
    this._myParams.copy(params);
    this.paramsUpdated();
  }
  getParamsGeneric() {
    return this._myParams;
  }
  setParamsGeneric(params) {
    if (params.myType != this._myParams.myType) {
      throw new Error("Trying to set params with a different type - Current Type: " + params.myType + " - New Type: " + this._myParams.myType);
    }
    this.setParams(params);
  }
  copyParamsGeneric(params) {
    if (params.myType != this._myParams.myType) {
      throw new Error("Trying to copy from params with a different type - From Type: " + params.myType + " - To Type: " + this._myParams.myType);
    }
    this.copyParams(params);
  }
  paramsUpdated() {
    if (!this._myParams.equals(this._myPrevParams)) {
      this._markDirty();
    }
  }
  _markDirty() {
    this._myDirty = true;
    if (this._myAutoRefresh) {
      this.update(0);
    }
  }
  clone() {
    const clonedParams = this._myParams.clone();
    const clone13 = this._new(clonedParams);
    clone13.setAutoRefresh(this._myAutoRefresh);
    clone13.setVisible(this._myVisible);
    clone13._myDirty = this._myDirty;
    return clone13;
  }
  _prepare() {
    this._myPrevParams.copy(this._myParams, false);
    this._build();
    this._myDirty = true;
    this.refresh();
    this.setVisible(true);
  }
  _refresh() {
    this._myPrevParams.copy(this._myParams, false);
    this._refreshHook();
  }
  _updateHook(dt) {
  }
  _visibleChanged() {
  }
  _destroyHook() {
  }
  destroy() {
    this._myDestroyed = true;
    this._destroyHook();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/cauldron/visual/elements/visual_element_types.js
var VisualElementDefaultType;
(function(VisualElementDefaultType2) {
  VisualElementDefaultType2["MESH"] = "mesh";
  VisualElementDefaultType2["LINE"] = "line";
  VisualElementDefaultType2["POINT"] = "point";
  VisualElementDefaultType2["TEXT"] = "text";
  VisualElementDefaultType2["ARROW"] = "arrow";
  VisualElementDefaultType2["TRANSFORM"] = "transform";
  VisualElementDefaultType2["RAYCAST"] = "raycast";
  VisualElementDefaultType2["TORUS"] = "torus";
})(VisualElementDefaultType || (VisualElementDefaultType = {}));

// dist/pp/cauldron/visual/elements/visual_line.js
import { MeshComponent as MeshComponent3 } from "@wonderlandengine/api";
var VisualLineParams = class _VisualLineParams extends AbstractVisualElementParams {
  /**
   * TS type inference helper
   *
   * @param {any} engine
   */
  constructor(engine = Globals.getMainEngine()) {
    super(engine);
    this.myStart = vec3_create();
    this.myDirection = vec3_create(0, 0, 1);
    this.myLength = 0;
    this.myThickness = 5e-3;
    this.myMesh = null;
    this.myMaterial = null;
    this.myColor = null;
    this.myLocal = false;
    this.myType = VisualElementDefaultType.LINE;
  }
  setStartEnd(start, end) {
    end.vec3_sub(start, this.myDirection);
    this.myLength = this.myDirection.vec3_length();
    this.myDirection.vec3_normalize(this.myDirection);
    this.myStart.vec3_copy(start);
    return this;
  }
  _copyHook(other, deepCopy) {
  }
  _new() {
    return new _VisualLineParams(this.myParent.pp_getEngine());
  }
  _equalsHook(other) {
    return this.myThickness == other.myThickness && this.myLength == other.myLength && this.myMesh == other.myMesh && this.myMaterial == other.myMaterial && this.myLocal == other.myLocal && (this.myColor == other.myColor || this.myColor != null && other.myColor != null && this.myColor.vec_equals(other.myColor)) && this.myStart.vec3_equals(other.myStart) && this.myDirection.vec3_equals(other.myDirection);
  }
};
var VisualLine = class _VisualLine extends AbstractVisualElement {
  constructor(params = new VisualLineParams()) {
    super(params);
    this._myLineParentObject = null;
    this._myLineObject = null;
    this._myLineMeshComponent = null;
    this._myFlatOpaqueMaterial = null;
    this._prepare();
  }
  _visibleChanged() {
    this._myLineParentObject.pp_setActive(this._myVisible);
  }
  _build() {
    this._myLineParentObject = Globals.getSceneObjects(this._myParams.myParent.pp_getEngine()).myVisualElements.pp_addChild();
    this._myLineObject = this._myLineParentObject.pp_addChild();
    this._myLineMeshComponent = this._myLineObject.pp_addComponent(MeshComponent3);
  }
  _refreshHook() {
  }
  _new(params) {
    return new _VisualLine(params);
  }
  _destroyHook() {
    this._myLineParentObject.pp_destroy();
  }
};
VisualLine.prototype._refreshHook = function() {
  let scaleLine = vec3_create();
  let translateLine = vec3_create();
  let forward = vec3_create(0, 1, 0);
  return function _refreshHook() {
    this._myLineParentObject.pp_setParent(this._myParams.myParent, false);
    if (this._myParams.myLocal) {
      this._myLineParentObject.pp_setPositionLocal(this._myParams.myStart);
    } else {
      this._myLineParentObject.pp_setPosition(this._myParams.myStart);
    }
    scaleLine.vec3_set(this._myParams.myThickness / 2, this._myParams.myLength / 2, this._myParams.myThickness / 2);
    if (this._myParams.myLocal) {
      this._myLineObject.pp_setScaleLocal(scaleLine);
    } else {
      this._myLineObject.pp_setScale(scaleLine);
    }
    if (this._myParams.myLocal) {
      this._myLineObject.pp_setUpLocal(this._myParams.myDirection, forward);
    } else {
      this._myLineObject.pp_setUp(this._myParams.myDirection, forward);
    }
    this._myLineObject.pp_resetPositionLocal();
    translateLine.vec3_set(0, this._myParams.myLength / 2, 0);
    this._myLineObject.pp_translateObject(translateLine);
    if (this._myParams.myMesh != null) {
      this._myLineMeshComponent.mesh = this._myParams.myMesh;
    } else {
      this._myLineMeshComponent.mesh = Globals.getDefaultMeshes(this._myParams.myParent.pp_getEngine()).myCylinder;
    }
    if (this._myParams.myMaterial == null) {
      if (this._myParams.myColor == null) {
        this._myLineMeshComponent.material = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myMesh;
      } else {
        if (this._myFlatOpaqueMaterial == null) {
          this._myFlatOpaqueMaterial = Globals.getDefaultMaterials(this._myParams.myParent.pp_getEngine()).myFlatOpaque.clone();
        }
        this._myLineMeshComponent.material = this._myFlatOpaqueMaterial;
        this._myFlatOpaqueMaterial.color = this._myParams.myColor;
      }
    } else {
      this._myLineMeshComponent.material = this._myParams.myMaterial;
    }
  };
}();
VisualLineParams.prototype._copyHook = function _copyHook(other, deepCopy) {
  this.myStart.vec3_copy(other.myStart);
  this.myDirection.vec3_copy(other.myDirection);
  this.myLength = other.myLength;
  this.myThickness = other.myThickness;
  this.myMesh = other.myMesh;
  if (other.myMaterial != null && deepCopy) {
    this.myMaterial = other.myMaterial.clone();
  } else {
    this.myMaterial = other.myMaterial;
  }
  if (other.myColor != null) {
    if (this.myColor != null) {
      this.myColor.vec4_copy(other.myColor);
    } else {
      this.myColor = other.myColor.vec4_clone();
    }
  } else {
    this.myColor = null;
  }
  this.myLocal = other.myLocal;
};

// dist/pp/cauldron/visual/elements/visual_arrow.js
var VisualArrowParams = class _VisualArrowParams extends AbstractVisualElementParams {
  /**
   * TS type inference helper
   *
   * @param {any} engine
   */
  constructor(engine = Globals.getMainEngine()) {
    super(engine);
    this.myStart = vec3_create();
    this.myDirection = vec3_create(0, 0, 1);
    this.myLength = 0;
    this.myThickness = 5e-3;
    this.myArrowThickness = null;
    this.myArrowLength = null;
    this.myShareArrowLengthWithLineWhenArrowLongerThanLength = true;
    this.myLineMesh = null;
    this.myArrowMesh = null;
    this.myMaterial = null;
    this.myColor = null;
    this.myLocal = false;
    this.myType = VisualElementDefaultType.ARROW;
  }
  setStartEnd(start, end) {
    end.vec3_sub(start, this.myDirection);
    this.myLength = this.myDirection.vec3_length();
    this.myDirection.vec3_normalize(this.myDirection);
    this.myStart.vec3_copy(start);
    return this;
  }
  _copyHook(other, deepCopy) {
  }
  _new() {
    return new _VisualArrowParams(this.myParent.pp_getEngine());
  }
  _equalsHook(other) {
    return this.myThickness == other.myThickness && this.myLength == other.myLength && this.myLineMesh == other.myLineMesh && this.myArrowMesh == other.myArrowMesh && this.myMaterial == other.myMaterial && this.myLocal == other.myLocal && this.myArrowThickness == other.myArrowThickness && this.myArrowLength == other.myArrowLength && this.myShareArrowLengthWithLineWhenArrowLongerThanLength == other.myShareArrowLengthWithLineWhenArrowLongerThanLength && (this.myColor == other.myColor || this.myColor != null && other.myColor != null && this.myColor.vec_equals(other.myColor)) && this.myStart.vec3_equals(other.myStart) && this.myDirection.vec3_equals(other.myDirection);
  }
};
var VisualArrow = class _VisualArrow extends AbstractVisualElement {
  constructor(params = new VisualArrowParams()) {
    super(params);
    this._myVisualLine = new VisualLine(new VisualLineParams(this._myParams.myParent.pp_getEngine()));
    this._myVisualLine.setAutoRefresh(false);
    this._myArrowParentObject = null;
    this._myArrowObject = null;
    this._myArrowMeshComponent = null;
    this._myFlatOpaqueMaterial = null;
    this._prepare();
  }
  _visibleChanged() {
    this._myVisualLine.setVisible(this._myVisible);
    this._myArrowParentObject.pp_setActive(this._myVisible);
  }
  _updateHook(dt) {
    this._myVisualLine.update(dt);
  }
  _build() {
    this._myArrowParentObject = Globals.getSceneObjects(this._myParams.myParent.pp_getEngine()).myVisualElements.pp_addChild();
    this._myArrowObject = this._myArrowParentObject.pp_addChild();
    this._myArrowMeshComponent = this._myArrowObject.pp_addComponent(MeshComponent4);
  }
  _refreshHook() {
  }
  _new(params) {
    return new _VisualArrow(params);
  }
  _destroyHook() {
    this._myVisualLine.destroy();
    this._myArrowParentObject.pp_destroy();
  }
};
VisualArrow.prototype._refreshHook = function() {
  let arrowPosition = vec3_create();
  let parentTranslate = vec3_create();
  let arrowScale = vec3_create();
  let forward = vec3_create(0, 1, 0);
  return function _refreshHook() {
    this._myArrowParentObject.pp_setParent(this._myParams.myParent, false);
    let arrowThickness = this._myParams.myArrowThickness != null ? this._myParams.myArrowThickness : this._myParams.myThickness * 1.5;
    let arrowLength = this._myParams.myArrowLength != null ? this._myParams.myArrowLength : this._myParams.myThickness * 3.5;
    if (this._myParams.myShareArrowLengthWithLineWhenArrowLongerThanLength && arrowLength > this._myParams.myLength / 2) {
      arrowLength = this._myParams.myLength / 2;
    }
    arrowLength = Math.min(arrowLength, this._myParams.myLength);
    arrowScale.vec3_set(arrowThickness, arrowLength / 2, arrowThickness);
    let lineLength = this._myParams.myLength - arrowLength;
    this._myParams.myDirection.vec3_scale(lineLength, arrowPosition);
    arrowPosition.vec3_add(this._myParams.myStart, arrowPosition);
    if (this._myParams.myLocal) {
      this._myArrowParentObject.pp_setPositionLocal(arrowPosition);
      this._myArrowParentObject.pp_setUpLocal(this._myParams.myDirection, forward);
    } else {
      this._myArrowParentObject.pp_setPosition(arrowPosition);
      this._myArrowParentObject.pp_setUp(this._myParams.myDirection, forward);
    }
    parentTranslate.vec3_set(0, arrowLength / 2 - 1e-5, 0);
    this._myArrowParentObject.pp_translateObject(parentTranslate);
    if (this._myParams.myLocal) {
      this._myArrowObject.pp_setScaleLocal(arrowScale);
    } else {
      this._myArrowObject.pp_setScale(arrowScale);
    }
    if (this._myParams.myArrowMesh != null) {
      this._myArrowMeshComponent.mesh = this._myParams.myArrowMesh;
    } else {
      this._myArrowMeshComponent.mesh = Globals.getDefaultMeshes(this._myParams.myParent.pp_getEngine()).myCone;
    }
    if (this._myParams.myMaterial == null) {
      if (this._myParams.myColor == null) {
        this._myArrowMeshComponent.material = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myMesh;
      } else {
        if (this._myFlatOpaqueMaterial == null) {
          this._myFlatOpaqueMaterial = Globals.getDefaultMaterials(this._myParams.myParent.pp_getEngine()).myFlatOpaque.clone();
        }
        this._myArrowMeshComponent.material = this._myFlatOpaqueMaterial;
        this._myFlatOpaqueMaterial.color = this._myParams.myColor;
      }
    } else {
      this._myArrowMeshComponent.material = this._myParams.myMaterial;
    }
    let visualLineParams = this._myVisualLine.getParams();
    visualLineParams.myStart.vec3_copy(this._myParams.myStart);
    visualLineParams.myDirection.vec3_copy(this._myParams.myDirection);
    visualLineParams.myLength = lineLength;
    visualLineParams.myThickness = this._myParams.myThickness;
    visualLineParams.myMesh = this._myParams.myLineMesh;
    visualLineParams.myMaterial = this._myArrowMeshComponent.material;
    visualLineParams.myParent = this._myParams.myParent;
    visualLineParams.myLocal = this._myParams.myLocal;
    this._myVisualLine.paramsUpdated();
  };
}();
VisualArrowParams.prototype._copyHook = function _copyHook2(other, deepCopy) {
  this.myStart.vec3_copy(other.myStart);
  this.myDirection.vec3_copy(other.myDirection);
  this.myLength = other.myLength;
  this.myThickness = other.myThickness;
  this.myArrowThickness = other.myArrowThickness;
  this.myArrowLength = other.myArrowLength;
  this.myShareArrowLengthWithLineWhenArrowLongerThanLength = other.myShareArrowLengthWithLineWhenArrowLongerThanLength;
  this.myArrowMesh = other.myArrowMesh;
  this.myLineMesh = other.myLineMesh;
  if (other.myMaterial != null && deepCopy) {
    this.myMaterial = other.myMaterial.clone();
  } else {
    this.myMaterial = other.myMaterial;
  }
  if (other.myColor != null) {
    if (this.myColor != null) {
      this.myColor.vec4_copy(other.myColor);
    } else {
      this.myColor = other.myColor.vec4_clone();
    }
  } else {
    this.myColor = null;
  }
  this.myLocal = other.myLocal;
};

// dist/pp/cauldron/visual/elements/visual_mesh.js
import { MeshComponent as MeshComponent5 } from "@wonderlandengine/api";
var VisualMeshParams = class _VisualMeshParams extends AbstractVisualElementParams {
  myType = VisualElementDefaultType.MESH;
  myTransform = mat4_create();
  myLocal = false;
  /** `null` means it will default to `Globals.getDefaultMeshes().mySphere` */
  myMesh = null;
  /** `null` means it will default to `Globals.getVisualResources().myDefaultMaterials.myMesh` */
  myMaterial = null;
  _copyHook(other, deepCopy) {
    this.myTransform.pp_copy(other.myTransform);
    if (other.myMesh != null) {
      this.myMesh = other.myMesh;
    } else {
      this.myMesh = null;
    }
    if (other.myMaterial != null && deepCopy) {
      this.myMaterial = other.myMaterial.clone();
    } else {
      this.myMaterial = other.myMaterial;
    }
    this.myLocal = other.myLocal;
  }
  _new() {
    return new _VisualMeshParams(this.myParent.pp_getEngine());
  }
  _equalsHook(other) {
    return this.myMesh == other.myMesh && this.myMaterial == other.myMaterial && this.myLocal == other.myLocal && this.myTransform.vec_equals(other.myTransform);
  }
};
var VisualMesh = class _VisualMesh extends AbstractVisualElement {
  _myMeshObject;
  _myMeshComponent;
  constructor(params = new VisualMeshParams()) {
    super(params);
    this._prepare();
  }
  _visibleChanged() {
    this._myMeshObject.pp_setActive(this._myVisible);
  }
  _build() {
    this._myMeshObject = Globals.getSceneObjects(this._myParams.myParent.pp_getEngine()).myVisualElements.pp_addChild();
    this._myMeshComponent = this._myMeshObject.pp_addComponent(MeshComponent5);
  }
  _refreshHook() {
    this._myMeshObject.pp_setParent(this._myParams.myParent, false);
    if (this._myParams.myLocal) {
      this._myMeshObject.pp_setTransformLocal(this._myParams.myTransform);
    } else {
      this._myMeshObject.pp_setTransform(this._myParams.myTransform);
    }
    if (this._myParams.myMesh == null) {
      this._myMeshComponent.mesh = Globals.getDefaultMeshes(this._myParams.myParent.pp_getEngine()).mySphere;
    } else {
      this._myMeshComponent.mesh = this._myParams.myMesh;
    }
    if (this._myParams.myMaterial == null) {
      this._myMeshComponent.material = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myMesh;
    } else {
      this._myMeshComponent.material = this._myParams.myMaterial;
    }
  }
  _new(params) {
    return new _VisualMesh(params);
  }
  _destroyHook() {
    this._myMeshObject.pp_destroy();
  }
};

// dist/pp/cauldron/visual/elements/visual_point.js
import { MeshComponent as MeshComponent6 } from "@wonderlandengine/api";
var VisualPointParams = class _VisualPointParams extends AbstractVisualElementParams {
  /**
   * TS type inference helper
   *
   * @param {any} engine
   */
  constructor(engine = Globals.getMainEngine()) {
    super(engine);
    this.myPosition = vec3_create();
    this.myRadius = 5e-3;
    this.myMesh = null;
    this.myMaterial = null;
    this.myColor = null;
    this.myLocal = false;
    this.myType = VisualElementDefaultType.POINT;
  }
  _copyHook(other, deepCopy) {
  }
  _new() {
    return new _VisualPointParams(this.myParent.pp_getEngine());
  }
  _equalsHook(other) {
    return this.myRadius == other.myRadius && this.myMesh == other.myMesh && this.myMaterial == other.myMaterial && this.myLocal == other.myLocal && (this.myColor == other.myColor || this.myColor != null && other.myColor != null && this.myColor.vec_equals(other.myColor)) && this.myPosition.vec3_equals(other.myPosition);
  }
};
var VisualPoint = class _VisualPoint extends AbstractVisualElement {
  constructor(params = new VisualPointParams()) {
    super(params);
    this._myPointObject = null;
    this._myPointMeshComponent = null;
    this._myFlatOpaqueMaterial = null;
    this._prepare();
  }
  _visibleChanged() {
    this._myPointObject.pp_setActive(this._myVisible);
  }
  _build() {
    this._myPointObject = Globals.getSceneObjects(this._myParams.myParent.pp_getEngine()).myVisualElements.pp_addChild();
    this._myPointMeshComponent = this._myPointObject.pp_addComponent(MeshComponent6);
  }
  _refreshHook() {
  }
  _new(params) {
    return new _VisualPoint(params);
  }
  _destroyHook() {
    this._myPointObject.pp_destroy();
  }
};
VisualPoint.prototype._refreshHook = function() {
  let rotation = vec3_create(0, 0, 0);
  return function _refreshHook() {
    this._myPointObject.pp_setParent(this._myParams.myParent, false);
    if (this._myParams.myLocal) {
      this._myPointObject.pp_setPositionLocal(this._myParams.myPosition);
      this._myPointObject.pp_setRotationLocal(rotation);
      this._myPointObject.pp_setScaleLocal(this._myParams.myRadius);
    } else {
      this._myPointObject.pp_setPosition(this._myParams.myPosition);
      this._myPointObject.pp_setRotation(rotation);
      this._myPointObject.pp_setScale(this._myParams.myRadius);
    }
    if (this._myParams.myMesh != null) {
      this._myPointMeshComponent.mesh = this._myParams.myMesh;
    } else {
      this._myPointMeshComponent.mesh = Globals.getDefaultMeshes(this._myParams.myParent.pp_getEngine()).mySphere;
    }
    if (this._myParams.myMaterial == null) {
      if (this._myParams.myColor == null) {
        this._myPointMeshComponent.material = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myMesh;
      } else {
        if (this._myFlatOpaqueMaterial == null) {
          this._myFlatOpaqueMaterial = Globals.getDefaultMaterials(this._myParams.myParent.pp_getEngine()).myFlatOpaque.clone();
        }
        this._myPointMeshComponent.material = this._myFlatOpaqueMaterial;
        this._myFlatOpaqueMaterial.color = this._myParams.myColor;
      }
    } else {
      this._myPointMeshComponent.material = this._myParams.myMaterial;
    }
  };
}();
VisualPointParams.prototype._copyHook = function _copyHook3(other, deepCopy) {
  this.myPosition.vec3_copy(other.myPosition);
  this.myRadius = other.myRadius;
  this.myMesh = other.myMesh;
  if (other.myMaterial != null && deepCopy) {
    this.myMaterial = other.myMaterial.clone();
  } else {
    this.myMaterial = other.myMaterial;
  }
  if (other.myColor != null) {
    if (this.myColor != null) {
      this.myColor.vec4_copy(other.myColor);
    } else {
      this.myColor = other.myColor.vec4_clone();
    }
  } else {
    this.myColor = null;
  }
  this.myLocal = other.myLocal;
};

// dist/pp/cauldron/physics/physics_utils.js
import { PhysXComponent as PhysXComponent2 } from "@wonderlandengine/api";
var _myLayerFlagsNames = ["0", "1", "2", "3", "4", "5", "6", "7"];
var _myRaycastCount = /* @__PURE__ */ new WeakMap();
var _myRaycastVisualDebugEnabled = /* @__PURE__ */ new WeakMap();
function setLayerFlagsNames(layerFlagsNames) {
  _myLayerFlagsNames = layerFlagsNames;
}
function getLayerFlagsNames() {
  return _myLayerFlagsNames;
}
function getRaycastCount(physics = Globals.getPhysics()) {
  const raycastCount = _myRaycastCount.get(physics);
  return raycastCount != null ? raycastCount : 0;
}
function resetRaycastCount(physics = Globals.getPhysics()) {
  _myRaycastCount.set(physics, 0);
}
function isRaycastVisualDebugEnabled(physics = Globals.getPhysics()) {
  return _myRaycastVisualDebugEnabled.get(physics) || false;
}
function setRaycastVisualDebugEnabled(visualDebugEnabled, physics = Globals.getPhysics()) {
  _myRaycastVisualDebugEnabled.set(physics, visualDebugEnabled);
}
var raycast = function() {
  let maxHitCount = 20;
  let objects = new Array(maxHitCount);
  let distances = new Float32Array(maxHitCount);
  let locations = Array.from({ length: maxHitCount }, () => new Float32Array(3));
  let normals = Array.from({ length: maxHitCount }, () => new Float32Array(3));
  const insideCheckSubVector = vec3_create();
  const invertedRaycastDirection = vec3_create();
  const objectsEqualCallback = (first2, second) => first2 == second;
  return function raycast2(raycastParams, raycastResults = new RaycastResults()) {
    const internalRaycastResults = raycastParams.myPhysics.rayCast(raycastParams.myOrigin, raycastParams.myDirection, raycastParams.myBlockLayerFlags.getMask(), raycastParams.myDistance);
    if (raycastResults.myRaycastParams == null) {
      raycastResults.myRaycastParams = new RaycastParams(raycastParams.myPhysics);
    }
    raycastResults.myRaycastParams.copy(raycastParams);
    let currentValidHitIndex = 0;
    let validHitsCount = 0;
    const hitCount = internalRaycastResults.hitCount;
    if (hitCount != 0) {
      if (hitCount > maxHitCount) {
        console.warn("Raycast hitcount is more than the expected one: " + hitCount + " - Allocation of needed resources performed");
        maxHitCount = Math.ceil(hitCount + hitCount * 0.5);
        objects = new Array(maxHitCount);
        distances = new Float32Array(maxHitCount);
        locations = Array.from({ length: maxHitCount }, () => new Float32Array(3));
        normals = Array.from({ length: maxHitCount }, () => new Float32Array(3));
      }
      let objectsAlreadyGet = false;
      let distancesAlreadyGet = false;
      let locationsAlreadyGet = false;
      let normalsAlreadyGet = false;
      raycastParams.myDirection.vec3_negate(invertedRaycastDirection);
      for (let i = 0; i < hitCount; i++) {
        if (raycastParams.myObjectsToIgnore.length != 0) {
          if (!objectsAlreadyGet) {
            objectsAlreadyGet = true;
            internalRaycastResults.getObjects(objects);
          }
          if (raycastParams.myObjectsToIgnore.pp_hasEqual(objects[i], objectsEqualCallback)) {
            continue;
          }
        }
        if (!distancesAlreadyGet) {
          distancesAlreadyGet = true;
          internalRaycastResults.getDistances(distances);
        }
        let colliderTypeValid = true;
        if (raycastParams.myBlockColliderType != RaycastBlockColliderType.BOTH) {
          colliderTypeValid = false;
          if (!objectsAlreadyGet) {
            objectsAlreadyGet = true;
            internalRaycastResults.getObjects(objects);
          }
          const physXComponent = objects[i].pp_getComponentSelf(PhysXComponent2);
          colliderTypeValid = physXComponent.trigger && raycastParams.myBlockColliderType == RaycastBlockColliderType.TRIGGER || !physXComponent.trigger && raycastParams.myBlockColliderType == RaycastBlockColliderType.NORMAL;
        }
        if (colliderTypeValid) {
          let hitInsideCollision = distances[i] == 0;
          if (hitInsideCollision) {
            if (!locationsAlreadyGet) {
              locationsAlreadyGet = true;
              internalRaycastResults.getLocations(locations);
            }
            hitInsideCollision &&= raycastParams.myOrigin.vec3_sub(locations[i], insideCheckSubVector).vec3_isZero(Math.PP_EPSILON);
            if (hitInsideCollision) {
              if (!normalsAlreadyGet) {
                normalsAlreadyGet = true;
                internalRaycastResults.getNormals(normals);
              }
              hitInsideCollision &&= invertedRaycastDirection.vec3_equals(normals[i], Math.PP_EPSILON_DEGREES);
            }
          }
          if (!raycastParams.myIgnoreHitsInsideCollision || !hitInsideCollision) {
            let hit = null;
            const raycastResultsUnusedHits = raycastResults._myUnusedHits;
            if (currentValidHitIndex < raycastResults.myHits.length) {
              hit = raycastResults.myHits[currentValidHitIndex];
            } else if (raycastResultsUnusedHits != null && raycastResultsUnusedHits.length > 0) {
              hit = raycastResultsUnusedHits.pop();
              raycastResults.myHits.push(hit);
            } else {
              hit = new RaycastHit();
              raycastResults.myHits.push(hit);
            }
            if (!objectsAlreadyGet) {
              objectsAlreadyGet = true;
              internalRaycastResults.getObjects(objects);
            }
            if (!locationsAlreadyGet) {
              locationsAlreadyGet = true;
              internalRaycastResults.getLocations(locations);
            }
            if (!normalsAlreadyGet) {
              normalsAlreadyGet = true;
              internalRaycastResults.getNormals(normals);
            }
            hit.myPosition.vec3_copy(locations[i]);
            hit.myNormal.vec3_copy(normals[i]);
            hit.myDistance = distances[i];
            hit.myObject = objects[i];
            hit.myInsideCollision = hitInsideCollision;
            validHitsCount++;
            currentValidHitIndex++;
          }
        }
      }
    }
    if (raycastResults.myHits.length > validHitsCount) {
      let raycastResultsUnusedHits = raycastResults._myUnusedHits;
      if (raycastResultsUnusedHits == null) {
        raycastResultsUnusedHits = [];
        raycastResults._myUnusedHits = raycastResultsUnusedHits;
      }
      const hitsToRemove = raycastResults.myHits.length - validHitsCount;
      for (let i = 0; i < hitsToRemove; i++) {
        raycastResultsUnusedHits.push(raycastResults.myHits.pop());
      }
    }
    if (Globals.isDebugEnabled(raycastParams.myPhysics.engine)) {
      if (PhysicsUtils.isRaycastVisualDebugEnabled(raycastParams.myPhysics)) {
        Globals.getDebugVisualManager(raycastParams.myPhysics.engine).drawRaycast(0, raycastResults);
      }
      _increaseRaycastCount(raycastParams.myPhysics);
    }
    return raycastResults;
  };
}();
var PhysicsUtils = {
  setLayerFlagsNames,
  getLayerFlagsNames,
  getRaycastCount,
  resetRaycastCount,
  isRaycastVisualDebugEnabled,
  setRaycastVisualDebugEnabled,
  raycast
};
function _increaseRaycastCount(physics = Globals.getPhysics()) {
  const raycastCount = _myRaycastCount.get(physics);
  if (raycastCount == null) {
    _myRaycastCount.set(physics, 1);
  } else {
    _myRaycastCount.set(physics, raycastCount + 1);
  }
}

// dist/pp/cauldron/physics/physics_layer_flags.js
var PhysicsLayerFlags = class {
  constructor() {
    this._myLayerMask = 0;
  }
  setFlagActive(indexOrName, active) {
    let index = indexOrName;
    if (isNaN(indexOrName)) {
      index = PhysicsUtils.getLayerFlagsNames().pp_findIndexEqual(indexOrName);
    }
    if (index >= 0 && index < PhysicsUtils.getLayerFlagsNames().length) {
      let mask = 1 << index;
      if (active) {
        this._myLayerMask = this._myLayerMask | mask;
      } else {
        this._myLayerMask = this._myLayerMask & ~mask;
      }
    }
  }
  isFlagActive(indexOrName) {
    let index = indexOrName;
    if (isNaN(indexOrName)) {
      index = PhysicsUtils.getLayerFlagsNames().pp_findIndexEqual(indexOrName);
    }
    let active = false;
    if (index >= 0 && index < PhysicsUtils.getLayerFlagsNames().length) {
      let mask = 1 << index;
      active = !!(this._myLayerMask & mask);
    }
    return active;
  }
  setAllFlagsActive(active) {
    if (!active) {
      this._myLayerMask = 0;
    } else {
      this._myLayerMask = Math.pow(2, PhysicsUtils.getLayerFlagsNames().length) - 1;
    }
  }
  add(layerFlags) {
    this._myLayerMask = this._myLayerMask | layerFlags.getMask();
  }
  remove(layerFlags) {
    this._myLayerMask = this._myLayerMask & ~layerFlags.getMask();
  }
  intersect(layerFlags) {
    this._myLayerMask = this._myLayerMask & layerFlags.getMask();
  }
  copy(layerFlags) {
    this._myLayerMask = layerFlags._myLayerMask;
  }
  getMask() {
    return this._myLayerMask;
  }
  setMask(layerMask) {
    this._myLayerMask = layerMask;
  }
  equals(other) {
    return this._myLayerMask == other._myLayerMask;
  }
};

// dist/pp/cauldron/physics/physics_raycast_params.js
var RaycastBlockColliderType;
(function(RaycastBlockColliderType2) {
  RaycastBlockColliderType2[RaycastBlockColliderType2["NORMAL"] = 0] = "NORMAL";
  RaycastBlockColliderType2[RaycastBlockColliderType2["TRIGGER"] = 1] = "TRIGGER";
  RaycastBlockColliderType2[RaycastBlockColliderType2["BOTH"] = 2] = "BOTH";
})(RaycastBlockColliderType || (RaycastBlockColliderType = {}));
var RaycastParams = class {
  myOrigin = vec3_create();
  myDirection = vec3_create();
  myDistance = 0;
  myBlockLayerFlags = new PhysicsLayerFlags();
  myBlockColliderType = RaycastBlockColliderType.NORMAL;
  myObjectsToIgnore = [];
  myIgnoreHitsInsideCollision = false;
  myPhysics;
  constructor(physics = Globals.getPhysics()) {
    this.myPhysics = physics;
  }
  copy(other) {
    this.myOrigin.vec3_copy(other.myOrigin);
    this.myDirection.vec3_copy(other.myDirection);
    this.myDistance = other.myDistance;
    this.myBlockLayerFlags.copy(other.myBlockLayerFlags);
    this.myObjectsToIgnore.pp_copy(other.myObjectsToIgnore);
    this.myIgnoreHitsInsideCollision = other.myIgnoreHitsInsideCollision;
    this.myPhysics = other.myPhysics;
  }
  reset() {
    this.myOrigin.vec3_zero();
    this.myDirection.vec3_zero();
    this.myDistance = 0;
    this.myBlockLayerFlags.setAllFlagsActive(false);
    this.myObjectsToIgnore.pp_clear();
    this.myIgnoreHitsInsideCollision = false;
  }
  equals(other) {
    if (this == other)
      return true;
    return this.myOrigin.vec3_equals(other.myOrigin) && this.myDirection.vec3_equals(other.myDirection) && this.myDistance == other.myDistance && this.myBlockLayerFlags.equals(other.myBlockLayerFlags) && this.myBlockColliderType == other.myBlockColliderType && this.myObjectsToIgnore.pp_equals(other.myObjectsToIgnore) && this.myIgnoreHitsInsideCollision == other.myIgnoreHitsInsideCollision && this.myPhysics == other.myPhysics;
  }
};
var RaycastResults = class _RaycastResults {
  myRaycastParams = null;
  myHits = [];
  _myUnusedHits = null;
  isColliding(ignoreHitsInsideCollision = false) {
    return ignoreHitsInsideCollision ? this.getFirstHitOutsideCollision() != null : this.myHits.length > 0;
  }
  getFirstHitInsideCollision() {
    let firstHit = null;
    for (let i = 0; i < this.myHits.length; i++) {
      const hit = this.myHits[i];
      if (hit.myInsideCollision) {
        firstHit = hit;
        break;
      }
    }
    return firstHit;
  }
  getFirstHitOutsideCollision() {
    let firstHit = null;
    for (let i = 0; i < this.myHits.length; i++) {
      const hit = this.myHits[i];
      if (!hit.myInsideCollision) {
        firstHit = hit;
        break;
      }
    }
    return firstHit;
  }
  getHitsInsideCollision() {
    const hits = [];
    for (let i = 0; i < this.myHits.length; i++) {
      const hit = this.myHits[i];
      if (hit.myInsideCollision) {
        hits.push(hit);
      }
    }
    return hits;
  }
  getHitsOutsideCollision() {
    const hits = [];
    for (let i = 0; i < this.myHits.length; i++) {
      const hit = this.myHits[i];
      if (!hit.myInsideCollision) {
        hits.push(hit);
      }
    }
    return hits;
  }
  removeHit(hitIndex) {
    const removedHit = this.myHits.pp_removeIndex(hitIndex);
    if (removedHit != null) {
      if (this._myUnusedHits == null) {
        this._myUnusedHits = [];
      }
      this._myUnusedHits.push(removedHit);
    }
    return removedHit ?? null;
  }
  removeAllHits() {
    if (this._myUnusedHits == null) {
      this._myUnusedHits = [];
    }
    for (let i = 0; i < this.myHits.length; i++) {
      this._myUnusedHits.push(this.myHits[i]);
    }
    this.myHits.pp_clear();
  }
  static _copySV = {
    copyHitCallback(elementToCopy, currentElement) {
      if (currentElement == null) {
        currentElement = new RaycastHit();
      }
      currentElement.copy(elementToCopy);
      return currentElement;
    }
  };
  copy(other) {
    if (other.myRaycastParams == null) {
      this.myRaycastParams = null;
    } else {
      if (this.myRaycastParams == null) {
        this.myRaycastParams = new RaycastParams(other.myRaycastParams.myPhysics);
      }
      this.myRaycastParams.copy(other.myRaycastParams);
    }
    if (this.myHits.length > other.myHits.length) {
      if (this._myUnusedHits == null) {
        this._myUnusedHits = [];
      }
      for (let i = 0; i < this.myHits.length - other.myHits.length; i++) {
        this._myUnusedHits.push(this.myHits.pop());
      }
    } else if (this.myHits.length < other.myHits.length) {
      if (this._myUnusedHits != null) {
        const length6 = Math.min(this._myUnusedHits.length, other.myHits.length - this.myHits.length);
        for (let i = 0; i < length6; i++) {
          this.myHits.push(this._myUnusedHits.pop());
        }
      }
    }
    const copyHitCallback = _RaycastResults._copySV.copyHitCallback;
    this.myHits.pp_copy(other.myHits, copyHitCallback);
  }
  reset() {
    if (this.myRaycastParams != null) {
      this.myRaycastParams.reset();
    }
    this.removeAllHits();
  }
  static _equalsSV = {
    hitsEqualCallback: (first2, second) => first2.equals(second)
  };
  equals(other) {
    if (this == other)
      return true;
    const hitsEqualCallback = _RaycastResults._equalsSV.hitsEqualCallback;
    return (this.myRaycastParams == other.myRaycastParams || this.myRaycastParams != null && other.myRaycastParams != null && this.myRaycastParams.equals(other.myRaycastParams)) && this.myHits.pp_equals(other.myHits, hitsEqualCallback);
  }
};
var RaycastHit = class {
  myPosition = vec3_create();
  myNormal = vec3_create();
  myDistance = 0;
  myObject = null;
  myInsideCollision = false;
  isValid() {
    return this.myObject != null;
  }
  copy(other) {
    this.myPosition.vec3_copy(other.myPosition);
    this.myNormal.vec3_copy(other.myNormal);
    this.myDistance = other.myDistance;
    this.myObject = other.myObject;
    this.myInsideCollision = other.myInsideCollision;
  }
  reset() {
    this.myPosition.vec3_zero();
    this.myNormal.vec3_zero();
    this.myDistance = 0;
    this.myObject = null;
    this.myInsideCollision = false;
  }
  equals(other) {
    if (this == other)
      return true;
    return this.myPosition.vec3_equals(other.myPosition) && this.myNormal.vec3_equals(other.myNormal) && this.myDistance == other.myDistance && this.myObject == other.myObject && this.myInsideCollision == other.myInsideCollision;
  }
};

// dist/pp/cauldron/visual/elements/visual_raycast.js
var VisualRaycastParams = class _VisualRaycastParams extends AbstractVisualElementParams {
  /**
   * TS type inference helper
   *
   * @param {any} engine
   */
  constructor(engine = Globals.getMainEngine()) {
    super(engine);
    this._myRaycastResults = new RaycastResults();
    this.myHitNormalLength = 0.2;
    this.myThickness = 5e-3;
    this.myShowOnlyFirstHit = true;
    this.myRayMaterial = null;
    this.myHitNormalMaterial = null;
    this.myLocal = false;
    this.myType = VisualElementDefaultType.RAYCAST;
  }
  get myRaycastResults() {
    return this._myRaycastResults;
  }
  set myRaycastResults(result) {
    this._myRaycastResults.copy(result);
  }
  _copyHook(other, deepCopy) {
  }
  _new() {
    return new _VisualRaycastParams(this.myParent.pp_getEngine());
  }
  _equalsHook(other) {
    return this.myHitNormalLength == other.myHitNormalLength && this.myThickness == other.myThickness && this.myShowOnlyFirstHit == other.myShowOnlyFirstHit && this.myRayMaterial == other.myRayMaterial && this.myHitNormalMaterial == other.myHitNormalMaterial && this.myLocal == other.myLocal && this._myRaycastResults.equals(other._myRaycastResults);
  }
};
var VisualRaycast = class _VisualRaycast extends AbstractVisualElement {
  constructor(params = new VisualRaycastParams()) {
    super(params);
    this._myVisualRaycast = new VisualArrow(new VisualArrowParams(this._myParams.myParent.pp_getEngine()));
    this._myVisualRaycast.setAutoRefresh(false);
    this._myVisualRaycastHitList = [];
    this._addVisualRaycastHit();
    this._prepare();
  }
  _updateHook(dt) {
    this._myVisualRaycast.update(dt);
    for (let visualRaycastHit of this._myVisualRaycastHitList) {
      visualRaycastHit.update(dt);
    }
  }
  _visibleChanged() {
    if (this._myVisible) {
      if (this._myParams.myRaycastResults.myRaycastParams != null) {
        this._myVisualRaycast.setVisible(true);
      }
      if (this._myParams.myRaycastResults.myHits.length > 0) {
        let hitsToShow = Math.min(this._myParams.myRaycastResults.myHits.length, this._myVisualRaycastHitList.length);
        for (let i = 0; i < hitsToShow; i++) {
          let visualRaycastHit = this._myVisualRaycastHitList[i];
          visualRaycastHit.setVisible(true);
        }
      }
    } else {
      this._myVisualRaycast.setVisible(false);
      for (let visualRaycastHit of this._myVisualRaycastHitList) {
        visualRaycastHit.setVisible(false);
      }
    }
  }
  _build() {
  }
  _refreshHook() {
    for (let visualRaycastHit of this._myVisualRaycastHitList) {
      visualRaycastHit.setVisible(false);
    }
    if (this._myParams.myRaycastResults.myHits.length > 0) {
      let raycastDistance = this._myParams.myShowOnlyFirstHit ? this._myParams.myRaycastResults.myHits.pp_first().myDistance : this._myParams.myRaycastResults.myHits.pp_last().myDistance;
      {
        let visualRaycastParams = this._myVisualRaycast.getParams();
        visualRaycastParams.myStart.vec3_copy(this._myParams.myRaycastResults.myRaycastParams.myOrigin);
        visualRaycastParams.myDirection.vec3_copy(this._myParams.myRaycastResults.myRaycastParams.myDirection);
        visualRaycastParams.myLength = raycastDistance;
        visualRaycastParams.myThickness = this._myParams.myThickness;
        if (this._myParams.myRayMaterial == null) {
          visualRaycastParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myRay;
        } else {
          visualRaycastParams.myMaterial = this._myParams.myRayMaterial;
        }
        visualRaycastParams.myParent = this._myParams.myParent;
        visualRaycastParams.myLocal = this._myParams.myLocal;
        this._myVisualRaycast.paramsUpdated();
        this._myVisualRaycast.setVisible(this._myVisible);
      }
      let hitsToShow = this._myParams.myShowOnlyFirstHit ? 1 : this._myParams.myRaycastResults.myHits.length;
      while (hitsToShow > this._myVisualRaycastHitList.length) {
        this._addVisualRaycastHit();
      }
      for (let i = 0; i < hitsToShow; i++) {
        let visualRaycastHit = this._myVisualRaycastHitList[i];
        {
          let visualRaycastHitParams = visualRaycastHit.getParams();
          visualRaycastHitParams.myStart.vec3_copy(this._myParams.myRaycastResults.myHits[i].myPosition);
          visualRaycastHitParams.myDirection.vec3_copy(this._myParams.myRaycastResults.myHits[i].myNormal);
          visualRaycastHitParams.myLength = this._myParams.myHitNormalLength;
          visualRaycastHitParams.myThickness = this._myParams.myThickness;
          if (this._myParams.myHitNormalMaterial == null) {
            visualRaycastHitParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myHitNormal;
          } else {
            visualRaycastHitParams.myMaterial = this._myParams.myHitNormalMaterial;
          }
          visualRaycastHitParams.myParent = this._myParams.myParent;
          visualRaycastHitParams.myLocal = this._myParams.myLocal;
          visualRaycastHit.paramsUpdated();
          visualRaycastHit.setVisible(this._myVisible);
        }
      }
    } else if (this._myParams.myRaycastResults.myRaycastParams != null) {
      {
        let visualRaycastParams = this._myVisualRaycast.getParams();
        visualRaycastParams.myStart.vec3_copy(this._myParams.myRaycastResults.myRaycastParams.myOrigin);
        visualRaycastParams.myDirection.vec3_copy(this._myParams.myRaycastResults.myRaycastParams.myDirection);
        visualRaycastParams.myLength = this._myParams.myRaycastResults.myRaycastParams.myDistance;
        visualRaycastParams.myThickness = this._myParams.myThickness;
        if (this._myParams.myRayMaterial == null) {
          visualRaycastParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myRay;
        } else {
          visualRaycastParams.myMaterial = this._myParams.myRayMaterial;
        }
        visualRaycastParams.myParent = this._myParams.myParent;
        visualRaycastParams.myLocal = this._myParams.myLocal;
        this._myVisualRaycast.paramsUpdated();
        this._myVisualRaycast.setVisible(this._myVisible);
      }
    } else {
      this._myVisualRaycast.setVisible(false);
    }
  }
  _new(params) {
    return new _VisualRaycast(params);
  }
  _addVisualRaycastHit() {
    let visualRaycastHit = new VisualArrow(new VisualArrowParams(this._myParams.myParent.pp_getEngine()));
    visualRaycastHit.setAutoRefresh(false);
    visualRaycastHit.setVisible(false);
    this._myVisualRaycastHitList.push(visualRaycastHit);
  }
  _destroyHook() {
    this._myVisualRaycast.destroy();
    for (let visualRaycastHit of this._myVisualRaycastHitList) {
      visualRaycastHit.destroy();
    }
  }
};
VisualRaycastParams.prototype._copyHook = function _copyHook4(other, deepCopy) {
  this.myRaycastResults = other.myRaycastResults;
  this.myHitNormalLength = other.myHitNormalLength;
  this.myThickness = other.myThickness;
  this.myShowOnlyFirstHit = other.myShowOnlyFirstHit;
  if (other.myRayMaterial != null && deepCopy) {
    this.myRayMaterial = other.myRayMaterial.clone();
  } else {
    this.myRayMaterial = other.myRayMaterial;
  }
  if (other.myHitNormalMaterial != null && deepCopy) {
    this.myHitNormalMaterial = other.myForwardMaterial.clone();
  } else {
    this.myHitNormalMaterial = other.myHitNormalMaterial;
  }
  this.myParent = other.myParent;
  this.myLocal = other.myLocal;
  this.myType = other.myType;
};

// dist/pp/cauldron/visual/elements/visual_text.js
import { Alignment, TextComponent as TextComponent3, VerticalAlignment } from "@wonderlandengine/api";
var VisualTextParams = class _VisualTextParams extends AbstractVisualElementParams {
  /**
   * TS type inference helper
   *
   * @param {any} engine
   */
  constructor(engine = Globals.getMainEngine()) {
    super(engine);
    this.myText = "";
    this.myAlignment = Alignment.Center;
    this.myVerticalAlignment = VerticalAlignment.Middle;
    this.myTransform = mat4_create();
    this.myMaterial = null;
    this.myColor = null;
    this.myLocal = false;
    this.myLookAtObject = null;
    this.myType = VisualElementDefaultType.TEXT;
  }
  _copyHook(other, deepCopy) {
  }
  _new() {
    return new _VisualTextParams(this.myParent.pp_getEngine());
  }
  _equalsHook(other) {
    return this.myText == other.myText && this.myAlignment == other.myAlignment && this.myVerticalAlignment == other.myVerticalAlignment && this.myMaterial == other.myMaterial && this.myLookAtObject == other.myLookAtObject && this.myLocal == other.myLocal && (this.myColor == other.myColor || this.myColor != null && other.myColor != null && this.myColor.vec_equals(other.myColor)) && this.myTransform.vec_equals(other.myTransform);
  }
};
var VisualText = class _VisualText extends AbstractVisualElement {
  constructor(params = new VisualTextParams()) {
    super(params);
    this._myTextObject = null;
    this._myTextComponent = null;
    this._myTextMaterial = null;
    this._prepare();
  }
  _visibleChanged() {
    this._myTextObject.pp_setActive(this._myVisible);
  }
  _build() {
    this._myTextObject = Globals.getSceneObjects(this._myParams.myParent.pp_getEngine()).myVisualElements.pp_addChild();
    this._myTextComponent = this._myTextObject.pp_addComponent(TextComponent3);
  }
  _refreshHook() {
  }
  _new(params) {
    return new _VisualText(params);
  }
  _destroyHook() {
    this._myTextObject.pp_destroy();
  }
};
VisualTextParams.prototype._copyHook = function _copyHook5(other, deepCopy) {
  this.myText = other.myText;
  this.myAlignment = other.myAlignment;
  this.myVerticalAlignment = other.myVerticalAlignment;
  this.myTransform.mat4_copy(other.myTransform);
  if (other.myMaterial != null && deepCopy) {
    this.myMaterial = other.myMaterial.clone();
  } else {
    this.myMaterial = other.myMaterial;
  }
  if (other.myColor != null) {
    if (this.myColor != null) {
      this.myColor.vec4_copy(other.myColor);
    } else {
      this.myColor = other.myColor.vec4_clone();
    }
  } else {
    this.myColor = null;
  }
  this.myLocal = other.myLocal;
  this.myLookAtObject = other.myLookAtObject;
};
VisualText.prototype._refreshHook = function() {
  let lookAtPosition = vec3_create();
  return function _refreshHook() {
    this._myTextObject.pp_setParent(this._myParams.myParent, false);
    if (this._myParams.myLocal) {
      this._myTextObject.pp_setTransformLocal(this._myParams.myTransform);
    } else {
      this._myTextObject.pp_setTransform(this._myParams.myTransform);
    }
    if (this._myParams.myLookAtObject != null) {
      this._myParams.myLookAtObject.pp_getPosition(lookAtPosition);
      this._myTextObject.pp_lookAt(lookAtPosition);
    }
    if (this._myParams.myMaterial == null) {
      if (this._myParams.myColor == null) {
        this._myTextComponent.material = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myText;
      } else {
        if (this._myTextMaterial == null) {
          this._myTextMaterial = Globals.getDefaultMaterials(this._myParams.myParent.pp_getEngine()).myText.clone();
        }
        this._myTextComponent.material = this._myTextMaterial;
        this._myTextMaterial.color = this._myParams.myColor;
      }
    } else {
      this._myTextComponent.material = this._myParams.myMaterial;
    }
    this._myTextComponent.text = this._myParams.myText;
    this._myTextComponent.alignment = this._myParams.myAlignment;
    this._myTextComponent.verticalAlignment = this._myParams.myVerticalAlignment;
    this._myDirty = false;
  };
}();

// dist/pp/cauldron/visual/elements/visual_torus.js
var VisualTorusParams = class _VisualTorusParams extends AbstractVisualElementParams {
  /**
   * TS type inference helper
   *
   * @param {any} engine
   */
  constructor(engine = Globals.getMainEngine()) {
    super(engine);
    this.myTransform = mat4_create();
    this.myRadius = 0;
    this.mySegmentsAmount = 12;
    this.mySegmentThickness = 0.05;
    this.mySegmentMesh = null;
    this.myMaterial = null;
    this.myColor = null;
    this.myLocal = false;
    this.myType = VisualElementDefaultType.TORUS;
  }
  _copyHook(other, deepCopy) {
  }
  _new() {
    return new _VisualTorusParams(this.myParent.pp_getEngine());
  }
  _equalsHook(other) {
    return this.myRadius == other.myRadius && this.mySegmentsAmount == other.mySegmentsAmount && this.mySegmentThickness == other.mySegmentThickness && this.mySegmentMesh == other.mySegmentMesh && this.myMaterial == other.myMaterial && this.myLocal == other.myLocal && (this.myColor == other.myColor || this.myColor != null && other.myColor != null && this.myColor.vec_equals(other.myColor)) && this.myTransform.vec_equals(other.myTransform);
  }
};
var VisualTorus = class _VisualTorus extends AbstractVisualElement {
  constructor(params = new VisualTorusParams()) {
    super(params);
    this._myTorusParentObject = null;
    this._myVisualSegmentList = [];
    this._myFlatOpaqueMaterial = null;
    this._prepare();
  }
  _visibleChanged() {
    if (this._myVisible) {
      let segmentToShow = Math.min(this._myParams.mySegmentsAmount, this._myVisualSegmentList.length);
      for (let i = 0; i < segmentToShow; i++) {
        let visualSegment = this._myVisualSegmentList[i];
        visualSegment.setVisible(true);
      }
    } else {
      for (let visualSegment of this._myVisualSegmentList) {
        visualSegment.setVisible(false);
      }
    }
  }
  _updateHook(dt) {
    for (let visualSegment of this._myVisualSegmentList) {
      visualSegment.update(dt);
    }
  }
  _build() {
    this._myTorusParentObject = Globals.getSceneObjects(this._myParams.myParent.pp_getEngine()).myVisualElements.pp_addChild();
    this._fillSegmentList();
  }
  _fillSegmentList() {
    while (this._myVisualSegmentList.length < this._myParams.mySegmentsAmount) {
      let visualSegment = new VisualLine(new VisualLineParams(this._myParams.myParent.pp_getEngine()));
      visualSegment.setAutoRefresh(false);
      visualSegment.setVisible(false);
      visualSegment.getParams().myParent = this._myTorusParentObject;
      visualSegment.getParams().myLocal = true;
      this._myVisualSegmentList.push(visualSegment);
    }
  }
  _refreshHook() {
  }
  _new(params) {
    return new _VisualTorus(params);
  }
  _destroyHook() {
    for (let visualSegment of this._myVisualSegmentList) {
      visualSegment.destroy();
    }
    this._myTorusParentObject.pp_destroy();
  }
};
VisualTorus.prototype._refreshHook = function() {
  let segmentStart = vec3_create();
  let segmentEnd = vec3_create();
  let segmentDirection = vec3_create();
  let fixedSegmentStart = vec3_create();
  let fixedSegmentEnd = vec3_create();
  let up = vec3_create(0, 1, 0);
  return function _refreshHook() {
    this._fillSegmentList();
    for (let i = this._myParams.mySegmentsAmount; i < this._myVisualSegmentList.length; i++) {
      let visualSegment = this._myVisualSegmentList[i];
      visualSegment.setVisible(false);
    }
    this._myTorusParentObject.pp_setParent(this._myParams.myParent, false);
    if (this._myParams.myLocal) {
      this._myTorusParentObject.pp_setTransformLocal(this._myParams.myTransform);
    } else {
      this._myTorusParentObject.pp_setTransform(this._myParams.myTransform);
    }
    let sliceAngle = 2 * Math.PI / this._myParams.mySegmentsAmount;
    segmentStart.vec3_set(this._myParams.myRadius, 0, 0);
    for (let i = 0; i < this._myParams.mySegmentsAmount; i++) {
      segmentEnd = segmentStart.vec3_rotateAxisRadians(sliceAngle, up, segmentEnd);
      segmentDirection = segmentEnd.vec3_sub(segmentStart, segmentDirection).vec3_normalize(segmentDirection);
      let extraLength = Math.tan(sliceAngle / 2) * this._myParams.mySegmentThickness / 2;
      fixedSegmentStart = segmentStart.vec3_sub(segmentDirection.vec3_scale(extraLength, fixedSegmentStart), fixedSegmentStart);
      fixedSegmentEnd = segmentEnd.vec3_add(segmentDirection.vec3_scale(extraLength, fixedSegmentEnd), fixedSegmentEnd);
      let visualSegment = this._myVisualSegmentList[i];
      let visualSegmentParams = visualSegment.getParams();
      visualSegmentParams.setStartEnd(fixedSegmentStart, fixedSegmentEnd);
      visualSegmentParams.myThickness = this._myParams.mySegmentThickness;
      visualSegmentParams.myMesh = this._myParams.mySegmentMesh;
      if (this._myParams.myMaterial == null) {
        if (this._myParams.myColor == null) {
          visualSegmentParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myMesh;
        } else {
          if (this._myFlatOpaqueMaterial == null) {
            this._myFlatOpaqueMaterial = Globals.getDefaultMaterials(this._myParams.myParent.pp_getEngine()).myFlatOpaque.clone();
          }
          visualSegmentParams.myMaterial = this._myFlatOpaqueMaterial;
          this._myFlatOpaqueMaterial.color = this._myParams.myColor;
        }
      } else {
        visualSegmentParams.myMaterial = this._myParams.myMaterial;
      }
      visualSegment.paramsUpdated();
      visualSegment.setVisible(this._myVisible);
      segmentStart.vec3_copy(segmentEnd);
    }
  };
}();
VisualTorusParams.prototype._copyHook = function _copyHook6(other, deepCopy) {
  this.myRadius = other.myRadius;
  this.mySegmentsAmount = other.mySegmentsAmount;
  this.mySegmentThickness = other.mySegmentThickness;
  this.myTransform.mat4_copy(other.myTransform);
  this.mySegmentMesh = other.mySegmentMesh;
  if (other.myMaterial != null && deepCopy) {
    this.myMaterial = other.myMaterial.clone();
  } else {
    this.myMaterial = other.myMaterial;
  }
  if (other.myColor != null) {
    if (this.myColor != null) {
      this.myColor.vec4_copy(other.myColor);
    } else {
      this.myColor = other.myColor.vec4_clone();
    }
  } else {
    this.myColor = null;
  }
  this.myLocal = other.myLocal;
};

// dist/pp/cauldron/visual/elements/visual_transform.js
var VisualTransformParams = class _VisualTransformParams extends AbstractVisualElementParams {
  /**
   * TS type inference helper
   *
   * @param {any} engine
   */
  constructor(engine = Globals.getMainEngine()) {
    super(engine);
    this.myTransform = mat4_create();
    this.myLength = 0.2;
    this.myThickness = 5e-3;
    this.myForwardMaterial = null;
    this.myUpMaterial = null;
    this.myRightMaterial = null;
    this.myLocal = false;
    this.myType = VisualElementDefaultType.TRANSFORM;
  }
  _copyHook(other, deepCopy) {
  }
  _new() {
    return new _VisualTransformParams(this.myParent.pp_getEngine());
  }
  _equalsHook(other) {
    return this.myThickness == other.myThickness && this.myLength == other.myLength && this.myForwardMaterial == other.myForwardMaterial && this.myUpMaterial == other.myUpMaterial && this.myRightMaterial == other.myRightMaterial && this.myLocal == other.myLocal && this.myTransform.vec_equals(other.myTransform);
  }
};
var VisualTransform = class _VisualTransform extends AbstractVisualElement {
  constructor(params = new VisualTransformParams()) {
    super(params);
    this._myVisualRight = new VisualArrow(new VisualArrowParams(this._myParams.myParent.pp_getEngine()));
    this._myVisualUp = new VisualArrow(new VisualArrowParams(this._myParams.myParent.pp_getEngine()));
    this._myVisualForward = new VisualArrow(new VisualArrowParams(this._myParams.myParent.pp_getEngine()));
    this._myVisualRight.setAutoRefresh(false);
    this._myVisualUp.setAutoRefresh(false);
    this._myVisualForward.setAutoRefresh(false);
    this._prepare();
  }
  _updateHook(dt) {
    this._myVisualRight.update(dt);
    this._myVisualUp.update(dt);
    this._myVisualForward.update(dt);
  }
  _visibleChanged() {
    this._myVisualRight.setVisible(this._myVisible);
    this._myVisualUp.setVisible(this._myVisible);
    this._myVisualForward.setVisible(this._myVisible);
  }
  _build() {
  }
  _refreshHook() {
  }
  _new(params) {
    return new _VisualTransform(params);
  }
  _destroyHook() {
    this._myVisualRight.destroy();
    this._myVisualUp.destroy();
    this._myVisualForward.destroy();
  }
};
VisualTransform.prototype._refreshHook = function() {
  let axes = [vec3_create(), vec3_create(), vec3_create()];
  let scale4 = vec3_create();
  let position = vec3_create();
  return function _refreshHook() {
    axes = this._myParams.myTransform.mat4_getAxes(axes);
    scale4 = this._myParams.myTransform.mat4_getScale(scale4);
    let maxValue = 0;
    for (let value of scale4) {
      maxValue = Math.max(value, maxValue);
    }
    if (maxValue == 0) {
      scale4[0] = 1;
      scale4[1] = 1;
      scale4[2] = 1;
    } else {
      scale4[0] = scale4[0] / maxValue;
      scale4[1] = scale4[1] / maxValue;
      scale4[2] = scale4[2] / maxValue;
    }
    position = this._myParams.myTransform.mat4_getPosition(position);
    {
      let visualArrowParams = this._myVisualRight.getParams();
      visualArrowParams.myStart.vec3_copy(position);
      visualArrowParams.myDirection = axes[0].vec3_negate(visualArrowParams.myDirection).vec3_normalize(visualArrowParams.myDirection);
      visualArrowParams.myLength = Math.max(this._myParams.myLength * scale4[0], 1e-3);
      visualArrowParams.myThickness = this._myParams.myThickness;
      if (this._myParams.myRightMaterial == null) {
        visualArrowParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myRight;
      } else {
        visualArrowParams.myMaterial = this._myParams.myRightMaterial;
      }
      visualArrowParams.myParent = this._myParams.myParent;
      visualArrowParams.myLocal = this._myParams.myLocal;
      this._myVisualRight.paramsUpdated();
    }
    {
      let visualArrowParams = this._myVisualUp.getParams();
      visualArrowParams.myStart.vec3_copy(position);
      visualArrowParams.myDirection = axes[1].vec3_normalize(visualArrowParams.myDirection);
      visualArrowParams.myLength = Math.max(this._myParams.myLength * scale4[1], 1e-3);
      visualArrowParams.myThickness = this._myParams.myThickness;
      if (this._myParams.myUpMaterial == null) {
        visualArrowParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myUp;
      } else {
        visualArrowParams.myMaterial = this._myParams.myUpMaterial;
      }
      visualArrowParams.myParent = this._myParams.myParent;
      visualArrowParams.myLocal = this._myParams.myLocal;
      this._myVisualUp.paramsUpdated();
    }
    {
      let visualArrowParams = this._myVisualForward.getParams();
      visualArrowParams.myStart.vec3_copy(position);
      visualArrowParams.myDirection = axes[2].vec3_normalize(visualArrowParams.myDirection);
      visualArrowParams.myLength = Math.max(this._myParams.myLength * scale4[2], 1e-3);
      visualArrowParams.myThickness = this._myParams.myThickness;
      if (this._myParams.myForwardMaterial == null) {
        visualArrowParams.myMaterial = Globals.getVisualResources(this._myParams.myParent.pp_getEngine()).myDefaultMaterials.myForward;
      } else {
        visualArrowParams.myMaterial = this._myParams.myForwardMaterial;
      }
      visualArrowParams.myParent = this._myParams.myParent;
      visualArrowParams.myLocal = this._myParams.myLocal;
      this._myVisualForward.paramsUpdated();
    }
  };
}();
VisualTransformParams.prototype._copyHook = function _copyHook7(other, deepCopy) {
  this.myTransform.mat4_copy(other.myTransform);
  this.myLength = other.myLength;
  this.myThickness = other.myThickness;
  if (other.myRightMaterial != null && deepCopy) {
    this.myRightMaterial = other.myRightMaterial.clone();
  } else {
    this.myRightMaterial = other.myRightMaterial;
  }
  if (other.myUpMaterial != null && deepCopy) {
    this.myUpMaterial = other.myUpMaterial.clone();
  } else {
    this.myUpMaterial = other.myUpMaterial;
  }
  if (other.myForwardMaterial != null && deepCopy) {
    this.myForwardMaterial = other.myForwardMaterial.clone();
  } else {
    this.myForwardMaterial = other.myForwardMaterial;
  }
  this.myLocal = other.myLocal;
};

// dist/pp/cauldron/visual/visual_manager.js
var VisualManager = class {
  _myVisualElementPrototypeCreationCallbacks = /* @__PURE__ */ new Map();
  _myVisualElementsTypeMap = /* @__PURE__ */ new Map();
  _myVisualElementLastID = 0;
  _myVisualElementsToShow = [];
  _myVisualElementsParent = null;
  _myActive = true;
  _myObjectPoolManagerPrefix;
  _myTypePoolIDs = /* @__PURE__ */ new Map();
  _myEngine;
  _myDestroyed = false;
  constructor(engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myObjectPoolManagerPrefix = this._getClassName() + "_" + Math.pp_randomUUID() + "_visual_element_type_";
    this._addDefaultVisualElementTypes();
  }
  setActive(active) {
    if (this._myActive != active) {
      if (!active) {
        this.clearAllVisualElements();
      } else {
        this._myVisualElementsParent = Globals.getSceneObjects(this._myEngine)?.myVisualElements ?? null;
      }
      this._myActive = active;
    }
  }
  isActive() {
    return this._myActive && this._myVisualElementsParent != null;
  }
  start() {
    if (this._myActive) {
      this._myVisualElementsParent = Globals.getSceneObjects(this._myEngine)?.myVisualElements ?? null;
    }
  }
  update(dt) {
    if (this._myActive) {
      this._myVisualElementsParent = Globals.getSceneObjects(this._myEngine)?.myVisualElements ?? null;
      this._updateDraw(dt);
    }
  }
  /** `lifetimeSeconds` can be `null`, in that case the element will be drawn until cleared */
  draw(visualElementParams, lifetimeSeconds = 0, idToReuse) {
    if (!this.isActive()) {
      return null;
    }
    let visualElement = null;
    let idReused = false;
    if (idToReuse != null) {
      if (this._myVisualElementsTypeMap.has(visualElementParams.myType)) {
        const visualElements2 = this._myVisualElementsTypeMap.get(visualElementParams.myType);
        if (visualElements2.has(idToReuse)) {
          visualElement = visualElements2.get(idToReuse)[0];
          visualElement.copyParamsGeneric(visualElementParams);
          visualElement.setVisible(false);
          idReused = true;
        }
      }
    }
    if (visualElement == null) {
      visualElement = this._getVisualElementFromPool(visualElementParams);
    }
    if (visualElement == null) {
      console.error("Couldn't create the requested visual element");
      return null;
    }
    if (!this._myVisualElementsTypeMap.has(visualElementParams.myType)) {
      this._myVisualElementsTypeMap.set(visualElementParams.myType, /* @__PURE__ */ new Map());
    }
    const visualElements = this._myVisualElementsTypeMap.get(visualElementParams.myType);
    let elementID = null;
    if (!idReused) {
      elementID = this._myVisualElementLastID + 1;
      this._myVisualElementLastID = elementID;
      visualElements.set(elementID, [visualElement, new Timer(lifetimeSeconds != null ? lifetimeSeconds : 0, lifetimeSeconds != null)]);
    } else {
      elementID = idToReuse;
      const visualElementPair = visualElements.get(elementID);
      visualElementPair[0] = visualElement;
      if (lifetimeSeconds != null) {
        visualElementPair[1].reset(lifetimeSeconds);
        visualElementPair[1].start();
      } else {
        visualElementPair[1].reset();
      }
    }
    this._myVisualElementsToShow.push(visualElement);
    return elementID;
  }
  getVisualElement(elementID) {
    let visualElement = null;
    for (const visualElements of this._myVisualElementsTypeMap.values()) {
      if (visualElements.has(elementID)) {
        const visualElementPair = visualElements.get(elementID);
        visualElement = visualElementPair[0];
        break;
      }
    }
    return visualElement;
  }
  getVisualElementParams(elementID) {
    const visualElement = this.getVisualElement(elementID);
    return visualElement != null ? visualElement.getParamsGeneric() : null;
  }
  getVisualElementID(visualElement) {
    let elementID = null;
    for (const currentVisualElements of this._myVisualElementsTypeMap.values()) {
      for (const [currentElementID, currentVisualElement] of currentVisualElements.entries()) {
        if (currentVisualElement[0] == visualElement) {
          elementID = currentElementID;
          break;
        }
      }
      if (elementID != null) {
        break;
      }
    }
    return elementID;
  }
  clearAllVisualElements() {
    if (!this.isActive())
      return;
    for (const visualElements of this._myVisualElementsTypeMap.values()) {
      for (const visualElement of visualElements.values()) {
        this._releaseElement(visualElement[0]);
      }
    }
    this._myVisualElementsToShow.pp_clear();
    this._myVisualElementsTypeMap.clear();
    this._myVisualElementLastID = 0;
  }
  clearVisualElement(elementID) {
    if (!this.isActive())
      return;
    for (const visualElements of this._myVisualElementsTypeMap.values()) {
      if (visualElements.has(elementID)) {
        const visualElementPair = visualElements.get(elementID);
        this._releaseElement(visualElementPair[0]);
        visualElements.delete(elementID);
        this._myVisualElementsToShow.pp_removeEqual(visualElementPair[0]);
        break;
      }
    }
  }
  allocateVisualElementType(visualElementType, amount) {
    if (!this.isActive())
      return;
    if (!Globals.getObjectPoolManager(this._myEngine).hasPool(this._getTypePoolID(visualElementType))) {
      this._addVisualElementTypeToPool(visualElementType);
    }
    const pool = Globals.getObjectPoolManager(this._myEngine).getPool(this._getTypePoolID(visualElementType));
    const difference = pool.getAvailableSize() - amount;
    if (difference < 0) {
      pool.increase(-difference);
    }
  }
  addVisualElementType(visualElementType, visuaElementPrototypeCreationCallback) {
    this._myVisualElementPrototypeCreationCallbacks.set(visualElementType, visuaElementPrototypeCreationCallback);
  }
  removeVisualElementType(visualElementType) {
    this._myVisualElementPrototypeCreationCallbacks.delete(visualElementType);
  }
  _updateDraw(dt) {
    for (const visualElement of this._myVisualElementsToShow) {
      visualElement.setVisible(true);
    }
    this._myVisualElementsToShow.pp_clear();
    for (const visualElements of this._myVisualElementsTypeMap.values()) {
      const idsToRemove = [];
      for (const visualElementsEntry of visualElements.entries()) {
        const visualElement = visualElementsEntry[1];
        if (visualElement[1].isDone()) {
          this._releaseElement(visualElement[0]);
          idsToRemove.push(visualElementsEntry[0]);
        } else {
          visualElement[0].update(dt);
          visualElement[1].update(dt);
        }
      }
      for (const id of idsToRemove) {
        visualElements.delete(id);
      }
    }
  }
  _getVisualElementFromPool(params) {
    let element = null;
    if (!Globals.getObjectPoolManager(this._myEngine).hasPool(this._getTypePoolID(params.myType))) {
      this._addVisualElementTypeToPool(params.myType);
    }
    element = Globals.getObjectPoolManager(this._myEngine).get(this._getTypePoolID(params.myType));
    if (element != null) {
      element.copyParamsGeneric(params);
    }
    return element;
  }
  _addVisualElementTypeToPool(visualElementType) {
    const objectPoolParams = new ObjectPoolParams();
    objectPoolParams.myInitialPoolSize = 10;
    objectPoolParams.myAmountToAddWhenEmpty = 0;
    objectPoolParams.myPercentageToAddWhenEmpty = 0.5;
    objectPoolParams.myCloneCallback = function(visualElement) {
      return visualElement.clone();
    };
    objectPoolParams.mySetActiveCallback = function(visualElement, active) {
      visualElement.setVisible(active);
    };
    objectPoolParams.myDestroyCallback = function(visualElement) {
      visualElement.destroy();
    };
    let visualElementPrototype = null;
    if (this._myVisualElementPrototypeCreationCallbacks.has(visualElementType)) {
      visualElementPrototype = this._myVisualElementPrototypeCreationCallbacks.get(visualElementType)();
    }
    if (visualElementPrototype != null) {
      visualElementPrototype.setVisible(false);
      visualElementPrototype.setAutoRefresh(true);
      Globals.getObjectPoolManager(this._myEngine).addPool(this._getTypePoolID(visualElementType), new ObjectPool(visualElementPrototype, objectPoolParams));
    } else {
      console.error("Visual element type not supported: " + visualElementType);
    }
  }
  _addDefaultVisualElementTypes() {
    this.addVisualElementType(VisualElementDefaultType.LINE, () => new VisualLine(new VisualLineParams(this._myEngine)));
    this.addVisualElementType(VisualElementDefaultType.MESH, () => new VisualMesh(new VisualMeshParams(this._myEngine)));
    this.addVisualElementType(VisualElementDefaultType.POINT, () => new VisualPoint(new VisualPointParams(this._myEngine)));
    this.addVisualElementType(VisualElementDefaultType.ARROW, () => new VisualArrow(new VisualArrowParams(this._myEngine)));
    this.addVisualElementType(VisualElementDefaultType.TEXT, () => new VisualText(new VisualTextParams(this._myEngine)));
    this.addVisualElementType(VisualElementDefaultType.TRANSFORM, () => new VisualTransform(new VisualTransformParams(this._myEngine)));
    this.addVisualElementType(VisualElementDefaultType.RAYCAST, () => new VisualRaycast(new VisualRaycastParams(this._myEngine)));
    this.addVisualElementType(VisualElementDefaultType.TORUS, () => new VisualTorus(new VisualTorusParams(this._myEngine)));
  }
  _getTypePoolID(visualElementType) {
    let typePoolID = this._myTypePoolIDs.get(visualElementType);
    if (typePoolID == null) {
      typePoolID = this._myObjectPoolManagerPrefix + visualElementType;
      this._myTypePoolIDs.set(visualElementType, typePoolID);
    }
    return typePoolID;
  }
  _releaseElement(visualElement) {
    if (this._myVisualElementsParent != null) {
      if (visualElement.getParamsGeneric().myParent != this._myVisualElementsParent) {
        visualElement.getParamsGeneric().myParent = this._myVisualElementsParent;
        visualElement.paramsUpdated();
        visualElement.refresh();
      }
    }
    Globals.getObjectPoolManager(this._myEngine)?.release(this._getTypePoolID(visualElement.getParamsGeneric().myType), visualElement);
  }
  _getClassName() {
    return "visual_manager";
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
    for (const poolID of this._myTypePoolIDs.values()) {
      Globals.getObjectPoolManager(this._myEngine)?.destroyPool(poolID);
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/cauldron/visual/visual_resources.js
var VisualResources = class {
  myDefaultMaterials = new VisualResourcesMaterials();
};
var VisualResourcesMaterials = class {
  myMesh = null;
  myText = null;
  myRight = null;
  myUp = null;
  myForward = null;
  myRay = null;
  myHitNormal = null;
};

// dist/pp/cauldron/visual/components/visual_manager_component.js
var VisualManagerComponent = class extends Component7 {
  static TypeName = "pp-visual-manager";
  start() {
    this._myVisualManager = new VisualManager(this.engine);
    this._myVisualResources = new VisualResources();
    this._myVisualResources.myDefaultMaterials.myMesh = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
    this._myVisualResources.myDefaultMaterials.myText = Globals.getDefaultMaterials(this.engine).myText.clone();
    this._myVisualResources.myDefaultMaterials.myRight = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
    this._myVisualResources.myDefaultMaterials.myRight.color = vec4_create(1, 0, 0, 1);
    this._myVisualResources.myDefaultMaterials.myUp = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
    this._myVisualResources.myDefaultMaterials.myUp.color = vec4_create(0, 1, 0, 1);
    this._myVisualResources.myDefaultMaterials.myForward = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
    this._myVisualResources.myDefaultMaterials.myForward.color = vec4_create(0, 0, 1, 1);
    this._myVisualResources.myDefaultMaterials.myRay = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
    this._myVisualResources.myDefaultMaterials.myRay.color = vec4_create(0, 1, 0, 1);
    this._myVisualResources.myDefaultMaterials.myHitNormal = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
    this._myVisualResources.myDefaultMaterials.myHitNormal.color = vec4_create(1, 0, 0, 1);
    this._myVisualManager.start();
  }
  update(dt) {
    if (Globals.getVisualManager(this.engine) == this._myVisualManager) {
      this._myVisualManager.update(dt);
    }
  }
  onActivate() {
    if (!Globals.hasVisualManager(this.engine)) {
      this._myVisualManager.setActive(true);
      Globals.setVisualManager(this._myVisualManager, this.engine);
    }
    if (!Globals.hasVisualResources(this.engine)) {
      Globals.setVisualResources(this._myVisualResources, this.engine);
    }
  }
  onDeactivate() {
    if (this._myVisualManager != null) {
      this._myVisualManager.setActive(false);
      if (Globals.getVisualManager(this.engine) == this._myVisualManager) {
        Globals.removeVisualManager(this.engine);
      }
    }
    if (this._myVisualResources != null && Globals.getVisualResources(this.engine) == this._myVisualResources) {
      Globals.removeVisualResources(this.engine);
    }
  }
  onDestroy() {
    if (this._myVisualManager != null) {
      this._myVisualManager.destroy();
    }
  }
};

// dist/pp/cauldron/wl/components/add_wl_to_window_component.js
import * as WLAPI from "@wonderlandengine/api";
import { Component as Component8, Property as Property4 } from "@wonderlandengine/api";
import * as WLComponents from "@wonderlandengine/components";
var AddWLToWindowComponent = class extends Component8 {
  static TypeName = "pp-add-wl-to-window";
  static Properties = {
    _myAdd: Property4.bool(true)
  };
  start() {
    this._myWL = null;
    if (this._myAdd) {
      this._myWL = {};
      this._addProperties(WLAPI);
      this._addProperties(WLComponents);
      window.WL = this._myWL;
    }
  }
  _addProperties(object) {
    let propertyNames = Object.getOwnPropertyNames(object);
    for (let propertyName of propertyNames) {
      if (object[propertyName] != void 0) {
        this._myWL[propertyName] = object[propertyName];
      }
    }
  }
  onActivate() {
    if (this._myWL != null) {
      window.WL = this._myWL;
    }
  }
  onDeactivate() {
    if (this._myWL != null) {
      delete window.WL;
    }
  }
};

// dist/pp/cauldron/wl/getters/components/get_default_resources_component.js
import { Component as Component9, Property as Property5 } from "@wonderlandengine/api";

// dist/pp/cauldron/wl/getters/default_resources.js
var DefaultResources = class {
  myMeshes = new DefaultResourcesMeshes();
  myMaterials = new DefaultResourcesMaterials();
};
var DefaultResourcesMeshes = class {
  myPlane = null;
  myCube = null;
  mySphere = null;
  myCone = null;
  myCylinder = null;
  myCircle = null;
  myInvertedCube = null;
  myInvertedSphere = null;
  myInvertedCone = null;
  myInvertedCylinder = null;
  myDoubleSidedPlane = null;
  myDoubleSidedCube = null;
  myDoubleSidedSphere = null;
  myDoubleSidedCone = null;
  myDoubleSidedCylinder = null;
  myDoubleSidedCircle = null;
};
var DefaultResourcesMaterials = class {
  myFlatOpaque = null;
  /** For now, the pipeline associated to this material needs to be the last one to make it work properly */
  myFlatTransparentNoDepth = null;
  myPhongOpaque = null;
  myText = null;
};

// dist/pp/cauldron/wl/getters/components/get_default_resources_component.js
var GetDefaultResourcesComponent = class extends Component9 {
  static TypeName = "pp-get-default-resources";
  static Properties = {
    _myPlane: Property5.mesh(),
    _myCube: Property5.mesh(),
    _mySphere: Property5.mesh(),
    _myCone: Property5.mesh(),
    _myCylinder: Property5.mesh(),
    _myCircle: Property5.mesh(),
    _myFlatOpaque: Property5.material(),
    _myFlatTransparentNoDepth: Property5.material(),
    _myPhongOpaque: Property5.material(),
    _myText: Property5.material()
  };
  start() {
    this._myDefaultResources = new DefaultResources();
    this._myDefaultResources.myMeshes.myPlane = MeshUtils.clone(this._myPlane);
    this._myDefaultResources.myMeshes.myCube = MeshUtils.clone(this._myCube);
    this._myDefaultResources.myMeshes.mySphere = MeshUtils.clone(this._mySphere);
    this._myDefaultResources.myMeshes.myCone = MeshUtils.clone(this._myCone);
    this._myDefaultResources.myMeshes.myCylinder = MeshUtils.clone(this._myCylinder);
    this._myDefaultResources.myMeshes.myCircle = MeshUtils.clone(this._myCircle);
    this._myDefaultResources.myMeshes.myInvertedCube = MeshUtils.invert(this._myCube);
    this._myDefaultResources.myMeshes.myInvertedSphere = MeshUtils.invert(this._mySphere);
    this._myDefaultResources.myMeshes.myInvertedCone = MeshUtils.invert(this._myCone);
    this._myDefaultResources.myMeshes.myInvertedCylinder = MeshUtils.invert(this._myCylinder);
    this._myDefaultResources.myMeshes.myDoubleSidedPlane = MeshUtils.makeDoubleSided(this._myPlane);
    this._myDefaultResources.myMeshes.myDoubleSidedCube = MeshUtils.makeDoubleSided(this._myCube);
    this._myDefaultResources.myMeshes.myDoubleSidedSphere = MeshUtils.makeDoubleSided(this._mySphere);
    this._myDefaultResources.myMeshes.myDoubleSidedCone = MeshUtils.makeDoubleSided(this._myCone);
    this._myDefaultResources.myMeshes.myDoubleSidedCylinder = MeshUtils.makeDoubleSided(this._myCylinder);
    this._myDefaultResources.myMeshes.myDoubleSidedCircle = MeshUtils.makeDoubleSided(this._myCircle);
    if (this._myFlatOpaque != null) {
      this._myDefaultResources.myMaterials.myFlatOpaque = this._myFlatOpaque.clone();
    }
    if (this._myFlatTransparentNoDepth != null) {
      this._myDefaultResources.myMaterials.myFlatTransparentNoDepth = this._myFlatTransparentNoDepth.clone();
    }
    if (this._myPhongOpaque != null) {
      this._myDefaultResources.myMaterials.myPhongOpaque = this._myPhongOpaque.clone();
    }
    if (this._myText != null) {
      this._myDefaultResources.myMaterials.myText = this._myText.clone();
    }
  }
  onActivate() {
    if (!Globals.hasDefaultResources(this.engine)) {
      Globals.setDefaultResources(this._myDefaultResources, this.engine);
    }
  }
  onDeactivate() {
    if (this._myDefaultResources != null && Globals.getDefaultResources(this.engine) == this._myDefaultResources) {
      Globals.removeDefaultResources(this.engine);
    }
  }
};

// dist/pp/cauldron/wl/getters/components/get_scene_objects_component.js
import { Component as Component10, Property as Property6 } from "@wonderlandengine/api";

// dist/pp/input/cauldron/input_types.js
var Handedness;
(function(Handedness2) {
  Handedness2["LEFT"] = "left";
  Handedness2["RIGHT"] = "right";
})(Handedness || (Handedness = {}));
var HandednessIndex;
(function(HandednessIndex2) {
  HandednessIndex2[HandednessIndex2["LEFT"] = 0] = "LEFT";
  HandednessIndex2[HandednessIndex2["RIGHT"] = 1] = "RIGHT";
})(HandednessIndex || (HandednessIndex = {}));
var InputSourceType;
(function(InputSourceType2) {
  InputSourceType2[InputSourceType2["GAMEPAD"] = 0] = "GAMEPAD";
  InputSourceType2[InputSourceType2["TRACKED_HAND"] = 1] = "TRACKED_HAND";
})(InputSourceType || (InputSourceType = {}));
var TrackedHandJointID;
(function(TrackedHandJointID2) {
  TrackedHandJointID2["WRIST"] = "wrist";
  TrackedHandJointID2["THUMB_METACARPAL"] = "thumb-metacarpal";
  TrackedHandJointID2["THUMB_PHALANX_PROXIMAL"] = "thumb-phalanx-proximal";
  TrackedHandJointID2["THUMB_PHALANX_DISTAL"] = "thumb-phalanx-distal";
  TrackedHandJointID2["THUMB_TIP"] = "thumb-tip";
  TrackedHandJointID2["INDEX_FINGER_METACARPAL"] = "index-finger-metacarpal";
  TrackedHandJointID2["INDEX_FINGER_PHALANX_PROXIMAL"] = "index-finger-phalanx-proximal";
  TrackedHandJointID2["INDEX_FINGER_PHALANX_INTERMEDIATE"] = "index-finger-phalanx-intermediate";
  TrackedHandJointID2["INDEX_FINGER_PHALANX_DISTAL"] = "index-finger-phalanx-distal";
  TrackedHandJointID2["INDEX_FINGER_TIP"] = "index-finger-tip";
  TrackedHandJointID2["MIDDLE_FINGER_METACARPAL"] = "middle-finger-metacarpal";
  TrackedHandJointID2["MIDDLE_FINGER_PHALANX_PROXIMAL"] = "middle-finger-phalanx-proximal";
  TrackedHandJointID2["MIDDLE_FINGER_PHALANX_INTERMEDIATE"] = "middle-finger-phalanx-intermediate";
  TrackedHandJointID2["MIDDLE_FINGER_PHALANX_DISTAL"] = "middle-finger-phalanx-distal";
  TrackedHandJointID2["MIDDLE_FINGER_TIP"] = "middle-finger-tip";
  TrackedHandJointID2["RING_FINGER_METACARPAL"] = "ring-finger-metacarpal";
  TrackedHandJointID2["RING_FINGER_PHALANX_PROXIMAL"] = "ring-finger-phalanx-proximal";
  TrackedHandJointID2["RING_FINGER_PHALANX_INTERMEDIATE"] = "ring-finger-phalanx-intermediate";
  TrackedHandJointID2["RING_FINGER_PHALANX_DISTAL"] = "ring-finger-phalanx-distal";
  TrackedHandJointID2["RING_FINGER_TIP"] = "ring-finger-tip";
  TrackedHandJointID2["PINKY_FINGER_METACARPAL"] = "pinky-finger-metacarpal";
  TrackedHandJointID2["PINKY_FINGER_PHALANX_PROXIMAL"] = "pinky-finger-phalanx-proximal";
  TrackedHandJointID2["PINKY_FINGER_PHALANX_INTERMEDIATE"] = "pinky-finger-phalanx-intermediate";
  TrackedHandJointID2["PINKY_FINGER_PHALANX_DISTAL"] = "pinky-finger-phalanx-distal";
  TrackedHandJointID2["PINKY_FINGER_TIP"] = "pinky-finger-tip";
})(TrackedHandJointID || (TrackedHandJointID = {}));
var TrackedHandJointIDIndex;
(function(TrackedHandJointIDIndex2) {
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["WRIST"] = 0] = "WRIST";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["THUMB_METACARPAL"] = 1] = "THUMB_METACARPAL";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["THUMB_PHALANX_PROXIMAL"] = 2] = "THUMB_PHALANX_PROXIMAL";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["THUMB_PHALANX_DISTAL"] = 3] = "THUMB_PHALANX_DISTAL";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["THUMB_TIP"] = 4] = "THUMB_TIP";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["INDEX_FINGER_METACARPAL"] = 5] = "INDEX_FINGER_METACARPAL";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["INDEX_FINGER_PHALANX_PROXIMAL"] = 6] = "INDEX_FINGER_PHALANX_PROXIMAL";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["INDEX_FINGER_PHALANX_INTERMEDIATE"] = 7] = "INDEX_FINGER_PHALANX_INTERMEDIATE";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["INDEX_FINGER_PHALANX_DISTAL"] = 8] = "INDEX_FINGER_PHALANX_DISTAL";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["INDEX_FINGER_TIP"] = 9] = "INDEX_FINGER_TIP";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["MIDDLE_FINGER_METACARPAL"] = 10] = "MIDDLE_FINGER_METACARPAL";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["MIDDLE_FINGER_PHALANX_PROXIMAL"] = 11] = "MIDDLE_FINGER_PHALANX_PROXIMAL";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["MIDDLE_FINGER_PHALANX_INTERMEDIATE"] = 12] = "MIDDLE_FINGER_PHALANX_INTERMEDIATE";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["MIDDLE_FINGER_PHALANX_DISTAL"] = 13] = "MIDDLE_FINGER_PHALANX_DISTAL";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["MIDDLE_FINGER_TIP"] = 14] = "MIDDLE_FINGER_TIP";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["RING_FINGER_METACARPAL"] = 15] = "RING_FINGER_METACARPAL";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["RING_FINGER_PHALANX_PROXIMAL"] = 16] = "RING_FINGER_PHALANX_PROXIMAL";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["RING_FINGER_PHALANX_INTERMEDIATE"] = 17] = "RING_FINGER_PHALANX_INTERMEDIATE";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["RING_FINGER_PHALANX_DISTAL"] = 18] = "RING_FINGER_PHALANX_DISTAL";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["RING_FINGER_TIP"] = 19] = "RING_FINGER_TIP";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["PINKY_FINGER_METACARPAL"] = 20] = "PINKY_FINGER_METACARPAL";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["PINKY_FINGER_PHALANX_PROXIMAL"] = 21] = "PINKY_FINGER_PHALANX_PROXIMAL";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["PINKY_FINGER_PHALANX_INTERMEDIATE"] = 22] = "PINKY_FINGER_PHALANX_INTERMEDIATE";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["PINKY_FINGER_PHALANX_DISTAL"] = 23] = "PINKY_FINGER_PHALANX_DISTAL";
  TrackedHandJointIDIndex2[TrackedHandJointIDIndex2["PINKY_FINGER_TIP"] = 24] = "PINKY_FINGER_TIP";
})(TrackedHandJointIDIndex || (TrackedHandJointIDIndex = {}));

// dist/pp/cauldron/wl/getters/scene_objects.js
var SceneObjects = class {
  myRoot = null;
  myScene = null;
  myCauldron = null;
  myDynamics = null;
  myParticles = null;
  myVisualElements = null;
  myTools = null;
  myPlayerObjects = new PlayerObjects();
};
var PlayerObjects = class {
  myPlayer = null;
  myCauldron = null;
  myReferenceSpace = null;
  myCameraNonXR = null;
  myEyes = { [Handedness.LEFT]: null, [Handedness.RIGHT]: null };
  myEyeLeft = null;
  myEyeRight = null;
  myHands = { [Handedness.LEFT]: null, [Handedness.RIGHT]: null };
  myHandLeft = null;
  myHandRight = null;
  myHead = null;
  myHeadDebugs = null;
};

// dist/pp/cauldron/wl/getters/components/get_scene_objects_component.js
var GetSceneObjectsComponent = class extends Component10 {
  static TypeName = "pp-get-scene-objects";
  static Properties = {
    _myRoot: Property6.object(),
    _myScene: Property6.object(),
    _myPlayer: Property6.object(),
    _myReferenceSpace: Property6.object(),
    // If u don't have a pivot under the player you set this to null, by default will be the same as the player
    _myCameraNonXR: Property6.object(),
    _myEyeLeft: Property6.object(),
    _myEyeRight: Property6.object(),
    _myHandLeft: Property6.object(),
    _myHandRight: Property6.object(),
    _myHead: Property6.object()
  };
  start() {
    this._mySceneObjects = new SceneObjects();
    this._mySceneObjects.myRoot = this._myRoot;
    this._mySceneObjects.myScene = this._myScene;
    this._mySceneObjects.myPlayerObjects.myPlayer = this._myPlayer;
    this._mySceneObjects.myPlayerObjects.myReferenceSpace = this._myReferenceSpace;
    this._mySceneObjects.myPlayerObjects.myCameraNonXR = this._myCameraNonXR;
    this._mySceneObjects.myPlayerObjects.myEyeLeft = this._myEyeLeft;
    this._mySceneObjects.myPlayerObjects.myEyeRight = this._myEyeRight;
    this._mySceneObjects.myPlayerObjects.myHandLeft = this._myHandLeft;
    this._mySceneObjects.myPlayerObjects.myHandRight = this._myHandRight;
    this._mySceneObjects.myPlayerObjects.myEyes[Handedness.LEFT] = this._myEyeLeft;
    this._mySceneObjects.myPlayerObjects.myEyes[Handedness.RIGHT] = this._myEyeRight;
    this._mySceneObjects.myPlayerObjects.myHands[Handedness.LEFT] = this._myHandLeft;
    this._mySceneObjects.myPlayerObjects.myHands[Handedness.RIGHT] = this._myHandRight;
    this._mySceneObjects.myPlayerObjects.myHead = this._myHead;
    if (this._mySceneObjects.myPlayerObjects.myReferenceSpace == null) {
      this._mySceneObjects.myPlayerObjects.myReferenceSpace = this._mySceneObjects.myPlayerObjects.myPlayer;
    }
    this._mySceneObjects.myCauldron = this._mySceneObjects.myScene.pp_addChild();
    this._mySceneObjects.myCauldron.pp_setName("Cauldron");
    this._mySceneObjects.myDynamics = this._mySceneObjects.myScene.pp_addChild();
    this._mySceneObjects.myDynamics.pp_setName("Dynamics");
    this._mySceneObjects.myParticles = this._mySceneObjects.myScene.pp_addChild();
    this._mySceneObjects.myParticles.pp_setName("Particles");
    this._mySceneObjects.myVisualElements = this._mySceneObjects.myScene.pp_addChild();
    this._mySceneObjects.myVisualElements.pp_setName("Visual Elements");
    this._mySceneObjects.myTools = this._mySceneObjects.myScene.pp_addChild();
    this._mySceneObjects.myTools.pp_setName("Tools");
    this._mySceneObjects.myPlayerObjects.myCauldron = this._mySceneObjects.myPlayerObjects.myPlayer.pp_addChild();
    this._mySceneObjects.myPlayerObjects.myCauldron.pp_setName("Cauldron");
    this._mySceneObjects.myPlayerObjects.myHeadDebugs = this._mySceneObjects.myPlayerObjects.myHead.pp_addChild();
    this._mySceneObjects.myPlayerObjects.myHeadDebugs.pp_setName("Head Debugs");
  }
  onActivate() {
    if (!Globals.hasSceneObjects(this.engine)) {
      Globals.setSceneObjects(this._mySceneObjects, this.engine);
    }
  }
  onDeactivate() {
    if (this._mySceneObjects != null && Globals.getSceneObjects(this.engine) == this._mySceneObjects) {
      Globals.removeSceneObjects(this.engine);
    }
  }
};

// dist/pp/debug/components/debug_manager_component.js
import { Component as Component11 } from "@wonderlandengine/api";

// dist/pp/debug/debug_visual_manager.js
import { Alignment as Alignment2, VerticalAlignment as VerticalAlignment2 } from "@wonderlandengine/api";
var DebugVisualManager = class extends VisualManager {
  constructor(engine) {
    super(engine);
    this._myDefaultColor = vec4_create(1, 0, 1, 1);
    this._myDefaultLineThickness = 5e-3;
    this._myDefaultPointRadius = 0.01;
    this._myDefaultAxisLength = 0.2;
    this._myDefaultTextLookAtPlayer = true;
    this._myDefaultTextAlignment = Alignment2.Center;
    this._myDefaultTextVerticalAlignment = VerticalAlignment2.Middle;
    this._myDefaultUITextAlignment = Alignment2.Center;
    this._myDefaultUITextVerticalAlignment = VerticalAlignment2.Middle;
    this._myDefaultUITextScale = 1;
    this._myDefaultUITextScreenPosition = vec3_create(1, 1, 1);
  }
  setActive(active) {
    active = active && Globals.isDebugEnabled(this._myEngine);
    super.setActive(active);
  }
  drawLine(lifetimeSeconds, start, direction, length6, color = this._myDefaultColor, thickness = this._myDefaultLineThickness) {
    let elementID = null;
    if (this.isActive()) {
      let visualParams = new VisualLineParams(this._myEngine);
      visualParams.myStart.vec3_copy(start);
      visualParams.myDirection.vec3_copy(direction);
      visualParams.myLength = length6;
      visualParams.myThickness = thickness;
      visualParams.myColor = vec4_create();
      visualParams.myColor.vec4_copy(color);
      elementID = this.draw(visualParams, lifetimeSeconds);
    }
    return elementID;
  }
  drawLineEnd(lifetimeSeconds, start, end, color = this._myDefaultColor, thickness = this._myDefaultLineThickness) {
  }
  drawArrow(lifetimeSeconds, start, direction, length6, color = this._myDefaultColor, thickness = this._myDefaultLineThickness) {
    let elementID = null;
    if (this.isActive()) {
      let visualParams = new VisualArrowParams(this._myEngine);
      visualParams.myStart.vec3_copy(start);
      visualParams.myDirection.vec3_copy(direction);
      visualParams.myLength = length6;
      visualParams.myThickness = thickness;
      visualParams.myColor = vec4_create();
      visualParams.myColor.vec4_copy(color);
      elementID = this.draw(visualParams, lifetimeSeconds);
    }
    return elementID;
  }
  drawArrowEnd(lifetimeSeconds, start, end, color = this._myDefaultColor, thickness = this._myDefaultLineThickness) {
  }
  drawPoint(lifetimeSeconds, position, color = this._myDefaultColor, radius = this._myDefaultPointRadius) {
    let elementID = null;
    if (this.isActive()) {
      let visualParams = new VisualPointParams(this._myEngine);
      visualParams.myPosition.vec3_copy(position);
      visualParams.myRadius = radius;
      visualParams.myColor = vec4_create();
      visualParams.myColor.vec4_copy(color);
      elementID = this.draw(visualParams, lifetimeSeconds);
    }
    return elementID;
  }
  drawText(lifetimeSeconds, text, transform, color = this._myDefaultColor, lookAtPlayer = this._myDefaultTextLookAtPlayer, alignment = this._myDefaultTextAlignment, verticalAlignment = this._myDefaultTextVerticalAlignment) {
    let elementID = null;
    if (this.isActive()) {
      let visualParams = new VisualTextParams(this._myEngine);
      visualParams.myText = text;
      visualParams.myAlignment = alignment;
      visualParams.myVerticalAlignment = verticalAlignment;
      visualParams.myTransform.mat4_copy(transform);
      visualParams.myColor = vec4_create();
      visualParams.myColor.vec4_copy(color);
      if (lookAtPlayer) {
        visualParams.myLookAtObject = Globals.getPlayerObjects(this._myEngine).myHead;
      }
      elementID = this.draw(visualParams, lifetimeSeconds);
    }
    return elementID;
  }
  drawRaycast(lifetimeSeconds, raycastResult, showOnlyFirstHit = true, hitNormalLength = this._myDefaultAxisLength, thickness = this._myDefaultLineThickness) {
    let elementID = null;
    if (this.isActive()) {
      let visualParams = new VisualRaycastParams(this._myEngine);
      visualParams.myRaycastResults = raycastResult;
      visualParams.myShowOnlyFirstHit = showOnlyFirstHit;
      visualParams.myHitNormalLength = hitNormalLength;
      visualParams.myThickness = thickness;
      elementID = this.draw(visualParams, lifetimeSeconds);
    }
    return elementID;
  }
  drawTransform(lifetimeSeconds, transform, length6 = this._myDefaultAxisLength, thickness = this._myDefaultLineThickness) {
    let elementID = null;
    if (this.isActive()) {
      let visualParams = new VisualTransformParams(this._myEngine);
      visualParams.myTransform.mat4_copy(transform);
      visualParams.myLength = length6;
      visualParams.myThickness = thickness;
      elementID = this.draw(visualParams, lifetimeSeconds);
    }
    return elementID;
  }
  drawUIText(lifetimeSeconds, text, screenPosition, scale4 = this._myDefaultUITextScale, color = this._myDefaultColor, alignment = this._myDefaultUITextAlignment, verticalAlignment = this._myDefaultUITextVerticalAlignment) {
  }
  _getClassName() {
    return "debug_visual_manager";
  }
};
DebugVisualManager.prototype.drawLineEnd = function() {
  let direction = vec3_create();
  return function drawLineEnd(lifetimeSeconds, start, end, color = this._myDefaultColor, thickness = this._myDefaultLineThickness) {
    let elementID = null;
    if (this.isActive()) {
      direction = end.vec3_sub(start, direction);
      let length6 = direction.vec3_length();
      direction.vec3_normalize(direction);
      elementID = this.drawLine(lifetimeSeconds, start, direction, length6, color, thickness);
    }
    return elementID;
  };
}();
DebugVisualManager.prototype.drawArrowEnd = function() {
  let direction = vec3_create();
  return function drawArrowEnd(lifetimeSeconds, start, end, color = this._myDefaultColor, thickness = this._myDefaultLineThickness) {
    let elementID = null;
    if (this.isActive()) {
      direction = end.vec3_sub(start, direction);
      let length6 = direction.vec3_length();
      direction.vec3_normalize(direction);
      elementID = this.drawArrow(lifetimeSeconds, start, direction, length6, color, thickness);
    }
    return elementID;
  };
}();
DebugVisualManager.prototype.drawUIText = function() {
  let textRotationQuat = quat_create();
  let up = vec3_create(0, 1, 0);
  let lookToForward = vec3_create();
  let screenPositionNormalizedXR = vec3_create(-0.12 * 1, 0.12 * 1, 0.35);
  let screenPositionNormalizedNonXR = vec3_create(-0.27 * 1.15, 0.13 * 1.05, 0.35);
  let textPosition = vec3_create();
  let textRotation = vec3_create();
  let textScale = vec3_create();
  return function drawUIText(lifetimeSeconds, text, screenPosition = this._myDefaultUITextScreenPosition, scale4 = this._myDefaultUITextScale, color = this._myDefaultColor, alignment = this._myDefaultUITextAlignment, verticalAlignment = this._myDefaultUITextVerticalAlignment) {
    let elementID = null;
    if (this.isActive()) {
      let visualParams = new VisualTextParams(this._myEngine);
      visualParams.myText = text;
      visualParams.myAlignment = alignment;
      visualParams.myVerticalAlignment = verticalAlignment;
      visualParams.myColor = vec4_create();
      visualParams.myColor.vec4_copy(color);
      let scaleNormalized = 0.2;
      if (XRUtils.isSessionActive(this._myEngine)) {
        visualParams.myTransform.mat4_setPositionRotationScale(screenPositionNormalizedXR.vec3_mul(screenPosition, textPosition), textRotation.vec3_set(0, 180, 0), textScale.vec3_set(scaleNormalized * scale4, scaleNormalized * scale4, scaleNormalized * scale4));
        lookToForward = visualParams.myTransform.mat4_getPosition(lookToForward).vec3_negate(lookToForward).vec3_normalize(lookToForward);
        textRotationQuat = visualParams.myTransform.mat4_getRotationQuat(textRotationQuat);
        textRotationQuat.quat_setForward(lookToForward, up, textRotationQuat);
        visualParams.myTransform.mat4_setRotationQuat(textRotationQuat);
      } else {
        visualParams.myTransform.mat4_setPositionRotationScale(screenPositionNormalizedNonXR.vec3_mul(screenPosition, textPosition), textRotation.vec3_set(0, 180, 0), textScale.vec3_set(scaleNormalized * scale4, scaleNormalized * scale4, scaleNormalized * scale4));
      }
      visualParams.myParent = Globals.getPlayerObjects(this._myEngine).myHeadDebugs;
      visualParams.myLocal = true;
      elementID = this.draw(visualParams, lifetimeSeconds);
    }
    return elementID;
  };
}();

// dist/pp/debug/debug_manager.js
var DebugManager = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myDebugVisualManager = new DebugVisualManager(this._myEngine);
    this._myActive = true;
    this._myDestroyed = false;
  }
  getDebugVisualManager() {
    return this._myDebugVisualManager;
  }
  start() {
    this._myDebugVisualManager.start();
  }
  update(dt) {
    if (!this._myActive)
      return;
    this._myDebugVisualManager.update(dt);
  }
  setActive(active) {
    active = active && Globals.isDebugEnabled(this._myEngine);
    if (this._myActive != active) {
      this._myActive = active;
    }
    this._myDebugVisualManager.setActive(active);
  }
  isActive() {
    return this._myActive;
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
    this._myDebugVisualManager.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/debug/components/debug_manager_component.js
var DebugManagerComponent = class extends Component11 {
  static TypeName = "pp-debug-manager";
  init() {
    this._myDebugManager = null;
    this._myCurrentActive = false;
    this._myInitDone = false;
  }
  _init() {
    this._myDebugManager = new DebugManager(this.engine);
    this._myDebugManager.setActive(this._myCurrentActive);
    this._myDebugManager.start();
    this._myInitDone = true;
  }
  update(dt) {
    if (!this._myInitDone && Globals.isDebugEnabled(this.engine)) {
      this._init();
      if (this._myDebugManager != null && !Globals.hasDebugManager(this.engine)) {
        Globals.setDebugManager(this._myDebugManager, this.engine);
      }
    } else if (this._myDebugManager != null && !Globals.hasDebugManager(this.engine) && Globals.isDebugEnabled(this.engine) && this._myCurrentActive != Globals.isDebugEnabled(this.engine)) {
      Globals.setDebugManager(this._myDebugManager, this.engine);
    }
    if (this._myDebugManager != null && Globals.getDebugManager(this.engine) == this._myDebugManager) {
      if (this._myCurrentActive != Globals.isDebugEnabled(this.engine)) {
        this._myCurrentActive = Globals.isDebugEnabled(this.engine);
        this._myDebugManager.setActive(this._myCurrentActive);
        if (this._myCurrentActive) {
          if (!Globals.hasDebugManager(this.engine)) {
            Globals.setDebugManager(this._myDebugManager, this.engine);
          }
        } else {
          if (Globals.getDebugManager(this.engine) == this._myDebugManager) {
            Globals.removeDebugManager(this.engine);
          }
        }
      }
      this._myDebugManager.update(dt);
    }
  }
  onDeactivate() {
    if (this._myDebugManager != null) {
      this._myCurrentActive = false;
      this._myDebugManager.setActive(false);
      if (Globals.getDebugManager(this.engine) == this._myDebugManager) {
        Globals.removeDebugManager(this.engine);
      }
    }
  }
  onDestroy() {
    if (this._myDebugManager != null) {
      this._myDebugManager.destroy();
    }
  }
};

// dist/pp/debug/components/enable_debug_component.js
import { Component as Component12, Property as Property7 } from "@wonderlandengine/api";
var EnableDebugComponent = class extends Component12 {
  static TypeName = "pp-enable-debug";
  static Properties = {
    _myEnable: Property7.bool(true)
  };
  start() {
    this._myHasDebugEnabled = this._myEnable;
    this._myDebugEnabled = this._myEnable;
  }
  onActivate() {
    if (this._myHasDebugEnabled) {
      Globals.setDebugEnabled(this._myDebugEnabled, this.engine);
    }
  }
  onDeactivate() {
    this._myHasDebugEnabled = Globals.hasDebugEnabled();
    this._myDebugEnabled = Globals.isDebugEnabled();
    Globals.removeDebugEnabled(this.engine);
  }
};

// dist/pp/gameplay/experimental/character_controller/collision/components/character_collision_system_component.js
import { Component as Component13 } from "@wonderlandengine/api";

// dist/pp/gameplay/experimental/character_controller/collision/character_collision_results.js
var CharacterCollisionResults = class {
  constructor() {
    this.myCheckType = null;
    this.myTransformResults = new CharacterCollisionTransformResults();
    this.myMovementResults = new CharacterCollisionMovementResults();
    this.myHorizontalMovementResults = new CharacterCollisionMovementResults();
    this.myVerticalMovementResults = new CharacterCollisionMovementResults();
    this.myTeleportResults = new CharacterCollisionTeleportResults();
    this.myCheckTransformResults = new CharacterCollisionCheckTransformResults();
    this.myWallSlideResults = new CharacterCollisionWallSlideResults();
    this.myGroundInfo = new CharacterCollisionSurfaceInfo();
    this.myCeilingInfo = new CharacterCollisionSurfaceInfo();
    this.myGroundResults = new CharacterCollisionSurfaceResults();
    this.myCeilingResults = new CharacterCollisionSurfaceResults();
    this.mySplitMovementResults = new CharacterCollisionSplitMovementResults();
    this.myDebugResults = new CharacterCollisionDebugResults();
    this.myInternalResults = new CharacterCollisionInternalResults();
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionCheckType = {
  CHECK_MOVEMENT: 0,
  CHECK_TELEPORT: 1,
  CHECK_TRANSFORM: 2,
  UPDATE_SURFACE_INFO: 3,
  UPDATE_GROUND_INFO: 4,
  UPDATE_CEILING_INFO: 5
};
var CharacterCollisionSurfaceInfo = class {
  constructor() {
    this.myOnSurface = false;
    this.mySurfaceReferenceCollisionHit = new RaycastHit();
    this.mySurfaceAngle = 0;
    this.mySurfacePerceivedAngle = 0;
    this.mySurfaceNormal = vec3_create();
    this.mySurfaceHitMaxAngle = 0;
    this.mySurfaceHitMaxNormal = vec3_create();
    this.mySurfaceDistance = null;
    this.myBaseInsideCollision = false;
    this.myOnSurfaceDueToBasePartiallyInsideCollision = false;
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionWallSlideResults = class {
  constructor() {
    this.myHasSlid = false;
    this.mySlideMovementAngle = 0;
    this.mySlideMovementWallAngle = 0;
    this.myWallNormal = vec3_create();
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionTransformResults = class {
  constructor() {
    this.myInitialTransformQuat = quat2_create();
    this.myFinalTransformQuat = quat2_create();
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionMovementResults = class {
  constructor() {
    this.myInitialMovement = vec3_create();
    this.myFinalMovement = vec3_create();
    this.myMovementFailed = false;
    this.myMovementCollided = false;
    this.myReferenceCollisionHit = new RaycastHit();
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionTeleportResults = class {
  constructor() {
    this.myInitialTeleportTransformQuat = quat2_create();
    this.myFinalTeleportTransformQuat = quat2_create();
    this.myTeleportFailed = false;
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionCheckTransformResults = class {
  constructor() {
    this.myInitialCheckTransformQuat = quat2_create();
    this.myFinalCheckTransformQuat = quat2_create();
    this.myCheckTransformFailed = false;
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionSurfaceResults = class {
  constructor() {
    this.myHasSnappedOnSurface = false;
    this.myHasPoppedOutSurface = false;
    this.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill = false;
    this.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill = false;
    this.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill = false;
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionSplitMovementResults = class {
  constructor() {
    this.myStepsToPerform = 0;
    this.myStepsPerformed = 0;
    this.myMovementInterrupted = false;
    this.myMovementReduced = false;
    this.myLastStepLongerThanMaxStepLength = false;
    this.myMovementChecked = vec3_create();
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionDebugResults = class {
  constructor() {
    this._myRaycastsPerformed = 0;
  }
  reset() {
  }
  copy(other) {
  }
};
var CharacterCollisionInternalResults = class {
  constructor() {
    this.myLastRelevantInitialHorizontalMovement = vec3_create();
    this.myLastRelevantAdjustedInitialHorizontalMovement = vec3_create();
    this.myLastRelevantFinalHorizontalMovement = vec3_create();
    this.myLastRelevantInitialVerticalMovement = vec3_create();
    this.myLastRelevantAdjustedInitialVerticalMovement = vec3_create();
    this.myLastRelevantFinalVerticalMovement = vec3_create();
    this.myLastRelevantHasWallSlid = false;
    this.myHasWallSlidTowardOppositeDirection = false;
    this.myLastRelevantWallSlideFlickerPrevented = false;
    this.myWallSlideFlickerPreventionForceCheckCounter = 0;
    this.myWallSlide90DegreesDirectionSign = 0;
    this.myWallSlide90DegreesRecomputeDirectionSign = true;
  }
  reset() {
  }
  copy(other) {
  }
};
CharacterCollisionResults.prototype.reset = function reset() {
  this.myCheckType = null;
  this.myTransformResults.reset();
  this.myMovementResults.reset();
  this.myHorizontalMovementResults.reset();
  this.myVerticalMovementResults.reset();
  this.myTeleportResults.reset();
  this.myCheckTransformResults.reset();
  this.myWallSlideResults.reset();
  this.myGroundInfo.reset();
  this.myCeilingInfo.reset();
  this.myGroundResults.reset();
  this.myCeilingResults.reset();
  this.mySplitMovementResults.reset();
  this.myInternalResults.reset();
};
CharacterCollisionResults.prototype.copy = function copy10(other) {
  this.myCheckType = other.myCheckType;
  this.myTransformResults.copy(other.myTransformResults);
  this.myMovementResults.copy(other.myMovementResults);
  this.myHorizontalMovementResults.copy(other.myHorizontalMovementResults);
  this.myVerticalMovementResults.copy(other.myVerticalMovementResults);
  this.myTeleportResults.copy(other.myTeleportResults);
  this.myCheckTransformResults.copy(other.myCheckTransformResults);
  this.myWallSlideResults.copy(other.myWallSlideResults);
  this.myGroundInfo.copy(other.myGroundInfo);
  this.myCeilingInfo.copy(other.myCeilingInfo);
  this.myGroundResults.copy(other.myGroundResults);
  this.myCeilingResults.copy(other.myCeilingResults);
  this.mySplitMovementResults.copy(other.mySplitMovementResults);
  this.myInternalResults.copy(other.myInternalResults);
};
CharacterCollisionSurfaceInfo.prototype.reset = function reset2() {
  this.myOnSurface = false;
  this.mySurfaceAngle = 0;
  this.mySurfacePerceivedAngle = 0;
  this.mySurfaceNormal.vec3_zero();
  this.mySurfaceReferenceCollisionHit.reset();
  this.mySurfaceHitMaxAngle = 0;
  this.mySurfaceHitMaxNormal.vec3_zero();
  this.mySurfaceDistance = null;
  this.myBaseInsideCollision = false;
  this.myOnSurfaceDueToBasePartiallyInsideCollision = false;
};
CharacterCollisionSurfaceInfo.prototype.copy = function copy11(other) {
  this.myOnSurface = other.myOnSurface;
  this.mySurfaceAngle = other.mySurfaceAngle;
  this.mySurfacePerceivedAngle = other.mySurfacePerceivedAngle;
  this.mySurfaceNormal.vec3_copy(other.mySurfaceNormal);
  this.mySurfaceReferenceCollisionHit.copy(other.mySurfaceReferenceCollisionHit);
  this.mySurfaceHitMaxAngle = other.mySurfaceHitMaxAngle;
  this.mySurfaceHitMaxNormal.vec3_copy(other.mySurfaceHitMaxNormal);
  this.mySurfaceDistance = other.mySurfaceDistance;
  this.myBaseInsideCollision = other.myBaseInsideCollision;
  this.myOnSurfaceDueToBasePartiallyInsideCollision = other.myOnSurfaceDueToBasePartiallyInsideCollision;
};
CharacterCollisionWallSlideResults.prototype.reset = function reset3() {
  this.myHasSlid = false;
  this.mySlideMovementAngle = 0;
  this.mySlideMovementWallAngle = 0;
  this.myWallNormal.vec3_zero();
};
CharacterCollisionWallSlideResults.prototype.copy = function copy12(other) {
  this.myHasSlid = other.myHasSlid;
  this.mySlideMovementAngle = other.mySlideMovementAngle;
  this.mySlideMovementWallAngle = other.mySlideMovementWallAngle;
  this.myWallNormal.vec3_copy(other.myWallNormal);
};
CharacterCollisionTransformResults.prototype.reset = function reset4() {
  this.myInitialTransformQuat.quat2_identity();
  this.myFinalTransformQuat.quat2_identity();
};
CharacterCollisionTransformResults.prototype.copy = function copy13(other) {
  this.myInitialTransformQuat.quat2_copy(other.myInitialTransformQuat);
  this.myFinalTransformQuat.quat2_copy(other.myFinalTransformQuat);
};
CharacterCollisionMovementResults.prototype.reset = function reset5() {
  this.myInitialMovement.vec3_zero();
  this.myFinalMovement.vec3_zero();
  this.myMovementFailed = false;
  this.myMovementCollided = false;
  this.myReferenceCollisionHit.reset();
};
CharacterCollisionMovementResults.prototype.copy = function copy14(other) {
  this.myInitialMovement.vec3_copy(other.myInitialMovement);
  this.myFinalMovement.vec3_copy(other.myFinalMovement);
  this.myMovementFailed = other.myMovementFailed;
  this.myMovementCollided = other.myMovementCollided;
  this.myReferenceCollisionHit.copy(other.myReferenceCollisionHit);
};
CharacterCollisionTeleportResults.prototype.reset = function reset6() {
  this.myInitialTeleportTransformQuat.quat2_identity();
  this.myFinalTeleportTransformQuat.quat2_identity();
  this.myTeleportFailed = false;
};
CharacterCollisionTeleportResults.prototype.copy = function copy15(other) {
  this.myInitialTeleportTransformQuat.quat2_copy(other.myInitialTeleportTransformQuat);
  this.myFinalTeleportTransformQuat.quat2_copy(other.myFinalTeleportTransformQuat);
  this.myTeleportFailed = other.myTeleportFailed;
};
CharacterCollisionCheckTransformResults.prototype.reset = function reset7() {
  this.myInitialCheckTransformQuat.quat2_identity();
  this.myFinalCheckTransformQuat.quat2_identity();
  this.myCheckTransformFailed = false;
};
CharacterCollisionCheckTransformResults.prototype.copy = function copy16(other) {
  this.myInitialCheckTransformQuat.quat2_copy(other.myInitialCheckTransformQuat);
  this.myFinalCheckTransformQuat.quat2_copy(other.myFinalCheckTransformQuat);
  this.myCheckTransformFailed = other.myCheckTransformFailed;
};
CharacterCollisionSurfaceResults.prototype.reset = function reset8() {
  this.myHasSnappedOnSurface = false;
  this.myHasPoppedOutSurface = false;
  this.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill = false;
  this.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill = false;
  this.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill = false;
};
CharacterCollisionSurfaceResults.prototype.copy = function copy17(other) {
  this.myHasSnappedOnSurface = other.myHasSnappedOnSurface;
  this.myHasPoppedOutSurface = other.myHasPoppedOutSurface;
  this.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill = other.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill;
  this.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill = other.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill;
  this.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill = other.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill;
};
CharacterCollisionSplitMovementResults.prototype.reset = function reset9() {
  this.myStepsToPerform = 0;
  this.myStepsPerformed = 0;
  this.myMovementInterrupted = false;
  this.myMovementReduced = false;
  this.myLastStepLongerThanMaxStepLength = false;
  this.myMovementChecked.vec3_zero();
};
CharacterCollisionSplitMovementResults.prototype.copy = function copy18(other) {
  this.myStepsToPerform = other.myStepsToPerform;
  this.myStepsPerformed = other.myStepsPerformed;
  this.myMovementInterrupted = other.myMovementInterrupted;
  this.myMovementReduced = other.myMovementReduced;
  this.myLastStepLongerThanMaxStepLength = other.myLastStepLongerThanMaxStepLength;
  this.myMovementChecked.vec3_copy(other.myMovementChecked);
};
CharacterCollisionDebugResults.prototype.reset = function reset10() {
  this._myRaycastsPerformed = 0;
};
CharacterCollisionDebugResults.prototype.copy = function copy19(other) {
  this._myRaycastsPerformed = other._myRaycastsPerformed;
};
CharacterCollisionInternalResults.prototype.reset = function reset11() {
};
CharacterCollisionInternalResults.prototype.copy = function copy20(other) {
  this.myLastRelevantInitialHorizontalMovement.vec3_copy(other.myLastRelevantInitialHorizontalMovement);
  this.myLastRelevantAdjustedInitialHorizontalMovement.vec3_copy(other.myLastRelevantAdjustedInitialHorizontalMovement);
  this.myLastRelevantFinalHorizontalMovement.vec3_copy(other.myLastRelevantFinalHorizontalMovement);
  this.myLastRelevantInitialVerticalMovement.vec3_copy(other.myLastRelevantInitialVerticalMovement);
  this.myLastRelevantAdjustedInitialVerticalMovement.vec3_copy(other.myLastRelevantAdjustedInitialVerticalMovement);
  this.myLastRelevantFinalVerticalMovement.vec3_copy(other.myLastRelevantFinalVerticalMovement);
  this.myLastRelevantHasWallSlid = other.myLastRelevantHasWallSlid;
  this.myHasWallSlidTowardOppositeDirection = other.myHasWallSlidTowardOppositeDirection;
  this.myLastRelevantWallSlideFlickerPrevented = other.myLastRelevantWallSlideFlickerPrevented;
  this.myWallSlideFlickerPreventionForceCheckCounter = other.myWallSlideFlickerPreventionForceCheckCounter;
  this.myWallSlide90DegreesDirectionSign = other.myWallSlide90DegreesDirectionSign;
  this.myWallSlide90DegreesRecomputeDirectionSign = other.myWallSlide90DegreesRecomputeDirectionSign;
};

// dist/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_params.js
var CollisionCheckParams = class {
  constructor() {
    this.mySplitMovementEnabled = false;
    this.mySplitMovementMaxLength = 0;
    this.mySplitMovementMaxLengthEnabled = false;
    this.mySplitMovementMaxLengthLastStepCanBeLonger = false;
    this.mySplitMovementMaxSteps = 0;
    this.mySplitMovementMaxStepsEnabled = false;
    this.mySplitMovementMinLength = 0;
    this.mySplitMovementMinLengthEnabled = false;
    this.mySplitMovementStopWhenHorizontalMovementCanceled = false;
    this.mySplitMovementStopWhenVerticalMovementCanceled = false;
    this.mySplitMovementStopWhenVerticalMovementReduced = false;
    this.mySplitMovementStopCallback = null;
    this.mySplitMovementStopReturnPrevious = false;
    this.mySplitMovementStopAndFailIfMovementWouldBeReduced = false;
    this.myRadius = 0;
    this.myDistanceFromFeetToIgnore = 0;
    this.myDistanceFromHeadToIgnore = 0;
    this.myPositionOffsetLocal = vec3_create();
    this.myRotationOffsetLocalQuat = quat_create();
    this.myHorizontalMovementCheckEnabled = false;
    this.myHorizontalMovementStepEnabled = false;
    this.myHorizontalMovementStepMaxLength = 0;
    this.myHorizontalMovementRadialStepAmount = 0;
    this.myHorizontalMovementCheckDiagonalOutward = false;
    this.myHorizontalMovementCheckDiagonalInward = false;
    this.myHorizontalMovementCheckStraight = false;
    this.myHorizontalMovementCheckHorizontalBorder = false;
    this.myHorizontalMovementCheckVerticalStraight = false;
    this.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = false;
    this.myHorizontalMovementCheckVerticalDiagonalUpwardInward = false;
    this.myHorizontalMovementCheckVerticalDiagonalDownwardOutward = false;
    this.myHorizontalMovementCheckVerticalDiagonalDownwardInward = false;
    this.myHorizontalMovementCheckVerticalStraightDiagonalUpward = false;
    this.myHorizontalMovementCheckVerticalStraightDiagonalDownward = false;
    this.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward = false;
    this.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward = false;
    this.myHorizontalMovementHorizontalStraightCentralCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightCentralCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = false;
    this.myHorizontalPositionCheckEnabled = false;
    this.myHalfConeAngle = 0;
    this.myHalfConeSliceAmount = 0;
    this.myCheckConeBorder = false;
    this.myCheckConeRay = false;
    this.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = true;
    this.myHorizontalPositionCheckVerticalDirectionType = 0;
    this.myCheckHorizontalFixedForwardEnabled = false;
    this.myCheckHorizontalFixedForward = vec3_create();
    this.myVerticalMovementCheckEnabled = false;
    this.myVerticalPositionCheckEnabled = false;
    this.myFeetRadius = 0;
    this.myAdjustVerticalMovementWithGroundAngleDownhill = false;
    this.myAdjustVerticalMovementWithGroundAngleUphill = false;
    this.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle = null;
    this.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle = null;
    this.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle = null;
    this.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle = null;
    this.myAdjustHorizontalMovementWithGroundAngleDownhill = false;
    this.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle = null;
    this.myAdjustVerticalMovementWithCeilingAngleDownhill = false;
    this.myAdjustVerticalMovementWithCeilingAngleUphill = false;
    this.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = null;
    this.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = null;
    this.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = null;
    this.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = null;
    this.myAdjustHorizontalMovementWithCeilingAngleDownhill = false;
    this.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle = null;
    this.myCheckVerticalFixedForwardEnabled = false;
    this.myCheckVerticalFixedForward = vec3_create();
    this.myCheckVerticalBothDirection = false;
    this.myCheckVerticalPositionBothDirection = false;
    this.mySnapOnGroundEnabled = false;
    this.mySnapOnGroundExtraDistance = 0;
    this.mySnapOnCeilingEnabled = false;
    this.mySnapOnCeilingExtraDistance = 0;
    this.myGroundPopOutEnabled = false;
    this.myGroundPopOutExtraDistance = 0;
    this.myCeilingPopOutEnabled = false;
    this.myCeilingPopOutExtraDistance = 0;
    this.myVerticalMovementReduceEnabled = false;
    this.myGroundCircumferenceAddCenter = false;
    this.myGroundCircumferenceSliceAmount = 0;
    this.myGroundCircumferenceStepAmount = 0;
    this.myGroundCircumferenceRotationPerStep = 0;
    this.myVerticalAllowHitInsideCollisionIfOneOk = false;
    this.myCheckHeight = false;
    this.myCheckHeightVerticalMovement = false;
    this.myCheckHeightVerticalPosition = false;
    this.myCheckHeightTopMovement = false;
    this.myCheckHeightTopPosition = false;
    this.myCheckHeightConeOnCollision = false;
    this.myCheckHeightConeOnCollisionKeepHit = false;
    this.myHeightCheckStepAmountMovement = 0;
    this.myHeightCheckStepAmountPosition = 0;
    this.myCheckVerticalStraight = false;
    this.myCheckVerticalDiagonalRayOutward = false;
    this.myCheckVerticalDiagonalRayInward = false;
    this.myCheckVerticalDiagonalBorderOutward = false;
    this.myCheckVerticalDiagonalBorderInward = false;
    this.myCheckVerticalDiagonalBorderRayOutward = false;
    this.myCheckVerticalDiagonalBorderRayInward = false;
    this.myCheckVerticalSearchFartherVerticalHit = false;
    this.myGroundAngleToIgnore = 0;
    this.myGroundAngleToIgnoreWithPerceivedAngle = null;
    this.myCeilingAngleToIgnore = 0;
    this.myCeilingAngleToIgnoreWithPerceivedAngle = null;
    this.myHorizontalMovementGroundAngleIgnoreHeight = null;
    this.myHorizontalMovementCeilingAngleIgnoreHeight = null;
    this.myHorizontalPositionGroundAngleIgnoreHeight = null;
    this.myHorizontalPositionCeilingAngleIgnoreHeight = null;
    this.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = null;
    this.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft = null;
    this.myHeight = 0;
    this.myComputeGroundInfoEnabled = false;
    this.myComputeCeilingInfoEnabled = false;
    this.myDistanceToBeOnGround = 0;
    this.myDistanceToComputeGroundInfo = 0;
    this.myDistanceToBeOnCeiling = 0;
    this.myDistanceToComputeCeilingInfo = 0;
    this.myVerticalFixToBeOnGround = 0;
    this.myVerticalFixToComputeGroundInfo = 0;
    this.myVerticalFixToBeOnCeiling = 0;
    this.myVerticalFixToComputeCeilingInfo = 0;
    this.myGroundIsBaseInsideCollisionCheckEnabled = false;
    this.myCeilingIsBaseInsideCollisionCheckEnabled = false;
    this.myIsOnGroundIfInsideHit = false;
    this.myIsOnCeilingIfInsideHit = false;
    this.myIsOnGroundMaxSurfaceAngle = null;
    this.myIsOnCeilingMaxSurfaceAngle = null;
    this.myFindGroundDistanceMaxOutsideDistance = 0;
    this.myFindGroundDistanceMaxInsideDistance = 0;
    this.myFindCeilingDistanceMaxOutsideDistance = 0;
    this.myFindCeilingDistanceMaxInsideDistance = 0;
    this.myCollectGroundCollisionHitOutsideDistance = 0;
    this.myCollectGroundCollisionHitInsideDistance = 0;
    this.myCollectCeilingCollisionHitOutsideDistance = 0;
    this.myCollectCeilingCollisionHitInsideDistance = 0;
    this.myAllowGroundSteepFix = false;
    this.myAllowCeilingSteepFix = false;
    this.myMustStayOnGround = false;
    this.myMustStayOnCeiling = false;
    this.myMustStayOnValidGroundAngleDownhill = false;
    this.myMustStayOnValidCeilingAngleDownhill = false;
    this.myRegatherGroundInfoOnSurfaceCheckFail = false;
    this.myRegatherCeilingInfoOnSurfaceCheckFail = false;
    this.myMustStayBelowIgnorableGroundAngleDownhill = false;
    this.myMustStayBelowIgnorableCeilingAngleDownhill = false;
    this.myMustStayBelowGroundAngleDownhill = null;
    this.myMustStayBelowCeilingAngleDownhill = null;
    this.myMovementMustStayOnGroundHitAngle = null;
    this.myMovementMustStayOnCeilingHitAngle = null;
    this.myTeleportMustBeOnIgnorableGroundAngle = false;
    this.myCheckTransformMustBeOnIgnorableGroundAngle = false;
    this.myTeleportMustBeOnIgnorableCeilingAngle = false;
    this.myCheckTransformMustBeOnIgnorableCeilingAngle = false;
    this.myTeleportMustBeOnGroundAngle = null;
    this.myCheckTransformMustBeOnGroundAngle = null;
    this.myTeleportMustBeOnCeilingAngle = null;
    this.myCheckTransformMustBeOnCeilingAngle = null;
    this.myTeleportMustBeOnGround = false;
    this.myCheckTransformMustBeOnGround = false;
    this.myTeleportMustBeOnCeiling = false;
    this.myCheckTransformMustBeOnCeiling = false;
    this.mySlidingEnabled = false;
    this.mySlidingHorizontalMovementCheckBetterNormal = false;
    this.mySlidingMaxAttempts = 0;
    this.mySlidingCheckBothDirections = false;
    this.mySlidingFlickeringPreventionType = 0;
    this.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding = false;
    this.mySlidingFlickerPreventionCheckAnywayCounter = 0;
    this.mySlidingAdjustSign90Degrees = false;
    this.myHorizontalBlockLayerFlags = new PhysicsLayerFlags();
    this.myHorizontalObjectsToIgnore = [];
    this.myHorizontalBlockColliderType = RaycastBlockColliderType.BOTH;
    this.myVerticalBlockLayerFlags = new PhysicsLayerFlags();
    this.myVerticalObjectsToIgnore = [];
    this.myVerticalBlockColliderType = RaycastBlockColliderType.BOTH;
    this.myExtraMovementCheckCallback = null;
    this.myExtraTeleportCheckCallback = null;
    this.myExtraCheckTransformCheckCallback = null;
    this.myDebugEnabled = false;
    this.myDebugHorizontalMovementEnabled = false;
    this.myDebugHorizontalPositionEnabled = false;
    this.myDebugVerticalMovementEnabled = false;
    this.myDebugVerticalPositionEnabled = false;
    this.myDebugSlidingEnabled = false;
    this.myDebugGroundInfoEnabled = false;
    this.myDebugCeilingInfoEnabled = false;
    this.myDebugRuntimeParamsEnabled = false;
    this.myDebugMovementEnabled = false;
    this._myInternalSplitMovementMaxStepsDisabled = false;
  }
  copy(other) {
    if (this == other)
      return;
    this.mySplitMovementEnabled = other.mySplitMovementEnabled;
    this.mySplitMovementMaxLength = other.mySplitMovementMaxLength;
    this.mySplitMovementMaxLengthEnabled = other.mySplitMovementMaxLengthEnabled;
    this.mySplitMovementMaxLengthLastStepCanBeLonger = other.mySplitMovementMaxLengthLastStepCanBeLonger;
    this.mySplitMovementMaxSteps = other.mySplitMovementMaxSteps;
    this.mySplitMovementMaxStepsEnabled = other.mySplitMovementMaxStepsEnabled;
    this.mySplitMovementMinLength = other.mySplitMovementMinLength;
    this.mySplitMovementMinLengthEnabled = other.mySplitMovementMinLengthEnabled;
    this.mySplitMovementStopWhenHorizontalMovementCanceled = other.mySplitMovementStopWhenHorizontalMovementCanceled;
    this.mySplitMovementStopWhenVerticalMovementCanceled = other.mySplitMovementStopWhenVerticalMovementCanceled;
    this.mySplitMovementStopWhenVerticalMovementReduced = other.mySplitMovementStopWhenVerticalMovementReduced;
    this.mySplitMovementStopCallback = other.mySplitMovementStopCallback;
    this.mySplitMovementStopReturnPrevious = other.mySplitMovementStopReturnPrevious;
    this.mySplitMovementStopAndFailIfMovementWouldBeReduced = other.mySplitMovementStopAndFailIfMovementWouldBeReduced;
    this.myRadius = other.myRadius;
    this.myDistanceFromFeetToIgnore = other.myDistanceFromFeetToIgnore;
    this.myDistanceFromHeadToIgnore = other.myDistanceFromHeadToIgnore;
    this.myPositionOffsetLocal.vec3_copy(other.myPositionOffsetLocal);
    this.myRotationOffsetLocalQuat.quat_copy(other.myRotationOffsetLocalQuat);
    this.myHorizontalMovementCheckEnabled = other.myHorizontalMovementCheckEnabled;
    this.myHorizontalMovementStepEnabled = other.myHorizontalMovementStepEnabled;
    this.myHorizontalMovementStepMaxLength = other.myHorizontalMovementStepMaxLength;
    this.myHorizontalMovementRadialStepAmount = other.myHorizontalMovementRadialStepAmount;
    this.myHorizontalMovementCheckDiagonalOutward = other.myHorizontalMovementCheckDiagonalOutward;
    this.myHorizontalMovementCheckDiagonalInward = other.myHorizontalMovementCheckDiagonalInward;
    this.myHorizontalMovementCheckStraight = other.myHorizontalMovementCheckStraight;
    this.myHorizontalMovementCheckHorizontalBorder = other.myHorizontalMovementCheckHorizontalBorder;
    this.myHorizontalMovementCheckVerticalStraight = other.myHorizontalMovementCheckVerticalStraight;
    this.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = other.myHorizontalMovementCheckVerticalDiagonalUpwardOutward;
    this.myHorizontalMovementCheckVerticalDiagonalUpwardInward = other.myHorizontalMovementCheckVerticalDiagonalUpwardInward;
    this.myHorizontalMovementCheckVerticalDiagonalDownwardOutward = other.myHorizontalMovementCheckVerticalDiagonalDownwardOutward;
    this.myHorizontalMovementCheckVerticalDiagonalDownwardInward = other.myHorizontalMovementCheckVerticalDiagonalDownwardInward;
    this.myHorizontalMovementCheckVerticalStraightDiagonalUpward = other.myHorizontalMovementCheckVerticalStraightDiagonalUpward;
    this.myHorizontalMovementCheckVerticalStraightDiagonalDownward = other.myHorizontalMovementCheckVerticalStraightDiagonalDownward;
    this.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward = other.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward;
    this.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward = other.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward;
    this.myHorizontalMovementHorizontalStraightCentralCheckEnabled = other.myHorizontalMovementHorizontalStraightCentralCheckEnabled;
    this.myHorizontalMovementVerticalStraightCentralCheckEnabled = other.myHorizontalMovementVerticalStraightCentralCheckEnabled;
    this.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled;
    this.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled;
    this.myHorizontalPositionCheckEnabled = other.myHorizontalPositionCheckEnabled;
    this.myHalfConeAngle = other.myHalfConeAngle;
    this.myHalfConeSliceAmount = other.myHalfConeSliceAmount;
    this.myCheckConeBorder = other.myCheckConeBorder;
    this.myCheckConeRay = other.myCheckConeRay;
    this.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = other.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision;
    this.myHorizontalPositionCheckVerticalDirectionType = other.myHorizontalPositionCheckVerticalDirectionType;
    this.myVerticalMovementCheckEnabled = other.myVerticalMovementCheckEnabled;
    this.myVerticalPositionCheckEnabled = other.myVerticalPositionCheckEnabled;
    this.myFeetRadius = other.myFeetRadius;
    this.myAdjustVerticalMovementWithGroundAngleDownhill = other.myAdjustVerticalMovementWithGroundAngleDownhill;
    this.myAdjustVerticalMovementWithGroundAngleUphill = other.myAdjustVerticalMovementWithGroundAngleUphill;
    this.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle = other.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle;
    this.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle = other.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle;
    this.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle = other.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle;
    this.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle = other.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle;
    this.myAdjustHorizontalMovementWithGroundAngleDownhill = other.myAdjustHorizontalMovementWithGroundAngleDownhill;
    this.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle = other.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle;
    this.myAdjustVerticalMovementWithCeilingAngleDownhill = other.myAdjustVerticalMovementWithCeilingAngleDownhill;
    this.myAdjustVerticalMovementWithCeilingAngleUphill = other.myAdjustVerticalMovementWithCeilingAngleUphill;
    this.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = other.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle;
    this.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = other.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle;
    this.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = other.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle;
    this.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = other.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle;
    this.myAdjustHorizontalMovementWithCeilingAngleDownhill = other.myAdjustHorizontalMovementWithCeilingAngleDownhill;
    this.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle = other.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle;
    this.myCheckVerticalFixedForwardEnabled = other.myCheckVerticalFixedForwardEnabled;
    this.myCheckVerticalFixedForward.vec3_copy(other.myCheckVerticalFixedForward);
    this.myCheckVerticalBothDirection = other.myCheckVerticalBothDirection;
    this.myCheckVerticalPositionBothDirection = other.myCheckVerticalPositionBothDirection;
    this.mySnapOnGroundEnabled = other.mySnapOnGroundEnabled;
    this.mySnapOnGroundExtraDistance = other.mySnapOnGroundExtraDistance;
    this.mySnapOnCeilingEnabled = other.mySnapOnCeilingEnabled;
    this.mySnapOnCeilingExtraDistance = other.mySnapOnCeilingExtraDistance;
    this.myGroundPopOutEnabled = other.myGroundPopOutEnabled;
    this.myGroundPopOutExtraDistance = other.myGroundPopOutExtraDistance;
    this.myCeilingPopOutEnabled = other.myCeilingPopOutEnabled;
    this.myCeilingPopOutExtraDistance = other.myCeilingPopOutExtraDistance;
    this.myVerticalMovementReduceEnabled = other.myVerticalMovementReduceEnabled;
    this.myGroundCircumferenceAddCenter = other.myGroundCircumferenceAddCenter;
    this.myGroundCircumferenceSliceAmount = other.myGroundCircumferenceSliceAmount;
    this.myGroundCircumferenceStepAmount = other.myGroundCircumferenceStepAmount;
    this.myGroundCircumferenceRotationPerStep = other.myGroundCircumferenceRotationPerStep;
    this.myVerticalAllowHitInsideCollisionIfOneOk = other.myVerticalAllowHitInsideCollisionIfOneOk;
    this.myCheckHeight = other.myCheckHeight;
    this.myCheckHeightVerticalMovement = other.myCheckHeightVerticalMovement;
    this.myCheckHeightVerticalPosition = other.myCheckHeightVerticalPosition;
    this.myCheckHeightTopMovement = other.myCheckHeightTopMovement;
    this.myCheckHeightTopPosition = other.myCheckHeightTopPosition;
    this.myCheckHeightConeOnCollision = other.myCheckHeightConeOnCollision;
    this.myCheckHeightConeOnCollisionKeepHit = other.myCheckHeightConeOnCollisionKeepHit;
    this.myHeightCheckStepAmountMovement = other.myHeightCheckStepAmountMovement;
    this.myHeightCheckStepAmountPosition = other.myHeightCheckStepAmountPosition;
    this.myCheckVerticalStraight = other.myCheckVerticalStraight;
    this.myCheckVerticalDiagonalRayOutward = other.myCheckVerticalDiagonalRayOutward;
    this.myCheckVerticalDiagonalRayInward = other.myCheckVerticalDiagonalRayInward;
    this.myCheckVerticalDiagonalBorderOutward = other.myCheckVerticalDiagonalBorderOutward;
    this.myCheckVerticalDiagonalBorderInward = other.myCheckVerticalDiagonalBorderInward;
    this.myCheckVerticalDiagonalBorderRayOutward = other.myCheckVerticalDiagonalBorderRayOutward;
    this.myCheckVerticalDiagonalBorderRayInward = other.myCheckVerticalDiagonalBorderRayInward;
    this.myCheckVerticalSearchFartherVerticalHit = other.myCheckVerticalSearchFartherVerticalHit;
    this.myGroundAngleToIgnore = other.myGroundAngleToIgnore;
    this.myGroundAngleToIgnoreWithPerceivedAngle = other.myGroundAngleToIgnoreWithPerceivedAngle;
    this.myCeilingAngleToIgnore = other.myCeilingAngleToIgnore;
    this.myCeilingAngleToIgnoreWithPerceivedAngle = other.myCeilingAngleToIgnoreWithPerceivedAngle;
    this.myHorizontalMovementGroundAngleIgnoreHeight = other.myHorizontalMovementGroundAngleIgnoreHeight;
    this.myHorizontalMovementCeilingAngleIgnoreHeight = other.myHorizontalMovementCeilingAngleIgnoreHeight;
    this.myHorizontalPositionGroundAngleIgnoreHeight = other.myHorizontalPositionGroundAngleIgnoreHeight;
    this.myHorizontalPositionCeilingAngleIgnoreHeight = other.myHorizontalPositionCeilingAngleIgnoreHeight;
    this.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = other.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft;
    this.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft = other.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft;
    this.myHeight = other.myHeight;
    this.myComputeGroundInfoEnabled = other.myComputeGroundInfoEnabled;
    this.myComputeCeilingInfoEnabled = other.myComputeCeilingInfoEnabled;
    this.myDistanceToBeOnGround = other.myDistanceToBeOnGround;
    this.myDistanceToComputeGroundInfo = other.myDistanceToComputeGroundInfo;
    this.myDistanceToBeOnCeiling = other.myDistanceToBeOnCeiling;
    this.myDistanceToComputeCeilingInfo = other.myDistanceToComputeCeilingInfo;
    this.myVerticalFixToBeOnGround = other.myVerticalFixToBeOnGround;
    this.myVerticalFixToComputeGroundInfo = other.myVerticalFixToComputeGroundInfo;
    this.myVerticalFixToBeOnCeiling = other.myVerticalFixToBeOnCeiling;
    this.myVerticalFixToComputeCeilingInfo = other.myVerticalFixToComputeCeilingInfo;
    this.myGroundIsBaseInsideCollisionCheckEnabled = other.myGroundIsBaseInsideCollisionCheckEnabled;
    this.myCeilingIsBaseInsideCollisionCheckEnabled = other.myCeilingIsBaseInsideCollisionCheckEnabled;
    this.myIsOnGroundIfInsideHit = other.myIsOnGroundIfInsideHit;
    this.myIsOnCeilingIfInsideHit = other.myIsOnCeilingIfInsideHit;
    this.myIsOnGroundMaxSurfaceAngle = other.myIsOnGroundMaxSurfaceAngle;
    this.myIsOnCeilingMaxSurfaceAngle = other.myIsOnCeilingMaxSurfaceAngle;
    this.myFindGroundDistanceMaxOutsideDistance = other.myFindGroundDistanceMaxOutsideDistance;
    this.myFindGroundDistanceMaxInsideDistance = other.myFindGroundDistanceMaxInsideDistance;
    this.myFindCeilingDistanceMaxOutsideDistance = other.myFindCeilingDistanceMaxOutsideDistance;
    this.myFindCeilingDistanceMaxInsideDistance = other.myFindCeilingDistanceMaxInsideDistance;
    this.myCollectGroundCollisionHitOutsideDistance = other.myCollectGroundCollisionHitOutsideDistance;
    this.myCollectGroundCollisionHitInsideDistance = other.myCollectGroundCollisionHitInsideDistance;
    this.myCollectCeilingCollisionHitOutsideDistance = other.myCollectCeilingCollisionHitOutsideDistance;
    this.myCollectCeilingCollisionHitInsideDistance = other.myCollectCeilingCollisionHitInsideDistance;
    this.myAllowGroundSteepFix = other.myAllowGroundSteepFix;
    this.myAllowCeilingSteepFix = other.myAllowCeilingSteepFix;
    this.myMustStayOnGround = other.myMustStayOnGround;
    this.myMustStayOnCeiling = other.myMustStayOnCeiling;
    this.myMustStayOnValidGroundAngleDownhill = other.myMustStayOnValidGroundAngleDownhill;
    this.myMustStayOnValidCeilingAngleDownhill = other.myMustStayOnValidCeilingAngleDownhill;
    this.myRegatherGroundInfoOnSurfaceCheckFail = other.myRegatherGroundInfoOnSurfaceCheckFail;
    this.myRegatherCeilingInfoOnSurfaceCheckFail = other.myRegatherCeilingInfoOnSurfaceCheckFail;
    this.myMustStayBelowGroundAngleDownhill = other.myMustStayBelowGroundAngleDownhill;
    this.myMustStayBelowCeilingAngleDownhill = other.myMustStayBelowCeilingAngleDownhill;
    this.myMustStayBelowIgnorableGroundAngleDownhill = other.myMustStayBelowIgnorableGroundAngleDownhill;
    this.myMustStayBelowIgnorableCeilingAngleDownhill = other.myMustStayBelowIgnorableCeilingAngleDownhill;
    this.myMovementMustStayOnGroundHitAngle = other.myMovementMustStayOnGroundHitAngle;
    this.myMovementMustStayOnCeilingHitAngle = other.myMovementMustStayOnCeilingHitAngle;
    this.myTeleportMustBeOnIgnorableGroundAngle = other.myTeleportMustBeOnIgnorableGroundAngle;
    this.myCheckTransformMustBeOnIgnorableGroundAngle = other.myCheckTransformMustBeOnIgnorableGroundAngle;
    this.myTeleportMustBeOnIgnorableCeilingAngle = other.myTeleportMustBeOnIgnorableCeilingAngle;
    this.myCheckTransformMustBeOnIgnorableCeilingAngle = other.myCheckTransformMustBeOnIgnorableCeilingAngle;
    this.myTeleportMustBeOnGroundAngle = other.myTeleportMustBeOnGroundAngle;
    this.myCheckTransformMustBeOnGroundAngle = other.myCheckTransformMustBeOnGroundAngle;
    this.myTeleportMustBeOnCeilingAngle = other.myTeleportMustBeOnCeilingAngle;
    this.myCheckTransformMustBeOnCeilingAngle = other.myCheckTransformMustBeOnCeilingAngle;
    this.myTeleportMustBeOnGround = other.myTeleportMustBeOnGround;
    this.myCheckTransformMustBeOnGround = other.myCheckTransformMustBeOnGround;
    this.myTeleportMustBeOnCeiling = other.myTeleportMustBeOnCeiling;
    this.myCheckTransformMustBeOnCeiling = other.myCheckTransformMustBeOnCeiling;
    this.mySlidingEnabled = other.mySlidingEnabled;
    this.mySlidingHorizontalMovementCheckBetterNormal = other.mySlidingHorizontalMovementCheckBetterNormal;
    this.mySlidingMaxAttempts = other.mySlidingMaxAttempts;
    this.mySlidingCheckBothDirections = other.mySlidingCheckBothDirections;
    this.mySlidingFlickeringPreventionType = other.mySlidingFlickeringPreventionType;
    this.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding = other.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding;
    this.mySlidingFlickerPreventionCheckAnywayCounter = other.mySlidingFlickerPreventionCheckAnywayCounter;
    this.mySlidingAdjustSign90Degrees = other.mySlidingAdjustSign90Degrees;
    this.myHorizontalBlockLayerFlags.copy(other.myHorizontalBlockLayerFlags);
    this.myHorizontalObjectsToIgnore.pp_copy(other.myHorizontalObjectsToIgnore);
    this.myHorizontalBlockColliderType = other.myHorizontalBlockColliderType;
    this.myVerticalBlockLayerFlags.copy(other.myVerticalBlockLayerFlags);
    this.myVerticalObjectsToIgnore.pp_copy(other.myVerticalObjectsToIgnore);
    this.myVerticalBlockColliderType = other.myVerticalBlockColliderType;
    this.myExtraMovementCheckCallback = other.myExtraMovementCheckCallback;
    this.myExtraTeleportCheckCallback = other.myExtraTeleportCheckCallback;
    this.myExtraCheckTransformCheckCallback = other.myExtraCheckTransformCheckCallback;
    this.myDebugEnabled = other.myDebugEnabled;
    this.myDebugHorizontalMovementEnabled = other.myDebugHorizontalMovementEnabled;
    this.myDebugHorizontalPositionEnabled = other.myDebugHorizontalPositionEnabled;
    this.myDebugVerticalMovementEnabled = other.myDebugVerticalMovementEnabled;
    this.myDebugVerticalPositionEnabled = other.myDebugVerticalPositionEnabled;
    this.myDebugSlidingEnabled = other.myDebugSlidingEnabled;
    this.myDebugGroundInfoEnabled = other.myDebugGroundInfoEnabled;
    this.myDebugCeilingInfoEnabled = other.myDebugCeilingInfoEnabled;
    this.myDebugRuntimeParamsEnabled = other.myDebugRuntimeParamsEnabled;
    this.myDebugMovementEnabled = other.myDebugMovementEnabled;
    this._myInternalSplitMovementMaxStepsDisabled = other._myInternalSplitMovementMaxStepsDisabled;
  }
};
var CollisionRuntimeParams = class {
  constructor() {
    this.myOriginalPosition = vec3_create();
    this.myNewPosition = vec3_create();
    this.myOriginalHeight = 0;
    this.myOriginalForward = vec3_create();
    this.myOriginalUp = vec3_create();
    this.myOffsetUp = vec3_create();
    this.myTeleportForward = vec3_create();
    this.myOriginalMovement = vec3_create();
    this.myFixedMovement = vec3_create();
    this.myLastValidOriginalHorizontalMovement = vec3_create();
    this.myLastValidOriginalVerticalMovement = vec3_create();
    this.myLastValidSurfaceAdjustedHorizontalMovement = vec3_create();
    this.myLastValidSurfaceAdjustedVerticalMovement = vec3_create();
    this.myLastValidEndHorizontalMovement = vec3_create();
    this.myLastValidEndVerticalMovement = vec3_create();
    this.myIsOnGround = false;
    this.myGroundCollisionHit = new RaycastHit();
    this.myGroundAngle = 0;
    this.myGroundPerceivedAngle = 0;
    this.myGroundNormal = vec3_create();
    this.myGroundHitMaxAngle = 0;
    this.myGroundHitMaxNormal = vec3_create();
    this.myGroundDistance = null;
    this.myGroundIsBaseInsideCollision = false;
    this.myIsOnCeiling = false;
    this.myCeilingCollisionHit = new RaycastHit();
    this.myCeilingAngle = 0;
    this.myCeilingPerceivedAngle = 0;
    this.myCeilingNormal = vec3_create();
    this.myCeilingHitMaxAngle = 0;
    this.myCeilingHitMaxNormal = vec3_create();
    this.myCeilingDistance = null;
    this.myCeilingIsBaseInsideCollision = false;
    this.myHorizontalMovementCanceled = false;
    this.myIsCollidingHorizontally = false;
    this.myHorizontalCollisionHit = new RaycastHit();
    this.myVerticalMovementCanceled = false;
    this.myIsCollidingVertically = false;
    this.myVerticalCollisionHit = new RaycastHit();
    this.myHasSnappedOnGround = false;
    this.myHasSnappedOnCeiling = false;
    this.myHasPoppedOutGround = false;
    this.myHasPoppedOutCeiling = false;
    this.myHasReducedVerticalMovement = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = false;
    this.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill = false;
    this.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = false;
    this.myIsSliding = false;
    this.myIsSlidingIntoOppositeDirection = false;
    this.myIsSlidingFlickerPrevented = false;
    this.mySlidingFlickerPreventionCheckAnywayCounter = 0;
    this.mySlidingMovementAngle = 0;
    this.mySlidingCollisionAngle = 0;
    this.mySlidingCollisionHit = new RaycastHit();
    this.mySlidingWallNormal = new vec3_create();
    this.mySliding90DegreesSign = 0;
    this.mySlidingRecompute90DegreesSign = true;
    this.myLastValidIsSliding = false;
    this.mySlidingPreviousHorizontalMovement = vec3_create();
    this.myOriginalTeleportPosition = vec3_create();
    this.myFixedTeleportPosition = vec3_create();
    this.myOriginalPositionCheckPosition = vec3_create();
    this.myFixedPositionCheckPosition = vec3_create();
    this.myTeleportCanceled = false;
    this.myIsPositionOk = false;
    this.myIsTeleport = false;
    this.myIsMove = false;
    this.myIsPositionCheck = false;
    this.myIsPositionCheckAllowAdjustments = false;
    this.mySplitMovementSteps = 0;
    this.mySplitMovementStepsPerformed = 0;
    this.mySplitMovementStop = false;
    this.mySplitMovementLastStepLongerThanMaxLength = false;
    this.mySplitMovementReduced = false;
    this.mySplitMovementMovementChecked = vec3_create();
    this.myRealIsOnGround = false;
    this.myRealIsOnCeiling = false;
  }
  reset() {
    this.myOriginalPosition.vec3_zero();
    this.myNewPosition.vec3_zero();
    this.myOriginalHeight = 0;
    this.myOriginalForward.vec3_zero();
    this.myOriginalUp.vec3_zero();
    this.myOffsetUp.vec3_zero();
    this.myTeleportForward.vec3_zero();
    this.myOriginalMovement.vec3_zero();
    this.myFixedMovement.vec3_zero();
    this.myLastValidOriginalHorizontalMovement.vec3_zero();
    this.myLastValidOriginalVerticalMovement.vec3_zero();
    this.myLastValidSurfaceAdjustedHorizontalMovement.vec3_zero();
    this.myLastValidSurfaceAdjustedVerticalMovement.vec3_zero();
    this.myLastValidEndHorizontalMovement.vec3_zero();
    this.myLastValidEndVerticalMovement.vec3_zero();
    this.myIsOnGround = false;
    this.myGroundCollisionHit.reset();
    this.myGroundAngle = 0;
    this.myGroundPerceivedAngle = 0;
    this.myGroundNormal.vec3_zero();
    this.myGroundHitMaxAngle = 0;
    this.myGroundHitMaxNormal.vec3_zero();
    this.myGroundDistance = null;
    this.myGroundIsBaseInsideCollision = false;
    this.myIsOnCeiling = false;
    this.myCeilingCollisionHit.reset();
    this.myCeilingAngle = 0;
    this.myCeilingPerceivedAngle = 0;
    this.myCeilingNormal.vec3_zero();
    this.myCeilingHitMaxAngle = 0;
    this.myCeilingHitMaxNormal.vec3_zero();
    this.myCeilingDistance = null;
    this.myCeilingIsBaseInsideCollision = false;
    this.myHorizontalMovementCanceled = false;
    this.myIsCollidingHorizontally = false;
    this.myHorizontalCollisionHit.reset();
    this.myVerticalMovementCanceled = false;
    this.myIsCollidingVertically = false;
    this.myVerticalCollisionHit.reset();
    this.myHasSnappedOnGround = false;
    this.myHasSnappedOnCeiling = false;
    this.myHasPoppedOutGround = false;
    this.myHasPoppedOutCeiling = false;
    this.myHasReducedVerticalMovement = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = false;
    this.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill = false;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill = false;
    this.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = false;
    this.myIsSliding = false;
    this.myIsSlidingIntoOppositeDirection = false;
    this.myIsSlidingFlickerPrevented = false;
    this.mySlidingFlickerPreventionCheckAnywayCounter = 0;
    this.mySlidingMovementAngle = 0;
    this.mySlidingCollisionAngle = 0;
    this.mySlidingCollisionHit.reset();
    this.mySliding90DegreesSign = 0;
    this.mySlidingRecompute90DegreesSign = true;
    this.myLastValidIsSliding = false;
    this.mySlidingPreviousHorizontalMovement.vec3_zero();
    this.mySlidingWallNormal.vec3_zero();
    this.myOriginalTeleportPosition.vec3_zero();
    this.myFixedTeleportPosition.vec3_zero();
    this.myOriginalPositionCheckPosition.vec3_zero();
    this.myFixedPositionCheckPosition.vec3_zero();
    this.myTeleportCanceled = false;
    this.myIsPositionOk = false;
    this.myIsTeleport = false;
    this.myIsMove = false;
    this.myIsPositionCheck = false;
    this.myIsPositionCheckAllowAdjustments = false;
    this.mySplitMovementSteps = 0;
    this.mySplitMovementStepsPerformed = 0;
    this.mySplitMovementStop = false;
    this.mySplitMovementLastStepLongerThanMaxLength = false;
    this.mySplitMovementReduced = false;
    this.mySplitMovementMovementChecked.vec3_zero();
    this.myRealIsOnGround = false;
    this.myRealIsOnCeiling = false;
  }
  copy(other) {
    if (this == other)
      return;
    this.myOriginalPosition.vec3_copy(other.myOriginalPosition);
    this.myNewPosition.vec3_copy(other.myNewPosition);
    this.myOriginalHeight = other.myOriginalHeight;
    this.myOriginalForward.vec3_copy(other.myOriginalForward);
    this.myOriginalUp.vec3_copy(other.myOriginalUp);
    this.myOffsetUp.vec3_copy(other.myOffsetUp);
    this.myTeleportForward.vec3_copy(other.myTeleportForward);
    this.myOriginalMovement.vec3_copy(other.myOriginalMovement);
    this.myFixedMovement.vec3_copy(other.myFixedMovement);
    this.myLastValidOriginalHorizontalMovement.vec3_copy(other.myLastValidOriginalHorizontalMovement);
    this.myLastValidOriginalVerticalMovement.vec3_copy(other.myLastValidOriginalVerticalMovement);
    this.myLastValidSurfaceAdjustedHorizontalMovement.vec3_copy(other.myLastValidSurfaceAdjustedHorizontalMovement);
    this.myLastValidSurfaceAdjustedVerticalMovement.vec3_copy(other.myLastValidSurfaceAdjustedVerticalMovement);
    this.myLastValidEndHorizontalMovement.vec3_copy(other.myLastValidEndHorizontalMovement);
    this.myLastValidEndVerticalMovement.vec3_copy(other.myLastValidEndVerticalMovement);
    this.myIsOnGround = other.myIsOnGround;
    this.myGroundCollisionHit.copy(other.myGroundCollisionHit);
    this.myGroundAngle = other.myGroundAngle;
    this.myGroundPerceivedAngle = other.myGroundPerceivedAngle;
    this.myGroundNormal.vec3_copy(other.myGroundNormal);
    this.myGroundHitMaxAngle = other.myGroundHitMaxAngle;
    this.myGroundHitMaxNormal.vec3_copy(other.myGroundHitMaxNormal);
    this.myGroundDistance = other.myGroundDistance;
    this.myGroundIsBaseInsideCollision = other.myGroundIsBaseInsideCollision;
    this.myIsOnCeiling = other.myIsOnCeiling;
    this.myCeilingCollisionHit.copy(other.myCeilingCollisionHit);
    this.myCeilingAngle = other.myCeilingAngle;
    this.myCeilingPerceivedAngle = other.myCeilingPerceivedAngle;
    this.myCeilingNormal.vec3_copy(other.myCeilingNormal);
    this.myCeilingHitMaxAngle = other.myCeilingHitMaxAngle;
    this.myCeilingHitMaxNormal.vec3_copy(other.myCeilingHitMaxNormal);
    this.myCeilingDistance = other.myCeilingDistance;
    this.myCeilingIsBaseInsideCollision = other.myCeilingIsBaseInsideCollision;
    this.myHorizontalMovementCanceled = other.myHorizontalMovementCanceled;
    this.myIsCollidingHorizontally = other.myIsCollidingHorizontally;
    this.myHorizontalCollisionHit.copy(other.myHorizontalCollisionHit);
    this.myVerticalMovementCanceled = other.myVerticalMovementCanceled;
    this.myIsCollidingVertically = other.myIsCollidingVertically;
    this.myVerticalCollisionHit.copy(other.myVerticalCollisionHit);
    this.myHasSnappedOnGround = other.myHasSnappedOnGround;
    this.myHasSnappedOnCeiling = other.myHasSnappedOnCeiling;
    this.myHasPoppedOutGround = other.myHasPoppedOutGround;
    this.myHasPoppedOutCeiling = other.myHasPoppedOutCeiling;
    this.myHasReducedVerticalMovement = other.myHasReducedVerticalMovement;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = other.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = other.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill;
    this.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill = other.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill = other.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill;
    this.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill = other.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill;
    this.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = other.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill;
    this.myIsSliding = other.myIsSliding;
    this.myIsSlidingIntoOppositeDirection = other.myIsSlidingIntoOppositeDirection;
    this.myIsSlidingFlickerPrevented = other.myIsSlidingFlickerPrevented;
    this.mySlidingFlickerPreventionCheckAnywayCounter = other.mySlidingFlickerPreventionCheckAnywayCounter;
    this.mySlidingMovementAngle = other.mySlidingMovementAngle;
    this.mySlidingCollisionAngle = other.mySlidingCollisionAngle;
    this.mySlidingCollisionHit.copy(other.mySlidingCollisionHit);
    this.mySliding90DegreesSign = other.mySliding90DegreesSign;
    this.mySlidingRecompute90DegreesSign = other.mySlidingRecompute90DegreesSign;
    this.myLastValidIsSliding = other.myLastValidIsSliding;
    this.mySlidingPreviousHorizontalMovement.vec3_copy(other.mySlidingPreviousHorizontalMovement);
    this.mySlidingWallNormal.vec3_copy(other.mySlidingWallNormal);
    this.myOriginalTeleportPosition.vec3_copy(other.myOriginalTeleportPosition);
    this.myFixedTeleportPosition.vec3_copy(other.myFixedTeleportPosition);
    this.myTeleportCanceled = other.myTeleportCanceled;
    this.myIsPositionOk = other.myIsPositionOk;
    this.myOriginalPositionCheckPosition.vec3_copy(other.myOriginalPositionCheckPosition);
    this.myFixedPositionCheckPosition.vec3_copy(other.myFixedPositionCheckPosition);
    this.myIsTeleport = other.myIsTeleport;
    this.myIsMove = other.myIsMove;
    this.myIsPositionCheck = other.myIsPositionCheck;
    this.myIsPositionCheckAllowAdjustments = other.myIsPositionCheckAllowAdjustments;
    this.mySplitMovementSteps = other.mySplitMovementSteps;
    this.mySplitMovementStepsPerformed = other.mySplitMovementStepsPerformed;
    this.mySplitMovementStop = other.mySplitMovementStop;
    this.mySplitMovementLastStepLongerThanMaxLength = other.mySplitMovementLastStepLongerThanMaxLength;
    this.mySplitMovementReduced = other.mySplitMovementReduced;
    this.mySplitMovementMovementChecked.vec3_copy(other.mySplitMovementMovementChecked);
    this.myRealIsOnGround = other.myRealIsOnGround;
    this.myRealIsOnCeiling = other.myRealIsOnCeiling;
  }
};

// dist/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_base.js
var CollisionCheckBase = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myRaycastParams = new RaycastParams(Globals.getPhysics(this._myEngine));
    this._myRaycastResult = new RaycastResults();
    this._myFixRaycastResult = new RaycastResults();
    this._myBackupRaycastHit = new RaycastHit();
    this._myPrevCollisionRuntimeParams = new CollisionRuntimeParams();
    this._mySlidingCollisionRuntimeParams = new CollisionRuntimeParams();
    this._myCheckBetterSlidingNormalCollisionRuntimeParams = new CollisionRuntimeParams();
    this._myInternalSlidingCollisionRuntimeParams = new CollisionRuntimeParams();
    this._mySlidingFlickeringFixCollisionRuntimeParams = new CollisionRuntimeParams();
    this._mySlidingFlickeringFixSlidingCollisionRuntimeParams = new CollisionRuntimeParams();
    this._mySlidingOppositeDirectionCollisionRuntimeParams = new CollisionRuntimeParams();
    this._mySlidingOnVerticalCheckCollisionRuntimeParams = new CollisionRuntimeParams();
    this._myCollisionCheckDisabled = false;
    this._myDebugEnabled = false;
    this._myTotalRaycasts = 0;
  }
  isCollisionCheckDisabled() {
    return this._myCollisionCheckDisabled;
  }
  setCollisionCheckDisabled(collisionCheckDisabled) {
    this._myCollisionCheckDisabled = collisionCheckDisabled;
  }
  _raycastAndDebug(origin, direction, distance2, ignoreHitsInsideCollision, isHorizontal, collisionCheckParams, collisionRuntimeParams) {
  }
  _setRuntimeParamsForMoveCollisionCheckDisabled(movement, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
  }
  _setRuntimeParamsForTeleportCollisionCheckDisabled(position, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
  }
  _setRuntimeParamsForPositionCheckCollisionCheckDisabled(allowFix, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
  }
  _setRuntimeParamsForUpdateSurfaceInfoCollisionCheckDisabled(transformQuat2, collisionCheckParams, collisionRuntimeParams) {
  }
  _debugMovement(movement, fixedMovement, feetPosition, up, collisionCheckParams) {
    let originalHorizontalMovement = movement.vec3_removeComponentAlongAxis(up);
    let horizontalMovement = fixedMovement.vec3_removeComponentAlongAxis(up);
    let verticalMovement = fixedMovement.vec3_componentAlongAxis(up);
    let feetPositionPlusOffset = feetPosition.vec3_add(up.vec3_scale(collisionCheckParams.myDistanceFromFeetToIgnore + 1e-3));
    if (!originalHorizontalMovement.vec3_isZero()) {
      originalHorizontalMovement.vec3_normalize(originalHorizontalMovement);
      Globals.getDebugVisualManager(this._myEngine).drawArrow(0, feetPositionPlusOffset, originalHorizontalMovement, 0.2, vec4_create(0.5, 0.5, 1, 1));
    }
    if (!horizontalMovement.vec3_isZero()) {
      horizontalMovement.vec3_normalize(horizontalMovement);
      Globals.getDebugVisualManager(this._myEngine).drawArrow(0, feetPositionPlusOffset, horizontalMovement, 0.2, vec4_create(0, 0, 1, 1));
    }
    if (!verticalMovement.vec3_isZero()) {
      verticalMovement.vec3_normalize(verticalMovement);
      Globals.getDebugVisualManager(this._myEngine).drawArrow(0, feetPosition, verticalMovement, 0.2, vec4_create(0, 0, 1, 1));
    }
  }
  _debugRuntimeParams(collisionRuntimeParams) {
    if (collisionRuntimeParams.myHorizontalCollisionHit.isValid()) {
      Globals.getDebugVisualManager(this._myEngine).drawArrow(0, collisionRuntimeParams.myHorizontalCollisionHit.myPosition, collisionRuntimeParams.myHorizontalCollisionHit.myNormal, 0.2, vec4_create(1, 0, 0, 1));
    }
    if (collisionRuntimeParams.mySlidingCollisionHit.isValid()) {
      Globals.getDebugVisualManager(this._myEngine).drawArrow(0, collisionRuntimeParams.mySlidingCollisionHit.myPosition, collisionRuntimeParams.mySlidingCollisionHit.myNormal, 0.2, vec4_create(1, 0, 0, 1));
    }
    if (collisionRuntimeParams.myVerticalCollisionHit.isValid()) {
      Globals.getDebugVisualManager(this._myEngine).drawArrow(0, collisionRuntimeParams.myVerticalCollisionHit.myPosition, collisionRuntimeParams.myVerticalCollisionHit.myNormal, 0.2, vec4_create(1, 0, 0, 1));
    }
  }
};
CollisionCheckBase.prototype._raycastAndDebug = function() {
  let tempRaycastResult = new RaycastResults();
  return function _raycastAndDebug(origin, direction, distance2, ignoreHitsInsideCollision, isHorizontal, collisionCheckParams, collisionRuntimeParams) {
    this._myRaycastParams.myOrigin.vec3_copy(origin);
    this._myRaycastParams.myDirection.vec3_copy(direction);
    this._myRaycastParams.myDistance = distance2;
    if (isHorizontal) {
      this._myRaycastParams.myBlockLayerFlags.copy(collisionCheckParams.myHorizontalBlockLayerFlags);
      this._myRaycastParams.myObjectsToIgnore = collisionCheckParams.myHorizontalObjectsToIgnore;
      this._myRaycastParams.myBlockColliderType = collisionCheckParams.myHorizontalBlockColliderType;
    } else {
      this._myRaycastParams.myBlockLayerFlags.copy(collisionCheckParams.myVerticalBlockLayerFlags);
      this._myRaycastParams.myObjectsToIgnore = collisionCheckParams.myVerticalObjectsToIgnore;
      this._myRaycastParams.myBlockColliderType = collisionCheckParams.myVerticalBlockColliderType;
    }
    this._myRaycastParams.myIgnoreHitsInsideCollision = ignoreHitsInsideCollision;
    let raycastResult = null;
    let raycastPerformanceDebugEnabled = false;
    if (raycastPerformanceDebugEnabled && Globals.isDebugEnabled(this._myEngine)) {
      let raycastAlways = false;
      if (raycastAlways || !this._myRaycastResult.isColliding()) {
        raycastResult = PhysicsUtils.raycast(this._myRaycastParams, tempRaycastResult);
      }
      if (!this._myRaycastResult.isColliding() && tempRaycastResult.isColliding()) {
        this._myRaycastResult.copy(tempRaycastResult);
      }
      raycastResult = this._myRaycastResult;
    } else {
      raycastResult = PhysicsUtils.raycast(this._myRaycastParams, this._myRaycastResult);
    }
    this._myTotalRaycasts++;
    if (this._myDebugEnabled && Globals.isDebugEnabled(this._myEngine)) {
      Globals.getDebugVisualManager(this._myEngine).drawRaycast(0, raycastResult);
    }
    return raycastResult;
  };
}();
CollisionCheckBase.prototype._setRuntimeParamsForMoveCollisionCheckDisabled = function() {
  let transformOffsetLocalQuat = quat2_create();
  let offsetTransformQuat = quat2_create();
  return function _setRuntimeParamsForMoveCollisionCheckDisabled(movement, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    collisionRuntimeParams.reset();
    collisionRuntimeParams.myRealIsOnGround = true;
    collisionRuntimeParams.myIsOnGround = true;
    collisionRuntimeParams.myGroundCollisionHit.reset();
    collisionRuntimeParams.myGroundAngle = 0;
    collisionRuntimeParams.myGroundPerceivedAngle = 0;
    collisionRuntimeParams.myGroundNormal.vec3_set(0, 1, 0);
    collisionRuntimeParams.myGroundHitMaxAngle = collisionRuntimeParams.myGroundAngle;
    collisionRuntimeParams.myGroundHitMaxNormal.vec3_copy(collisionRuntimeParams.myGroundNormal);
    collisionRuntimeParams.myGroundDistance = 0;
    collisionRuntimeParams.myGroundIsBaseInsideCollision = false;
    collisionRuntimeParams.myOnGroundDueToBasePartiallyInsideCollision = false;
    collisionRuntimeParams.myRealIsOnCeiling = false;
    collisionRuntimeParams.myIsOnCeiling = false;
    collisionRuntimeParams.myCeilingCollisionHit.reset();
    collisionRuntimeParams.myCeilingAngle = 0;
    collisionRuntimeParams.myCeilingPerceivedAngle = 0;
    collisionRuntimeParams.myCeilingNormal.vec3_set(0, 1, 0);
    collisionRuntimeParams.myCeilingHitMaxAngle = collisionRuntimeParams.myCeilingAngle;
    collisionRuntimeParams.myCeilingHitMaxNormal.vec3_copy(collisionRuntimeParams.myCeilingNormal);
    collisionRuntimeParams.myCeilingDistance = 0;
    collisionRuntimeParams.myCeilingIsBaseInsideCollision = false;
    collisionRuntimeParams.myOnCeilingDueToBasePartiallyInsideCollision = false;
    collisionRuntimeParams.mySplitMovementSteps = 1;
    collisionRuntimeParams.mySplitMovementStepsPerformed = 1;
    collisionRuntimeParams.mySplitMovementStop = false;
    collisionRuntimeParams.mySplitMovementMovementChecked.vec3_copy(movement);
    collisionRuntimeParams.myOriginalUp = transformQuat2.quat2_getUp(collisionRuntimeParams.myOriginalUp);
    collisionRuntimeParams.myOriginalForward = transformQuat2.quat2_getForward(collisionRuntimeParams.myOriginalForward);
    collisionRuntimeParams.myOriginalPosition = transformQuat2.quat2_getPosition(collisionRuntimeParams.myOriginalPosition);
    transformOffsetLocalQuat.quat2_setPositionRotationQuat(collisionCheckParams.myPositionOffsetLocal, collisionCheckParams.myRotationOffsetLocalQuat);
    offsetTransformQuat = transformOffsetLocalQuat.quat2_toWorld(transformQuat2, offsetTransformQuat);
    if (transformQuat2.vec_equals(offsetTransformQuat, 1e-5)) {
      offsetTransformQuat.quat2_copy(transformQuat2);
    }
    collisionRuntimeParams.myOffsetUp = offsetTransformQuat.quat2_getUp(collisionRuntimeParams.myOffsetUp);
    collisionRuntimeParams.myOriginalHeight = collisionCheckParams.myHeight;
    collisionRuntimeParams.myOriginalMovement.vec3_copy(movement);
    collisionRuntimeParams.myFixedMovement.vec3_copy(movement);
    collisionRuntimeParams.myNewPosition = collisionRuntimeParams.myOriginalPosition.vec3_add(collisionRuntimeParams.myFixedMovement, collisionRuntimeParams.myNewPosition);
    collisionRuntimeParams.myIsMove = true;
  };
}();
CollisionCheckBase.prototype._setRuntimeParamsForTeleportCollisionCheckDisabled = function() {
  let transformOffsetLocalQuat = quat2_create();
  let offsetTransformQuat = quat2_create();
  return function _setRuntimeParamsForTeleportCollisionCheckDisabled(position, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    collisionRuntimeParams.reset();
    collisionRuntimeParams.myRealIsOnGround = true;
    collisionRuntimeParams.myIsOnGround = true;
    collisionRuntimeParams.myGroundCollisionHit.reset();
    collisionRuntimeParams.myGroundAngle = 0;
    collisionRuntimeParams.myGroundPerceivedAngle = 0;
    collisionRuntimeParams.myGroundNormal.vec3_set(0, 1, 0);
    collisionRuntimeParams.myGroundHitMaxAngle = collisionRuntimeParams.myGroundAngle;
    collisionRuntimeParams.myGroundHitMaxNormal.vec3_copy(collisionRuntimeParams.myGroundNormal);
    collisionRuntimeParams.myGroundDistance = 0;
    collisionRuntimeParams.myGroundIsBaseInsideCollision = false;
    collisionRuntimeParams.myOnGroundDueToBasePartiallyInsideCollision = false;
    collisionRuntimeParams.myRealIsOnCeiling = false;
    collisionRuntimeParams.myIsOnCeiling = false;
    collisionRuntimeParams.myCeilingCollisionHit.reset();
    collisionRuntimeParams.myCeilingAngle = 0;
    collisionRuntimeParams.myCeilingPerceivedAngle = 0;
    collisionRuntimeParams.myCeilingNormal.vec3_set(0, 1, 0);
    collisionRuntimeParams.myCeilingHitMaxAngle = collisionRuntimeParams.myCeilingAngle;
    collisionRuntimeParams.myCeilingHitMaxNormal.vec3_copy(collisionRuntimeParams.myCeilingNormal);
    collisionRuntimeParams.myCeilingDistance = 0;
    collisionRuntimeParams.myCeilingIsBaseInsideCollision = false;
    collisionRuntimeParams.myOnCeilingDueToBasePartiallyInsideCollision = false;
    collisionRuntimeParams.myOriginalUp = transformQuat2.quat2_getUp(collisionRuntimeParams.myOriginalUp);
    collisionRuntimeParams.myOriginalForward = transformQuat2.quat2_getForward(collisionRuntimeParams.myOriginalForward);
    collisionRuntimeParams.myOriginalPosition = transformQuat2.quat2_getPosition(collisionRuntimeParams.myOriginalPosition);
    transformOffsetLocalQuat.quat2_setPositionRotationQuat(collisionCheckParams.myPositionOffsetLocal, collisionCheckParams.myRotationOffsetLocalQuat);
    offsetTransformQuat = transformOffsetLocalQuat.quat2_toWorld(transformQuat2, offsetTransformQuat);
    if (transformQuat2.vec_equals(offsetTransformQuat, 1e-5)) {
      offsetTransformQuat.quat2_copy(transformQuat2);
    }
    collisionRuntimeParams.myOffsetUp = offsetTransformQuat.quat2_getUp(collisionRuntimeParams.myOffsetUp);
    collisionRuntimeParams.myOriginalHeight = collisionCheckParams.myHeight;
    collisionRuntimeParams.myOriginalTeleportPosition.vec3_copy(position);
    collisionRuntimeParams.myFixedTeleportPosition.vec3_copy(position);
    collisionRuntimeParams.myNewPosition.vec3_copy(collisionRuntimeParams.myFixedTeleportPosition);
    collisionRuntimeParams.myIsTeleport = true;
  };
}();
CollisionCheckBase.prototype._setRuntimeParamsForPositionCheckCollisionCheckDisabled = function() {
  let feetPosition = vec3_create();
  return function _setRuntimeParamsForPositionCheckCollisionCheckDisabled(allowFix, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    feetPosition = transformQuat2.quat2_getPosition(feetPosition);
    this._setRuntimeParamsForTeleportCollisionCheckDisabled(feetPosition, transformQuat2, collisionCheckParams, collisionRuntimeParams);
    collisionRuntimeParams.myIsPositionOk = true;
    collisionRuntimeParams.myIsPositionCheck = true;
    collisionRuntimeParams.myOriginalPositionCheckPosition.vec3_copy(collisionRuntimeParams.myOriginalTeleportPosition);
    collisionRuntimeParams.myFixedPositionCheckPosition.vec3_copy(collisionRuntimeParams.myFixedTeleportPosition);
    collisionRuntimeParams.myIsPositionCheckAllowAdjustments = allowFix;
    collisionRuntimeParams.myOriginalTeleportPosition.vec3_zero();
    collisionRuntimeParams.myFixedTeleportPosition.vec3_zero();
    collisionRuntimeParams.myTeleportCanceled = false;
    collisionRuntimeParams.myIsTeleport = false;
  };
}();
CollisionCheckBase.prototype._setRuntimeParamsForUpdateSurfaceInfoCollisionCheckDisabled = /* @__PURE__ */ function() {
  return function _setRuntimeParamsForUpdateSurfaceInfoCollisionCheckDisabled(transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    collisionRuntimeParams.myRealIsOnGround = true;
    collisionRuntimeParams.myIsOnGround = true;
    collisionRuntimeParams.myGroundCollisionHit.reset();
    collisionRuntimeParams.myGroundAngle = 0;
    collisionRuntimeParams.myGroundPerceivedAngle = 0;
    collisionRuntimeParams.myGroundNormal.vec3_set(0, 1, 0);
    collisionRuntimeParams.myGroundHitMaxAngle = collisionRuntimeParams.myGroundAngle;
    collisionRuntimeParams.myGroundHitMaxNormal.vec3_copy(collisionRuntimeParams.myGroundNormal);
    collisionRuntimeParams.myGroundDistance = 0;
    collisionRuntimeParams.myGroundIsBaseInsideCollision = false;
    collisionRuntimeParams.myOnGroundDueToBasePartiallyInsideCollision = false;
    collisionRuntimeParams.myRealIsOnCeiling = false;
    collisionRuntimeParams.myIsOnCeiling = false;
    collisionRuntimeParams.myCeilingCollisionHit.reset();
    collisionRuntimeParams.myCeilingAngle = 0;
    collisionRuntimeParams.myCeilingPerceivedAngle = 0;
    collisionRuntimeParams.myCeilingNormal.vec3_set(0, 1, 0);
    collisionRuntimeParams.myCeilingHitMaxAngle = collisionRuntimeParams.myCeilingAngle;
    collisionRuntimeParams.myCeilingHitMaxNormal.vec3_copy(collisionRuntimeParams.myCeilingNormal);
    collisionRuntimeParams.myCeilingDistance = 0;
    collisionRuntimeParams.myCeilingIsBaseInsideCollision = false;
    collisionRuntimeParams.myOnCeilingDueToBasePartiallyInsideCollision = false;
  };
}();

// dist/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_surface.js
var CollisionCheckSurface = class extends CollisionCheckBase {
  updateSurfaceInfo(transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    if (this.isCollisionCheckDisabled() && Globals.isDebugEnabled(this._myEngine)) {
      this._setRuntimeParamsForUpdateSurfaceInfoCollisionCheckDisabled(transformQuat2, collisionCheckParams, collisionRuntimeParams);
      return;
    }
    this._updateSurfaceInfo(transformQuat2, collisionCheckParams, collisionRuntimeParams);
  }
  computeSurfacePerceivedAngle(surfaceNormal, forward, up, isGround = true) {
  }
  _updateSurfaceInfo(transformQuat2, collisionCheckParams, collisionRuntimeParams) {
  }
  _postSurfaceCheck(fixedHorizontalMovement, originalVerticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
  }
  _surfaceTooSteep(up, direction, collisionCheckParams, collisionRuntimeParams) {
  }
  _adjustVerticalMovementWithSurface(horizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outAdjustedVerticalMovement) {
  }
  _adjustHorizontalMovementWithSurface(horizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outAdjustedHorizontalMovement) {
  }
  _computeExtraSurfaceVerticalMovement(horizontalMovement, up, collisionCheckParams, collisionRuntimeParams, outExtraSurfaceVerticalMovement) {
  }
  _gatherSurfaceInfo(feetPosition, height, up, forwardForPerceivedAngle, forwardForVertical, isGround, collisionCheckParams, collisionRuntimeParams) {
  }
};
CollisionCheckSurface.prototype._updateSurfaceInfo = function() {
  let transformUp = vec3_create();
  let transformForward = vec3_create();
  let feetPosition = vec3_create();
  let transformOffsetLocalQuat = quat2_create();
  let offsetTransformQuat = quat2_create();
  let forwardForPerceivedAngle = vec3_create();
  let forwardForVertical = vec3_create();
  let zAxis = vec3_create(0, 0, 1);
  let xAxis = vec3_create(1, 0, 0);
  return function _updateSurfaceInfo(transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    transformOffsetLocalQuat.quat2_setPositionRotationQuat(collisionCheckParams.myPositionOffsetLocal, collisionCheckParams.myRotationOffsetLocalQuat);
    offsetTransformQuat = transformOffsetLocalQuat.quat2_toWorld(transformQuat2, offsetTransformQuat);
    if (transformQuat2.vec_equals(offsetTransformQuat, 1e-5)) {
      offsetTransformQuat.quat2_copy(transformQuat2);
    }
    transformUp = offsetTransformQuat.quat2_getUp(transformUp);
    transformForward = offsetTransformQuat.quat2_getForward(transformForward);
    feetPosition = offsetTransformQuat.quat2_getPosition(feetPosition);
    let height = collisionCheckParams.myHeight;
    height = height - 1e-5;
    if (height < 1e-5) {
      height = 0;
    }
    forwardForPerceivedAngle.vec3_copy(transformForward);
    forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
    if (!collisionCheckParams.myCheckVerticalFixedForwardEnabled) {
      forwardForVertical.vec3_copy(transformForward);
    } else {
      if (collisionCheckParams.myCheckVerticalFixedForward.vec3_isOnAxis(transformUp)) {
        if (zAxis.vec3_isOnAxis(transformUp)) {
          forwardForVertical.vec3_copy(xAxis);
        } else {
          forwardForVertical.vec3_copy(zAxis);
        }
      }
      forwardForVertical = forwardForVertical.vec3_removeComponentAlongAxis(transformUp, forwardForVertical);
      forwardForVertical = forwardForVertical.vec3_normalize(forwardForVertical);
      if (forwardForVertical.vec_equals(collisionCheckParams.myCheckVerticalFixedForward, 1e-5)) {
        forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
      }
    }
    if (collisionCheckParams.myComputeGroundInfoEnabled) {
      this._gatherSurfaceInfo(feetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
    }
    if (collisionCheckParams.myComputeCeilingInfoEnabled) {
      this._gatherSurfaceInfo(feetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
    }
  };
}();
CollisionCheckSurface.prototype._postSurfaceCheck = function() {
  let horizontalDirection = vec3_create();
  return function _postSurfaceCheck(fixedHorizontalMovement, originalVerticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
    let isVerticalMovementZero = originalVerticalMovement.vec3_isZero(1e-5);
    let isVerticalMovemenDownward = Math.pp_sign(originalVerticalMovement.vec3_lengthSigned(transformUp), -1) < 0;
    let horizontalMovementIsZero = fixedHorizontalMovement.vec3_isZero(1e-5);
    horizontalDirection = fixedHorizontalMovement.vec3_normalize(horizontalDirection);
    let groundPerceivedAngle = this.computeSurfacePerceivedAngle(collisionRuntimeParams.myGroundNormal, horizontalDirection, transformUp, true);
    let ceilingPerceivedAngle = this.computeSurfacePerceivedAngle(collisionRuntimeParams.myCeilingNormal, horizontalDirection, transformUp, false);
    let mustRemainOnGroundOk = true;
    if (collisionCheckParams.myMustStayOnGround) {
      if (previousCollisionRuntimeParams.myIsOnGround && !collisionRuntimeParams.myIsOnGround && (isVerticalMovementZero || isVerticalMovemenDownward)) {
        mustRemainOnGroundOk = false;
      }
    }
    let mustRemainOnCeilingOk = true;
    if (collisionCheckParams.myMustStayOnCeiling) {
      if (previousCollisionRuntimeParams.myIsOnCeiling && !collisionRuntimeParams.myIsOnCeiling && (isVerticalMovementZero || isVerticalMovemenDownward)) {
        mustRemainOnCeilingOk = false;
      }
    }
    let mustStayBelowGroundAngleOk = true;
    if (collisionCheckParams.myMustStayBelowGroundAngleDownhill != null || collisionCheckParams.myMustStayBelowIgnorableGroundAngleDownhill) {
      let minAngle = null;
      if (!collisionCheckParams.myMustStayBelowIgnorableGroundAngleDownhill) {
        minAngle = collisionCheckParams.myMustStayBelowGroundAngleDownhill;
      } else if (collisionCheckParams.myMustStayBelowGroundAngleDownhill == null) {
        minAngle = collisionCheckParams.myGroundAngleToIgnore;
      } else {
        minAngle = Math.min(collisionCheckParams.myMustStayBelowGroundAngleDownhill, collisionCheckParams.myGroundAngleToIgnore);
      }
      if (!horizontalMovementIsZero && groundPerceivedAngle < 0 && previousCollisionRuntimeParams.myIsOnGround && previousCollisionRuntimeParams.myGroundAngle <= minAngle && collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundAngle > minAngle + 1e-4) {
        mustStayBelowGroundAngleOk = false;
      }
    }
    let mustStayBelowCeilingAngleOk = true;
    if (collisionCheckParams.myMustStayBelowCeilingAngleDownhill != null || collisionCheckParams.myMustStayBelowIgnorableCeilingAngleDownhill) {
      let minAngle = null;
      if (!collisionCheckParams.myMustStayBelowIgnorableCeilingAngleDownhill) {
        minAngle = collisionCheckParams.myMustStayBelowCeilingAngleDownhill;
      } else if (collisionCheckParams.myMustStayBelowCeilingAngleDownhill == null) {
        minAngle = collisionCheckParams.myCeilingAngleToIgnore;
      } else {
        minAngle = Math.min(collisionCheckParams.myMustStayBelowCeilingAngleDownhill, collisionCheckParams.myCeilingAngleToIgnore);
      }
      if (!horizontalMovementIsZero && groundPerceivedAngle < 0 && previousCollisionRuntimeParams.myIsOnCeiling && previousCollisionRuntimeParams.myCeilingAngle <= minAngle && collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingAngle > minAngle + 1e-4) {
        mustStayBelowCeilingAngleOk = false;
      }
    }
    let mustStayOnGroundHitAngleOk = true;
    if (collisionCheckParams.myMovementMustStayOnGroundHitAngle != null) {
      if (!horizontalMovementIsZero && previousCollisionRuntimeParams.myIsOnGround && previousCollisionRuntimeParams.myGroundHitMaxAngle <= collisionCheckParams.myMovementMustStayOnGroundHitAngle && collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundHitMaxAngle > collisionCheckParams.myMovementMustStayOnGroundHitAngle + 1e-4) {
        mustStayOnGroundHitAngleOk = false;
      }
    }
    let mustStayOnCeilingHitAngleOk = true;
    if (collisionCheckParams.myMovementMustStayOnCeilingHitAngle != null) {
      if (!horizontalMovementIsZero && previousCollisionRuntimeParams.myIsOnCeiling && previousCollisionRuntimeParams.myCeilingHitMaxAngle <= collisionCheckParams.myMovementMustStayOnCeilingHitAngle && collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingHitMaxAngle > collisionCheckParams.myMovementMustStayOnCeilingHitAngle + 1e-4) {
        mustStayOnCeilingHitAngleOk = false;
      }
    }
    let isOnValidGroundAngleUphill = true;
    let isOnValidGroundAngleDownhill = true;
    if (collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundAngle > collisionCheckParams.myGroundAngleToIgnore + 1e-4) {
      if (previousCollisionRuntimeParams.myIsOnGround && !horizontalMovementIsZero) {
        if (groundPerceivedAngle > 0) {
          isOnValidGroundAngleUphill = false;
          if (collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle != null && collisionRuntimeParams.myGroundAngle <= collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle + 1e-4) {
            isOnValidGroundAngleUphill = Math.abs(groundPerceivedAngle) <= collisionCheckParams.myGroundAngleToIgnore + 1e-4;
          }
        } else if (groundPerceivedAngle < 0) {
          if (previousCollisionRuntimeParams.myGroundAngle <= collisionCheckParams.myGroundAngleToIgnore + 1e-4) {
            if (collisionCheckParams.myMustStayOnValidGroundAngleDownhill) {
              isOnValidGroundAngleDownhill = false;
            }
          }
        }
      }
    }
    let isOnValidCeilingAngleUphill = true;
    let isOnValidCeilingAngleDownhill = true;
    if (collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingAngle > collisionCheckParams.myCeilingAngleToIgnore + 1e-4) {
      if (previousCollisionRuntimeParams.myIsOnCeiling && !horizontalMovementIsZero) {
        if (ceilingPerceivedAngle > 0) {
          isOnValidCeilingAngleUphill = false;
          if (collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle != null && collisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle + 1e-4) {
            isOnValidCeilingAngleUphill = Math.abs(ceilingPerceivedAngle) <= collisionCheckParams.myCeilingAngleToIgnore + 1e-4;
          }
        } else if (ceilingPerceivedAngle < 0) {
          if (previousCollisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myCeilingAngleToIgnore + 1e-4) {
            if (collisionCheckParams.myMustStayOnValidCeilingAngleDownhill) {
              isOnValidCeilingAngleDownhill = false;
            }
          }
        }
      }
    }
    return mustRemainOnGroundOk && mustRemainOnCeilingOk && mustStayBelowGroundAngleOk && mustStayBelowCeilingAngleOk && mustStayOnGroundHitAngleOk && mustStayOnCeilingHitAngleOk && isOnValidGroundAngleUphill && isOnValidGroundAngleDownhill && isOnValidCeilingAngleUphill && isOnValidCeilingAngleDownhill;
  };
}();
CollisionCheckSurface.prototype._surfaceTooSteep = /* @__PURE__ */ function() {
  let surfaceSteepResults = [false, false];
  return function _surfaceTooSteep(up, direction, collisionCheckParams, collisionRuntimeParams) {
    let groundTooSteep = false;
    let ceilingTooSteep = false;
    if (collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundAngle > collisionCheckParams.myGroundAngleToIgnore + 1e-4) {
      let groundPerceivedAngle = this.computeSurfacePerceivedAngle(collisionRuntimeParams.myGroundNormal, direction, up, true);
      groundTooSteep = groundPerceivedAngle > 0;
      if (groundTooSteep && collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle != null && collisionRuntimeParams.myGroundAngle <= collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle + 1e-4) {
        groundTooSteep = Math.abs(groundPerceivedAngle) > collisionCheckParams.myGroundAngleToIgnore + 1e-4;
      }
    }
    if (!groundTooSteep) {
      if (collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingAngle > collisionCheckParams.myCeilingAngleToIgnore + 1e-4) {
        let ceilingPerceivedAngle = this.computeSurfacePerceivedAngle(collisionRuntimeParams.myCeilingNormal, direction, up, false);
        ceilingTooSteep = ceilingPerceivedAngle > 0;
        if (ceilingTooSteep && collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle != null && collisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle + 1e-4) {
          ceilingTooSteep = Math.abs(ceilingPerceivedAngle) > collisionCheckParams.myCeilingAngleToIgnore + 1e-4;
        }
      }
    }
    surfaceSteepResults[0] = groundTooSteep;
    surfaceSteepResults[1] = ceilingTooSteep;
    return surfaceSteepResults;
  };
}();
CollisionCheckSurface.prototype._adjustVerticalMovementWithSurface = function() {
  let horizontalDirection = vec3_create();
  let extraVerticalMovement = vec3_create();
  return function _adjustVerticalMovementWithSurface(horizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outAdjustedVerticalMovement) {
    outAdjustedVerticalMovement.vec3_copy(verticalMovement);
    if (horizontalMovement.vec3_isZero(1e-5)) {
      return outAdjustedVerticalMovement;
    }
    let extraVerticalLength = 0;
    horizontalDirection = horizontalMovement.vec3_normalize(horizontalDirection);
    if (previousCollisionRuntimeParams.myIsOnGround) {
      let groundPerceivedAngle = this.computeSurfacePerceivedAngle(previousCollisionRuntimeParams.myGroundNormal, horizontalDirection, up, true);
      let groundExtraVerticalLength = horizontalMovement.vec3_length() * Math.tan(Math.pp_toRadians(Math.abs(groundPerceivedAngle)));
      groundExtraVerticalLength *= Math.pp_sign(groundPerceivedAngle);
      if (Math.abs(groundExtraVerticalLength) > 1e-5) {
        if (groundPerceivedAngle > 0) {
          if (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphill && (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle == null || Math.abs(groundPerceivedAngle) <= collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle) && (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle == null || previousCollisionRuntimeParams.myGroundAngle <= collisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle)) {
            extraVerticalLength = groundExtraVerticalLength;
            collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = true;
          }
        } else if (groundPerceivedAngle < 0) {
          if (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhill && (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle == null || Math.abs(groundPerceivedAngle) <= collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle) && (collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle == null || previousCollisionRuntimeParams.myGroundAngle <= collisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle)) {
            extraVerticalLength = groundExtraVerticalLength;
            collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = true;
          }
        }
      }
    }
    if (previousCollisionRuntimeParams.myIsOnCeiling) {
      let ceilingPerceivedAngle = this.computeSurfacePerceivedAngle(previousCollisionRuntimeParams.myCeilingNormal, horizontalDirection, up, false);
      let ceilingExtraVerticalLength = horizontalMovement.vec3_length() * Math.tan(Math.pp_toRadians(Math.abs(ceilingPerceivedAngle)));
      ceilingExtraVerticalLength *= Math.pp_sign(ceilingPerceivedAngle);
      if (Math.abs(ceilingExtraVerticalLength) > 1e-5) {
        let sameSignThanGround = Math.pp_sign(extraVerticalLength) == Math.pp_sign(ceilingExtraVerticalLength);
        if (extraVerticalLength == 0 || sameSignThanGround && Math.abs(ceilingExtraVerticalLength) > Math.abs(extraVerticalLength)) {
          if (ceilingPerceivedAngle > 0) {
            if (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphill && (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxPerceivedAngle == null || Math.abs(ceilingPerceivedAngle) <= collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxPerceivedAngle) && (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle == null || previousCollisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle)) {
              extraVerticalLength = ceilingExtraVerticalLength;
              collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill = true;
              collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = false;
            }
          } else if (ceilingPerceivedAngle < 0) {
            if (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhill && (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxPerceivedAngle == null || Math.abs(ceilingPerceivedAngle) <= collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxPerceivedAngle) && (collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle == null || previousCollisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle)) {
              extraVerticalLength = ceilingExtraVerticalLength;
              collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill = true;
              collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = false;
            }
          }
        }
      }
    }
    if (Math.abs(extraVerticalLength) > 1e-5) {
      let verticalMovementLength = verticalMovement.vec3_lengthSigned(up);
      let sameSignThanExtra = Math.pp_sign(extraVerticalLength) == Math.pp_sign(verticalMovementLength);
      extraVerticalMovement = up.vec3_scale(extraVerticalLength, extraVerticalMovement);
      if (verticalMovement.vec3_isZero(1e-5)) {
        outAdjustedVerticalMovement.vec3_copy(extraVerticalMovement);
      } else if (sameSignThanExtra) {
        outAdjustedVerticalMovement = verticalMovement.vec3_add(extraVerticalMovement, outAdjustedVerticalMovement);
      } else if (!sameSignThanExtra && (collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill || collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill)) {
        outAdjustedVerticalMovement = verticalMovement.vec3_add(extraVerticalMovement, outAdjustedVerticalMovement);
      } else {
        collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill = false;
        collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = false;
        collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill = false;
        collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = false;
      }
    }
    if (outAdjustedVerticalMovement.vec3_isZero(1e-6)) {
      outAdjustedVerticalMovement.vec3_zero();
    }
    return outAdjustedVerticalMovement;
  };
}();
CollisionCheckSurface.prototype._adjustHorizontalMovementWithSurface = function() {
  let extraHorizontalMovement = vec3_create();
  let groundHorizontalDirection = vec3_create();
  let ceilingHorizontalDirection = vec3_create();
  let scaledCeilingHorizontalDirection = vec3_create();
  let scaledCeilingHorizontalDirectionAlongGroundHorizontalDirection = vec3_create();
  let scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection = vec3_create();
  return function _adjustHorizontalMovementWithSurface(horizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outAdjustedHorizontalMovement) {
    outAdjustedHorizontalMovement.vec3_copy(horizontalMovement);
    if (verticalMovement.vec3_isZero(1e-5)) {
      return outAdjustedHorizontalMovement;
    }
    let isMovementDownward = !verticalMovement.vec3_isConcordant(up);
    extraHorizontalMovement.vec3_zero();
    groundHorizontalDirection.vec3_zero();
    if (previousCollisionRuntimeParams.myIsOnGround) {
      groundHorizontalDirection = previousCollisionRuntimeParams.myGroundNormal.vec3_removeComponentAlongAxis(up, groundHorizontalDirection);
      if (!groundHorizontalDirection.vec3_isZero(1e-5)) {
        groundHorizontalDirection.vec3_normalize(groundHorizontalDirection);
        let groundExtraHorizontalLength = verticalMovement.vec3_length() / Math.tan(Math.pp_toRadians(previousCollisionRuntimeParams.myGroundAngle));
        groundExtraHorizontalLength *= isMovementDownward ? 1 : -1;
        if (Math.abs(groundExtraHorizontalLength) > 1e-5) {
          if (isMovementDownward) {
            if (collisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhill && (collisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle == null || previousCollisionRuntimeParams.myGroundAngle >= collisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle)) {
              extraHorizontalMovement = groundHorizontalDirection.vec3_scale(groundExtraHorizontalLength, extraHorizontalMovement);
              collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill = true;
            }
          }
        }
      }
    }
    if (previousCollisionRuntimeParams.myIsOnCeiling) {
      ceilingHorizontalDirection = previousCollisionRuntimeParams.myCeilingNormal.vec3_removeComponentAlongAxis(up, ceilingHorizontalDirection);
      if (!ceilingHorizontalDirection.vec3_isZero(1e-5)) {
        ceilingHorizontalDirection.vec3_normalize(ceilingHorizontalDirection);
        let ceilingExtraHorizontalLength = verticalMovement.vec3_length() / Math.tan(Math.pp_toRadians(previousCollisionRuntimeParams.myCeilingAngle));
        ceilingExtraHorizontalLength *= isMovementDownward ? -1 : 1;
        if (Math.abs(ceilingExtraHorizontalLength) > 1e-5) {
          let sameDirectionAsGround = ceilingHorizontalDirection.vec3_isConcordant(groundHorizontalDirection);
          if (extraHorizontalMovement.vec3_isZero() || sameDirectionAsGround) {
            if (!isMovementDownward) {
              if (collisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhill && (collisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle == null || previousCollisionRuntimeParams.myCeilingAngle >= collisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle)) {
                scaledCeilingHorizontalDirection = ceilingHorizontalDirection.vec3_scale(ceilingExtraHorizontalLength, scaledCeilingHorizontalDirection);
                if (!groundHorizontalDirection.vec3_isZero()) {
                  scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection = scaledCeilingHorizontalDirection.vec3_removeComponentAlongAxis(scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection);
                  scaledCeilingHorizontalDirectionAlongGroundHorizontalDirection = scaledCeilingHorizontalDirection.vec3_componentAlongAxis(scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection);
                  if (scaledCeilingHorizontalDirectionAlongGroundHorizontalDirection.vec3_isFartherAlongAxis(extraHorizontalMovement, groundHorizontalDirection)) {
                    collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill = false;
                    extraHorizontalMovement.vec3_copy(scaledCeilingHorizontalDirection);
                    collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = true;
                  } else if (!scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection.vec3_isZero(1e-5)) {
                    extraHorizontalMovement = extraHorizontalMovement.vec3_add(scaledCeilingHorizontalDirectionWithoutGroundHorizontalDirection, extraHorizontalMovement);
                    collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = true;
                  }
                } else {
                  extraHorizontalMovement.vec3_copy(scaledCeilingHorizontalDirection);
                  collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = true;
                }
              }
            }
          }
        }
      }
    }
    if (!extraHorizontalMovement.vec3_isZero()) {
      if (horizontalMovement.vec3_isZero(1e-5)) {
        outAdjustedHorizontalMovement.vec3_copy(extraHorizontalMovement);
      } else if (extraHorizontalMovement.vec3_isConcordant(horizontalMovement)) {
        outAdjustedHorizontalMovement = horizontalMovement.vec3_add(extraHorizontalMovement, outAdjustedHorizontalMovement);
      } else {
        outAdjustedHorizontalMovement = horizontalMovement.vec3_add(extraHorizontalMovement, outAdjustedHorizontalMovement);
      }
    }
    if (outAdjustedHorizontalMovement.vec3_isZero(1e-6)) {
      outAdjustedHorizontalMovement.vec3_zero();
    }
    return outAdjustedHorizontalMovement;
  };
}();
CollisionCheckSurface.prototype._computeExtraSurfaceVerticalMovement = function() {
  let direction = vec3_create();
  let tempVector = vec3_create();
  return function _computeExtraSurfaceVerticalMovement(horizontalMovement, up, collisionCheckParams, collisionRuntimeParams, outExtraSurfaceVerticalMovement) {
    outExtraSurfaceVerticalMovement.vec3_zero();
    if (!horizontalMovement.vec3_isZero()) {
      if (collisionRuntimeParams.myIsOnGround && collisionRuntimeParams.myGroundAngle != 0) {
        direction = horizontalMovement.vec3_normalize(direction);
        let groundPerceivedAngle = this.computeSurfacePerceivedAngle(collisionRuntimeParams.myGroundNormal, direction, up, true);
        let extraVerticalLength = horizontalMovement.vec3_length() * Math.tan(Math.pp_toRadians(Math.abs(groundPerceivedAngle)));
        extraVerticalLength *= Math.pp_sign(groundPerceivedAngle);
        if (Math.abs(extraVerticalLength) > 1e-5 && (collisionCheckParams.mySnapOnGroundEnabled || extraVerticalLength > 0)) {
          outExtraSurfaceVerticalMovement.vec3_add(up.vec3_scale(extraVerticalLength, tempVector), outExtraSurfaceVerticalMovement);
        }
      } else if (collisionRuntimeParams.myIsOnCeiling && collisionRuntimeParams.myCeilingAngle != 0) {
        direction = horizontalMovement.vec3_normalize(direction);
        let ceilingPerceivedAngle = this.computeSurfacePerceivedAngle(collisionRuntimeParams.myCeilingNormal, direction, up, false);
        let extraVerticalLength = horizontalMovement.vec3_length() * Math.tan(Math.pp_toRadians(Math.abs(ceilingPerceivedAngle)));
        extraVerticalLength *= Math.pp_sign(ceilingPerceivedAngle);
        extraVerticalLength *= -1;
        if (Math.abs(extraVerticalLength) > 1e-5 && (collisionCheckParams.mySnapOnCeilingEnabled || extraVerticalLength < 0)) {
          outExtraSurfaceVerticalMovement.vec3_add(up.vec3_scale(extraVerticalLength, tempVector), outExtraSurfaceVerticalMovement);
        }
      }
    }
    return outExtraSurfaceVerticalMovement;
  };
}();
CollisionCheckSurface.prototype._gatherSurfaceInfo = function() {
  let verticalDirection = vec3_create();
  let startOffset = vec3_create();
  let endOffset = vec3_create();
  let heightOffset = vec3_create();
  let smallOffset = vec3_create();
  let smallStartPosition = vec3_create();
  let smallEndPosition = vec3_create();
  let surfaceNormal = vec3_create();
  let surfaceHitMaxNormal = vec3_create();
  let hitFromCurrentPosition = vec3_create();
  let startPosition = vec3_create();
  let endPosition = vec3_create();
  let direction = vec3_create();
  let surfaceCollisionHit = new RaycastHit();
  let surfaceCollisionHitForBaseInsideCollision = new RaycastHit();
  return function _gatherSurfaceInfo(feetPosition, height, up, forwardForPerceivedAngle, forwardForVertical, isGround, collisionCheckParams, collisionRuntimeParams) {
    this._myDebugEnabled = collisionCheckParams.myDebugEnabled && (isGround && collisionCheckParams.myDebugGroundInfoEnabled || !isGround && collisionCheckParams.myDebugCeilingInfoEnabled);
    let checkPositions = this._getVerticalCheckPositions(feetPosition, up, forwardForVertical, collisionCheckParams, collisionRuntimeParams);
    verticalDirection.vec3_copy(up);
    let distanceToBeOnSurface = collisionCheckParams.myDistanceToBeOnGround;
    let distanceToComputeSurfaceInfo = collisionCheckParams.myDistanceToComputeGroundInfo;
    let distanceToFindSurfaceDistance = collisionCheckParams.myFindGroundDistanceMaxOutsideDistance;
    let distanceToCollectCollisionHit = collisionCheckParams.myCollectGroundCollisionHitOutsideDistance;
    let verticalFixToBeOnSurface = collisionCheckParams.myVerticalFixToBeOnGround;
    let verticalFixToComputeSurfaceInfo = collisionCheckParams.myVerticalFixToComputeGroundInfo;
    let verticalFixToFindSurfaceDistance = collisionCheckParams.myFindGroundDistanceMaxInsideDistance;
    let verticalFixToCollectCollisionHit = collisionCheckParams.myCollectGroundCollisionHitInsideDistance;
    let isOnSurfaceIfInsideHit = collisionCheckParams.myIsOnGroundIfInsideHit;
    let isBaseInsideCollisionCheckEnabled = collisionCheckParams.myGroundIsBaseInsideCollisionCheckEnabled;
    if (!isGround) {
      verticalDirection.vec3_negate(verticalDirection);
      distanceToBeOnSurface = collisionCheckParams.myDistanceToBeOnCeiling;
      distanceToComputeSurfaceInfo = collisionCheckParams.myDistanceToComputeCeilingInfo;
      distanceToFindSurfaceDistance = collisionCheckParams.myFindCeilingDistanceMaxOutsideDistance;
      distanceToCollectCollisionHit = collisionCheckParams.myCollectCeilingCollisionHitOutsideDistance;
      verticalFixToBeOnSurface = collisionCheckParams.myVerticalFixToBeOnCeiling;
      verticalFixToComputeSurfaceInfo = collisionCheckParams.myVerticalFixToComputeCeilingInfo;
      verticalFixToFindSurfaceDistance = collisionCheckParams.myFindCeilingDistanceMaxInsideDistance;
      verticalFixToCollectCollisionHit = collisionCheckParams.myCollectCeilingCollisionHitInsideDistance;
      isOnSurfaceIfInsideHit = collisionCheckParams.myIsOnCeilingIfInsideHit;
      isBaseInsideCollisionCheckEnabled = collisionCheckParams.myCeilingIsBaseInsideCollisionCheckEnabled;
    }
    startOffset = verticalDirection.vec3_scale(Math.max(verticalFixToBeOnSurface, verticalFixToComputeSurfaceInfo, verticalFixToFindSurfaceDistance, 1e-5), startOffset);
    endOffset = verticalDirection.vec3_negate(endOffset).vec3_scale(Math.max(distanceToBeOnSurface, distanceToComputeSurfaceInfo, distanceToFindSurfaceDistance, 1e-5), endOffset);
    heightOffset.vec3_zero();
    if (!isGround) {
      heightOffset = up.vec3_scale(height, heightOffset);
    }
    smallOffset = verticalDirection.vec3_scale(1e-4, smallOffset);
    let isOnSurface = false;
    let isActuallyOnSurface = false;
    let surfaceAngle = 0;
    let surfacePerceivedAngle = 0;
    surfaceNormal.vec3_zero();
    surfaceCollisionHit.reset();
    surfaceCollisionHitForBaseInsideCollision.reset();
    let surfaceHitMaxAngle = 0;
    surfaceHitMaxNormal.vec3_zero();
    let surfaceDistance = null;
    let surfaceDistanceForCollectCollisionHit = null;
    let isBaseInsideCollision = checkPositions.length > 0;
    for (let i = 0; i < checkPositions.length; i++) {
      let currentPosition = checkPositions[i];
      currentPosition.vec3_add(heightOffset, currentPosition);
      let baseHitIsInsideCollision = false;
      if (isBaseInsideCollisionCheckEnabled) {
        smallStartPosition = currentPosition.vec3_add(smallOffset, smallStartPosition);
        smallEndPosition = currentPosition.vec3_sub(smallOffset, smallEndPosition);
        let origin = smallStartPosition;
        direction = smallEndPosition.vec3_sub(origin, direction);
        let distance2 = direction.vec3_length();
        direction.vec3_normalize(direction);
        let raycastResult = this._raycastAndDebug(origin, direction, distance2, false, false, collisionCheckParams, collisionRuntimeParams);
        if (raycastResult.isColliding()) {
          baseHitIsInsideCollision = raycastResult.myHits[0].myInsideCollision;
          surfaceCollisionHitForBaseInsideCollision.copy(raycastResult.myHits[0]);
        }
      }
      isBaseInsideCollision &&= baseHitIsInsideCollision;
      if (!baseHitIsInsideCollision) {
        startPosition = currentPosition.vec3_add(startOffset, startPosition);
        endPosition = currentPosition.vec3_add(endOffset, endPosition);
        let origin = startPosition;
        direction = endPosition.vec3_sub(origin, direction);
        let distance2 = direction.vec3_length();
        direction.vec3_normalize(direction);
        let raycastResult = this._raycastAndDebug(origin, direction, distance2, true, false, collisionCheckParams, collisionRuntimeParams);
        if (raycastResult.isColliding()) {
          hitFromCurrentPosition = raycastResult.myHits[0].myPosition.vec3_sub(currentPosition, hitFromCurrentPosition);
          let hitFromCurrentPositionLength = hitFromCurrentPosition.vec3_lengthSigned(verticalDirection);
          if (hitFromCurrentPositionLength >= 0 && hitFromCurrentPositionLength <= verticalFixToBeOnSurface + 1e-5 || hitFromCurrentPositionLength < 0 && Math.abs(hitFromCurrentPositionLength) <= distanceToBeOnSurface + 1e-5) {
            isOnSurface = true;
            isActuallyOnSurface = true;
          }
          if (hitFromCurrentPositionLength >= 0 && hitFromCurrentPositionLength <= verticalFixToComputeSurfaceInfo + 1e-5 || hitFromCurrentPositionLength < 0 && Math.abs(hitFromCurrentPositionLength) <= distanceToComputeSurfaceInfo + 1e-5) {
            let currentSurfaceNormal = raycastResult.myHits[0].myNormal;
            surfaceNormal.vec3_add(currentSurfaceNormal, surfaceNormal);
            let surfaceHitAngle = currentSurfaceNormal.vec3_angle(verticalDirection);
            if (surfaceHitAngle > surfaceHitMaxAngle) {
              surfaceHitMaxAngle = surfaceHitAngle;
              surfaceHitMaxNormal.vec3_copy(currentSurfaceNormal);
            }
          }
          if (hitFromCurrentPositionLength >= 0 && hitFromCurrentPositionLength <= verticalFixToFindSurfaceDistance + 1e-5 || hitFromCurrentPositionLength < 0 && Math.abs(hitFromCurrentPositionLength) <= distanceToFindSurfaceDistance + 1e-5) {
            if (surfaceDistance == null) {
              surfaceDistance = -hitFromCurrentPositionLength;
            } else {
              if (Math.abs(hitFromCurrentPositionLength) < Math.abs(surfaceDistance)) {
                surfaceDistance = -hitFromCurrentPositionLength;
              }
            }
          }
          if (hitFromCurrentPositionLength >= 0 && hitFromCurrentPositionLength <= verticalFixToCollectCollisionHit + 1e-5 || hitFromCurrentPositionLength < 0 && Math.abs(hitFromCurrentPositionLength) <= distanceToCollectCollisionHit + 1e-5) {
            if (surfaceDistanceForCollectCollisionHit == null) {
              surfaceDistanceForCollectCollisionHit = -hitFromCurrentPositionLength;
              surfaceCollisionHit.copy(raycastResult.myHits[0]);
            } else {
              if (Math.abs(hitFromCurrentPositionLength) < Math.abs(surfaceDistanceForCollectCollisionHit)) {
                surfaceDistanceForCollectCollisionHit = -hitFromCurrentPositionLength;
                surfaceCollisionHit.copy(raycastResult.myHits[0]);
              }
            }
          }
        }
      } else if (isOnSurfaceIfInsideHit) {
        if (!isOnSurface) {
          isOnSurface = true;
          if (!surfaceCollisionHit.isValid()) {
            surfaceCollisionHit.copy(surfaceCollisionHitForBaseInsideCollision);
          }
        }
      }
    }
    if (!surfaceNormal.vec3_isZero()) {
      surfaceNormal.vec3_normalize(surfaceNormal);
      surfaceAngle = surfaceNormal.vec3_angle(verticalDirection);
      if (surfaceAngle <= 1e-4) {
        surfaceAngle = 0;
        surfaceNormal.vec3_copy(verticalDirection);
      } else if (surfaceAngle >= 180 - 1e-4) {
        surfaceAngle = 180;
        surfaceNormal = verticalDirection.vec3_negate(surfaceNormal);
      }
      surfacePerceivedAngle = this.computeSurfacePerceivedAngle(surfaceNormal, forwardForPerceivedAngle, up, isGround);
    }
    if (isGround) {
      collisionRuntimeParams.myRealIsOnGround = isOnSurface;
      collisionRuntimeParams.myGroundCollisionHit.copy(surfaceCollisionHit);
      collisionRuntimeParams.myGroundAngle = surfaceAngle;
      collisionRuntimeParams.myGroundPerceivedAngle = surfacePerceivedAngle;
      collisionRuntimeParams.myGroundNormal.vec3_copy(surfaceNormal);
      collisionRuntimeParams.myGroundHitMaxAngle = surfaceHitMaxAngle;
      collisionRuntimeParams.myGroundHitMaxNormal.vec3_copy(surfaceHitMaxNormal);
      collisionRuntimeParams.myGroundDistance = surfaceDistance;
      collisionRuntimeParams.myGroundIsBaseInsideCollision = isBaseInsideCollision;
      if (isOnSurface && (collisionCheckParams.myIsOnGroundMaxSurfaceAngle == null || collisionRuntimeParams.myGroundAngle <= collisionCheckParams.myIsOnGroundMaxSurfaceAngle)) {
        collisionRuntimeParams.myIsOnGround = true;
      } else {
        collisionRuntimeParams.myIsOnGround = false;
      }
      collisionRuntimeParams.myOnGroundDueToBasePartiallyInsideCollision = isOnSurface && !isActuallyOnSurface;
    } else {
      collisionRuntimeParams.myRealIsOnCeiling = isOnSurface;
      collisionRuntimeParams.myCeilingCollisionHit.copy(surfaceCollisionHit);
      collisionRuntimeParams.myCeilingAngle = surfaceAngle;
      collisionRuntimeParams.myCeilingPerceivedAngle = surfacePerceivedAngle;
      collisionRuntimeParams.myCeilingNormal.vec3_copy(surfaceNormal);
      collisionRuntimeParams.myCeilingHitMaxAngle = surfaceHitMaxAngle;
      collisionRuntimeParams.myCeilingHitMaxNormal.vec3_copy(surfaceHitMaxNormal);
      collisionRuntimeParams.myCeilingDistance = surfaceDistance;
      collisionRuntimeParams.myCeilingIsBaseInsideCollision = isBaseInsideCollision;
      if (isOnSurface && (collisionCheckParams.myIsOnCeilingMaxSurfaceAngle == null || collisionRuntimeParams.myCeilingAngle <= collisionCheckParams.myIsOnCeilingMaxSurfaceAngle)) {
        collisionRuntimeParams.myIsOnCeiling = true;
      } else {
        collisionRuntimeParams.myIsOnCeiling = false;
      }
      collisionRuntimeParams.myOnCeilingDueToBasePartiallyInsideCollision = isOnSurface && !isActuallyOnSurface;
    }
  };
}();
CollisionCheckSurface.prototype.computeSurfacePerceivedAngle = function() {
  let forwardOnSurface = vec3_create();
  let verticalDirection = vec3_create();
  return function computeSurfacePerceivedAngle2(surfaceNormal, forward, up, isGround = true) {
    let surfacePerceivedAngle = 0;
    verticalDirection.vec3_copy(up);
    if (!isGround) {
      verticalDirection.vec3_negate(verticalDirection);
    }
    let surfaceAngle = surfaceNormal.vec3_angle(verticalDirection);
    if (surfaceAngle <= Math.PP_EPSILON_DEGREES) {
      surfaceAngle = 0;
    } else if (surfaceAngle >= 180 - Math.PP_EPSILON_DEGREES) {
      surfaceAngle = 180;
    }
    forwardOnSurface = forward.vec3_projectOnPlaneAlongAxis(surfaceNormal, up, forwardOnSurface);
    surfacePerceivedAngle = forwardOnSurface.vec3_angle(forward);
    let isFartherOnUp = forwardOnSurface.vec3_isFartherAlongAxis(forward, up);
    if (!isFartherOnUp && isGround || isFartherOnUp && !isGround) {
      surfacePerceivedAngle *= -1;
    }
    if (Math.abs(surfacePerceivedAngle) >= surfaceAngle) {
      if (surfaceAngle != 0 && surfaceAngle != 180) {
        surfacePerceivedAngle = surfaceAngle * Math.pp_sign(surfacePerceivedAngle);
      } else {
        surfacePerceivedAngle = surfaceAngle;
      }
    }
    return surfacePerceivedAngle;
  };
}();

// dist/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_horizontal_base.js
var CollisionCheckHorizontalBase = class extends CollisionCheckSurface {
  _horizontalCheckRaycast(startPosition, endPosition, movementDirection, up, ignoreHitsInsideCollision, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, fixHitOnCollision, collisionCheckParams, collisionRuntimeParams, checkAllHits = false, ignoreHitsInsideCollisionIfObjectToIgnore = false) {
  }
  _ignoreSurfaceAngle(feetPosition, height, movementOrForward, objectsToIgnore, outIgnoredObjects, isGround, isMovementCheck, up, collisionCheckParams, hit, ignoreHitsInsideCollisionIfObjectToIgnore) {
  }
};
CollisionCheckHorizontalBase.prototype._horizontalCheckRaycast = function() {
  let direction = vec3_create();
  let fixedFeetPosition = vec3_create();
  let fixedHitPosition = vec3_create();
  return function _horizontalCheckRaycast(startPosition, endPosition, movementDirection, up, ignoreHitsInsideCollision, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, fixHitOnCollision, collisionCheckParams, collisionRuntimeParams, checkAllHits = false, ignoreHitsInsideCollisionIfObjectToIgnore = false) {
    let origin = startPosition;
    direction = endPosition.vec3_sub(origin, direction);
    if (movementDirection != null && !direction.vec3_isConcordant(movementDirection)) {
      direction.vec3_negate(direction);
      origin = endPosition;
    }
    let distance2 = direction.vec3_length();
    direction.vec3_normalize(direction);
    let raycastResult = this._raycastAndDebug(origin, direction, distance2, ignoreHitsInsideCollision, true, collisionCheckParams, collisionRuntimeParams);
    let isOk = true;
    if (raycastResult.isColliding()) {
      let hitsToControl = checkAllHits ? raycastResult.myHits.length : 1;
      let validHitIndex = 0;
      for (let i = 0; i < hitsToControl; i++) {
        let hit = raycastResult.myHits[i];
        if ((ignoreGroundAngleCallback == null || !ignoreGroundAngleCallback(hit, ignoreHitsInsideCollisionIfObjectToIgnore)) && (ignoreCeilingAngleCallback == null || !ignoreCeilingAngleCallback(hit, ignoreHitsInsideCollisionIfObjectToIgnore))) {
          isOk = false;
          validHitIndex = i;
          break;
        }
      }
      if (!isOk && validHitIndex > 0) {
        for (let i = 0; i < validHitIndex; i++) {
          raycastResult.removeHit(0);
        }
      }
    }
    if (!isOk && fixHitOnCollision) {
      let hitPosition = raycastResult.myHits[0].myPosition;
      fixedFeetPosition = feetPosition.vec3_copyComponentAlongAxis(hitPosition, up, fixedFeetPosition);
      fixedHitPosition.vec3_copy(hitPosition);
      let directionOffsetEpsilonValue = 1e-4;
      direction = direction.vec3_componentAlongAxis(up, direction);
      if (!direction.vec3_isZero(1e-6)) {
        direction.vec3_normalize(direction);
        direction.vec3_scale(directionOffsetEpsilonValue, direction);
        fixedFeetPosition.vec3_add(direction, fixedFeetPosition);
        fixedHitPosition.vec3_add(direction, fixedHitPosition);
      }
      direction = fixedHitPosition.vec3_sub(fixedFeetPosition, direction);
      direction.vec3_normalize(direction);
      direction.vec3_scale(directionOffsetEpsilonValue, direction);
      fixedHitPosition = fixedHitPosition.vec3_add(direction, fixedHitPosition);
      let swapRaycastResult = this._myRaycastResult;
      this._myRaycastResult = this._myFixRaycastResult;
      isOk = this._horizontalCheckRaycast(fixedFeetPosition, fixedHitPosition, null, up, false, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, false, collisionCheckParams, collisionRuntimeParams);
      if (this._myRaycastResult.isColliding()) {
        this._myFixRaycastResult = swapRaycastResult;
      } else {
        isOk = false;
        this._myRaycastResult = swapRaycastResult;
      }
    }
    return isOk;
  };
}();
CollisionCheckHorizontalBase.prototype._ignoreSurfaceAngle = function() {
  let objectsEqualCallback = (first2, second) => first2 == second;
  let movementDirection = vec3_create();
  let hitDirection = vec3_create();
  let hitMovement = vec3_create();
  let projectAlongAxis = vec3_create();
  return function _ignoreSurfaceAngle(feetPosition, height, movementOrForward, objectsToIgnore, outIgnoredObjects, isGround, isMovementCheck, up, collisionCheckParams, hit, ignoreHitsInsideCollisionIfObjectToIgnore) {
    let isIgnorable = false;
    let surfaceIgnoreHeight = null;
    let groundIgnoreHeight = isMovementCheck ? collisionCheckParams.myHorizontalMovementGroundAngleIgnoreHeight : collisionCheckParams.myHorizontalPositionGroundAngleIgnoreHeight;
    let ceilingIgnoreHeight = isMovementCheck ? collisionCheckParams.myHorizontalMovementCeilingAngleIgnoreHeight : collisionCheckParams.myHorizontalPositionCeilingAngleIgnoreHeight;
    if (isGround && groundIgnoreHeight != null) {
      surfaceIgnoreHeight = Math.pp_clamp(groundIgnoreHeight + 2e-4, 0, height);
    } else if (!isGround && ceilingIgnoreHeight != null) {
      surfaceIgnoreHeight = Math.pp_clamp(height - ceilingIgnoreHeight - 2e-4, 0, height);
    }
    let surfaceIgnoreMaxMovementLeft = null;
    if (isMovementCheck) {
      if (isGround && collisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft != null) {
        surfaceIgnoreMaxMovementLeft = collisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft;
      } else if (!isGround && collisionCheckParams.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft != null) {
        surfaceIgnoreMaxMovementLeft = collisionCheckParams.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft;
      }
    }
    if (!hit.myInsideCollision) {
      movementDirection = movementOrForward.vec3_normalize(movementDirection);
      let surfaceAngle = hit.myNormal.vec3_angle(up);
      if (!isGround) {
        surfaceAngle = 180 - surfaceAngle;
      }
      if (isGround && collisionCheckParams.myGroundAngleToIgnore > 0 && surfaceAngle > collisionCheckParams.myGroundAngleToIgnore + 1e-4) {
        if (collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle != null && surfaceAngle <= collisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle + 1e-4) {
          let perceivedAngle = this.computeSurfacePerceivedAngle(hit.myNormal, movementDirection, up, true);
          surfaceAngle = Math.abs(perceivedAngle);
        }
      } else if (!isGround && collisionCheckParams.myCeilingAngleToIgnore > 0 && surfaceAngle > collisionCheckParams.myCeilingAngleToIgnore + 1e-4) {
        if (collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle != null && surfaceAngle <= collisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle + 1e-4) {
          let perceivedAngle = this.computeSurfacePerceivedAngle(hit.myNormal, movementDirection, up, false);
          surfaceAngle = Math.abs(perceivedAngle);
        }
      }
      if (isGround && (collisionCheckParams.myGroundAngleToIgnore > 0 && surfaceAngle <= collisionCheckParams.myGroundAngleToIgnore + 1e-4) || !isGround && (collisionCheckParams.myCeilingAngleToIgnore > 0 && surfaceAngle <= collisionCheckParams.myCeilingAngleToIgnore + 1e-4)) {
        if (objectsToIgnore == null || objectsToIgnore.pp_hasEqual(hit.myObject, objectsEqualCallback)) {
          let surfaceHeightCheckOk = true;
          let maxMovementLeftCheckOk = true;
          if (surfaceIgnoreHeight != null) {
            surfaceHeightCheckOk = false;
            let feetPositionUp = feetPosition.vec3_valueAlongAxis(up);
            let hitUp = hit.myPosition.vec3_valueAlongAxis(up);
            let hitHeight = hitUp - feetPositionUp;
            if (isGround && hitHeight <= surfaceIgnoreHeight || !isGround && hitHeight >= surfaceIgnoreHeight) {
              surfaceHeightCheckOk = true;
            } else {
            }
          }
          if (surfaceHeightCheckOk && isMovementCheck) {
            if (surfaceIgnoreMaxMovementLeft != null) {
              let movementLength = movementOrForward.vec3_length();
              if (movementLength > surfaceIgnoreMaxMovementLeft) {
                maxMovementLeftCheckOk = false;
                let hitPosition = hit.myPosition;
                let halfConeAngle = Math.min(collisionCheckParams.myHalfConeAngle, 90);
                hitDirection = hitPosition.vec3_sub(feetPosition, hitDirection);
                if (hitDirection.vec3_isToTheRight(movementDirection, up)) {
                  projectAlongAxis = movementDirection.vec3_rotateAxis(-halfConeAngle, up, projectAlongAxis);
                } else {
                  projectAlongAxis = movementDirection.vec3_rotateAxis(halfConeAngle, up, projectAlongAxis);
                }
                hitMovement = hitDirection.vec3_projectOnAxisAlongAxis(movementDirection, projectAlongAxis, hitMovement);
                let hitMovementLength = hitMovement.vec3_length();
                let movementLeft = movementLength - hitMovementLength;
                if (movementLeft <= surfaceIgnoreMaxMovementLeft) {
                  maxMovementLeftCheckOk = true;
                } else {
                }
              }
            }
          }
          if (surfaceHeightCheckOk && maxMovementLeftCheckOk) {
            isIgnorable = true;
          }
        }
      }
    } else if (ignoreHitsInsideCollisionIfObjectToIgnore) {
      if (objectsToIgnore == null || objectsToIgnore.pp_hasEqual(hit.myObject, objectsEqualCallback)) {
        isIgnorable = true;
      }
    }
    if (isIgnorable) {
      if (outIgnoredObjects != null) {
        outIgnoredObjects.pp_pushUnique(hit.myObject, objectsEqualCallback);
      }
    }
    return isIgnorable;
  };
}();

// dist/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_horizontal_position.js
var CollisionCheckHorizontalPosition = class extends CollisionCheckHorizontalBase {
  _horizontalPositionCheck(originalFeetPosition, originalHeight, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
  }
  _horizontalPositionHorizontalCheck(feetPosition, checkPositions, heightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
  }
  _horizontalPositionVerticalCheck(feetPosition, checkPositions, heightOffset, heightStep, verticalDirection, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
  }
};
CollisionCheckHorizontalPosition.prototype._horizontalPositionCheck = function() {
  let checkPositions = [];
  let cachedCheckPositions = [];
  let currentCachedCheckPositionIndex = 0;
  let _localGetCachedCheckPosition = function() {
    let item = null;
    while (cachedCheckPositions.length <= currentCachedCheckPositionIndex) {
      cachedCheckPositions.push(vec3_create());
    }
    item = cachedCheckPositions[currentCachedCheckPositionIndex];
    currentCachedCheckPositionIndex++;
    return item;
  };
  let _localGroundObjectsToIgnore = [];
  let _localCeilingObjectsToIgnore = [];
  let _localGroundCeilingObjectsToIgnore = [];
  let objectsEqualCallback = (first2, second) => first2 == second;
  let heightOffset = vec3_create();
  let heightStep = vec3_create();
  let currentHeightOffset = vec3_create();
  let hitHeightOffset = vec3_create();
  let hitHeightOffsetEpsilon = vec3_create();
  let downwardHeightOffset = vec3_create();
  let downwardHeightStep = vec3_create();
  let verticalDirection = vec3_create();
  let vertilCheckHit = new RaycastHit();
  return function _horizontalPositionCheck(originalFeetPosition, originalHeight, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
    this._myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugHorizontalPositionEnabled;
    checkPositions.length = 0;
    currentCachedCheckPositionIndex = 0;
    let halfConeAngle = Math.min(collisionCheckParams.myHalfConeAngle, 180);
    let sliceAngle = halfConeAngle / collisionCheckParams.myHalfConeSliceAmount;
    let tempCheckPosition = _localGetCachedCheckPosition();
    checkPositions.push(feetPosition.vec3_add(forward.vec3_scale(collisionCheckParams.myRadius, tempCheckPosition), tempCheckPosition));
    for (let i = 1; i <= collisionCheckParams.myHalfConeSliceAmount; i++) {
      let currentAngle = i * sliceAngle;
      tempCheckPosition = _localGetCachedCheckPosition();
      let radialDirection = forward.vec3_rotateAxis(-currentAngle, up, tempCheckPosition);
      checkPositions.push(feetPosition.vec3_add(radialDirection.vec3_scale(collisionCheckParams.myRadius, radialDirection), radialDirection));
      tempCheckPosition = _localGetCachedCheckPosition();
      radialDirection = forward.vec3_rotateAxis(currentAngle, up, tempCheckPosition);
      checkPositions.push(feetPosition.vec3_add(radialDirection.vec3_scale(collisionCheckParams.myRadius, radialDirection), radialDirection));
    }
    let groundObjectsToIgnore = null;
    let ceilingObjectsToIgnore = null;
    let groundCeilingObjectsToIgnore = null;
    if (collisionCheckParams.myGroundAngleToIgnore > 0) {
      groundObjectsToIgnore = _localGroundObjectsToIgnore;
      groundObjectsToIgnore.length = 0;
      groundCeilingObjectsToIgnore = _localGroundCeilingObjectsToIgnore;
      groundCeilingObjectsToIgnore.length = 0;
      let ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, null, groundObjectsToIgnore, true, false, up, collisionCheckParams);
      let ignoreCeilingAngleCallback = null;
      if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
        ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, null, groundCeilingObjectsToIgnore, false, false, up, collisionCheckParams);
      }
      heightOffset.vec3_zero();
      this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, heightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
    }
    if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
      if (!collisionRuntimeParams.myIsCollidingHorizontally && collisionCheckParams.myCheckHeight) {
        ceilingObjectsToIgnore = _localCeilingObjectsToIgnore;
        ceilingObjectsToIgnore.length = 0;
        let ignoreGroundAngleCallback = null;
        if (collisionCheckParams.myGroundAngleToIgnore > 0) {
          ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, groundObjectsToIgnore, null, true, false, up, collisionCheckParams);
        }
        let ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, null, ceilingObjectsToIgnore, false, false, up, collisionCheckParams);
        heightOffset = up.vec3_scale(height, heightOffset);
        this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, heightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
      }
    }
    if (!collisionRuntimeParams.myIsCollidingHorizontally) {
      let groundCeilingCheckIsFine = true;
      if (groundCeilingObjectsToIgnore != null) {
        for (let object of groundCeilingObjectsToIgnore) {
          if (!ceilingObjectsToIgnore.pp_hasEqual(object, objectsEqualCallback)) {
            groundCeilingCheckIsFine = false;
            break;
          }
        }
      }
      let ignoreGroundAngleCallback = null;
      let ignoreCeilingAngleCallback = null;
      if (collisionCheckParams.myGroundAngleToIgnore > 0) {
        ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, groundObjectsToIgnore, null, true, false, up, collisionCheckParams);
      }
      if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
        ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, forward, ceilingObjectsToIgnore, null, false, false, up, collisionCheckParams);
      }
      let heightStepAmount = 0;
      if (collisionCheckParams.myCheckHeight && collisionCheckParams.myHeightCheckStepAmountPosition > 0 && height > 0) {
        heightStepAmount = collisionCheckParams.myHeightCheckStepAmountPosition;
        up.vec3_scale(height / heightStepAmount, heightStep);
      }
      for (let i = 0; i <= heightStepAmount; i++) {
        currentHeightOffset = heightStep.vec3_scale(i, currentHeightOffset);
        if (collisionCheckParams.myCheckHeightTopPosition || i == 0) {
          if (i != 0 && i != heightStepAmount || i == 0 && !groundCeilingCheckIsFine || i == 0 && collisionCheckParams.myGroundAngleToIgnore == 0 || i != 0 && i == heightStepAmount && collisionCheckParams.myCeilingAngleToIgnore == 0) {
            this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, currentHeightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
            if (collisionRuntimeParams.myIsCollidingHorizontally) {
              break;
            }
          }
        }
        if (i > 0) {
          if (collisionCheckParams.myCheckHeightVerticalPosition) {
            let hitHeightOffsetEpsilonValue = 1e-4;
            if (collisionCheckParams.myHorizontalPositionCheckVerticalDirectionType == 0 || collisionCheckParams.myHorizontalPositionCheckVerticalDirectionType == 2) {
              verticalDirection.vec3_copy(up);
              this._horizontalPositionVerticalCheck(feetPosition, checkPositions, currentHeightOffset, heightStep, verticalDirection, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
              if (collisionRuntimeParams.myIsCollidingHorizontally && collisionCheckParams.myCheckHeightConeOnCollision) {
                hitHeightOffset = collisionRuntimeParams.myHorizontalCollisionHit.myPosition.vec3_sub(feetPosition, hitHeightOffset).vec3_componentAlongAxis(up, hitHeightOffset);
                hitHeightOffset.vec3_add(verticalDirection.vec3_scale(hitHeightOffsetEpsilonValue, hitHeightOffsetEpsilon), hitHeightOffset);
                collisionRuntimeParams.myIsCollidingHorizontally = false;
                if (collisionCheckParams.myCheckHeightConeOnCollisionKeepHit) {
                  vertilCheckHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
                }
                collisionRuntimeParams.myHorizontalCollisionHit.reset();
                this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, hitHeightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
                if (collisionRuntimeParams.myIsCollidingHorizontally) {
                  break;
                } else if (collisionCheckParams.myCheckHeightConeOnCollisionKeepHit) {
                  collisionRuntimeParams.myIsCollidingHorizontally = true;
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(vertilCheckHit);
                  break;
                }
              }
            }
            if (!collisionRuntimeParams.myIsCollidingHorizontally) {
              if (collisionCheckParams.myHorizontalPositionCheckVerticalDirectionType == 1 || collisionCheckParams.myHorizontalPositionCheckVerticalDirectionType == 2) {
                verticalDirection = up.vec3_negate(verticalDirection);
                downwardHeightOffset = currentHeightOffset.vec3_sub(heightStep, downwardHeightOffset);
                downwardHeightStep = heightStep.vec3_negate(downwardHeightStep);
                this._horizontalPositionVerticalCheck(feetPosition, checkPositions, downwardHeightOffset, downwardHeightStep, verticalDirection, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
              }
              if (collisionRuntimeParams.myIsCollidingHorizontally && collisionCheckParams.myCheckHeightConeOnCollision) {
                hitHeightOffset = collisionRuntimeParams.myHorizontalCollisionHit.myPosition.vec3_sub(feetPosition, hitHeightOffset).vec3_componentAlongAxis(up, hitHeightOffset);
                hitHeightOffset.vec3_add(verticalDirection.vec3_scale(hitHeightOffsetEpsilonValue, hitHeightOffsetEpsilon), hitHeightOffset);
                collisionRuntimeParams.myIsCollidingHorizontally = false;
                if (collisionCheckParams.myCheckHeightConeOnCollisionKeepHit) {
                  vertilCheckHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
                }
                collisionRuntimeParams.myHorizontalCollisionHit.reset();
                this._horizontalPositionHorizontalCheck(feetPosition, checkPositions, hitHeightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
                if (collisionRuntimeParams.myIsCollidingHorizontally) {
                  break;
                } else if (collisionCheckParams.myCheckHeightConeOnCollisionKeepHit) {
                  collisionRuntimeParams.myIsCollidingHorizontally = true;
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(vertilCheckHit);
                  break;
                }
              }
            }
          }
        }
      }
    }
    return !collisionRuntimeParams.myIsCollidingHorizontally;
  };
}();
CollisionCheckHorizontalPosition.prototype._horizontalPositionHorizontalCheck = function() {
  let basePosition = vec3_create();
  let forwardNegate = vec3_create();
  let currentRadialPosition = vec3_create();
  let previousRadialPosition = vec3_create();
  return function _horizontalPositionHorizontalCheck(feetPosition, checkPositions, heightOffset, up, forward, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
    let isHorizontalCheckOk = true;
    basePosition = feetPosition.vec3_add(heightOffset, basePosition);
    let halfRadialPositions = Math.floor(checkPositions.length / 2) + 1;
    for (let j = 0; j < halfRadialPositions; j++) {
      if (j > 0) {
        let leftIndex = Math.max(0, j * 2);
        let rightIndex = Math.max(0, j * 2 - 1);
        let leftAndRightEqual = checkPositions[leftIndex].vec_equals(checkPositions[rightIndex], 1e-6);
        if (collisionCheckParams.myCheckConeBorder) {
          for (let r = 0; r < 2; r++) {
            let currentIndex = r == 0 ? leftIndex : rightIndex;
            currentRadialPosition = checkPositions[currentIndex].vec3_add(heightOffset, currentRadialPosition);
            let previousIndex = Math.max(0, currentIndex - 2);
            previousRadialPosition = checkPositions[previousIndex].vec3_add(heightOffset, previousRadialPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(previousRadialPosition, currentRadialPosition, forward.vec3_negate(forwardNegate), up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
        }
        if (collisionCheckParams.myCheckConeRay && isHorizontalCheckOk) {
          for (let r = 0; r < 2; r++) {
            if (r == 1 && leftAndRightEqual) {
              break;
            }
            let currentIndex = r == 0 ? leftIndex : rightIndex;
            currentRadialPosition = checkPositions[currentIndex].vec3_add(heightOffset, currentRadialPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(basePosition, currentRadialPosition, null, up, false, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, false, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
        }
      } else {
        if (collisionCheckParams.myCheckConeRay) {
          currentRadialPosition = checkPositions[j].vec3_add(heightOffset, currentRadialPosition);
          isHorizontalCheckOk = this._horizontalCheckRaycast(basePosition, currentRadialPosition, null, up, false, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, false, collisionCheckParams, collisionRuntimeParams);
          if (!isHorizontalCheckOk)
            break;
        }
      }
      if (!isHorizontalCheckOk) {
        break;
      }
    }
    if (!isHorizontalCheckOk) {
      collisionRuntimeParams.myIsCollidingHorizontally = true;
      collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
    }
    return isHorizontalCheckOk;
  };
}();
CollisionCheckHorizontalPosition.prototype._horizontalPositionVerticalCheck = function() {
  let basePosition = vec3_create();
  let previousBasePosition = vec3_create();
  let currentRadialPosition = vec3_create();
  let previousRadialPosition = vec3_create();
  let previousCurrentRadialPosition = vec3_create();
  let previousPreviousRadialPosition = vec3_create();
  return function _horizontalPositionVerticalCheck(feetPosition, checkPositions, heightOffset, heightStep, verticalDirection, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
    let isHorizontalCheckOk = true;
    basePosition = feetPosition.vec3_add(heightOffset, basePosition);
    previousBasePosition = basePosition.vec3_sub(heightStep, previousBasePosition);
    for (let j = 0; j <= checkPositions.length; j++) {
      let previousCheckPositionIsEqual = false;
      if (j == checkPositions.length) {
        currentRadialPosition.vec3_copy(basePosition);
        previousRadialPosition.vec3_copy(previousBasePosition);
      } else {
        currentRadialPosition = checkPositions[j].vec3_add(heightOffset, currentRadialPosition);
        previousRadialPosition = currentRadialPosition.vec3_sub(heightStep, previousRadialPosition);
        if (j > 0) {
          previousCheckPositionIsEqual = checkPositions[j].vec_equals(checkPositions[j - 1], 1e-6);
        }
      }
      if (collisionCheckParams.myCheckVerticalStraight && !previousCheckPositionIsEqual) {
        isHorizontalCheckOk = this._horizontalCheckRaycast(previousRadialPosition, currentRadialPosition, null, up, collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams, true, true);
        if (!isHorizontalCheckOk) {
          if (!collisionRuntimeParams.myIsCollidingHorizontally) {
            collisionRuntimeParams.myIsCollidingHorizontally = true;
            collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
          } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
            collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
          }
          if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
            break;
          }
        }
      }
      if (j < checkPositions.length) {
        if ((collisionCheckParams.myCheckVerticalDiagonalRayOutward || collisionCheckParams.myCheckVerticalDiagonalBorderRayOutward && (j == checkPositions.length - 2 || j == checkPositions.length - 1)) && !previousCheckPositionIsEqual) {
          isHorizontalCheckOk = this._horizontalCheckRaycast(previousBasePosition, currentRadialPosition, null, up, collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams, true, true);
          if (!isHorizontalCheckOk) {
            if (!collisionRuntimeParams.myIsCollidingHorizontally) {
              collisionRuntimeParams.myIsCollidingHorizontally = true;
              collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
            } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
              collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
            }
            if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
              break;
            }
          }
        }
        if ((collisionCheckParams.myCheckVerticalDiagonalRayInward || collisionCheckParams.myCheckVerticalDiagonalBorderRayInward && (j == checkPositions.length - 2 || j == checkPositions.length - 1)) && !previousCheckPositionIsEqual) {
          isHorizontalCheckOk = this._horizontalCheckRaycast(previousRadialPosition, basePosition, null, up, collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams, true, true);
          if (!isHorizontalCheckOk) {
            if (!collisionRuntimeParams.myIsCollidingHorizontally) {
              collisionRuntimeParams.myIsCollidingHorizontally = true;
              collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
            } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
              collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
            }
            if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
              break;
            }
          }
        }
        if (j > 0) {
          if (collisionCheckParams.myCheckVerticalDiagonalBorderOutward || collisionCheckParams.myCheckVerticalDiagonalBorderInward) {
            let previousIndex = Math.max(0, j - 2);
            previousCurrentRadialPosition = checkPositions[previousIndex].vec3_add(heightOffset, previousCurrentRadialPosition);
            previousPreviousRadialPosition = previousCurrentRadialPosition.vec3_sub(heightStep, previousPreviousRadialPosition);
            if (collisionCheckParams.myCheckVerticalDiagonalBorderOutward) {
              isHorizontalCheckOk = this._horizontalCheckRaycast(previousPreviousRadialPosition, currentRadialPosition, null, up, collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams, true, true);
              if (!isHorizontalCheckOk) {
                if (!collisionRuntimeParams.myIsCollidingHorizontally) {
                  collisionRuntimeParams.myIsCollidingHorizontally = true;
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                }
                if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
                  break;
                }
              }
            }
            if (collisionCheckParams.myCheckVerticalDiagonalBorderInward) {
              isHorizontalCheckOk = this._horizontalCheckRaycast(previousRadialPosition, previousCurrentRadialPosition, null, up, collisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams, true, true);
              if (!isHorizontalCheckOk) {
                if (!collisionRuntimeParams.myIsCollidingHorizontally) {
                  collisionRuntimeParams.myIsCollidingHorizontally = true;
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                } else if (this._myRaycastResult.myHits[0].myPosition.vec3_isFartherAlongAxis(collisionRuntimeParams.myHorizontalCollisionHit.myPosition, verticalDirection)) {
                  collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
                }
                if (!collisionCheckParams.myCheckVerticalSearchFartherVerticalHit) {
                  break;
                }
              }
            }
          }
        }
      }
    }
    return !collisionRuntimeParams.myIsCollidingHorizontally;
  };
}();

// dist/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_horizontal_movement.js
var CollisionCheckHorizontalMovement = class extends CollisionCheckHorizontalPosition {
  _horizontalMovementCheck(movement, originalFeetPosition, originalHeight, feetPosition, height, up, collisionCheckParams, collisionRuntimeParams) {
  }
  _horizontalMovementVerticalCheck(movement, feetPosition, checkPositions, heightOffset, heightStep, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
  }
  _horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, heightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
  }
};
CollisionCheckHorizontalMovement.prototype._horizontalMovementCheck = function() {
  let checkPositions = [];
  let cachedCheckPositions = [];
  let currentCachedCheckPositionIndex = 0;
  let _localGetCachedCheckPosition = function() {
    let item = null;
    while (cachedCheckPositions.length <= currentCachedCheckPositionIndex) {
      cachedCheckPositions.push(vec3_create());
    }
    item = cachedCheckPositions[currentCachedCheckPositionIndex];
    currentCachedCheckPositionIndex++;
    return item;
  };
  let _localGroundObjectsToIgnore = [];
  let _localCeilingObjectsToIgnore = [];
  let _localGroundCeilingObjectsToIgnore = [];
  let objectsEqualCallback = (first2, second) => first2 == second;
  let movementDirection = vec3_create();
  let heightOffset = vec3_create();
  let heightStep = vec3_create();
  let currentHeightOffset = vec3_create();
  let leftRadialDirection = vec3_create();
  let rightRadialDirection = vec3_create();
  return function _horizontalMovementCheck(movement, originalFeetPosition, originalHeight, feetPosition, height, up, collisionCheckParams, collisionRuntimeParams) {
    this._myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugHorizontalMovementEnabled;
    let halfConeAngle = Math.min(collisionCheckParams.myHalfConeAngle, 90);
    movementDirection = movement.vec3_normalize(movementDirection);
    checkPositions.length = 0;
    currentCachedCheckPositionIndex = 0;
    let steplength = collisionCheckParams.myRadius / collisionCheckParams.myHorizontalMovementRadialStepAmount;
    {
      let tempCheckPosition = _localGetCachedCheckPosition();
      tempCheckPosition.vec3_copy(feetPosition);
      checkPositions.push(tempCheckPosition);
    }
    {
      leftRadialDirection = movementDirection.vec3_rotateAxis(halfConeAngle, up, leftRadialDirection);
      rightRadialDirection = movementDirection.vec3_rotateAxis(-halfConeAngle, up, rightRadialDirection);
      for (let i = 1; i <= collisionCheckParams.myHorizontalMovementRadialStepAmount; i++) {
        {
          let currentStep = i * steplength;
          let tempCheckPosition = _localGetCachedCheckPosition();
          let currentRadialPosition = leftRadialDirection.vec3_scale(currentStep, tempCheckPosition);
          let currentCheckPosition = currentRadialPosition.vec3_add(feetPosition, currentRadialPosition);
          checkPositions.push(currentCheckPosition);
        }
        {
          let currentStep = i * steplength;
          let tempCheckPosition = _localGetCachedCheckPosition();
          let currentRadialPosition = rightRadialDirection.vec3_scale(currentStep, tempCheckPosition);
          let currentCheckPosition = currentRadialPosition.vec3_add(feetPosition, currentRadialPosition);
          checkPositions.push(currentCheckPosition);
        }
      }
    }
    let groundObjectsToIgnore = null;
    let ceilingObjectsToIgnore = null;
    let groundCeilingObjectsToIgnore = null;
    if (collisionCheckParams.myGroundAngleToIgnore > 0) {
      groundObjectsToIgnore = _localGroundObjectsToIgnore;
      groundObjectsToIgnore.length = 0;
      groundCeilingObjectsToIgnore = _localGroundCeilingObjectsToIgnore;
      groundCeilingObjectsToIgnore.length = 0;
      let ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, null, groundObjectsToIgnore, true, true, up, collisionCheckParams);
      let ignoreCeilingAngleCallback = null;
      if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
        ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, null, groundCeilingObjectsToIgnore, false, true, up, collisionCheckParams);
      }
      heightOffset.vec3_zero();
      this._horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, heightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
    }
    if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
      if (!collisionRuntimeParams.myIsCollidingHorizontally && collisionCheckParams.myCheckHeight) {
        ceilingObjectsToIgnore = _localCeilingObjectsToIgnore;
        ceilingObjectsToIgnore.length = 0;
        let ignoreGroundAngleCallback = null;
        if (collisionCheckParams.myGroundAngleToIgnore > 0) {
          ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, groundObjectsToIgnore, null, true, true, up, collisionCheckParams);
        }
        let ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, null, ceilingObjectsToIgnore, false, true, up, collisionCheckParams);
        heightOffset = up.vec3_scale(height, heightOffset);
        this._horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, heightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
      }
    }
    if (!collisionRuntimeParams.myIsCollidingHorizontally) {
      let groundCeilingCheckIsFine = true;
      if (groundCeilingObjectsToIgnore != null) {
        for (let object of groundCeilingObjectsToIgnore) {
          if (!ceilingObjectsToIgnore.pp_hasEqual(object, objectsEqualCallback)) {
            groundCeilingCheckIsFine = false;
            break;
          }
        }
      }
      let ignoreGroundAngleCallback = null;
      let ignoreCeilingAngleCallback = null;
      if (collisionCheckParams.myGroundAngleToIgnore > 0) {
        ignoreGroundAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, groundObjectsToIgnore, null, true, true, up, collisionCheckParams);
      }
      if (collisionCheckParams.myCeilingAngleToIgnore > 0) {
        ignoreCeilingAngleCallback = this._ignoreSurfaceAngle.bind(this, originalFeetPosition, originalHeight, movement, ceilingObjectsToIgnore, null, false, true, up, collisionCheckParams);
      }
      let heightStepAmount = 0;
      if (collisionCheckParams.myCheckHeight && collisionCheckParams.myHeightCheckStepAmountMovement > 0 && height > 1e-6) {
        heightStepAmount = collisionCheckParams.myHeightCheckStepAmountMovement;
        heightStep = up.vec3_scale(height / heightStepAmount, heightStep);
      }
      for (let i = 0; i <= heightStepAmount; i++) {
        currentHeightOffset = heightStep.vec3_scale(i, currentHeightOffset);
        if (collisionCheckParams.myCheckHeightTopMovement || i == 0) {
          if (i != 0 && i != heightStepAmount || i == 0 && !groundCeilingCheckIsFine || i == 0 && collisionCheckParams.myGroundAngleToIgnore == 0 || i == heightStepAmount && collisionCheckParams.myCeilingAngleToIgnore == 0) {
            this._horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, currentHeightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
            if (collisionRuntimeParams.myIsCollidingHorizontally) {
              break;
            }
          }
        }
        if (i > 0) {
          if (collisionCheckParams.myCheckHeightVerticalMovement) {
            this._horizontalMovementVerticalCheck(movement, feetPosition, checkPositions, currentHeightOffset, heightStep, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams);
          }
          if (collisionRuntimeParams.myIsCollidingHorizontally) {
            break;
          }
        }
      }
    }
    return !collisionRuntimeParams.myIsCollidingHorizontally;
  };
}();
CollisionCheckHorizontalMovement.prototype._horizontalMovementVerticalCheck = function() {
  let movementStep = vec3_create();
  let movementDirection = vec3_create();
  let firstPosition = vec3_create();
  let secondPosition = vec3_create();
  let firstMovementPosition = vec3_create();
  let secondMovementPosition = vec3_create();
  let firstHeightPosition = vec3_create();
  let secondHeightPosition = vec3_create();
  let firstHeightMovementPosition = vec3_create();
  let secondHeightMovementPosition = vec3_create();
  return function _horizontalMovementVerticalCheck(movement, feetPosition, checkPositions, heightOffset, heightStep, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
    let isHorizontalCheckOk = true;
    let movementStepAmount = 1;
    movementStep.vec3_copy(movement);
    if (collisionCheckParams.myHorizontalMovementStepEnabled) {
      movementStepAmount = Math.max(1, Math.ceil(movement.vec3_length() / collisionCheckParams.myHorizontalMovementStepMaxLength));
      movement.vec3_scale(1 / movementStepAmount, movementStep);
    }
    movementDirection = movement.vec3_normalize(movementDirection);
    for (let m = 0; m < movementStepAmount; m++) {
      for (let j = 0; j < checkPositions.length; j++) {
        firstPosition = checkPositions[j].vec3_add(movementStep.vec3_scale(m, firstPosition), firstPosition).vec3_add(heightOffset, firstPosition);
        if (j > 0) {
          let secondIndex = Math.max(0, j - 2);
          secondPosition = checkPositions[secondIndex].vec3_add(movementStep.vec3_scale(m, secondPosition), secondPosition).vec3_add(heightOffset, secondPosition);
          if (collisionCheckParams.myHorizontalMovementCheckVerticalDiagonalUpwardOutward) {
            firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
            secondHeightPosition = secondPosition.vec3_sub(heightStep, secondHeightPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(secondHeightPosition, firstMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckVerticalDiagonalUpwardInward) {
            secondMovementPosition = secondPosition.vec3_add(movementStep, secondMovementPosition);
            firstHeightPosition = firstPosition.vec3_sub(heightStep, firstHeightPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(firstHeightPosition, secondMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckVerticalDiagonalDownwardOutward) {
            firstHeightMovementPosition = firstPosition.vec3_add(movementStep, firstHeightMovementPosition);
            firstHeightMovementPosition = firstHeightMovementPosition.vec3_sub(heightStep, firstHeightMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(secondPosition, firstHeightMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckVerticalDiagonalDownwardInward) {
            secondHeightMovementPosition = secondPosition.vec3_add(movementStep, secondHeightMovementPosition);
            secondHeightMovementPosition = secondHeightMovementPosition.vec3_sub(heightStep, secondHeightMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(firstPosition, secondHeightMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
          if (m == 0) {
            if (collisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward) {
              secondHeightPosition = secondPosition.vec3_sub(heightStep, secondHeightPosition);
              isHorizontalCheckOk = this._horizontalCheckRaycast(secondHeightPosition, firstPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
              if (!isHorizontalCheckOk)
                break;
            }
            if (collisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward) {
              let firstHeightPosition2 = firstPosition.vec3_sub(heightStep);
              isHorizontalCheckOk = this._horizontalCheckRaycast(firstHeightPosition2, secondPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
              if (!isHorizontalCheckOk)
                break;
            }
          }
          if (collisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward) {
            firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
            secondHeightMovementPosition = secondPosition.vec3_sub(heightStep, secondHeightMovementPosition).vec3_add(movementStep, secondHeightMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(secondHeightMovementPosition, firstMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward) {
            secondMovementPosition = secondPosition.vec3_add(movementStep, secondMovementPosition);
            firstHeightMovementPosition = firstPosition.vec3_sub(heightStep, firstHeightMovementPosition).vec3_add(movementStep, firstHeightMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(firstHeightMovementPosition, secondMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
        }
        if (collisionCheckParams.myHorizontalMovementCheckVerticalStraight || collisionCheckParams.myHorizontalMovementHorizontalStraightCentralCheckEnabled && j == 0) {
          if (m == 0) {
            firstHeightPosition = firstPosition.vec3_sub(heightStep, firstHeightPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(firstHeightPosition, firstPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
          {
            firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
            firstHeightMovementPosition = firstMovementPosition.vec3_sub(heightStep, firstHeightMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(firstHeightMovementPosition, firstMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
        }
        if (collisionCheckParams.myHorizontalMovementCheckVerticalStraightDiagonalUpward || collisionCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled && j == 0) {
          firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
          firstHeightPosition = firstPosition.vec3_sub(heightStep, firstHeightPosition);
          isHorizontalCheckOk = this._horizontalCheckRaycast(firstHeightPosition, firstMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
          if (!isHorizontalCheckOk)
            break;
        }
        if (collisionCheckParams.myHorizontalMovementCheckVerticalStraightDiagonalDownward || collisionCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled && j == 0) {
          firstHeightMovementPosition = firstPosition.vec3_sub(heightStep, firstHeightMovementPosition).vec3_add(movementStep, firstHeightMovementPosition);
          isHorizontalCheckOk = this._horizontalCheckRaycast(firstPosition, firstHeightMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
          if (!isHorizontalCheckOk)
            break;
        }
        if (!isHorizontalCheckOk) {
          collisionRuntimeParams.myIsCollidingHorizontally = true;
          collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
          break;
        }
      }
    }
    return isHorizontalCheckOk;
  };
}();
CollisionCheckHorizontalMovement.prototype._horizontalMovementHorizontalCheck = function() {
  let movementStep = vec3_create();
  let movementDirection = vec3_create();
  let firstPosition = vec3_create();
  let secondPosition = vec3_create();
  let firstMovementPosition = vec3_create();
  let secondMovementPosition = vec3_create();
  return function _horizontalMovementHorizontalCheck(movement, feetPosition, checkPositions, heightOffset, up, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, collisionCheckParams, collisionRuntimeParams) {
    let isHorizontalCheckOk = true;
    let movementStepAmount = 1;
    movementStep.vec3_copy(movement);
    if (collisionCheckParams.myHorizontalMovementStepEnabled) {
      movementStepAmount = Math.max(1, Math.ceil(movement.vec3_length() / collisionCheckParams.myHorizontalMovementStepMaxLength));
      movement.vec3_scale(1 / movementStepAmount, movementStep);
    }
    movementDirection = movement.vec3_normalize(movementDirection);
    for (let m = 0; m < movementStepAmount; m++) {
      for (let j = 0; j < checkPositions.length; j++) {
        firstPosition = checkPositions[j].vec3_add(movementStep.vec3_scale(m, firstPosition), firstPosition).vec3_add(heightOffset, firstPosition);
        if (j > 0) {
          let secondIndex = Math.max(0, j - 2);
          secondPosition = checkPositions[secondIndex].vec3_add(movementStep.vec3_scale(m, secondPosition), secondPosition).vec3_add(heightOffset, secondPosition);
          if (collisionCheckParams.myHorizontalMovementCheckDiagonalOutward) {
            firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(secondPosition, firstMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckDiagonalInward) {
            secondMovementPosition = secondPosition.vec3_add(movementStep, secondMovementPosition);
            isHorizontalCheckOk = this._horizontalCheckRaycast(firstPosition, secondMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
            if (!isHorizontalCheckOk)
              break;
          }
          if (collisionCheckParams.myHorizontalMovementCheckHorizontalBorder) {
            if (m == 0) {
              isHorizontalCheckOk = this._horizontalCheckRaycast(secondPosition, firstPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
              if (!isHorizontalCheckOk)
                break;
            }
            {
              firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
              secondMovementPosition = secondPosition.vec3_add(movementStep, secondMovementPosition);
              isHorizontalCheckOk = this._horizontalCheckRaycast(secondMovementPosition, firstMovementPosition, movementDirection, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
              if (!isHorizontalCheckOk)
                break;
            }
          }
        }
        if (collisionCheckParams.myHorizontalMovementCheckStraight || collisionCheckParams.myHorizontalMovementVerticalStraightCentralCheckEnabled && j == 0) {
          firstMovementPosition = firstPosition.vec3_add(movementStep, firstMovementPosition);
          isHorizontalCheckOk = this._horizontalCheckRaycast(firstPosition, firstMovementPosition, null, up, true, ignoreGroundAngleCallback, ignoreCeilingAngleCallback, feetPosition, true, collisionCheckParams, collisionRuntimeParams);
          if (!isHorizontalCheckOk)
            break;
        }
      }
      if (!isHorizontalCheckOk) {
        collisionRuntimeParams.myIsCollidingHorizontally = true;
        collisionRuntimeParams.myHorizontalCollisionHit.copy(this._myRaycastResult.myHits[0]);
        break;
      }
    }
    return isHorizontalCheckOk;
  };
}();

// dist/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_horizontal_sliding.js
var CollisionCheckHorizontalSliding = class extends CollisionCheckHorizontalMovement {
  _horizontalSlide(movement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outSlideMovement) {
  }
  _horizontalSlideCheckOpposite(movement, feetPosition, height, up, forward, previousHorizontalMovement, previousIsSliding, allowSurfaceSteepFix, collisionCheckParams, preSlideCollisionRuntimeParams, postSlideCollisionRuntimeParams, previousCollisionRuntimeParams, outSlideMovement) {
  }
  _horizontalSlideFlickerCheck(movement, slideMovement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
  }
  _internalHorizontalSlide(movement, feetPosition, height, up, forward, previousHorizontalMovement, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, checkOppositeDirection, outSlideMovement) {
  }
  _horizontalCheckBetterSlideNormal(movement, originalFeetPosition, originalHeight, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
  }
  _isSlidingNormalValid(movement, up, collisionRuntimeParams) {
  }
};
CollisionCheckHorizontalSliding.prototype._horizontalSlide = function() {
  let previousHorizontalMovement = vec3_create();
  return function _horizontalSlide(movement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, outSlideMovement) {
    if (movement.vec3_isZero(1e-5)) {
      return outSlideMovement.vec3_zero();
    }
    this._mySlidingCollisionRuntimeParams.copy(collisionRuntimeParams);
    previousHorizontalMovement.vec3_copy(collisionRuntimeParams.mySlidingPreviousHorizontalMovement);
    outSlideMovement = this._internalHorizontalSlide(movement, feetPosition, height, up, forward, previousHorizontalMovement, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingCollisionRuntimeParams, previousCollisionRuntimeParams, false, outSlideMovement);
    if (collisionCheckParams.mySlidingCheckBothDirections) {
      this._horizontalSlideCheckOpposite(movement, feetPosition, height, up, forward, previousHorizontalMovement, this._myPrevCollisionRuntimeParams.myIsSliding, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, this._mySlidingCollisionRuntimeParams, previousCollisionRuntimeParams, outSlideMovement);
    }
    if (this._mySlidingCollisionRuntimeParams.myIsSliding && collisionCheckParams.mySlidingFlickeringPreventionType > 0) {
      let isFlickering = this._horizontalSlideFlickerCheck(movement, outSlideMovement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingCollisionRuntimeParams, previousCollisionRuntimeParams);
      this._mySlidingCollisionRuntimeParams.myIsSliding = !isFlickering;
    }
    if (this._mySlidingCollisionRuntimeParams.myIsSliding) {
      let backupFlickerPrevented = collisionRuntimeParams.myIsSlidingFlickerPrevented;
      collisionRuntimeParams.copy(this._mySlidingCollisionRuntimeParams);
      collisionRuntimeParams.myIsSlidingFlickerPrevented = backupFlickerPrevented || this._mySlidingCollisionRuntimeParams.myIsSlidingFlickerPrevented;
    } else {
      collisionRuntimeParams.myIsSlidingFlickerPrevented = collisionRuntimeParams.myIsSlidingFlickerPrevented || this._mySlidingCollisionRuntimeParams.myIsSlidingFlickerPrevented;
      outSlideMovement.vec3_zero();
    }
    return outSlideMovement;
  };
}();
CollisionCheckHorizontalSliding.prototype._horizontalSlideCheckOpposite = function() {
  let horizontalCollisionNormal = vec3_create();
  let oppositeSlideMovement = vec3_create();
  return function _horizontalSlideCheckOpposite(movement, feetPosition, height, up, forward, previousHorizontalMovement, previousIsSliding, allowSurfaceSteepFix, collisionCheckParams, preSlideCollisionRuntimeParams, postSlideCollisionRuntimeParams, previousCollisionRuntimeParams, outSlideMovement) {
    horizontalCollisionNormal = preSlideCollisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_removeComponentAlongAxis(up, horizontalCollisionNormal);
    horizontalCollisionNormal.vec3_normalize(horizontalCollisionNormal);
    let angleNormalWithMovementThreshold = 20;
    if (horizontalCollisionNormal.vec3_angle(movement) > 180 - angleNormalWithMovementThreshold) {
      return;
    } else if (previousIsSliding && postSlideCollisionRuntimeParams.myIsSliding && outSlideMovement.vec3_isConcordant(previousHorizontalMovement)) {
      return;
    } else {
    }
    this._mySlidingOppositeDirectionCollisionRuntimeParams.copy(preSlideCollisionRuntimeParams);
    oppositeSlideMovement = this._internalHorizontalSlide(movement, feetPosition, height, up, forward, previousHorizontalMovement, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingOppositeDirectionCollisionRuntimeParams, previousCollisionRuntimeParams, true, oppositeSlideMovement);
    if (this._mySlidingOppositeDirectionCollisionRuntimeParams.myIsSliding) {
      let isOppositeBetter = false;
      if (postSlideCollisionRuntimeParams.myIsSliding) {
        if (movement.vec3_angle(oppositeSlideMovement) < movement.vec3_angle(outSlideMovement) - 1e-4) {
          isOppositeBetter = true;
        } else {
          if (Math.abs(movement.vec3_angle(oppositeSlideMovement) - movement.vec3_angle(outSlideMovement)) <= 1e-4) {
            if (previousHorizontalMovement.vec3_angle(oppositeSlideMovement) < previousHorizontalMovement.vec3_angle(outSlideMovement) - 1e-4) {
              let angleNormalWithMovementThreshold2 = 5;
              if (horizontalCollisionNormal.vec3_angle(movement) < 90 + angleNormalWithMovementThreshold2) {
                isOppositeBetter = true;
              }
            }
          }
        }
      } else {
        let angleEpsilon = 1e-3;
        if (movement.vec3_isConcordant(oppositeSlideMovement) && movement.vec3_angle(oppositeSlideMovement) < 90 - angleEpsilon) {
          isOppositeBetter = true;
        } else {
        }
      }
      if (isOppositeBetter) {
        outSlideMovement.vec3_copy(oppositeSlideMovement);
        postSlideCollisionRuntimeParams.copy(this._mySlidingOppositeDirectionCollisionRuntimeParams);
      } else {
      }
    } else {
    }
  };
}();
CollisionCheckHorizontalSliding.prototype._horizontalSlideFlickerCheck = function() {
  let previousHorizontalMovement = vec3_create();
  let newFeetPosition = vec3_create();
  let fixedMovement = vec3_create();
  let flickerFixSlideMovement = vec3_create();
  return function _horizontalSlideFlickerCheck(movement, slideMovement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
    let isFlickering = false;
    previousHorizontalMovement.vec3_copy(collisionRuntimeParams.mySlidingPreviousHorizontalMovement);
    let shouldCheckFlicker = this._myPrevCollisionRuntimeParams.myIsSlidingFlickerPrevented || previousHorizontalMovement.vec3_isZero(1e-5);
    if (!shouldCheckFlicker) {
      if (this._myPrevCollisionRuntimeParams.myIsSliding || !collisionCheckParams.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding) {
        let flickerCollisionAngle = 90;
        let flickerMovementAngle = 85;
        switch (collisionCheckParams.mySlidingFlickeringPreventionType) {
          case 1:
            shouldCheckFlicker = previousHorizontalMovement.vec3_signTo(movement, up, 0) != slideMovement.vec3_signTo(movement, up, 0);
            break;
          case 2:
            shouldCheckFlicker = collisionCheckParams.mySlidingCheckBothDirections && collisionRuntimeParams.myIsSlidingIntoOppositeDirection;
            shouldCheckFlicker = shouldCheckFlicker || Math.abs(collisionRuntimeParams.mySlidingCollisionAngle) > flickerCollisionAngle + 1e-5;
            break;
          case 3:
            shouldCheckFlicker = collisionCheckParams.mySlidingCheckBothDirections && collisionRuntimeParams.myIsSlidingIntoOppositeDirection;
            shouldCheckFlicker = shouldCheckFlicker || Math.abs(collisionRuntimeParams.mySlidingCollisionAngle) > flickerCollisionAngle + 1e-5;
            shouldCheckFlicker = shouldCheckFlicker || Math.abs(Math.abs(collisionRuntimeParams.mySlidingCollisionAngle) - flickerCollisionAngle) < 1e-5 && Math.abs(collisionRuntimeParams.mySlidingMovementAngle) > flickerMovementAngle + 1e-5;
            break;
          case 4:
            shouldCheckFlicker = true;
            break;
        }
      }
    }
    if (shouldCheckFlicker || this._myPrevCollisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter > 0) {
      if (shouldCheckFlicker) {
        collisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter = collisionCheckParams.mySlidingFlickerPreventionCheckAnywayCounter;
      } else {
        collisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter = Math.max(0, this._myPrevCollisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter - 1);
      }
      if ((collisionCheckParams.mySlidingFlickeringPreventionType != 1 || collisionRuntimeParams.myIsSlidingFlickerPrevented || this._myPrevCollisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter > 0) && (this._myPrevCollisionRuntimeParams.myIsSliding && previousHorizontalMovement.vec3_signTo(movement, up, 0) != slideMovement.vec3_signTo(movement, up, 0))) {
        isFlickering = true;
        collisionRuntimeParams.myIsSlidingFlickerPrevented = true;
      } else {
        this._mySlidingFlickeringFixCollisionRuntimeParams.reset();
        this._mySlidingFlickeringFixCollisionRuntimeParams.mySliding90DegreesSign = collisionRuntimeParams.mySliding90DegreesSign;
        this._mySlidingFlickeringFixCollisionRuntimeParams.mySlidingRecompute90DegreesSign = false;
        newFeetPosition = feetPosition.vec3_add(slideMovement, newFeetPosition);
        let backupDebugEnabled = collisionCheckParams.myDebugEnabled;
        collisionCheckParams.myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugSlidingEnabled;
        fixedMovement.vec3_zero();
        fixedMovement = this._horizontalCheck(movement, newFeetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingFlickeringFixCollisionRuntimeParams, previousCollisionRuntimeParams, false, fixedMovement);
        collisionCheckParams.myDebugEnabled = backupDebugEnabled;
        if (fixedMovement.vec3_isZero(1e-5)) {
          this._mySlidingFlickeringFixSlidingCollisionRuntimeParams.copy(this._mySlidingFlickeringFixCollisionRuntimeParams);
          flickerFixSlideMovement = this._internalHorizontalSlide(movement, newFeetPosition, height, up, forward, slideMovement, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingFlickeringFixSlidingCollisionRuntimeParams, previousCollisionRuntimeParams, false, flickerFixSlideMovement);
          if (collisionCheckParams.mySlidingCheckBothDirections) {
            this._horizontalSlideCheckOpposite(movement, newFeetPosition, height, up, forward, slideMovement, true, allowSurfaceSteepFix, collisionCheckParams, this._mySlidingFlickeringFixCollisionRuntimeParams, this._mySlidingFlickeringFixSlidingCollisionRuntimeParams, previousCollisionRuntimeParams, flickerFixSlideMovement);
          }
          if (this._mySlidingFlickeringFixSlidingCollisionRuntimeParams.myIsSliding) {
            if (slideMovement.vec3_signTo(movement, up, 0) != flickerFixSlideMovement.vec3_signTo(movement, up, 0)) {
              isFlickering = true;
              collisionRuntimeParams.myIsSlidingFlickerPrevented = true;
            }
          }
        }
      }
    } else {
    }
    if (isFlickering) {
    } else {
    }
    return isFlickering;
  };
}();
CollisionCheckHorizontalSliding.prototype._internalHorizontalSlide = function() {
  let invertedNormal = vec3_create();
  let slidingMovement = vec3_create();
  let movement90 = vec3_create();
  let currentMovement = vec3_create();
  let slideMovementForward = vec3_create();
  let fixedMovement = vec3_create();
  return function _internalHorizontalSlide(movement, feetPosition, height, up, forward, previousHorizontalMovement, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, checkOppositeDirection, outSlideMovement) {
    if (movement.vec3_isZero(1e-5)) {
      return outSlideMovement.vec3_zero();
    }
    invertedNormal = collisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_negate(invertedNormal);
    invertedNormal.vec3_removeComponentAlongAxis(up, invertedNormal);
    invertedNormal[0] = Math.abs(invertedNormal[0]) < 0.01 ? 0 : invertedNormal[0];
    invertedNormal[2] = Math.abs(invertedNormal[2]) < 0.01 ? 0 : invertedNormal[2];
    invertedNormal.vec3_normalize(invertedNormal);
    collisionRuntimeParams.mySlidingCollisionHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
    collisionRuntimeParams.mySlidingWallNormal.vec3_copy(collisionRuntimeParams.myHorizontalCollisionHit.myNormal);
    outSlideMovement.vec3_zero();
    slidingMovement.vec3_copy(invertedNormal);
    if (checkOppositeDirection) {
      slidingMovement.vec3_copy(movement);
      slidingMovement.vec3_normalize(slidingMovement);
    }
    if (!slidingMovement.vec3_isZero(1e-5)) {
      slidingMovement.vec3_scale(movement.vec3_length(), slidingMovement);
      let slidingSign = invertedNormal.vec3_signTo(movement, up);
      if (collisionCheckParams.mySlidingAdjustSign90Degrees) {
        let angleThreshold = 0.1;
        if (invertedNormal.vec3_angle(movement) < angleThreshold && collisionRuntimeParams.mySliding90DegreesSign != 0) {
          slidingSign = collisionRuntimeParams.mySliding90DegreesSign;
        } else if (collisionRuntimeParams.mySliding90DegreesSign == 0 || collisionRuntimeParams.mySlidingRecompute90DegreesSign) {
          collisionRuntimeParams.mySliding90DegreesSign = slidingSign;
        } else {
        }
        collisionRuntimeParams.mySlidingRecompute90DegreesSign = false;
      }
      if (checkOppositeDirection) {
        slidingSign *= -1;
      }
      let currentAngle = 90 * slidingSign;
      let maxAngle = Math.pp_angleClamp(slidingMovement.vec3_angleSigned(movement.vec3_rotateAxis(90 * slidingSign, up, movement90), up) * slidingSign, true) * slidingSign;
      let minAngle = Math.pp_angleClamp(slidingMovement.vec3_angleSigned(movement, up) * slidingSign, true) * slidingSign;
      if (checkOppositeDirection) {
        maxAngle = currentAngle;
        minAngle = 0;
      } else {
        if (Math.abs(maxAngle) < Math.abs(minAngle)) {
          minAngle = 0;
        }
        if (Math.abs(Math.abs(maxAngle) - Math.abs(minAngle)) < 1e-4) {
          minAngle = maxAngle;
        }
        if (Math.abs(maxAngle) < Math.abs(currentAngle) || Math.abs(Math.abs(maxAngle) - Math.abs(currentAngle)) < 1e-4) {
          currentAngle = maxAngle;
        }
        if (Math.abs(currentAngle) < Math.abs(minAngle) || Math.abs(Math.abs(minAngle) - Math.abs(currentAngle)) < 1e-4) {
          currentAngle = minAngle;
        }
      }
      if (checkOppositeDirection && !previousHorizontalMovement.vec3_isZero(1e-6)) {
        let angleWithPrevious = movement.vec3_angleSigned(previousHorizontalMovement, up);
        if (Math.pp_sign(angleWithPrevious) == Math.pp_sign(maxAngle) && Math.abs(maxAngle) > Math.abs(angleWithPrevious)) {
          currentAngle = angleWithPrevious;
        }
      }
      currentMovement.vec3_zero();
      let backupDebugEnabled = collisionCheckParams.myDebugEnabled;
      collisionCheckParams.myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugSlidingEnabled;
      for (let i = 0; i < collisionCheckParams.mySlidingMaxAttempts; i++) {
        this._myInternalSlidingCollisionRuntimeParams.copy(collisionRuntimeParams);
        currentMovement = slidingMovement.vec3_rotateAxis(currentAngle, up, currentMovement);
        slideMovementForward.vec3_copy(forward);
        if (!collisionCheckParams.myCheckHorizontalFixedForwardEnabled) {
          if (!currentMovement.vec3_isZero()) {
            slideMovementForward = currentMovement.vec3_normalize(slideMovementForward);
          }
        }
        fixedMovement.vec3_zero();
        fixedMovement = this._horizontalCheck(currentMovement, feetPosition, height, up, slideMovementForward, allowSurfaceSteepFix, collisionCheckParams, this._myInternalSlidingCollisionRuntimeParams, previousCollisionRuntimeParams, true, fixedMovement);
        if (!fixedMovement.vec3_isZero(1e-5)) {
          outSlideMovement.vec3_copy(currentMovement);
          collisionRuntimeParams.copy(this._myInternalSlidingCollisionRuntimeParams);
          collisionRuntimeParams.myIsSliding = true;
          collisionRuntimeParams.myIsSlidingIntoOppositeDirection = checkOppositeDirection;
          collisionRuntimeParams.mySlidingMovementAngle = movement.vec3_angleSigned(currentMovement, up);
          collisionRuntimeParams.mySlidingCollisionAngle = invertedNormal.vec3_angleSigned(currentMovement, up);
          maxAngle = currentAngle;
          currentAngle = (maxAngle + minAngle) / 2;
        } else {
          if (currentAngle != maxAngle) {
            minAngle = currentAngle;
          }
          if (i == 0 && currentAngle != maxAngle) {
            currentAngle = maxAngle;
          } else {
            currentAngle = (minAngle + maxAngle) / 2;
          }
        }
        if (Math.abs(Math.abs(maxAngle) - Math.abs(minAngle)) < 1e-4) {
          break;
        }
      }
      collisionCheckParams.myDebugEnabled = backupDebugEnabled;
    }
    if (!collisionRuntimeParams.myIsSliding) {
      collisionRuntimeParams.mySlidingCollisionHit.reset();
    } else {
    }
    return outSlideMovement;
  };
}();
CollisionCheckHorizontalSliding.prototype._horizontalCheckBetterSlideNormal = function() {
  let movementDirection = vec3_create();
  let hitDirection = vec3_create();
  let projectAlongAxis = vec3_create();
  let fixedMovement = vec3_create();
  let newFixedFeetPosition = vec3_create();
  let newFeetPosition = vec3_create();
  return function _horizontalCheckBetterSlideNormal(movement, originalFeetPosition, originalHeight, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
    movementDirection = movement.vec3_normalize(movementDirection);
    let hitPosition = collisionRuntimeParams.myHorizontalCollisionHit.myPosition;
    let halfConeAngle = Math.min(collisionCheckParams.myHalfConeAngle, 90);
    hitDirection = hitPosition.vec3_sub(feetPosition, hitDirection);
    if (hitDirection.vec3_isToTheRight(movementDirection, up)) {
      projectAlongAxis = movementDirection.vec3_rotateAxis(-halfConeAngle, up, projectAlongAxis);
    } else {
      projectAlongAxis = movementDirection.vec3_rotateAxis(halfConeAngle, up, projectAlongAxis);
    }
    fixedMovement = hitDirection.vec3_projectOnAxisAlongAxis(movementDirection, projectAlongAxis, fixedMovement);
    if (fixedMovement.vec3_isConcordant(movementDirection)) {
      fixedMovement = movementDirection.vec3_scale(Math.min(fixedMovement.vec3_length(), movement.vec3_length()), fixedMovement);
    } else {
      fixedMovement.vec3_zero();
    }
    if (collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugHorizontalMovementEnabled && Globals.isDebugEnabled(this._myEngine)) {
      Globals.getDebugVisualManager(this._myEngine).drawArrow(0, feetPosition, movementDirection, fixedMovement.vec3_length(), vec4_create(1, 0, 1, 1));
    }
    this._myCheckBetterSlidingNormalCollisionRuntimeParams.copy(collisionRuntimeParams);
    this._myCheckBetterSlidingNormalCollisionRuntimeParams.myIsCollidingHorizontally = false;
    this._myCheckBetterSlidingNormalCollisionRuntimeParams.myHorizontalCollisionHit.reset();
    newFixedFeetPosition = feetPosition.vec3_add(fixedMovement, newFixedFeetPosition);
    newFeetPosition = feetPosition.vec3_add(fixedMovement, newFeetPosition);
    let backupDebugEnabled = collisionCheckParams.myDebugEnabled;
    collisionCheckParams.myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugSlidingEnabled;
    if (collisionCheckParams.myHorizontalPositionCheckEnabled) {
      this._horizontalPositionCheck(originalFeetPosition, originalHeight, newFixedFeetPosition, height, up, forward, collisionCheckParams, this._myCheckBetterSlidingNormalCollisionRuntimeParams);
    }
    collisionCheckParams.myDebugEnabled = backupDebugEnabled;
    if (this._myCheckBetterSlidingNormalCollisionRuntimeParams.myIsCollidingHorizontally && !this._myCheckBetterSlidingNormalCollisionRuntimeParams.myHorizontalCollisionHit.myInsideCollision) {
      collisionRuntimeParams.copy(this._myCheckBetterSlidingNormalCollisionRuntimeParams);
    }
  };
}();
CollisionCheckHorizontalSliding.prototype._isSlidingNormalValid = function() {
  let flatNormal = vec3_create();
  return function _isSlidingNormalValid(movement, up, collisionRuntimeParams) {
    let isValid = false;
    flatNormal = collisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_removeComponentAlongAxis(up, flatNormal);
    flatNormal.vec3_normalize(flatNormal);
    if (!flatNormal.vec3_isZero(1e-6)) {
      isValid = true;
    }
    return isValid;
  };
}();

// dist/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_horizontal.js
var CollisionCheckHorizontal = class extends CollisionCheckHorizontalSliding {
  _horizontalCheck(movement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, avoidSlidingExtraCheck, outFixedMovement) {
  }
};
CollisionCheckHorizontal.prototype._horizontalCheck = function() {
  let fixedFeetPosition = vec3_create();
  let newFixedFeetPosition = vec3_create();
  let newFeetPosition = vec3_create();
  let horizontalDirection = vec3_create();
  return function _horizontalCheck(movement, feetPosition, height, up, forward, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams, avoidSlidingExtraCheck, outFixedMovement) {
    collisionRuntimeParams.myIsCollidingHorizontally = false;
    collisionRuntimeParams.myHorizontalCollisionHit.reset();
    outFixedMovement.vec3_zero();
    horizontalDirection = movement.vec3_normalize(horizontalDirection);
    let surfaceTooSteepResults = this._surfaceTooSteep(up, horizontalDirection, collisionCheckParams, previousCollisionRuntimeParams);
    if (movement.vec3_isZero(1e-6) || (!surfaceTooSteepResults[0] || allowSurfaceSteepFix && collisionCheckParams.myAllowGroundSteepFix) && (!surfaceTooSteepResults[1] || allowSurfaceSteepFix && collisionCheckParams.myAllowCeilingSteepFix)) {
      fixedFeetPosition = feetPosition.vec3_add(up.vec3_scale(collisionCheckParams.myDistanceFromFeetToIgnore + 1e-4, fixedFeetPosition), fixedFeetPosition);
      let fixedHeight = Math.max(0, height - collisionCheckParams.myDistanceFromFeetToIgnore - collisionCheckParams.myDistanceFromHeadToIgnore - 1e-4 * 2);
      let canMove = true;
      if (collisionCheckParams.myHorizontalMovementCheckEnabled && !movement.vec3_isZero(1e-6)) {
        canMove = this._horizontalMovementCheck(movement, feetPosition, height, fixedFeetPosition, fixedHeight, up, collisionCheckParams, collisionRuntimeParams);
      }
      if (canMove) {
        if (collisionCheckParams.myHorizontalPositionCheckEnabled) {
          newFixedFeetPosition = fixedFeetPosition.vec3_add(movement, newFixedFeetPosition);
          newFeetPosition = feetPosition.vec3_add(movement, newFeetPosition);
          let canStay = this._horizontalPositionCheck(newFeetPosition, height, newFixedFeetPosition, fixedHeight, up, forward, collisionCheckParams, collisionRuntimeParams);
          if (canStay) {
            outFixedMovement.vec3_copy(movement);
          }
          if (outFixedMovement.vec3_isZero(1e-6)) {
            outFixedMovement.vec3_zero();
          }
        } else {
          outFixedMovement.vec3_copy(movement);
        }
      } else if (!avoidSlidingExtraCheck && collisionCheckParams.mySlidingEnabled && collisionCheckParams.mySlidingHorizontalMovementCheckBetterNormal) {
        this._horizontalCheckBetterSlideNormal(movement, feetPosition, height, fixedFeetPosition, fixedHeight, up, forward, collisionCheckParams, collisionRuntimeParams);
      }
    }
    return outFixedMovement;
  };
}();

// dist/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_vertical.js
var CollisionCheckVertical = class extends CollisionCheckHorizontal {
  _verticalCheck(verticalMovement, originalMovementSign, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
  }
  _verticalMovementAdjustment(verticalMovement, isMovementDownward, originalMovementSign, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
  }
  _verticalPositionCheck(feetPosition, checkUpward, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
  }
  _getVerticalCheckPositions(feetPosition, up, forward, collisionCheckParams, collisionRuntimeParams) {
  }
};
CollisionCheckVertical.prototype._verticalCheck = function() {
  let newFeetPosition = vec3_create();
  let additionalFixedMovement = vec3_create();
  let zero4 = vec3_create(0, 0, 0);
  return function _verticalCheck(verticalMovement, originalMovementSign, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
    collisionRuntimeParams.myIsCollidingVertically = false;
    collisionRuntimeParams.myVerticalCollisionHit.reset();
    let movementSign = Math.pp_sign(verticalMovement.vec3_lengthSigned(up), -1);
    let isMovementDownward = movementSign < 0;
    outFixedMovement.vec3_copy(verticalMovement);
    if (collisionCheckParams.myVerticalMovementCheckEnabled) {
      const firstRaycastPerformed = this._verticalMovementAdjustment(verticalMovement, isMovementDownward, originalMovementSign, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, outFixedMovement);
      if (!collisionRuntimeParams.myIsCollidingVertically && collisionCheckParams.myCheckVerticalBothDirection && (outFixedMovement.vec_equals(verticalMovement, 1e-5) || originalMovementSign == 0 || movementSign != originalMovementSign)) {
        newFeetPosition = feetPosition.vec3_add(outFixedMovement, newFeetPosition);
        let isOppositeMovementDownward = !isMovementDownward;
        const secondRaycastPerformed = this._verticalMovementAdjustment(zero4, isOppositeMovementDownward, originalMovementSign, newFeetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, additionalFixedMovement);
        if (!additionalFixedMovement.vec3_isZero() || secondRaycastPerformed && !firstRaycastPerformed) {
          outFixedMovement.vec3_add(additionalFixedMovement, outFixedMovement);
          isMovementDownward = !isMovementDownward;
        }
      }
    }
    if (!collisionRuntimeParams.myIsCollidingVertically && collisionCheckParams.myVerticalPositionCheckEnabled) {
      newFeetPosition = feetPosition.vec3_add(outFixedMovement, newFeetPosition);
      let canStay = this._verticalPositionCheck(newFeetPosition, isMovementDownward, height, up, forward, collisionCheckParams, collisionRuntimeParams);
      if (canStay && collisionCheckParams.myCheckVerticalPositionBothDirection) {
        canStay = this._verticalPositionCheck(newFeetPosition, !isMovementDownward, height, up, forward, collisionCheckParams, collisionRuntimeParams);
      }
      if (!canStay) {
        outFixedMovement.vec3_zero();
        collisionRuntimeParams.myHasSnappedOnGround = false;
        collisionRuntimeParams.myHasSnappedOnCeiling = false;
        collisionRuntimeParams.myHasPoppedOutGround = false;
        collisionRuntimeParams.myHasPoppedOutCeiling = false;
        collisionRuntimeParams.myHasReducedVerticalMovement = false;
      }
    } else if (collisionRuntimeParams.myIsCollidingVertically) {
      outFixedMovement.vec3_zero();
    }
    return outFixedMovement;
  };
}();
CollisionCheckVertical.prototype._verticalMovementAdjustment = function() {
  let startOffset = vec3_create();
  let endOffset = vec3_create();
  let tempVector = vec3_create();
  let furtherDirection = vec3_create();
  let furtherDirectionPosition = vec3_create();
  let upNegate = vec3_create();
  let origin = vec3_create();
  let direction = vec3_create();
  let verticalCollisionHit = new RaycastHit();
  return function _verticalMovementAdjustment(verticalMovement, isMovementDownward, originalMovementSign, feetPosition, height, up, forward, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
    this._myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugVerticalMovementEnabled;
    startOffset.vec3_zero();
    endOffset.vec3_zero();
    let raycastPerformed = false;
    let popOutEnabled = false;
    let snapEnabled = false;
    if (isMovementDownward) {
      startOffset.vec3_zero();
      endOffset.vec3_copy(verticalMovement);
      if (collisionCheckParams.myGroundPopOutExtraDistance > 0 && collisionCheckParams.myGroundPopOutEnabled) {
        startOffset.vec3_add(up.vec3_scale(collisionCheckParams.myGroundPopOutExtraDistance + 1e-5, tempVector), startOffset);
        popOutEnabled = true;
      }
    } else {
      startOffset = up.vec3_scale(height, startOffset);
      endOffset = up.vec3_scale(height, endOffset).vec3_add(verticalMovement, endOffset);
      if (collisionCheckParams.myCeilingPopOutExtraDistance > 0 && collisionCheckParams.myCeilingPopOutEnabled) {
        startOffset.vec3_add(up.vec3_scale(-collisionCheckParams.myCeilingPopOutExtraDistance - 1e-5, tempVector), startOffset);
        popOutEnabled = true;
      }
    }
    if (isMovementDownward && originalMovementSign <= 0 && this._myPrevCollisionRuntimeParams.myIsOnGround && collisionCheckParams.mySnapOnGroundEnabled && collisionCheckParams.mySnapOnGroundExtraDistance > 0) {
      endOffset.vec3_add(up.vec3_scale(-collisionCheckParams.mySnapOnGroundExtraDistance - 1e-5, tempVector), endOffset);
      snapEnabled = true;
    } else if (!isMovementDownward && this._myPrevCollisionRuntimeParams.myIsOnCeiling && collisionCheckParams.mySnapOnCeilingEnabled && collisionCheckParams.mySnapOnCeilingExtraDistance > 0 && (originalMovementSign > 0 || originalMovementSign == 0 && (!this._myPrevCollisionRuntimeParams.myIsOnGround || !collisionCheckParams.mySnapOnGroundEnabled))) {
      endOffset.vec3_add(up.vec3_scale(collisionCheckParams.mySnapOnCeilingExtraDistance + 1e-5, tempVector), endOffset);
      snapEnabled = true;
    }
    outFixedMovement.vec3_zero();
    if (startOffset.vec3_distance(endOffset) > 1e-5) {
      let checkPositions = this._getVerticalCheckPositions(feetPosition, up, forward, collisionCheckParams, collisionRuntimeParams);
      furtherDirection.vec3_copy(up);
      if (!isMovementDownward) {
        furtherDirection.vec3_negate(furtherDirection);
      }
      let furtherDirectionPositionSet = false;
      let atLeastOneIsOk = false;
      let insideHitSet = false;
      for (let i = 0; i < checkPositions.length; i++) {
        let currentPosition = checkPositions[i];
        origin = currentPosition.vec3_add(startOffset, origin);
        direction = currentPosition.vec3_add(endOffset, direction).vec3_sub(origin, direction);
        let distance2 = direction.vec3_length();
        direction.vec3_normalize(direction);
        let raycastResult = this._raycastAndDebug(origin, direction, distance2, false, false, collisionCheckParams, collisionRuntimeParams);
        raycastPerformed = true;
        if (raycastResult.isColliding()) {
          let hit = raycastResult.myHits[0];
          if (!hit.myInsideCollision) {
            atLeastOneIsOk = true;
            if (furtherDirectionPositionSet) {
              if (hit.myPosition.vec3_isFartherAlongAxis(furtherDirectionPosition, furtherDirection)) {
                furtherDirectionPosition.vec3_copy(hit.myPosition);
                verticalCollisionHit.copy(hit);
              }
            } else {
              furtherDirectionPositionSet = true;
              furtherDirectionPosition.vec3_copy(hit.myPosition);
              verticalCollisionHit.copy(hit);
            }
          } else if (!insideHitSet) {
            insideHitSet = true;
            verticalCollisionHit.copy(hit);
            if (!collisionCheckParams.myVerticalAllowHitInsideCollisionIfOneOk) {
              break;
            }
          }
        } else {
          atLeastOneIsOk = true;
        }
      }
      if (!atLeastOneIsOk) {
        outFixedMovement.vec3_zero();
        collisionRuntimeParams.myHasSnappedOnGround = false;
        collisionRuntimeParams.myHasSnappedOnCeiling = false;
        collisionRuntimeParams.myHasPoppedOutGround = false;
        collisionRuntimeParams.myHasPoppedOutCeiling = false;
        collisionRuntimeParams.myHasReducedVerticalMovement = false;
        collisionRuntimeParams.myIsCollidingVertically = true;
        collisionRuntimeParams.myVerticalCollisionHit.copy(verticalCollisionHit);
      } else {
        if (furtherDirectionPositionSet) {
          upNegate = up.vec3_negate(upNegate);
          if (isMovementDownward) {
            outFixedMovement = furtherDirectionPosition.vec3_sub(feetPosition, outFixedMovement).vec3_componentAlongAxis(up, outFixedMovement);
            if (!outFixedMovement.vec3_equals(verticalMovement, 1e-5)) {
              const outFixedMovementValueAlongUp = outFixedMovement.vec3_valueAlongAxis(up);
              const verticalMovementValueAlongUp = verticalMovement.vec3_valueAlongAxis(up);
              if (snapEnabled && outFixedMovementValueAlongUp < verticalMovementValueAlongUp) {
                collisionRuntimeParams.myHasSnappedOnGround = true;
              } else if (popOutEnabled && outFixedMovementValueAlongUp > 1e-5) {
                collisionRuntimeParams.myHasPoppedOutGround = true;
              } else if (outFixedMovementValueAlongUp > verticalMovementValueAlongUp) {
                collisionRuntimeParams.myHasReducedVerticalMovement = true;
              }
            }
          } else {
            outFixedMovement = furtherDirectionPosition.vec3_sub(feetPosition.vec3_add(up.vec3_scale(height, outFixedMovement), outFixedMovement), outFixedMovement).vec3_componentAlongAxis(up, outFixedMovement);
            if (!outFixedMovement.vec3_equals(verticalMovement, 1e-5)) {
              const outFixedMovementValueAlongUp = outFixedMovement.vec3_valueAlongAxis(up);
              const verticalMovementValueAlongUp = verticalMovement.vec3_valueAlongAxis(up);
              if (snapEnabled && outFixedMovementValueAlongUp > verticalMovementValueAlongUp) {
                collisionRuntimeParams.myHasSnappedOnCeiling = true;
              } else if (popOutEnabled && outFixedMovementValueAlongUp < -1e-5) {
                collisionRuntimeParams.myHasPoppedOutCeiling = true;
              } else if (outFixedMovementValueAlongUp < verticalMovementValueAlongUp) {
                collisionRuntimeParams.myHasReducedVerticalMovement = true;
              }
            }
          }
          if (!popOutEnabled && !outFixedMovement.vec3_isConcordant(verticalMovement)) {
            outFixedMovement.vec3_zero();
          }
          if (!collisionCheckParams.myVerticalMovementReduceEnabled && collisionRuntimeParams.myHasReducedVerticalMovement) {
            outFixedMovement.vec3_zero();
            collisionRuntimeParams.myHasSnappedOnGround = false;
            collisionRuntimeParams.myHasSnappedOnCeiling = false;
            collisionRuntimeParams.myHasPoppedOutGround = false;
            collisionRuntimeParams.myHasPoppedOutCeiling = false;
            collisionRuntimeParams.myHasReducedVerticalMovement = false;
            collisionRuntimeParams.myIsCollidingVertically = true;
            collisionRuntimeParams.myVerticalCollisionHit.copy(verticalCollisionHit);
          }
        } else {
          outFixedMovement.vec3_copy(verticalMovement);
        }
      }
    } else {
      outFixedMovement.vec3_copy(verticalMovement);
    }
    if (outFixedMovement.vec3_length() < 1e-5) {
      outFixedMovement.vec3_zero();
    }
    return raycastPerformed;
  };
}();
CollisionCheckVertical.prototype._verticalPositionCheck = function() {
  let smallHeightFixOffset = vec3_create();
  let heightOffset = vec3_create();
  let startPosition = vec3_create();
  let endPosition = vec3_create();
  let direction = vec3_create();
  return function _verticalPositionCheck(feetPosition, checkUpward, height, up, forward, collisionCheckParams, collisionRuntimeParams) {
    if (height < 1e-5) {
      return true;
    }
    this._myDebugEnabled = collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugVerticalPositionEnabled;
    let checkPositions = this._getVerticalCheckPositions(feetPosition, up, forward, collisionCheckParams, collisionRuntimeParams);
    let isVerticalPositionOk = true;
    let atLeastOneIsOk = false;
    let adjustmentEpsilon = 1e-4;
    smallHeightFixOffset = up.vec3_scale(adjustmentEpsilon, smallHeightFixOffset);
    heightOffset = up.vec3_scale(height - adjustmentEpsilon, heightOffset);
    if (height - adjustmentEpsilon < adjustmentEpsilon * 10) {
      heightOffset = up.vec3_scale(adjustmentEpsilon * 10, heightOffset);
    }
    let insideHitSet = false;
    for (let i = 0; i < checkPositions.length; i++) {
      let currentPosition = checkPositions[i];
      if (checkUpward) {
        startPosition = currentPosition.vec3_add(smallHeightFixOffset, startPosition);
        endPosition = currentPosition.vec3_add(heightOffset, endPosition);
      } else {
        startPosition = currentPosition.vec3_add(heightOffset, startPosition);
        endPosition = currentPosition.vec3_add(smallHeightFixOffset, endPosition);
      }
      let origin = startPosition;
      direction = endPosition.vec3_sub(origin, direction);
      let distance2 = direction.vec3_length();
      direction.vec3_normalize(direction);
      let raycastResult = this._raycastAndDebug(origin, direction, distance2, false, false, collisionCheckParams, collisionRuntimeParams);
      if (raycastResult.isColliding()) {
        let firstHitOutsideCollision = raycastResult.getFirstHitOutsideCollision();
        if (firstHitOutsideCollision != null) {
          isVerticalPositionOk = false;
          collisionRuntimeParams.myVerticalCollisionHit.copy(firstHitOutsideCollision);
          break;
        } else if (!insideHitSet) {
          insideHitSet = true;
          collisionRuntimeParams.myVerticalCollisionHit.copy(raycastResult.myHits[0]);
          if (!collisionCheckParams.myVerticalAllowHitInsideCollisionIfOneOk) {
            isVerticalPositionOk = false;
            break;
          }
        }
      } else {
        atLeastOneIsOk = true;
      }
    }
    collisionRuntimeParams.myIsCollidingVertically = !isVerticalPositionOk || !atLeastOneIsOk;
    return !collisionRuntimeParams.myIsCollidingVertically;
  };
}();
CollisionCheckVertical.prototype._getVerticalCheckPositions = function() {
  let checkPositions = [];
  let cachedCheckPositions = [];
  let currentCachedCheckPositionIndex = 0;
  let _localGetCachedCheckPosition = function() {
    let item = null;
    while (cachedCheckPositions.length <= currentCachedCheckPositionIndex) {
      cachedCheckPositions.push(vec3_create());
    }
    item = cachedCheckPositions[currentCachedCheckPositionIndex];
    currentCachedCheckPositionIndex++;
    return item;
  };
  let currentDirection = vec3_create();
  return function _getVerticalCheckPositions(feetPosition, up, forward, collisionCheckParams, collisionRuntimeParams) {
    checkPositions.length = 0;
    currentCachedCheckPositionIndex = 0;
    if (collisionCheckParams.myGroundCircumferenceAddCenter) {
      let tempCheckPosition = _localGetCachedCheckPosition();
      tempCheckPosition.vec3_copy(feetPosition);
      checkPositions.push(tempCheckPosition);
    }
    let radiusStep = collisionCheckParams.myFeetRadius / collisionCheckParams.myGroundCircumferenceStepAmount;
    let sliceAngle = 360 / collisionCheckParams.myGroundCircumferenceSliceAmount;
    let currentStepRotation = -collisionCheckParams.myGroundCircumferenceRotationPerStep * (collisionCheckParams.myGroundCircumferenceStepAmount - 1);
    for (let i = 0; i < collisionCheckParams.myGroundCircumferenceStepAmount; i++) {
      let currentRadius = radiusStep * (i + 1);
      currentDirection = forward.vec3_rotateAxis(currentStepRotation, up, currentDirection);
      for (let j = 0; j < collisionCheckParams.myGroundCircumferenceSliceAmount; j++) {
        let tempCheckPosition = _localGetCachedCheckPosition();
        let sliceDirection = currentDirection.vec3_rotateAxis(sliceAngle * j, up, tempCheckPosition);
        checkPositions.push(feetPosition.vec3_add(sliceDirection.vec3_scale(currentRadius, sliceDirection), sliceDirection));
      }
      currentStepRotation += collisionCheckParams.myGroundCircumferenceRotationPerStep;
    }
    return checkPositions;
  };
}();

// dist/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_move.js
var CollisionCheckMove = class extends CollisionCheckVertical {
  move(movement, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    if (this.isCollisionCheckDisabled() && Globals.isDebugEnabled(this._myEngine)) {
      this._setRuntimeParamsForMoveCollisionCheckDisabled(movement, transformQuat2, collisionCheckParams, collisionRuntimeParams);
      return;
    }
    this._move(movement, transformQuat2, collisionCheckParams, collisionRuntimeParams);
  }
  _move(movement, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
  }
  _moveStep(movement, feetPosition, transformUp, transformForward, height, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
  }
  _syncCollisionRuntimeParamsWithPrevious(surfaceAdjustedHorizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
  }
};
CollisionCheckMove.prototype._move = function() {
  let transformUp = vec3_create();
  let transformForward = vec3_create();
  let feetPosition = vec3_create();
  let transformOffsetLocalQuat = quat2_create();
  let offsetTransformQuat = quat2_create();
  let horizontalMovement = vec3_create();
  let verticalMovement = vec3_create();
  let movementStep = vec3_create();
  let currentMovementStep = vec3_create();
  let movementChecked = vec3_create();
  let fixedMovement = vec3_create();
  let newFeetPosition = vec3_create();
  let fixedMovementStep = vec3_create();
  let previousCollisionRuntimeParams = new CollisionRuntimeParams();
  let previousFixedMovement = vec3_create();
  let previousMovementChecked = vec3_create();
  return function _move(movement, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    transformOffsetLocalQuat.quat2_setPositionRotationQuat(collisionCheckParams.myPositionOffsetLocal, collisionCheckParams.myRotationOffsetLocalQuat);
    offsetTransformQuat = transformOffsetLocalQuat.quat2_toWorld(transformQuat2, offsetTransformQuat);
    if (transformQuat2.vec_equals(offsetTransformQuat, 1e-5)) {
      offsetTransformQuat.quat2_copy(transformQuat2);
    }
    transformUp = offsetTransformQuat.quat2_getUp(transformUp);
    transformForward = offsetTransformQuat.quat2_getForward(transformForward);
    feetPosition = offsetTransformQuat.quat2_getPosition(feetPosition);
    let height = collisionCheckParams.myHeight;
    height = height - 1e-5;
    if (height < 1e-5) {
      height = 0;
    }
    horizontalMovement = movement.vec3_removeComponentAlongAxis(transformUp, horizontalMovement);
    if (horizontalMovement.vec3_isZero(1e-6)) {
      horizontalMovement.vec3_zero();
    }
    verticalMovement = movement.vec3_componentAlongAxis(transformUp, verticalMovement);
    if (verticalMovement.vec3_isZero(1e-6)) {
      verticalMovement.vec3_zero();
    }
    let movementStepAmount = 1;
    movementStep.vec3_copy(movement);
    let lastStepLongerThanMaxLength = false;
    if (!movement.vec3_isZero(1e-5) && collisionCheckParams.mySplitMovementEnabled) {
      let minLength = collisionCheckParams.mySplitMovementMinLengthEnabled ? collisionCheckParams.mySplitMovementMinLength : void 0;
      let maxLength = collisionCheckParams.mySplitMovementMaxLengthEnabled && collisionCheckParams.mySplitMovementMaxLength > 0 ? collisionCheckParams.mySplitMovementMaxLength : void 0;
      let maxSteps = collisionCheckParams.mySplitMovementMaxStepsEnabled && collisionCheckParams.mySplitMovementMaxSteps > 0 ? collisionCheckParams.mySplitMovementMaxSteps : 1;
      let movementLength = movement.vec3_length();
      let equalStepLength = movementLength / maxSteps;
      let stepLength = Math.pp_clamp(equalStepLength, minLength, maxLength);
      if (stepLength != equalStepLength) {
        movementStepAmount = Math.ceil(movementLength / stepLength);
        movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(stepLength, movementStep);
        if (collisionCheckParams.mySplitMovementMaxStepsEnabled && (collisionCheckParams.mySplitMovementMaxLengthLastStepCanBeLonger || !collisionCheckParams._myInternalSplitMovementMaxStepsDisabled)) {
          if (movementStepAmount > maxSteps) {
            lastStepLongerThanMaxLength = true;
          }
          movementStepAmount = Math.min(movementStepAmount, maxSteps);
        }
      } else {
        movementStepAmount = maxSteps;
        movementStep = movementStep.vec3_normalize(movementStep).vec3_scale(equalStepLength, movementStep);
      }
      movementStepAmount = Math.max(1, movementStepAmount);
      if (movementStepAmount == 1) {
        movementStep.vec3_copy(movement);
      }
    }
    fixedMovement.vec3_zero();
    movementChecked.vec3_zero();
    previousCollisionRuntimeParams.copy(collisionRuntimeParams);
    previousFixedMovement.vec3_copy(fixedMovement);
    previousMovementChecked.vec3_copy(movementChecked);
    let stepsPerformed = 0;
    let splitMovementStop = false;
    let splitMovementLastStepLongerThanMaxLength = false;
    let splitMovementReduced = false;
    if (collisionCheckParams.mySplitMovementStopAndFailIfMovementWouldBeReduced && (!collisionCheckParams.mySplitMovementMaxLengthLastStepCanBeLonger && lastStepLongerThanMaxLength)) {
      fixedMovement.vec3_zero();
      this._moveStep(fixedMovement, feetPosition, transformUp, transformForward, height, true, collisionCheckParams, collisionRuntimeParams, fixedMovementStep);
      collisionRuntimeParams.myHorizontalMovementCanceled = true;
      collisionRuntimeParams.myVerticalMovementCanceled = true;
      splitMovementStop = true;
    } else {
      for (let i = 0; i < movementStepAmount; i++) {
        if (movementStepAmount == 1 || i != movementStepAmount - 1) {
          currentMovementStep.vec3_copy(movementStep);
        } else {
          if (collisionCheckParams.mySplitMovementMaxLengthLastStepCanBeLonger || !lastStepLongerThanMaxLength) {
            splitMovementLastStepLongerThanMaxLength = lastStepLongerThanMaxLength;
            currentMovementStep = movement.vec3_sub(movementChecked, currentMovementStep);
          } else {
            splitMovementReduced = true;
            currentMovementStep.vec3_copy(movementStep);
          }
        }
        newFeetPosition = feetPosition.vec3_add(fixedMovement, newFeetPosition);
        fixedMovementStep.vec3_zero();
        fixedMovementStep = this._moveStep(currentMovementStep, newFeetPosition, transformUp, transformForward, height, true, collisionCheckParams, collisionRuntimeParams, fixedMovementStep);
        fixedMovement.vec3_add(fixedMovementStep, fixedMovement);
        movementChecked = movementChecked.vec3_add(currentMovementStep, movementChecked);
        stepsPerformed = i + 1;
        if (collisionRuntimeParams.myHorizontalMovementCanceled && collisionRuntimeParams.myVerticalMovementCanceled || collisionRuntimeParams.myHorizontalMovementCanceled && (collisionCheckParams.mySplitMovementStopWhenHorizontalMovementCanceled || verticalMovement.vec3_isZero() && fixedMovementStep.vec3_isZero()) || collisionRuntimeParams.myVerticalMovementCanceled && (collisionCheckParams.mySplitMovementStopWhenVerticalMovementCanceled || horizontalMovement.vec3_isZero() && fixedMovementStep.vec3_isZero()) || collisionRuntimeParams.myHasReducedVerticalMovement && collisionCheckParams.mySplitMovementStopWhenVerticalMovementReduced || collisionCheckParams.mySplitMovementStopCallback != null && collisionCheckParams.mySplitMovementStopCallback(collisionRuntimeParams)) {
          if (collisionCheckParams.mySplitMovementStopReturnPrevious) {
            collisionRuntimeParams.copy(previousCollisionRuntimeParams);
            fixedMovement.vec3_copy(previousFixedMovement);
            movementChecked.vec3_copy(previousMovementChecked);
            stepsPerformed -= 1;
          }
          splitMovementStop = true;
          break;
        }
        previousCollisionRuntimeParams.copy(collisionRuntimeParams);
        previousFixedMovement.vec3_copy(fixedMovement);
        previousMovementChecked.vec3_copy(movementChecked);
      }
    }
    collisionRuntimeParams.mySplitMovementSteps = movementStepAmount;
    collisionRuntimeParams.mySplitMovementStepsPerformed = stepsPerformed;
    collisionRuntimeParams.mySplitMovementStop = splitMovementStop;
    collisionRuntimeParams.mySplitMovementLastStepLongerThanMaxLength = splitMovementLastStepLongerThanMaxLength;
    collisionRuntimeParams.mySplitMovementReduced = splitMovementReduced;
    collisionRuntimeParams.mySplitMovementMovementChecked.vec3_copy(movementChecked);
    collisionRuntimeParams.myOriginalUp = transformQuat2.quat2_getUp(collisionRuntimeParams.myOriginalUp);
    collisionRuntimeParams.myOriginalForward = transformQuat2.quat2_getForward(collisionRuntimeParams.myOriginalForward);
    collisionRuntimeParams.myOriginalPosition = transformQuat2.quat2_getPosition(collisionRuntimeParams.myOriginalPosition);
    collisionRuntimeParams.myOffsetUp.vec3_copy(transformUp);
    collisionRuntimeParams.myOriginalHeight = collisionCheckParams.myHeight;
    collisionRuntimeParams.myOriginalMovement.vec3_copy(movement);
    collisionRuntimeParams.myFixedMovement.vec3_copy(fixedMovement);
    collisionRuntimeParams.myNewPosition = collisionRuntimeParams.myOriginalPosition.vec3_add(collisionRuntimeParams.myFixedMovement, collisionRuntimeParams.myNewPosition);
    collisionRuntimeParams.myIsMove = true;
  };
}();
CollisionCheckMove.prototype._moveStep = function() {
  let horizontalMovement = vec3_create();
  let verticalMovement = vec3_create();
  let fixedHorizontalMovement = vec3_create();
  let fixedVerticalMovement = vec3_create();
  let horizontalDirection = vec3_create();
  let forwardForHorizontal = vec3_create();
  let forwardForVertical = vec3_create();
  let forwardForPerceivedAngle = vec3_create();
  let newFeetPosition = vec3_create();
  let surfaceAdjustedVerticalMovement = vec3_create();
  let surfaceAdjustedHorizontalMovement = vec3_create();
  let fixedMovement = vec3_create();
  let zAxis = vec3_create(0, 0, 1);
  let xAxis = vec3_create(1, 0, 0);
  return function _moveStep(movement, feetPosition, transformUp, transformForward, height, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, outFixedMovement) {
    horizontalMovement = movement.vec3_removeComponentAlongAxis(transformUp, horizontalMovement);
    if (horizontalMovement.vec3_isZero(1e-6)) {
      horizontalMovement.vec3_zero();
    }
    verticalMovement = movement.vec3_componentAlongAxis(transformUp, verticalMovement);
    if (verticalMovement.vec3_isZero(1e-6)) {
      verticalMovement.vec3_zero();
    }
    if (horizontalMovement.vec3_isZero()) {
    }
    this._myPrevCollisionRuntimeParams.copy(collisionRuntimeParams);
    collisionRuntimeParams.reset();
    surfaceAdjustedHorizontalMovement = this._adjustHorizontalMovementWithSurface(horizontalMovement, verticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, surfaceAdjustedHorizontalMovement);
    if (surfaceAdjustedHorizontalMovement.vec3_isZero(1e-5)) {
      surfaceAdjustedHorizontalMovement.vec3_zero();
    }
    this._syncCollisionRuntimeParamsWithPrevious(surfaceAdjustedHorizontalMovement, verticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams);
    {
      forwardForHorizontal.vec3_copy(collisionCheckParams.myCheckHorizontalFixedForward);
      if (!collisionCheckParams.myCheckHorizontalFixedForwardEnabled) {
        if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
          forwardForHorizontal = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForHorizontal);
        } else if (!horizontalMovement.vec3_isZero()) {
          forwardForHorizontal = horizontalMovement.vec3_normalize(forwardForHorizontal);
        } else {
          forwardForHorizontal.vec3_copy(transformForward);
        }
      } else {
        if (collisionCheckParams.myCheckHorizontalFixedForward.vec3_isOnAxis(transformUp)) {
          if (zAxis.vec3_isOnAxis(transformUp)) {
            forwardForHorizontal.vec3_copy(xAxis);
          } else {
            forwardForHorizontal.vec3_copy(zAxis);
          }
        }
        forwardForHorizontal = forwardForHorizontal.vec3_removeComponentAlongAxis(transformUp, forwardForHorizontal);
        forwardForHorizontal = forwardForHorizontal.vec3_normalize(forwardForHorizontal);
        if (forwardForHorizontal.vec_equals(collisionCheckParams.myCheckHorizontalFixedForward, 1e-5)) {
          forwardForHorizontal.vec3_copy(collisionCheckParams.myCheckHorizontalFixedForward);
        }
      }
      fixedHorizontalMovement.vec3_zero();
      if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
        fixedHorizontalMovement = this._horizontalCheck(surfaceAdjustedHorizontalMovement, feetPosition, height, transformUp, forwardForHorizontal, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, false, fixedHorizontalMovement);
        if (collisionCheckParams.mySlidingEnabled && collisionRuntimeParams.myIsCollidingHorizontally && this._isSlidingNormalValid(surfaceAdjustedHorizontalMovement, transformUp, collisionRuntimeParams)) {
          fixedHorizontalMovement = this._horizontalSlide(surfaceAdjustedHorizontalMovement, feetPosition, height, transformUp, forwardForHorizontal, allowSurfaceSteepFix, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, fixedHorizontalMovement);
        } else {
        }
      }
      if (fixedHorizontalMovement.vec3_isZero(1e-6)) {
        fixedHorizontalMovement.vec3_zero();
      }
      if (!surfaceAdjustedHorizontalMovement.vec3_isZero() && fixedHorizontalMovement.vec3_isZero()) {
        collisionRuntimeParams.myHorizontalMovementCanceled = true;
      }
    }
    {
      forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
      if (!collisionCheckParams.myCheckVerticalFixedForwardEnabled) {
        if (fixedHorizontalMovement.vec3_isZero()) {
          if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
            forwardForVertical = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForVertical);
          } else if (!horizontalMovement.vec3_isZero()) {
            forwardForVertical = horizontalMovement.vec3_normalize(forwardForVertical);
          } else {
            forwardForVertical.vec3_copy(transformForward);
          }
        } else {
          forwardForVertical = fixedHorizontalMovement.vec3_normalize(forwardForVertical);
        }
      } else {
        if (collisionCheckParams.myCheckVerticalFixedForward.vec3_isOnAxis(transformUp)) {
          if (zAxis.vec3_isOnAxis(transformUp)) {
            forwardForVertical.vec3_copy(xAxis);
          } else {
            forwardForVertical.vec3_copy(zAxis);
          }
        }
        forwardForVertical = forwardForVertical.vec3_removeComponentAlongAxis(transformUp, forwardForVertical);
        forwardForVertical = forwardForVertical.vec3_normalize(forwardForVertical);
        if (forwardForVertical.vec_equals(collisionCheckParams.myCheckVerticalFixedForward, 1e-5)) {
          forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
        }
      }
      surfaceAdjustedVerticalMovement = this._adjustVerticalMovementWithSurface(fixedHorizontalMovement, verticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, surfaceAdjustedVerticalMovement);
      newFeetPosition = feetPosition.vec3_add(fixedHorizontalMovement, newFeetPosition);
      let originalMovementSign = Math.pp_sign(verticalMovement.vec3_lengthSigned(transformUp), 0);
      fixedVerticalMovement.vec3_zero();
      fixedVerticalMovement = this._verticalCheck(surfaceAdjustedVerticalMovement, originalMovementSign, newFeetPosition, height, transformUp, forwardForVertical, collisionCheckParams, collisionRuntimeParams, fixedVerticalMovement);
      if (fixedVerticalMovement.vec3_isZero(1e-6)) {
        fixedVerticalMovement.vec3_zero();
      }
    }
    outFixedMovement.vec3_zero();
    if (!collisionRuntimeParams.myIsCollidingVertically) {
      outFixedMovement = fixedHorizontalMovement.vec3_add(fixedVerticalMovement, outFixedMovement);
    } else {
      collisionRuntimeParams.myHorizontalMovementCanceled = true;
      collisionRuntimeParams.myVerticalMovementCanceled = true;
      fixedHorizontalMovement.vec3_zero();
      fixedVerticalMovement.vec3_zero();
      if (!collisionCheckParams.myCheckVerticalFixedForwardEnabled) {
        if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
          forwardForVertical = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForVertical);
        } else if (!horizontalMovement.vec3_isZero()) {
          forwardForVertical = horizontalMovement.vec3_normalize(forwardForVertical);
        } else {
          forwardForVertical.vec3_copy(transformForward);
        }
      }
    }
    newFeetPosition = feetPosition.vec3_add(outFixedMovement, newFeetPosition);
    forwardForPerceivedAngle.vec3_copy(transformForward);
    if (!fixedHorizontalMovement.vec3_isZero()) {
      forwardForPerceivedAngle = fixedHorizontalMovement.vec3_normalize(forwardForPerceivedAngle);
    } else if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
      forwardForPerceivedAngle = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForPerceivedAngle);
    } else if (!horizontalMovement.vec3_isZero()) {
      forwardForPerceivedAngle = horizontalMovement.vec3_normalize(forwardForPerceivedAngle);
    }
    if (collisionCheckParams.myComputeGroundInfoEnabled) {
      this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
    }
    if (collisionCheckParams.myComputeCeilingInfoEnabled) {
      this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
    }
    if (!surfaceAdjustedHorizontalMovement.vec3_isZero() && !collisionRuntimeParams.myHorizontalMovementCanceled) {
      let surfaceCheckOk = this._postSurfaceCheck(fixedHorizontalMovement, fixedVerticalMovement, transformUp, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams);
      if (!surfaceCheckOk) {
        collisionRuntimeParams.myHorizontalMovementCanceled = true;
        collisionRuntimeParams.myVerticalMovementCanceled = true;
        fixedHorizontalMovement.vec3_zero();
        fixedVerticalMovement.vec3_zero();
        outFixedMovement.vec3_zero();
        newFeetPosition = feetPosition.vec3_add(outFixedMovement, newFeetPosition);
        if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
          forwardForPerceivedAngle = surfaceAdjustedHorizontalMovement.vec3_normalize(forwardForPerceivedAngle);
        } else if (!horizontalMovement.vec3_isZero()) {
          forwardForPerceivedAngle = horizontalMovement.vec3_normalize(forwardForPerceivedAngle);
        } else {
          forwardForPerceivedAngle.vec3_copy(transformForward);
        }
        if (collisionCheckParams.myComputeGroundInfoEnabled && collisionCheckParams.myRegatherGroundInfoOnSurfaceCheckFail) {
          this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
        } else {
          collisionRuntimeParams.myRealIsOnGround = this._myPrevCollisionRuntimeParams.myRealIsOnGround;
          collisionRuntimeParams.myIsOnGround = this._myPrevCollisionRuntimeParams.myIsOnGround;
          collisionRuntimeParams.myGroundCollisionHit.copy(this._myPrevCollisionRuntimeParams.myGroundCollisionHit);
          collisionRuntimeParams.myGroundAngle = this._myPrevCollisionRuntimeParams.myGroundAngle;
          collisionRuntimeParams.myGroundPerceivedAngle = this._myPrevCollisionRuntimeParams.myGroundPerceivedAngle;
          collisionRuntimeParams.myGroundNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myGroundNormal);
          collisionRuntimeParams.myGroundHitMaxAngle = this._myPrevCollisionRuntimeParams.myGroundHitMaxAngle;
          collisionRuntimeParams.myGroundHitMaxNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myGroundHitMaxNormal);
          collisionRuntimeParams.myGroundDistance = this._myPrevCollisionRuntimeParams.myGroundDistance;
          collisionRuntimeParams.myGroundIsBaseInsideCollision = this._myPrevCollisionRuntimeParams.myGroundIsBaseInsideCollision;
          collisionRuntimeParams.myOnGroundDueToBasePartiallyInsideCollision = this._myPrevCollisionRuntimeParams.myOnGroundDueToBasePartiallyInsideCollision;
        }
        if (collisionCheckParams.myComputeCeilingInfoEnabled && collisionCheckParams.myRegatherCeilingInfoOnSurfaceCheckFail) {
          this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
        } else {
          collisionRuntimeParams.myRealIsOnCeiling = this._myPrevCollisionRuntimeParams.myRealIsOnCeiling;
          collisionRuntimeParams.myIsOnCeiling = this._myPrevCollisionRuntimeParams.myIsOnCeiling;
          collisionRuntimeParams.myCeilingCollisionHit.copy(this._myPrevCollisionRuntimeParams.myCeilingCollisionHit);
          collisionRuntimeParams.myCeilingAngle = this._myPrevCollisionRuntimeParams.myCeilingAngle;
          collisionRuntimeParams.myCeilingPerceivedAngle = this._myPrevCollisionRuntimeParams.myCeilingPerceivedAngle;
          collisionRuntimeParams.myCeilingNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myCeilingNormal);
          collisionRuntimeParams.myCeilingHitMaxAngle = this._myPrevCollisionRuntimeParams.myCeilingHitMaxAngle;
          collisionRuntimeParams.myCeilingHitMaxNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myCeilingHitMaxNormal);
          collisionRuntimeParams.myCeilingDistance = this._myPrevCollisionRuntimeParams.myCeilingDistance;
          collisionRuntimeParams.myCeilingIsBaseInsideCollision = this._myPrevCollisionRuntimeParams.myCeilingIsBaseInsideCollision;
          collisionRuntimeParams.myOnCeilingDueToBasePartiallyInsideCollision = this._myPrevCollisionRuntimeParams.myOnCeilingDueToBasePartiallyInsideCollision;
        }
      }
    }
    if (collisionCheckParams.myExtraMovementCheckCallback != null) {
      fixedMovement.vec3_copy(outFixedMovement);
      outFixedMovement = collisionCheckParams.myExtraMovementCheckCallback(movement, fixedMovement, feetPosition, transformUp, transformForward, height, collisionCheckParams, this._myPrevCollisionRuntimeParams, collisionRuntimeParams, outFixedMovement);
      fixedHorizontalMovement = outFixedMovement.vec3_removeComponentAlongAxis(transformUp, fixedHorizontalMovement);
      fixedVerticalMovement = outFixedMovement.vec3_componentAlongAxis(transformUp, fixedVerticalMovement);
    }
    {
      if (collisionCheckParams.mySlidingAdjustSign90Degrees) {
        if (!collisionRuntimeParams.myHorizontalMovementCanceled && !collisionRuntimeParams.myIsSliding && !fixedHorizontalMovement.vec3_isZero()) {
          collisionRuntimeParams.mySlidingRecompute90DegreesSign = true;
        }
      }
      if (!horizontalMovement.vec3_isZero()) {
        collisionRuntimeParams.myLastValidOriginalHorizontalMovement.vec3_copy(horizontalMovement);
      }
      if (!surfaceAdjustedHorizontalMovement.vec3_isZero()) {
        collisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement.vec3_copy(surfaceAdjustedHorizontalMovement);
      }
      if (!verticalMovement.vec3_isZero()) {
        collisionRuntimeParams.myLastValidOriginalVerticalMovement.vec3_copy(verticalMovement);
      }
      if (!surfaceAdjustedVerticalMovement.vec3_isZero()) {
        collisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement.vec3_copy(surfaceAdjustedVerticalMovement);
      }
      if (!fixedHorizontalMovement.vec3_isZero(1e-6)) {
        collisionRuntimeParams.myLastValidIsSliding = collisionRuntimeParams.myIsSliding;
        collisionRuntimeParams.myIsSlidingFlickerPrevented = false;
        collisionRuntimeParams.myLastValidEndHorizontalMovement.vec3_copy(fixedHorizontalMovement);
        if (!collisionRuntimeParams.myIsSliding) {
        } else {
        }
      } else {
      }
      if (!fixedVerticalMovement.vec3_isZero(1e-6)) {
        collisionRuntimeParams.myLastValidEndVerticalMovement.vec3_copy(fixedVerticalMovement);
      }
    }
    let moveStepFixed = false;
    if (!collisionRuntimeParams.myHorizontalMovementCanceled && !fixedHorizontalMovement.vec3_isZero(1e-6)) {
      horizontalDirection = fixedHorizontalMovement.vec3_normalize(horizontalDirection);
      let surfaceTooSteepResults = this._surfaceTooSteep(transformUp, horizontalDirection, collisionCheckParams, this._myPrevCollisionRuntimeParams);
      if (surfaceTooSteepResults[0] || surfaceTooSteepResults[1]) {
        horizontalDirection = fixedHorizontalMovement.vec3_normalize(horizontalDirection);
        let newSurfaceTooSteepResults = this._surfaceTooSteep(transformUp, horizontalDirection, collisionCheckParams, collisionRuntimeParams);
        if (surfaceTooSteepResults[0] && newSurfaceTooSteepResults[0] || surfaceTooSteepResults[1] && newSurfaceTooSteepResults[1] || !allowSurfaceSteepFix || surfaceTooSteepResults[0] && !collisionCheckParams.myAllowGroundSteepFix || surfaceTooSteepResults[1] && !collisionCheckParams.myAllowCeilingSteepFix) {
          outFixedMovement.vec3_zero();
          collisionRuntimeParams.copy(this._myPrevCollisionRuntimeParams);
          this._moveStep(movement, feetPosition, transformUp, transformForward, height, false, collisionCheckParams, collisionRuntimeParams, outFixedMovement);
          moveStepFixed = true;
        }
      }
    }
    if (!moveStepFixed) {
      if (collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugMovementEnabled && Globals.isDebugEnabled(this._myEngine)) {
        this._debugMovement(movement, outFixedMovement, newFeetPosition, transformUp, collisionCheckParams);
      }
      if (collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugRuntimeParamsEnabled && Globals.isDebugEnabled(this._myEngine)) {
        this._debugRuntimeParams(collisionRuntimeParams);
      }
    }
    return outFixedMovement;
  };
}();
CollisionCheckMove.prototype._syncCollisionRuntimeParamsWithPrevious = function() {
  let previousFixedHorizontalMovement = vec3_create();
  return function _syncCollisionRuntimeParamsWithPrevious(surfaceAdjustedHorizontalMovement, verticalMovement, up, collisionCheckParams, collisionRuntimeParams, previousCollisionRuntimeParams) {
    collisionRuntimeParams.myIsSlidingFlickerPrevented = previousCollisionRuntimeParams.myIsSlidingFlickerPrevented;
    collisionRuntimeParams.myLastValidOriginalHorizontalMovement.vec3_copy(previousCollisionRuntimeParams.myLastValidOriginalHorizontalMovement);
    collisionRuntimeParams.myLastValidOriginalVerticalMovement.vec3_copy(previousCollisionRuntimeParams.myLastValidOriginalVerticalMovement);
    collisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement.vec3_copy(previousCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement);
    collisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement.vec3_copy(previousCollisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement);
    collisionRuntimeParams.myLastValidIsSliding = previousCollisionRuntimeParams.myLastValidIsSliding;
    collisionRuntimeParams.mySliding90DegreesSign = previousCollisionRuntimeParams.mySliding90DegreesSign;
    collisionRuntimeParams.mySlidingRecompute90DegreesSign = previousCollisionRuntimeParams.mySlidingRecompute90DegreesSign;
    if (collisionCheckParams.mySlidingAdjustSign90Degrees) {
      let angleWithPreviousThreshold = 0.5;
      if (!previousCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement.vec3_isZero() && !surfaceAdjustedHorizontalMovement.vec3_isZero() && surfaceAdjustedHorizontalMovement.vec3_angle(previousCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement) > angleWithPreviousThreshold) {
        if (!previousCollisionRuntimeParams.myLastValidIsSliding) {
          let angleSigned2 = surfaceAdjustedHorizontalMovement.vec3_angleSigned(previousCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement, up);
          let angleSignedThreshold = 10;
          if (Math.abs(angleSigned2) < 180 - angleSignedThreshold) {
            collisionRuntimeParams.mySliding90DegreesSign = Math.pp_sign(angleSigned2);
          }
        }
        collisionRuntimeParams.mySlidingRecompute90DegreesSign = true;
      }
    }
    previousFixedHorizontalMovement = previousCollisionRuntimeParams.myFixedMovement.vec3_removeComponentAlongAxis(up, previousFixedHorizontalMovement);
    if (previousFixedHorizontalMovement.vec3_isZero(1e-6)) {
      collisionRuntimeParams.mySlidingPreviousHorizontalMovement.vec3_copy(previousCollisionRuntimeParams.mySlidingPreviousHorizontalMovement);
    } else {
      collisionRuntimeParams.mySlidingPreviousHorizontalMovement.vec3_copy(previousFixedHorizontalMovement);
    }
  };
}();

// dist/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_teleport.js
var CollisionCheckTeleport = class extends CollisionCheckMove {
  // #TODO Add teleport position/transform and return originalteleportransform
  // instead of position old transform / new transform
  teleport(position, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    if (this.isCollisionCheckDisabled() && Globals.isDebugEnabled(this._myEngine)) {
      this._setRuntimeParamsForTeleportCollisionCheckDisabled(position, transformQuat2, collisionCheckParams, collisionRuntimeParams);
      return;
    }
    this._teleport(position, transformQuat2, collisionCheckParams, collisionRuntimeParams);
  }
  _teleport(teleportPosition, transformQuat2, collisionCheckParams, collisionRuntimeParams, isPositionCheck = false) {
  }
};
CollisionCheckTeleport.prototype._teleport = function() {
  let transformUp = vec3_create();
  let transformForward = vec3_create();
  let feetPosition = vec3_create();
  let originalFeetPosition = vec3_create();
  let transformOffsetLocalQuat = quat2_create();
  let offsetTransformQuat = quat2_create();
  let feetPositionOffsetToOriginal = vec3_create();
  let offsetTeleportPosition = vec3_create();
  let zero4 = vec3_create();
  let forwardForHorizontal = vec3_create();
  let forwardForVertical = vec3_create();
  let forwardForPerceivedAngle = vec3_create();
  let fixedHorizontalMovement = vec3_create();
  let fixedVerticalMovement = vec3_create();
  let newFeetPosition = vec3_create();
  let endPosition = vec3_create();
  let zAxis = vec3_create(0, 0, 1);
  let xAxis = vec3_create(1, 0, 0);
  return function _teleport(teleportPosition, transformQuat2, collisionCheckParams, collisionRuntimeParams, isPositionCheck = false) {
    transformOffsetLocalQuat.quat2_setPositionRotationQuat(collisionCheckParams.myPositionOffsetLocal, collisionCheckParams.myRotationOffsetLocalQuat);
    offsetTransformQuat = transformOffsetLocalQuat.quat2_toWorld(transformQuat2, offsetTransformQuat);
    if (transformQuat2.vec_equals(offsetTransformQuat, 1e-5)) {
      offsetTransformQuat.quat2_copy(transformQuat2);
    }
    transformUp = offsetTransformQuat.quat2_getUp(transformUp);
    transformForward = offsetTransformQuat.quat2_getForward(transformForward);
    feetPosition = offsetTransformQuat.quat2_getPosition(feetPosition);
    offsetTeleportPosition.vec3_copy(teleportPosition);
    originalFeetPosition = transformQuat2.quat2_getPosition(originalFeetPosition);
    feetPositionOffsetToOriginal = originalFeetPosition.vec3_sub(feetPosition, feetPositionOffsetToOriginal);
    if (feetPositionOffsetToOriginal.vec3_isZero(1e-5)) {
      feetPositionOffsetToOriginal.vec3_zero();
    } else {
      offsetTeleportPosition = offsetTeleportPosition.vec3_sub(feetPositionOffsetToOriginal, offsetTeleportPosition);
    }
    let height = collisionCheckParams.myHeight;
    height = height - 1e-5;
    if (height < 1e-5) {
      height = 0;
    }
    this._myPrevCollisionRuntimeParams.copy(collisionRuntimeParams);
    collisionRuntimeParams.reset();
    forwardForHorizontal.vec3_copy(collisionCheckParams.myCheckHorizontalFixedForward);
    if (!collisionCheckParams.myCheckHorizontalFixedForwardEnabled) {
      forwardForHorizontal.vec3_copy(transformForward);
    } else {
      if (collisionCheckParams.myCheckHorizontalFixedForward.vec3_isOnAxis(transformUp)) {
        if (zAxis.vec3_isOnAxis(transformUp)) {
          forwardForHorizontal.vec3_copy(xAxis);
        } else {
          forwardForHorizontal.vec3_copy(zAxis);
        }
      }
      forwardForHorizontal = forwardForHorizontal.vec3_removeComponentAlongAxis(transformUp, forwardForHorizontal);
      forwardForHorizontal = forwardForHorizontal.vec3_normalize(forwardForHorizontal);
      if (forwardForHorizontal.vec_equals(collisionCheckParams.myCheckHorizontalFixedForward, 1e-5)) {
        forwardForHorizontal.vec3_copy(collisionCheckParams.myCheckHorizontalFixedForward);
      }
    }
    fixedHorizontalMovement = this._horizontalCheck(zero4, offsetTeleportPosition, height, transformUp, forwardForHorizontal, false, collisionCheckParams, collisionRuntimeParams, this._myPrevCollisionRuntimeParams, false, fixedHorizontalMovement);
    if (!collisionRuntimeParams.myIsCollidingHorizontally) {
      newFeetPosition = offsetTeleportPosition.vec3_add(fixedHorizontalMovement, newFeetPosition);
      forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
      if (!collisionCheckParams.myCheckVerticalFixedForwardEnabled) {
        forwardForVertical.vec3_copy(transformForward);
      } else {
        if (collisionCheckParams.myCheckVerticalFixedForward.vec3_isOnAxis(transformUp)) {
          if (zAxis.vec3_isOnAxis(transformUp)) {
            forwardForVertical.vec3_copy(xAxis);
          } else {
            forwardForVertical.vec3_copy(zAxis);
          }
        }
        forwardForVertical = forwardForVertical.vec3_removeComponentAlongAxis(transformUp, forwardForVertical);
        forwardForVertical = forwardForVertical.vec3_normalize(forwardForVertical);
        if (forwardForVertical.vec_equals(collisionCheckParams.myCheckVerticalFixedForward, 1e-5)) {
          forwardForVertical.vec3_copy(collisionCheckParams.myCheckVerticalFixedForward);
        }
      }
      let downward = -1;
      fixedVerticalMovement = this._verticalCheck(zero4, downward, newFeetPosition, height, transformUp, forwardForVertical, collisionCheckParams, collisionRuntimeParams, fixedVerticalMovement);
      if (!collisionRuntimeParams.myIsCollidingVertically) {
        newFeetPosition = newFeetPosition.vec3_add(fixedVerticalMovement, newFeetPosition);
        forwardForPerceivedAngle.vec3_copy(transformForward);
        if (collisionCheckParams.myComputeGroundInfoEnabled) {
          this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
        }
        if (collisionCheckParams.myComputeCeilingInfoEnabled) {
          this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
        }
        if (!collisionRuntimeParams.myIsOnGround) {
          if (collisionCheckParams.myTeleportMustBeOnGround && !isPositionCheck || collisionCheckParams.myCheckTransformMustBeOnGround && isPositionCheck) {
            collisionRuntimeParams.myTeleportCanceled = true;
          }
        }
        if (!collisionRuntimeParams.myIsOnCeiling) {
          if (collisionCheckParams.myTeleportMustBeOnCeiling && !isPositionCheck || collisionCheckParams.myCheckTransformMustBeOnCeiling && isPositionCheck) {
            collisionRuntimeParams.myTeleportCanceled = true;
          }
        }
        if (collisionRuntimeParams.myIsOnGround) {
          let minAngle = null;
          if (!isPositionCheck) {
            if (collisionCheckParams.myTeleportMustBeOnIgnorableGroundAngle) {
              minAngle = collisionCheckParams.myGroundAngleToIgnore;
            }
            if (collisionCheckParams.myTeleportMustBeOnGroundAngle != null) {
              minAngle = Math.min(minAngle, collisionCheckParams.myTeleportMustBeOnGroundAngle);
            }
          } else {
            if (collisionCheckParams.myCheckTransformMustBeOnIgnorableGroundAngle) {
              minAngle = collisionCheckParams.myGroundAngleToIgnore;
            }
            if (collisionCheckParams.myCheckTransformMustBeOnGroundAngle != null) {
              minAngle = Math.min(minAngle, collisionCheckParams.myCheckTransformMustBeOnGroundAngle);
            }
          }
          if (minAngle != null && collisionRuntimeParams.myGroundAngle > minAngle + 1e-4) {
            collisionRuntimeParams.myTeleportCanceled = true;
          }
        }
        if (collisionRuntimeParams.myIsOnCeiling) {
          let minAngle = null;
          if (!isPositionCheck) {
            if (collisionCheckParams.myTeleportMustBeOnIgnorableCeilingAngle) {
              minAngle = collisionCheckParams.myCeilingAngleToIgnore;
            }
            if (collisionCheckParams.myTeleportMustBeOnCeilingAngle != null) {
              minAngle = Math.min(minAngle, collisionCheckParams.myTeleportMustBeOnCeilingAngle);
            }
          } else {
            if (collisionCheckParams.myCheckTransformMustBeOnIgnorableCeilingAngle) {
              minAngle = collisionCheckParams.myCeilingAngleToIgnore;
            }
            if (collisionCheckParams.myCheckTransformMustBeOnCeilingAngle != null) {
              minAngle = Math.min(minAngle, collisionCheckParams.myCheckTransformMustBeOnCeilingAngle);
            }
          }
          if (minAngle != null && collisionRuntimeParams.myCeilingAngle > minAngle + 1e-4) {
            collisionRuntimeParams.myTeleportCanceled = true;
          }
        }
        if (collisionRuntimeParams.myTeleportCanceled) {
          if (collisionCheckParams.myComputeGroundInfoEnabled && collisionCheckParams.myRegatherGroundInfoOnSurfaceCheckFail) {
            this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, true, collisionCheckParams, collisionRuntimeParams);
          } else {
            collisionRuntimeParams.myRealIsOnGround = this._myPrevCollisionRuntimeParams.myRealIsOnGround;
            collisionRuntimeParams.myIsOnGround = this._myPrevCollisionRuntimeParams.myIsOnGround;
            collisionRuntimeParams.myGroundCollisionHit.copy(this._myPrevCollisionRuntimeParams.myGroundCollisionHit);
            collisionRuntimeParams.myGroundAngle = this._myPrevCollisionRuntimeParams.myGroundAngle;
            collisionRuntimeParams.myGroundPerceivedAngle = this._myPrevCollisionRuntimeParams.myGroundPerceivedAngle;
            collisionRuntimeParams.myGroundNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myGroundNormal);
            collisionRuntimeParams.myGroundHitMaxAngle = this._myPrevCollisionRuntimeParams.myGroundHitMaxAngle;
            collisionRuntimeParams.myGroundHitMaxNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myGroundHitMaxNormal);
            collisionRuntimeParams.myGroundDistance = this._myPrevCollisionRuntimeParams.myGroundDistance;
            collisionRuntimeParams.myGroundIsBaseInsideCollision = this._myPrevCollisionRuntimeParams.myGroundIsBaseInsideCollision;
            collisionRuntimeParams.myOnGroundDueToBasePartiallyInsideCollision = this._myPrevCollisionRuntimeParams.myOnGroundDueToBasePartiallyInsideCollision;
          }
          if (collisionCheckParams.myComputeCeilingInfoEnabled && collisionCheckParams.myRegatherCeilingInfoOnSurfaceCheckFail) {
            this._gatherSurfaceInfo(newFeetPosition, height, transformUp, forwardForPerceivedAngle, forwardForVertical, false, collisionCheckParams, collisionRuntimeParams);
          } else {
            collisionRuntimeParams.myRealIsOnCeiling = this._myPrevCollisionRuntimeParams.myRealIsOnCeiling;
            collisionRuntimeParams.myIsOnCeiling = this._myPrevCollisionRuntimeParams.myIsOnCeiling;
            collisionRuntimeParams.myCeilingCollisionHit.copy(this._myPrevCollisionRuntimeParams.myCeilingCollisionHit);
            collisionRuntimeParams.myCeilingAngle = this._myPrevCollisionRuntimeParams.myCeilingAngle;
            collisionRuntimeParams.myCeilingPerceivedAngle = this._myPrevCollisionRuntimeParams.myCeilingPerceivedAngle;
            collisionRuntimeParams.myCeilingNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myCeilingNormal);
            collisionRuntimeParams.myCeilingHitMaxAngle = this._myPrevCollisionRuntimeParams.myCeilingHitMaxAngle;
            collisionRuntimeParams.myCeilingHitMaxNormal.vec3_copy(this._myPrevCollisionRuntimeParams.myCeilingHitMaxNormal);
            collisionRuntimeParams.myCeilingDistance = this._myPrevCollisionRuntimeParams.myCeilingDistance;
            collisionRuntimeParams.myCeilingIsBaseInsideCollision = this._myPrevCollisionRuntimeParams.myCeilingIsBaseInsideCollision;
            collisionRuntimeParams.myOnCeilingDueToBasePartiallyInsideCollision = this._myPrevCollisionRuntimeParams.myOnCeilingDueToBasePartiallyInsideCollision;
          }
        }
      } else {
        collisionRuntimeParams.myTeleportCanceled = true;
      }
    } else {
      collisionRuntimeParams.myTeleportCanceled = true;
    }
    if (!isPositionCheck) {
      if (collisionCheckParams.myExtraTeleportCheckCallback != null) {
        endPosition.vec3_copy(newFeetPosition);
        newFeetPosition = collisionCheckParams.myExtraTeleportCheckCallback(offsetTeleportPosition, endPosition, feetPosition, transformUp, transformForward, height, collisionCheckParams, this._myPrevCollisionRuntimeParams, collisionRuntimeParams, newFeetPosition);
      }
    } else {
      if (collisionCheckParams.myExtraCheckTransformCheckCallback != null) {
        endPosition.vec3_copy(newFeetPosition);
        newFeetPosition = collisionCheckParams.myExtraCheckTransformCheckCallback(endPosition, feetPosition, transformUp, transformForward, height, collisionCheckParams, this._myPrevCollisionRuntimeParams, collisionRuntimeParams, newFeetPosition);
      }
    }
    collisionRuntimeParams.myOriginalUp = transformQuat2.quat2_getUp(collisionRuntimeParams.myOriginalUp);
    collisionRuntimeParams.myOriginalForward = transformQuat2.quat2_getForward(collisionRuntimeParams.myOriginalForward);
    collisionRuntimeParams.myOriginalPosition = transformQuat2.quat2_getPosition(collisionRuntimeParams.myOriginalPosition);
    collisionRuntimeParams.myOffsetUp.vec3_copy(transformUp);
    collisionRuntimeParams.myTeleportForward.vec3_copy(forwardForHorizontal);
    collisionRuntimeParams.myOriginalHeight = collisionCheckParams.myHeight;
    collisionRuntimeParams.myOriginalTeleportPosition.vec3_copy(teleportPosition);
    if (!collisionRuntimeParams.myTeleportCanceled) {
      collisionRuntimeParams.myFixedTeleportPosition.vec3_copy(newFeetPosition);
      if (!feetPositionOffsetToOriginal.vec3_isZero(1e-5)) {
        collisionRuntimeParams.myFixedTeleportPosition = collisionRuntimeParams.myFixedTeleportPosition.vec3_add(feetPositionOffsetToOriginal, collisionRuntimeParams.myFixedTeleportPosition);
      }
      collisionRuntimeParams.myNewPosition.vec3_copy(collisionRuntimeParams.myFixedTeleportPosition);
    } else {
      collisionRuntimeParams.myNewPosition.vec3_copy(collisionRuntimeParams.myOriginalPosition);
    }
    collisionRuntimeParams.myIsTeleport = true;
    if (collisionCheckParams.myDebugEnabled && collisionCheckParams.myDebugRuntimeParamsEnabled && Globals.isDebugEnabled(this._myEngine)) {
      this._debugRuntimeParams(collisionRuntimeParams);
    }
  };
}();

// dist/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_position.js
var CollisionCheckPosition = class extends CollisionCheckTeleport {
  positionCheck(allowFix, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    if (this.isCollisionCheckDisabled() && Globals.isDebugEnabled(this._myEngine)) {
      this._setRuntimeParamsForPositionCheckCollisionCheckDisabled(allowFix, transformQuat2, collisionCheckParams, collisionRuntimeParams);
      return;
    }
    this._positionCheck(allowFix, transformQuat2, collisionCheckParams, collisionRuntimeParams);
  }
  _positionCheck(allowAdjustments, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
  }
};
CollisionCheckPosition.prototype._positionCheck = function() {
  let feetPosition = vec3_create();
  return function _positionCheck(allowAdjustments, transformQuat2, collisionCheckParams, collisionRuntimeParams) {
    feetPosition = transformQuat2.quat2_getPosition(feetPosition);
    this._teleport(feetPosition, transformQuat2, collisionCheckParams, collisionRuntimeParams, true);
    collisionRuntimeParams.myIsPositionOk = !collisionRuntimeParams.myTeleportCanceled;
    collisionRuntimeParams.myIsPositionCheck = true;
    collisionRuntimeParams.myOriginalPositionCheckPosition.vec3_copy(collisionRuntimeParams.myOriginalTeleportPosition);
    collisionRuntimeParams.myFixedPositionCheckPosition.vec3_copy(collisionRuntimeParams.myFixedTeleportPosition);
    collisionRuntimeParams.myIsPositionCheckAllowAdjustments = allowAdjustments;
    if (!allowAdjustments) {
      collisionRuntimeParams.myIsPositionOk = collisionRuntimeParams.myIsPositionOk && collisionRuntimeParams.myOriginalPositionCheckPosition.vec_equals(collisionRuntimeParams.myFixedPositionCheckPosition, 1e-5);
    }
    collisionRuntimeParams.myOriginalTeleportPosition.vec3_zero();
    collisionRuntimeParams.myFixedTeleportPosition.vec3_zero();
    collisionRuntimeParams.myTeleportCanceled = false;
    collisionRuntimeParams.myIsTeleport = false;
  };
}();

// dist/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check.js
var CollisionCheck = class extends CollisionCheckPosition {
};

// dist/pp/gameplay/experimental/character_controller/collision/collision_check_bridge.js
var _myCollisionChecks = /* @__PURE__ */ new WeakMap();
function getCollisionCheck(engine = Globals.getMainEngine()) {
  return _myCollisionChecks.get(engine);
}
function setCollisionCheck(collisionCheck, engine = Globals.getMainEngine()) {
  _myCollisionChecks.set(engine, collisionCheck);
}
function isCollisionCheckDisabled(engine = Globals.getMainEngine()) {
  let collisionCheck = CollisionCheckBridge.getCollisionCheck(engine);
  if (collisionCheck != null) {
    return collisionCheck.isCollisionCheckDisabled();
  }
  return false;
}
function setCollisionCheckDisabled(collisionCheckDisabled, engine = Globals.getMainEngine()) {
  let collisionCheck = CollisionCheckBridge.getCollisionCheck(engine);
  if (collisionCheck != null) {
    collisionCheck.setCollisionCheckDisabled(collisionCheckDisabled);
  }
}
function initBridge(engine = Globals.getMainEngine()) {
  if (!_myCollisionChecks.has(engine)) {
    CollisionCheckBridge.setCollisionCheck(new CollisionCheck(engine), engine);
  }
}
var checkMovement = function() {
  let collisionCheckParams = new CollisionCheckParams();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  return function checkMovement2(movement, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults(), engine = Globals.getMainEngine()) {
    CollisionCheckBridge.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
    CollisionCheckBridge.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
    CollisionCheckBridge.getCollisionCheck(engine).move(movement, currentTransformQuat, collisionCheckParams, collisionRuntimeParams);
    CollisionCheckBridge.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults);
  };
}();
var checkTeleportToTransform = function() {
  let teleportPosition = vec3_create();
  let collisionCheckParams = new CollisionCheckParams();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  return function checkTeleportToTransform2(teleportTransformQuat, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults(), engine = Globals.getMainEngine()) {
    CollisionCheckBridge.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
    CollisionCheckBridge.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
    teleportPosition = teleportTransformQuat.quat2_getPosition(teleportPosition);
    CollisionCheckBridge.getCollisionCheck(engine).teleport(teleportPosition, teleportTransformQuat, collisionCheckParams, collisionRuntimeParams);
    CollisionCheckBridge.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults);
  };
}();
var checkTransform = function() {
  let collisionCheckParams = new CollisionCheckParams();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  return function checkTransform2(checkTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults(), engine = Globals.getMainEngine()) {
    CollisionCheckBridge.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
    CollisionCheckBridge.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
    CollisionCheckBridge.getCollisionCheck(engine).positionCheck(true, checkTransformQuat, collisionCheckParams, collisionRuntimeParams);
    CollisionCheckBridge.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, checkTransformQuat, outCharacterCollisionResults);
  };
}();
var updateGroundInfo = function() {
  let collisionCheckParams = new CollisionCheckParams();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  return function updateGroundInfo2(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults(), engine = Globals.getMainEngine()) {
    CollisionCheckBridge.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
    CollisionCheckBridge.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
    collisionCheckParams.myComputeCeilingInfoEnabled = false;
    CollisionCheckBridge.getCollisionCheck(engine).updateSurfaceInfo(currentTransformQuat, collisionCheckParams, collisionRuntimeParams);
    CollisionCheckBridge.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults);
  };
}();
var updateCeilingInfo = function() {
  let collisionCheckParams = new CollisionCheckParams();
  let collisionRuntimeParams = new CollisionRuntimeParams();
  return function updateCeilingInfo2(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults(), engine = Globals.getMainEngine()) {
    CollisionCheckBridge.convertCharacterColliderSetupToCollisionCheckParams(characterColliderSetup, collisionCheckParams);
    CollisionCheckBridge.convertCharacterCollisionResultsToCollisionRuntimeParams(prevCharacterCollisionResults, collisionRuntimeParams);
    collisionCheckParams.myComputeGroundInfoEnabled = false;
    CollisionCheckBridge.getCollisionCheck(engine).updateSurfaceInfo(currentTransformQuat, collisionCheckParams, collisionRuntimeParams);
    CollisionCheckBridge.convertCollisionRuntimeParamsToCharacterCollisionResults(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults);
  };
}();
function convertCharacterCollisionResultsToCollisionRuntimeParams(characterCollisionResults, outCollisionRuntimeParams = new CollisionRuntimeParams()) {
  outCollisionRuntimeParams.reset();
  characterCollisionResults.myTransformResults.myInitialTransformQuat.quat2_getPosition(outCollisionRuntimeParams.myOriginalPosition);
  characterCollisionResults.myTransformResults.myFinalTransformQuat.quat2_getPosition(outCollisionRuntimeParams.myNewPosition);
  characterCollisionResults.myTransformResults.myInitialTransformQuat.quat2_getForward(outCollisionRuntimeParams.myOriginalForward);
  characterCollisionResults.myTransformResults.myInitialTransformQuat.quat2_getUp(outCollisionRuntimeParams.myOriginalUp);
  outCollisionRuntimeParams.myOriginalMovement.vec3_copy(characterCollisionResults.myMovementResults.myInitialMovement);
  outCollisionRuntimeParams.myFixedMovement.vec3_copy(characterCollisionResults.myMovementResults.myFinalMovement);
  outCollisionRuntimeParams.myLastValidOriginalHorizontalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantInitialHorizontalMovement);
  outCollisionRuntimeParams.myLastValidOriginalVerticalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantInitialVerticalMovement);
  outCollisionRuntimeParams.myLastValidEndHorizontalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantFinalHorizontalMovement);
  outCollisionRuntimeParams.myLastValidEndVerticalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantFinalVerticalMovement);
  outCollisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantAdjustedInitialHorizontalMovement);
  outCollisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantAdjustedInitialVerticalMovement);
  outCollisionRuntimeParams.myIsOnGround = characterCollisionResults.myGroundInfo.myOnSurface;
  outCollisionRuntimeParams.myGroundCollisionHit.copy(characterCollisionResults.myGroundInfo.mySurfaceReferenceCollisionHit);
  outCollisionRuntimeParams.myGroundAngle = characterCollisionResults.myGroundInfo.mySurfaceAngle;
  outCollisionRuntimeParams.myGroundPerceivedAngle = characterCollisionResults.myGroundInfo.mySurfacePerceivedAngle;
  outCollisionRuntimeParams.myGroundNormal.vec3_copy(characterCollisionResults.myGroundInfo.mySurfaceNormal);
  outCollisionRuntimeParams.myGroundHitMaxAngle = characterCollisionResults.myGroundInfo.mySurfaceHitMaxAngle;
  outCollisionRuntimeParams.myGroundHitMaxNormal.vec3_copy(characterCollisionResults.myGroundInfo.mySurfaceHitMaxNormal);
  outCollisionRuntimeParams.myGroundDistance = characterCollisionResults.myGroundInfo.mySurfaceDistance;
  outCollisionRuntimeParams.myGroundIsBaseInsideCollision = characterCollisionResults.myGroundInfo.myBaseInsideCollision;
  outCollisionRuntimeParams.myOnGroundDueToBasePartiallyInsideCollision = characterCollisionResults.myGroundInfo.myOnSurfaceDueToBasePartiallyInsideCollision;
  outCollisionRuntimeParams.myIsOnCeiling = characterCollisionResults.myCeilingInfo.myOnSurface;
  outCollisionRuntimeParams.myCeilingCollisionHit.copy(characterCollisionResults.myCeilingInfo.mySurfaceReferenceCollisionHit);
  outCollisionRuntimeParams.myCeilingAngle = characterCollisionResults.myCeilingInfo.mySurfaceAngle;
  outCollisionRuntimeParams.myCeilingPerceivedAngle = characterCollisionResults.myCeilingInfo.mySurfacePerceivedAngle;
  outCollisionRuntimeParams.myCeilingNormal.vec3_copy(characterCollisionResults.myCeilingInfo.mySurfaceNormal);
  outCollisionRuntimeParams.myCeilingHitMaxAngle = characterCollisionResults.myCeilingInfo.mySurfaceHitMaxAngle;
  outCollisionRuntimeParams.myCeilingHitMaxNormal.vec3_copy(characterCollisionResults.myCeilingInfo.mySurfaceHitMaxNormal);
  outCollisionRuntimeParams.myCeilingDistance = characterCollisionResults.myCeilingInfo.mySurfaceDistance;
  outCollisionRuntimeParams.myCeilingIsBaseInsideCollision = characterCollisionResults.myCeilingInfo.myBaseInsideCollision;
  outCollisionRuntimeParams.myOnCeilingDueToBasePartiallyInsideCollision = characterCollisionResults.myCeilingInfo.myOnSurfaceDueToBasePartiallyInsideCollision;
  outCollisionRuntimeParams.myHorizontalMovementCanceled = characterCollisionResults.myHorizontalMovementResults.myMovementFailed;
  outCollisionRuntimeParams.myIsCollidingHorizontally = characterCollisionResults.myHorizontalMovementResults.myMovementCollided;
  outCollisionRuntimeParams.myHorizontalCollisionHit.copy(characterCollisionResults.myHorizontalMovementResults.myReferenceCollisionHit);
  outCollisionRuntimeParams.myVerticalMovementCanceled = characterCollisionResults.myVerticalMovementResults.myMovementFailed;
  outCollisionRuntimeParams.myIsCollidingVertically = characterCollisionResults.myVerticalMovementResults.myMovementCollided;
  outCollisionRuntimeParams.myVerticalCollisionHit.copy(characterCollisionResults.myVerticalMovementResults.myReferenceCollisionHit);
  outCollisionRuntimeParams.myHasSnappedOnGround = characterCollisionResults.myGroundResults.myHasSnappedOnSurface;
  outCollisionRuntimeParams.myHasSnappedOnCeiling = characterCollisionResults.myCeilingResults.myHasSnappedOnSurface;
  outCollisionRuntimeParams.myHasPoppedOutGround = characterCollisionResults.myGroundResults.myHasPoppedOutSurface;
  outCollisionRuntimeParams.myHasPoppedOutCeiling = characterCollisionResults.myCeilingResults.myHasPoppedOutSurface;
  outCollisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill = characterCollisionResults.myGroundResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill;
  outCollisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill = characterCollisionResults.myGroundResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill;
  outCollisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill = characterCollisionResults.myGroundResults.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill;
  outCollisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill = characterCollisionResults.myCeilingResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill;
  outCollisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill = characterCollisionResults.myCeilingResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill;
  outCollisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill = characterCollisionResults.myCeilingResults.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill;
  outCollisionRuntimeParams.myIsSliding = characterCollisionResults.myWallSlideResults.myHasSlid;
  outCollisionRuntimeParams.mySlidingMovementAngle = characterCollisionResults.myWallSlideResults.mySlideMovementAngle;
  outCollisionRuntimeParams.mySlidingCollisionAngle = characterCollisionResults.myWallSlideResults.mySlideMovementWallAngle;
  outCollisionRuntimeParams.mySlidingWallNormal.vec3_copy(characterCollisionResults.myWallSlideResults.myWallNormal);
  outCollisionRuntimeParams.myIsSlidingIntoOppositeDirection = characterCollisionResults.myInternalResults.myHasWallSlidTowardOppositeDirection;
  outCollisionRuntimeParams.myIsSlidingFlickerPrevented = characterCollisionResults.myInternalResults.myLastRelevantWallSlideFlickerPrevented;
  outCollisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter = characterCollisionResults.myInternalResults.myWallSlideFlickerPreventionForceCheckCounter;
  outCollisionRuntimeParams.mySliding90DegreesSign = characterCollisionResults.myInternalResults.myWallSlide90DegreesDirectionSign;
  outCollisionRuntimeParams.mySlidingRecompute90DegreesSign = characterCollisionResults.myInternalResults.myWallSlide90DegreesRecomputeDirectionSign;
  outCollisionRuntimeParams.myLastValidIsSliding = characterCollisionResults.myInternalResults.myLastRelevantHasWallSlid;
  outCollisionRuntimeParams.mySlidingPreviousHorizontalMovement.vec3_copy(characterCollisionResults.myInternalResults.myLastRelevantFinalHorizontalMovement);
  outCollisionRuntimeParams.myOriginalTeleportPosition.vec3_copy(characterCollisionResults.myTeleportResults.myInitialTeleportTransformQuat);
  outCollisionRuntimeParams.myFixedTeleportPosition.vec3_copy(characterCollisionResults.myTeleportResults.myFinalTeleportTransformQuat);
  outCollisionRuntimeParams.myTeleportCanceled = characterCollisionResults.myTeleportResults.myTeleportFailed;
  outCollisionRuntimeParams.myIsPositionOk = characterCollisionResults.myCheckTransformResults.myCheckTransformFailed;
  characterCollisionResults.myCheckTransformResults.myInitialCheckTransformQuat.quat2_getPosition(outCollisionRuntimeParams.myOriginalPositionCheckPosition);
  characterCollisionResults.myCheckTransformResults.myFinalCheckTransformQuat.quat2_getPosition(outCollisionRuntimeParams.myFixedPositionCheckPosition);
  outCollisionRuntimeParams.myIsTeleport = characterCollisionResults.myCheckType == CharacterCollisionCheckType.CHECK_TELEPORT;
  outCollisionRuntimeParams.myIsMove = characterCollisionResults.myCheckType == CharacterCollisionCheckType.CHECK_MOVEMENT;
  outCollisionRuntimeParams.myIsPositionCheck = characterCollisionResults.myCheckType == CharacterCollisionCheckType.CHECK_TRANSFORM;
  outCollisionRuntimeParams.mySplitMovementSteps = characterCollisionResults.mySplitMovementResults.myStepsToPerform;
  outCollisionRuntimeParams.mySplitMovementStepsPerformed = characterCollisionResults.mySplitMovementResults.myStepsPerformed;
  outCollisionRuntimeParams.mySplitMovementStop = characterCollisionResults.mySplitMovementResults.myMovementInterrupted;
  outCollisionRuntimeParams.mySplitMovementReduced = characterCollisionResults.mySplitMovementResults.myMovementReduced;
  outCollisionRuntimeParams.mySplitMovementLastStepLongerThanMaxLength = characterCollisionResults.mySplitMovementResults.myLastStepLongerThanMaxStepLength;
  outCollisionRuntimeParams.mySplitMovementMovementChecked.vec3_copy(characterCollisionResults.mySplitMovementResults.myMovementChecked);
  return outCollisionRuntimeParams;
}
var convertCollisionRuntimeParamsToCharacterCollisionResults = function() {
  let rotationQuat = quat_create();
  return function convertCollisionRuntimeParamsToCharacterCollisionResults2(collisionRuntimeParams, currentTransformQuat, outCharacterCollisionResults = new CharacterCollisionResults()) {
    outCharacterCollisionResults.reset();
    if (collisionRuntimeParams.myIsMove) {
      outCharacterCollisionResults.myCheckType = CharacterCollisionCheckType.CHECK_MOVEMENT;
    } else if (collisionRuntimeParams.myIsTeleport) {
      outCharacterCollisionResults.myCheckType = CharacterCollisionCheckType.CHECK_TELEPORT;
    } else if (collisionRuntimeParams.myIsPositionCheck) {
      outCharacterCollisionResults.myCheckType = CharacterCollisionCheckType.CHECK_TRANSFORM;
    }
    rotationQuat.quat_setForward(collisionRuntimeParams.myOriginalForward, collisionRuntimeParams.myOriginalUp);
    outCharacterCollisionResults.myTransformResults.myInitialTransformQuat.quat2_setPositionRotationQuat(collisionRuntimeParams.myOriginalPosition, rotationQuat);
    outCharacterCollisionResults.myTransformResults.myFinalTransformQuat.quat2_setPositionRotationQuat(collisionRuntimeParams.myNewPosition, rotationQuat);
    outCharacterCollisionResults.myMovementResults.myInitialMovement.vec3_copy(collisionRuntimeParams.myOriginalMovement);
    outCharacterCollisionResults.myMovementResults.myFinalMovement.vec3_copy(collisionRuntimeParams.myFixedMovement);
    outCharacterCollisionResults.myMovementResults.myMovementFailed = collisionRuntimeParams.myHorizontalMovementCanceled && collisionRuntimeParams.myVerticalMovementCanceled;
    outCharacterCollisionResults.myMovementResults.myMovementCollided = collisionRuntimeParams.myIsCollidingHorizontally || collisionRuntimeParams.myIsCollidingVertically;
    if (collisionRuntimeParams.myIsCollidingHorizontally) {
      outCharacterCollisionResults.myMovementResults.myReferenceCollisionHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
    } else if (collisionRuntimeParams.myIsCollidingVertically) {
      outCharacterCollisionResults.myMovementResults.myReferenceCollisionHit.copy(collisionRuntimeParams.myVerticalCollisionHit);
    }
    outCharacterCollisionResults.myHorizontalMovementResults.myMovementFailed = collisionRuntimeParams.myHorizontalMovementCanceled;
    outCharacterCollisionResults.myHorizontalMovementResults.myMovementCollided = collisionRuntimeParams.myIsCollidingHorizontally;
    outCharacterCollisionResults.myHorizontalMovementResults.myReferenceCollisionHit.copy(collisionRuntimeParams.myHorizontalCollisionHit);
    outCharacterCollisionResults.myHorizontalMovementResults.myInitialMovement = collisionRuntimeParams.myOriginalMovement.vec3_removeComponentAlongAxis(collisionRuntimeParams.myOffsetUp, outCharacterCollisionResults.myHorizontalMovementResults.myInitialMovement);
    outCharacterCollisionResults.myHorizontalMovementResults.myFinalMovement = collisionRuntimeParams.myFixedMovement.vec3_removeComponentAlongAxis(collisionRuntimeParams.myOffsetUp, outCharacterCollisionResults.myHorizontalMovementResults.myFinalMovement);
    outCharacterCollisionResults.myVerticalMovementResults.myMovementFailed = collisionRuntimeParams.myVerticalMovementCanceled;
    outCharacterCollisionResults.myVerticalMovementResults.myMovementCollided = collisionRuntimeParams.myIsCollidingVertically;
    outCharacterCollisionResults.myVerticalMovementResults.myReferenceCollisionHit.copy(collisionRuntimeParams.myVerticalCollisionHit);
    outCharacterCollisionResults.myVerticalMovementResults.myInitialMovement = collisionRuntimeParams.myOriginalMovement.vec3_componentAlongAxis(collisionRuntimeParams.myOffsetUp, outCharacterCollisionResults.myVerticalMovementResults.myInitialMovement);
    outCharacterCollisionResults.myVerticalMovementResults.myFinalMovement = collisionRuntimeParams.myFixedMovement.vec3_componentAlongAxis(collisionRuntimeParams.myOffsetUp, outCharacterCollisionResults.myVerticalMovementResults.myFinalMovement);
    outCharacterCollisionResults.myTeleportResults.myInitialTeleportTransformQuat.quat2_copy(outCharacterCollisionResults.myTransformResults.myInitialTransformQuat);
    outCharacterCollisionResults.myTeleportResults.myInitialTeleportTransformQuat.quat2_setPosition(collisionRuntimeParams.myOriginalTeleportPosition);
    outCharacterCollisionResults.myTeleportResults.myFinalTeleportTransformQuat.quat2_copy(outCharacterCollisionResults.myTransformResults.myFinalTransformQuat);
    outCharacterCollisionResults.myTeleportResults.myFinalTeleportTransformQuat.quat2_setPosition(collisionRuntimeParams.myFixedTeleportPosition);
    outCharacterCollisionResults.myTeleportResults.myTeleportFailed = collisionRuntimeParams.myTeleportCanceled;
    outCharacterCollisionResults.myCheckTransformResults.myInitialCheckTransformQuat.quat2_copy(outCharacterCollisionResults.myTransformResults.myInitialTransformQuat);
    outCharacterCollisionResults.myCheckTransformResults.myInitialCheckTransformQuat.quat2_setPosition(collisionRuntimeParams.myOriginalPositionCheckPosition);
    outCharacterCollisionResults.myCheckTransformResults.myFinalCheckTransformQuat.quat2_copy(outCharacterCollisionResults.myTransformResults.myFinalTransformQuat);
    outCharacterCollisionResults.myCheckTransformResults.myFinalCheckTransformQuat.quat2_setPosition(collisionRuntimeParams.myFixedPositionCheckPosition);
    outCharacterCollisionResults.myCheckTransformResults.myCheckTransformFailed = !collisionRuntimeParams.myIsPositionOk;
    outCharacterCollisionResults.myWallSlideResults.myHasSlid = collisionRuntimeParams.myIsSliding;
    outCharacterCollisionResults.myWallSlideResults.mySlideMovementAngle = collisionRuntimeParams.mySlidingMovementAngle;
    outCharacterCollisionResults.myWallSlideResults.mySlideMovementWallAngle = collisionRuntimeParams.mySlidingCollisionAngle;
    outCharacterCollisionResults.myWallSlideResults.myWallNormal.vec3_copy(collisionRuntimeParams.mySlidingWallNormal);
    outCharacterCollisionResults.myGroundInfo.myOnSurface = collisionRuntimeParams.myIsOnGround;
    outCharacterCollisionResults.myGroundInfo.mySurfaceReferenceCollisionHit.copy(collisionRuntimeParams.myGroundCollisionHit);
    outCharacterCollisionResults.myGroundInfo.mySurfaceAngle = collisionRuntimeParams.myGroundAngle;
    outCharacterCollisionResults.myGroundInfo.mySurfacePerceivedAngle = collisionRuntimeParams.myGroundPerceivedAngle;
    outCharacterCollisionResults.myGroundInfo.mySurfaceNormal.vec3_copy(collisionRuntimeParams.myGroundNormal);
    outCharacterCollisionResults.myGroundInfo.mySurfaceHitMaxAngle = collisionRuntimeParams.myGroundHitMaxAngle;
    outCharacterCollisionResults.myGroundInfo.mySurfaceHitMaxNormal.vec3_copy(collisionRuntimeParams.myGroundHitMaxNormal);
    outCharacterCollisionResults.myGroundInfo.mySurfaceDistance = collisionRuntimeParams.myGroundDistance;
    outCharacterCollisionResults.myGroundInfo.myBaseInsideCollision = collisionRuntimeParams.myGroundIsBaseInsideCollision;
    outCharacterCollisionResults.myCeilingInfo.myOnSurface = collisionRuntimeParams.myIsOnCeiling;
    outCharacterCollisionResults.myCeilingInfo.mySurfaceReferenceCollisionHit.copy(collisionRuntimeParams.myCeilingCollisionHit);
    outCharacterCollisionResults.myCeilingInfo.mySurfaceAngle = collisionRuntimeParams.myCeilingAngle;
    outCharacterCollisionResults.myCeilingInfo.mySurfacePerceivedAngle = collisionRuntimeParams.myCeilingPerceivedAngle;
    outCharacterCollisionResults.myCeilingInfo.mySurfaceNormal.vec3_copy(collisionRuntimeParams.myCeilingNormal);
    outCharacterCollisionResults.myCeilingInfo.mySurfaceHitMaxAngle = collisionRuntimeParams.myCeilingHitMaxAngle;
    outCharacterCollisionResults.myCeilingInfo.mySurfaceHitMaxNormal.vec3_copy(collisionRuntimeParams.myCeilingHitMaxNormal);
    outCharacterCollisionResults.myCeilingInfo.mySurfaceDistance = collisionRuntimeParams.myCeilingDistance;
    outCharacterCollisionResults.myCeilingInfo.myBaseInsideCollision = collisionRuntimeParams.myCeilingIsBaseInsideCollision;
    outCharacterCollisionResults.myGroundResults.myHasSnappedOnSurface = collisionRuntimeParams.myHasSnappedOnGround;
    outCharacterCollisionResults.myGroundResults.myHasPoppedOutSurface = collisionRuntimeParams.myHasPoppedOutGround;
    outCharacterCollisionResults.myCeilingResults.myHasSnappedOnSurface = collisionRuntimeParams.myHasSnappedOnCeiling;
    outCharacterCollisionResults.myCeilingResults.myHasPoppedOutSurface = collisionRuntimeParams.myHasPoppedOutCeiling;
    outCharacterCollisionResults.myGroundResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill = collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleDownhill;
    outCharacterCollisionResults.myGroundResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill = collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverGroundPerceivedAngleUphill;
    outCharacterCollisionResults.myGroundResults.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill = collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverGroundAngleDownhill;
    outCharacterCollisionResults.myCeilingResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleDownhill = collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleDownhill;
    outCharacterCollisionResults.myCeilingResults.myHasHorizontalMovementAdjustedVerticalMovementOverSurfacePerceivedAngleUphill = collisionRuntimeParams.myHorizontalMovementHasAdjustedVerticalMovementOverCeilingPerceivedAngleUphill;
    outCharacterCollisionResults.myCeilingResults.myHasVerticalMovementAdjustedHorizontalMovementOverSurfaceAngleDownhill = collisionRuntimeParams.myVerticalMovementHasAdjustedHorizontalMovementOverCeilingAngleDownhill;
    outCharacterCollisionResults.mySplitMovementResults.myStepsToPerform = collisionRuntimeParams.mySplitMovementSteps;
    outCharacterCollisionResults.mySplitMovementResults.myStepsPerformed = collisionRuntimeParams.mySplitMovementStepsPerformed;
    outCharacterCollisionResults.mySplitMovementResults.myMovementInterrupted = collisionRuntimeParams.mySplitMovementStop;
    outCharacterCollisionResults.mySplitMovementResults.myMovementReduced = collisionRuntimeParams.mySplitMovementReduced;
    outCharacterCollisionResults.mySplitMovementResults.myLastStepLongerThanMaxStepLength = collisionRuntimeParams.mySplitMovementLastStepLongerThanMaxLength;
    outCharacterCollisionResults.mySplitMovementResults.myMovementChecked.vec3_copy(collisionRuntimeParams.mySplitMovementMovementChecked);
    outCharacterCollisionResults.myInternalResults.myLastRelevantInitialHorizontalMovement.vec3_copy(collisionRuntimeParams.myLastValidOriginalHorizontalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantFinalHorizontalMovement.vec3_copy(collisionRuntimeParams.myLastValidEndHorizontalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantInitialVerticalMovement.vec3_copy(collisionRuntimeParams.myLastValidOriginalVerticalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantFinalVerticalMovement.vec3_copy(collisionRuntimeParams.myLastValidEndVerticalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantAdjustedInitialHorizontalMovement.vec3_copy(collisionRuntimeParams.myLastValidSurfaceAdjustedHorizontalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantAdjustedInitialVerticalMovement.vec3_copy(collisionRuntimeParams.myLastValidSurfaceAdjustedVerticalMovement);
    outCharacterCollisionResults.myInternalResults.myLastRelevantHasWallSlid = collisionRuntimeParams.myLastValidIsSliding;
    outCharacterCollisionResults.myInternalResults.myHasWallSlidTowardOppositeDirection = collisionRuntimeParams.myIsSlidingIntoOppositeDirection;
    outCharacterCollisionResults.myInternalResults.myLastRelevantWallSlideFlickerPrevented = collisionRuntimeParams.myIsSlidingFlickerPrevented;
    outCharacterCollisionResults.myInternalResults.myWallSlideFlickerPreventionForceCheckCounter = collisionRuntimeParams.mySlidingFlickerPreventionCheckAnywayCounter;
    outCharacterCollisionResults.myInternalResults.myWallSlide90DegreesDirectionSign = collisionRuntimeParams.mySliding90DegreesSign;
    outCharacterCollisionResults.myInternalResults.myWallSlide90DegreesRecomputeDirectionSign = collisionRuntimeParams.mySlidingRecompute90DegreesSign;
    outCharacterCollisionResults.myTransformResults.myInitialTransformQuat.quat2_copy(currentTransformQuat);
    return outCharacterCollisionResults;
  };
}();
var convertCharacterColliderSetupToCollisionCheckParams = /* @__PURE__ */ function() {
  return function convertCharacterColliderSetupToCollisionCheckParams2(characterColliderSetup, outCollisionCheckParams = new CollisionCheckParams()) {
    outCollisionCheckParams.myHeight = characterColliderSetup.myHeight;
    outCollisionCheckParams.myRadius = characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeRadius;
    outCollisionCheckParams.myDistanceFromFeetToIgnore = characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckFeetDistanceToIgnore;
    outCollisionCheckParams.myDistanceFromHeadToIgnore = characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckHeadDistanceToIgnore;
    outCollisionCheckParams.myHorizontalMovementCheckEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementStepEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckSplitMovementEnabled;
    outCollisionCheckParams.myHorizontalMovementStepMaxLength = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckSplitMovementMaxStepLength == null ? 0 : characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckSplitMovementMaxStepLength;
    outCollisionCheckParams.myHorizontalMovementRadialStepAmount = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckRadialSteps;
    outCollisionCheckParams.myHorizontalMovementCheckDiagonalOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckDiagonalInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckStraight = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalStraightCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckHorizontalBorder = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalRadialCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalStraight = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalDiagonalUpwardInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalDiagonalDownwardOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalDiagonalDownwardInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalStraightDiagonalUpward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalStraightDiagonalDownward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalRadialDiagonalOutwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementCheckVerticalHorizontalBorderDiagonalInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalRadialDiagonalInwardCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementHorizontalStraightCentralCheckEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalStraightCentralCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementVerticalStraightCentralCheckEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightCentralCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled;
    outCollisionCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled;
    outCollisionCheckParams.myHorizontalPositionCheckEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckEnabled;
    outCollisionCheckParams.myHalfConeAngle = characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeHalfAngle;
    outCollisionCheckParams.myHalfConeSliceAmount = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckConeHalfSlices;
    outCollisionCheckParams.myCheckConeBorder = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHorizontalBorderCheckEnabled;
    outCollisionCheckParams.myCheckConeRay = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHorizontalRadialCheckEnabled;
    outCollisionCheckParams.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision;
    outCollisionCheckParams.myHorizontalPositionCheckVerticalDirectionType = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckDirection;
    outCollisionCheckParams.myCheckHeight = characterColliderSetup.myHorizontalCheckParams.myHorizontalHeightCheckEnabled;
    outCollisionCheckParams.myCheckHeightVerticalMovement = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightVerticalCheckEnabled;
    outCollisionCheckParams.myCheckHeightVerticalPosition = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightVerticalCheckEnabled;
    outCollisionCheckParams.myCheckHeightTopMovement = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightHorizontalCheckEnabled;
    outCollisionCheckParams.myCheckHeightTopPosition = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightHorizontalCheckEnabled;
    outCollisionCheckParams.myCheckHeightConeOnCollision = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit;
    outCollisionCheckParams.myCheckHeightConeOnCollisionKeepHit = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit;
    outCollisionCheckParams.myHeightCheckStepAmountMovement = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightCheckSteps;
    outCollisionCheckParams.myHeightCheckStepAmountPosition = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightCheckSteps;
    outCollisionCheckParams.myCheckVerticalStraight = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalStraightCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalRayOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalRayInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalRadialDiagonalInwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalBorderOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalBorderInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalBorderDiagonalInwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalBorderRayOutward = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalRadialBorderDiagonalOutwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalDiagonalBorderRayInward = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalRadialBorderDiagonalInwardCheckEnabled;
    outCollisionCheckParams.myCheckVerticalSearchFartherVerticalHit = characterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckGetFarthestHit;
    outCollisionCheckParams.myCheckHorizontalFixedForwardEnabled = characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckFixedForwardEnabled;
    outCollisionCheckParams.myCheckHorizontalFixedForward.vec3_copy(characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckFixedForward);
    outCollisionCheckParams.myVerticalMovementCheckEnabled = characterColliderSetup.myVerticalCheckParams.myVerticalMovementCheckEnabled;
    outCollisionCheckParams.myVerticalPositionCheckEnabled = characterColliderSetup.myVerticalCheckParams.myVerticalPositionCheckEnabled;
    outCollisionCheckParams.myFeetRadius = characterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadius;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhill = characterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphill = characterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxAngle = characterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfaceAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxAngle = characterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfaceAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleDownhillMaxPerceivedAngle = characterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithGroundAngleUphillMaxPerceivedAngle = characterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle;
    outCollisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhill = characterColliderSetup.myGroundParams.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhill;
    outCollisionCheckParams.myAdjustHorizontalMovementWithGroundAngleDownhillMinAngle = characterColliderSetup.myGroundParams.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhillMinSurfaceAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhill = characterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphill = characterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxAngle = characterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfaceAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxAngle = characterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfaceAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleDownhillMaxPerceivedAngle = characterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle;
    outCollisionCheckParams.myAdjustVerticalMovementWithCeilingAngleUphillMaxPerceivedAngle = characterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle;
    outCollisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhill = characterColliderSetup.myCeilingParams.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhill;
    outCollisionCheckParams.myAdjustHorizontalMovementWithCeilingAngleDownhillMinAngle = characterColliderSetup.myCeilingParams.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhillMinSurfaceAngle;
    outCollisionCheckParams.myCheckVerticalFixedForwardEnabled = characterColliderSetup.myVerticalCheckParams.myVerticalCheckFixedForwardEnabled;
    outCollisionCheckParams.myCheckVerticalFixedForward.vec3_copy(characterColliderSetup.myVerticalCheckParams.myVerticalCheckFixedForward);
    outCollisionCheckParams.myCheckVerticalBothDirection = characterColliderSetup.myVerticalCheckParams.myVerticalMovementCheckPerformCheckOnBothSides;
    outCollisionCheckParams.myCheckVerticalPositionBothDirection = characterColliderSetup.myVerticalCheckParams.myVerticalPositionCheckPerformCheckOnBothSides;
    outCollisionCheckParams.myVerticalMovementReduceEnabled = characterColliderSetup.myVerticalCheckParams.myVerticalMovementCheckReductionEnabled;
    outCollisionCheckParams.myGroundCircumferenceAddCenter = characterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceCentralCheckEnabled;
    outCollisionCheckParams.myGroundCircumferenceSliceAmount = characterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices;
    outCollisionCheckParams.myGroundCircumferenceStepAmount = characterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadialSteps;
    outCollisionCheckParams.myGroundCircumferenceRotationPerStep = characterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRotationPerRadialStep;
    outCollisionCheckParams.myVerticalAllowHitInsideCollisionIfOneOk = characterColliderSetup.myVerticalCheckParams.myVerticalCheckAllowHitsInsideCollisionIfOneValid;
    outCollisionCheckParams.myHorizontalBlockLayerFlags.copy(characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckBlockLayerFlags);
    outCollisionCheckParams.myVerticalBlockLayerFlags.copy(characterColliderSetup.myVerticalCheckParams.myVerticalCheckBlockLayerFlags);
    outCollisionCheckParams.myHorizontalObjectsToIgnore.pp_copy(characterColliderSetup.myHorizontalCheckParams.myHorizontalCheckObjectsToIgnore);
    outCollisionCheckParams.myVerticalObjectsToIgnore.pp_copy(characterColliderSetup.myVerticalCheckParams.myVerticalCheckObjectsToIgnore);
    outCollisionCheckParams.myHorizontalBlockColliderType = characterColliderSetup.myHorizontalCheckParams.myHorizontalBlockColliderType;
    outCollisionCheckParams.myVerticalBlockColliderType = characterColliderSetup.myVerticalCheckParams.myVerticalBlockColliderType;
    outCollisionCheckParams.mySnapOnGroundEnabled = characterColliderSetup.myGroundParams.mySurfaceSnapMaxDistance > 0;
    outCollisionCheckParams.mySnapOnGroundExtraDistance = characterColliderSetup.myGroundParams.mySurfaceSnapMaxDistance;
    outCollisionCheckParams.mySnapOnCeilingEnabled = characterColliderSetup.myCeilingParams.mySurfaceSnapMaxDistance > 0;
    outCollisionCheckParams.mySnapOnCeilingExtraDistance = characterColliderSetup.myCeilingParams.mySurfaceSnapMaxDistance;
    outCollisionCheckParams.myGroundPopOutEnabled = characterColliderSetup.myGroundParams.mySurfacePopOutMaxDistance > 0;
    outCollisionCheckParams.myGroundPopOutExtraDistance = characterColliderSetup.myGroundParams.mySurfacePopOutMaxDistance;
    outCollisionCheckParams.myCeilingPopOutEnabled = characterColliderSetup.myCeilingParams.mySurfacePopOutMaxDistance > 0;
    outCollisionCheckParams.myCeilingPopOutExtraDistance = characterColliderSetup.myCeilingParams.mySurfacePopOutMaxDistance;
    outCollisionCheckParams.myGroundAngleToIgnore = characterColliderSetup.myGroundParams.mySurfaceAngleToIgnore;
    outCollisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle = characterColliderSetup.myGroundParams.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle;
    outCollisionCheckParams.myCeilingAngleToIgnore = characterColliderSetup.myCeilingParams.mySurfaceAngleToIgnore;
    outCollisionCheckParams.myCeilingAngleToIgnoreWithPerceivedAngle = characterColliderSetup.myCeilingParams.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle;
    outCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreHeight = characterColliderSetup.myGroundParams.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance;
    outCollisionCheckParams.myHorizontalMovementCeilingAngleIgnoreHeight = characterColliderSetup.myCeilingParams.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance;
    outCollisionCheckParams.myHorizontalPositionGroundAngleIgnoreHeight = characterColliderSetup.myGroundParams.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance;
    outCollisionCheckParams.myHorizontalPositionCeilingAngleIgnoreHeight = characterColliderSetup.myCeilingParams.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance;
    outCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = characterColliderSetup.myGroundParams.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft;
    outCollisionCheckParams.myHorizontalMovementCeilingAngleIgnoreMaxMovementLeft = characterColliderSetup.myCeilingParams.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft;
    outCollisionCheckParams.myComputeGroundInfoEnabled = characterColliderSetup.myGroundParams.myCollectSurfaceInfo;
    outCollisionCheckParams.myComputeCeilingInfoEnabled = characterColliderSetup.myCeilingParams.myCollectSurfaceInfo;
    outCollisionCheckParams.myDistanceToBeOnGround = characterColliderSetup.myGroundParams.myOnSurfaceMaxOutsideDistance;
    outCollisionCheckParams.myDistanceToComputeGroundInfo = characterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxOutsideDistance;
    outCollisionCheckParams.myDistanceToBeOnCeiling = characterColliderSetup.myCeilingParams.myOnSurfaceMaxOutsideDistance;
    outCollisionCheckParams.myDistanceToComputeCeilingInfo = characterColliderSetup.myCeilingParams.myCollectSurfaceNormalMaxOutsideDistance;
    outCollisionCheckParams.myVerticalFixToBeOnGround = characterColliderSetup.myGroundParams.myOnSurfaceMaxInsideDistance;
    outCollisionCheckParams.myVerticalFixToComputeGroundInfo = characterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxInsideDistance;
    outCollisionCheckParams.myVerticalFixToBeOnCeiling = characterColliderSetup.myCeilingParams.myOnSurfaceMaxInsideDistance;
    outCollisionCheckParams.myVerticalFixToComputeCeilingInfo = characterColliderSetup.myCeilingParams.myCollectSurfaceNormalMaxInsideDistance;
    outCollisionCheckParams.myGroundIsBaseInsideCollisionCheckEnabled = characterColliderSetup.myGroundParams.myBaseInsideCollisionCheckEnabled;
    outCollisionCheckParams.myCeilingIsBaseInsideCollisionCheckEnabled = characterColliderSetup.myCeilingParams.myBaseInsideCollisionCheckEnabled;
    outCollisionCheckParams.myIsOnGroundIfInsideHit = characterColliderSetup.myGroundParams.myOnSurfaceIfBaseInsideCollision;
    outCollisionCheckParams.myIsOnCeilingIfInsideHit = characterColliderSetup.myCeilingParams.myOnSurfaceIfBaseInsideCollision;
    outCollisionCheckParams.myFindGroundDistanceMaxOutsideDistance = characterColliderSetup.myGroundParams.myCollectSurfaceDistanceOutsideDistance;
    outCollisionCheckParams.myFindGroundDistanceMaxInsideDistance = characterColliderSetup.myGroundParams.myCollectSurfaceDistanceInsideDistance;
    outCollisionCheckParams.myFindCeilingDistanceMaxOutsideDistance = characterColliderSetup.myCeilingParams.myCollectSurfaceDistanceOutsideDistance;
    outCollisionCheckParams.myFindCeilingDistanceMaxInsideDistance = characterColliderSetup.myCeilingParams.myCollectSurfaceDistanceInsideDistance;
    outCollisionCheckParams.myCollectGroundCollisionHitOutsideDistance = characterColliderSetup.myGroundParams.myCollectSurfaceCollisionHitOutsideDistance;
    outCollisionCheckParams.myCollectGroundCollisionHitInsideDistance = characterColliderSetup.myGroundParams.myCollectSurfaceCollisionHitInsideDistance;
    outCollisionCheckParams.myCollectCeilingCollisionHitOutsideDistance = characterColliderSetup.myCeilingParams.myCollectSurfaceCollisionHitOutsideDistance;
    outCollisionCheckParams.myCollectCeilingCollisionHitInsideDistance = characterColliderSetup.myCeilingParams.myCollectSurfaceCollisionHitInsideDistance;
    outCollisionCheckParams.myAllowGroundSteepFix = characterColliderSetup.myGroundParams.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle;
    outCollisionCheckParams.myAllowCeilingSteepFix = characterColliderSetup.myCeilingParams.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle;
    outCollisionCheckParams.myMustStayOnGround = characterColliderSetup.myGroundParams.myMovementMustStayOnSurface;
    outCollisionCheckParams.myMustStayOnCeiling = characterColliderSetup.myCeilingParams.myMovementMustStayOnSurface;
    outCollisionCheckParams.myRegatherGroundInfoOnSurfaceCheckFail = characterColliderSetup.myGroundParams.myRecollectSurfaceInfoOnSurfaceCheckFailed;
    outCollisionCheckParams.myRegatherCeilingInfoOnSurfaceCheckFail = characterColliderSetup.myCeilingParams.myRecollectSurfaceInfoOnSurfaceCheckFailed;
    outCollisionCheckParams.myMustStayBelowIgnorableGroundAngleDownhill = characterColliderSetup.myGroundParams.myMovementMustStayOnIgnorableSurfaceAngleDownhill;
    outCollisionCheckParams.myMustStayBelowIgnorableCeilingAngleDownhill = characterColliderSetup.myCeilingParams.myMovementMustStayOnIgnorableSurfaceAngleDownhill;
    outCollisionCheckParams.myMustStayBelowGroundAngleDownhill = characterColliderSetup.myGroundParams.myMovementMustStayOnSurfaceAngleDownhill;
    outCollisionCheckParams.myMustStayBelowCeilingAngleDownhill = characterColliderSetup.myCeilingParams.myMovementMustStayOnSurfaceAngleDownhill;
    outCollisionCheckParams.myMovementMustStayOnGroundHitAngle = characterColliderSetup.myGroundParams.myMovementMustStayOnSurfaceHitMaxAngle;
    outCollisionCheckParams.myMovementMustStayOnCeilingHitAngle = characterColliderSetup.myCeilingParams.myMovementMustStayOnSurfaceHitMaxAngle;
    outCollisionCheckParams.myTeleportMustBeOnIgnorableGroundAngle = characterColliderSetup.myGroundParams.myTeleportMustBeOnIgnorableSurfaceAngle;
    outCollisionCheckParams.myCheckTransformMustBeOnIgnorableGroundAngle = characterColliderSetup.myGroundParams.myCheckTransformMustBeOnIgnorableSurfaceAngle;
    outCollisionCheckParams.myTeleportMustBeOnIgnorableCeilingAngle = characterColliderSetup.myCeilingParams.myTeleportMustBeOnIgnorableSurfaceAngle;
    outCollisionCheckParams.myCheckTransformMustBeOnIgnorableCeilingAngle = characterColliderSetup.myCeilingParams.myCheckTransformMustBeOnIgnorableSurfaceAngle;
    outCollisionCheckParams.myTeleportMustBeOnGroundAngle = characterColliderSetup.myGroundParams.myTeleportMustBeOnSurfaceAngle;
    outCollisionCheckParams.myCheckTransformMustBeOnGroundAngle = characterColliderSetup.myGroundParams.myCheckTransformMustBeOnSurfaceAngle;
    outCollisionCheckParams.myTeleportMustBeOnCeilingAngle = characterColliderSetup.myCeilingParams.myTeleportMustBeOnSurfaceAngle;
    outCollisionCheckParams.myCheckTransformMustBeOnCeilingAngle = characterColliderSetup.myCeilingParams.myCheckTransformMustBeOnSurfaceAngle;
    outCollisionCheckParams.myTeleportMustBeOnGround = characterColliderSetup.myGroundParams.myTeleportMustBeOnSurface;
    outCollisionCheckParams.myCheckTransformMustBeOnGround = characterColliderSetup.myGroundParams.myCheckTransformMustBeOnSurface;
    outCollisionCheckParams.myTeleportMustBeOnCeiling = characterColliderSetup.myCeilingParams.myTeleportMustBeOnSurface;
    outCollisionCheckParams.myCheckTransformMustBeOnCeiling = characterColliderSetup.myCeilingParams.myCheckTransformMustBeOnSurface;
    outCollisionCheckParams.mySlidingEnabled = characterColliderSetup.myWallSlideParams.myWallSlideEnabled;
    outCollisionCheckParams.mySlidingHorizontalMovementCheckBetterNormal = characterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckGetBetterReferenceHit;
    outCollisionCheckParams.mySlidingMaxAttempts = characterColliderSetup.myWallSlideParams.myWallSlideMaxAttempts;
    outCollisionCheckParams.mySlidingCheckBothDirections = characterColliderSetup.myWallSlideParams.myCheckBothWallSlideDirections;
    outCollisionCheckParams.mySlidingFlickeringPreventionType = characterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionMode;
    outCollisionCheckParams.mySlidingFlickeringPreventionCheckOnlyIfAlreadySliding = characterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding;
    outCollisionCheckParams.mySlidingFlickerPreventionCheckAnywayCounter = characterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionForceCheckCounter;
    outCollisionCheckParams.mySlidingAdjustSign90Degrees = characterColliderSetup.myWallSlideParams.my90DegreesWallSlideAdjustDirectionSign;
    outCollisionCheckParams.mySplitMovementEnabled = characterColliderSetup.mySplitMovementParams.mySplitMovementEnabled;
    outCollisionCheckParams.mySplitMovementMaxLength = characterColliderSetup.mySplitMovementParams.mySplitMovementMaxStepLength == null ? 0 : characterColliderSetup.mySplitMovementParams.mySplitMovementMaxStepLength;
    outCollisionCheckParams.mySplitMovementMaxLengthEnabled = characterColliderSetup.mySplitMovementParams.mySplitMovementMaxStepLength != null;
    outCollisionCheckParams.mySplitMovementMaxLengthLastStepCanBeLonger = characterColliderSetup.mySplitMovementParams.mySplitMovementLastStepCanBeLongerThanMaxStepLength;
    outCollisionCheckParams.mySplitMovementMaxSteps = characterColliderSetup.mySplitMovementParams.mySplitMovementMaxSteps == null ? 0 : characterColliderSetup.mySplitMovementParams.mySplitMovementMaxSteps;
    outCollisionCheckParams.mySplitMovementMaxStepsEnabled = characterColliderSetup.mySplitMovementParams.mySplitMovementMaxSteps != null;
    outCollisionCheckParams.mySplitMovementMinLength = characterColliderSetup.mySplitMovementParams.mySplitMovementMinStepLength == null ? 0 : characterColliderSetup.mySplitMovementParams.mySplitMovementMinStepLength;
    outCollisionCheckParams.mySplitMovementMinLengthEnabled = characterColliderSetup.mySplitMovementParams.mySplitMovementMinStepLength != null;
    outCollisionCheckParams.mySplitMovementStopWhenHorizontalMovementCanceled = characterColliderSetup.mySplitMovementParams.mySplitMovementStopOnHorizontalMovementFailed;
    outCollisionCheckParams.mySplitMovementStopAndFailIfMovementWouldBeReduced = characterColliderSetup.mySplitMovementParams.mySplitMovementStopAndFailIfMovementWouldBeReduced;
    outCollisionCheckParams.mySplitMovementStopWhenVerticalMovementCanceled = characterColliderSetup.mySplitMovementParams.mySplitMovementStopOnVerticalMovementFailed;
    outCollisionCheckParams.mySplitMovementStopWhenVerticalMovementReduced = characterColliderSetup.mySplitMovementParams.mySplitMovementStopOnVerticalMovementReduced;
    outCollisionCheckParams.mySplitMovementStopCallback = null;
    outCollisionCheckParams.mySplitMovementStopReturnPrevious = characterColliderSetup.mySplitMovementParams.mySplitMovementStopReturnPreviousResults;
    outCollisionCheckParams.myPositionOffsetLocal.vec3_copy(characterColliderSetup.myAdditionalParams.myPositionOffsetLocal);
    outCollisionCheckParams.myRotationOffsetLocalQuat.quat_copy(characterColliderSetup.myAdditionalParams.myRotationOffsetLocalQuat);
    outCollisionCheckParams.myDebugEnabled = characterColliderSetup.myDebugParams.myVisualDebugEnabled;
    outCollisionCheckParams.myDebugHorizontalMovementEnabled = characterColliderSetup.myDebugParams.myVisualDebugHorizontalMovementCheckEnabled;
    outCollisionCheckParams.myDebugHorizontalPositionEnabled = characterColliderSetup.myDebugParams.myVisualDebugHorizontalPositionCheckEnabled;
    outCollisionCheckParams.myDebugVerticalMovementEnabled = characterColliderSetup.myDebugParams.myVisualDebugVerticalMovementCheckEnabled;
    outCollisionCheckParams.myDebugVerticalPositionEnabled = characterColliderSetup.myDebugParams.myVisualDebugVerticalPositionCheckEnabled;
    outCollisionCheckParams.myDebugSlidingEnabled = characterColliderSetup.myDebugParams.myVisualDebugSlideEnabled;
    outCollisionCheckParams.myDebugGroundInfoEnabled = characterColliderSetup.myDebugParams.myVisualDebugGroundInfoEnabled;
    outCollisionCheckParams.myDebugCeilingInfoEnabled = characterColliderSetup.myDebugParams.myVisualDebugGroundInfoEnabled;
    outCollisionCheckParams.myDebugRuntimeParamsEnabled = characterColliderSetup.myDebugParams.myVisualDebugResultsEnabled;
    outCollisionCheckParams.myDebugMovementEnabled = characterColliderSetup.myDebugParams.myVisualDebugMovementEnabled;
    return outCollisionCheckParams;
  };
}();
var CollisionCheckBridge = {
  getCollisionCheck,
  setCollisionCheck,
  isCollisionCheckDisabled,
  setCollisionCheckDisabled,
  initBridge,
  checkMovement,
  checkTeleportToTransform,
  checkTransform,
  updateGroundInfo,
  updateCeilingInfo,
  convertCharacterCollisionResultsToCollisionRuntimeParams,
  convertCollisionRuntimeParamsToCharacterCollisionResults,
  convertCharacterColliderSetupToCollisionCheckParams
};

// dist/pp/gameplay/experimental/character_controller/collision/character_collision_system.js
var CharacterCollisionSystem = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myLastCheckRaycastsPerformed = 0;
    this._myCurrentFrameRaycastsPerformed = 0;
    this._myMaxFrameRaycastsPerformed = 0;
    this.myEngine = engine;
    CollisionCheckBridge.initBridge(this.myEngine);
  }
  update(dt) {
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    this._myCurrentFrameRaycastsPerformed = 0;
    CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts = 0;
  }
  checkMovement(movement, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    CollisionCheckBridge.checkMovement(movement, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults, this.myEngine);
    this._myLastCheckRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
    this._myCurrentFrameRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
  checkTeleportToPosition(teleportPosition, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
  }
  checkTeleportToTransform(teleportTransformQuat, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    CollisionCheckBridge.checkTeleportToTransform(teleportTransformQuat, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults, this.myEngine);
    this._myLastCheckRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
    this._myCurrentFrameRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
  checkTransform(checkTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    CollisionCheckBridge.checkTransform(checkTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults, this.myEngine);
    this._myLastCheckRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
    this._myCurrentFrameRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
  updateSurfaceInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    let currentFramePerformedRaycasts = this._myCurrentFrameRaycastsPerformed;
    this.updateGroundInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults);
    this.updateCeilingInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults);
    this._myLastCheckRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts - currentFramePerformedRaycasts;
    this._myCurrentFrameRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
  updateGroundInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    CollisionCheckBridge.updateGroundInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults, this.myEngine);
    this._myLastCheckRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
    this._myCurrentFrameRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
  updateCeilingInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults = new CharacterCollisionResults()) {
    CollisionCheckBridge.updateCeilingInfo(currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults, this.myEngine);
    this._myLastCheckRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts - this._myCurrentFrameRaycastsPerformed;
    this._myCurrentFrameRaycastsPerformed = CollisionCheckBridge.getCollisionCheck(this.myEngine)._myTotalRaycasts;
    this._myMaxFrameRaycastsPerformed = Math.max(this._myCurrentFrameRaycastsPerformed, this._myMaxFrameRaycastsPerformed);
    outCharacterCollisionResults.myDebugResults._myRaycastsPerformed = this._myLastCheckRaycastsPerformed;
  }
};
CharacterCollisionSystem.prototype.checkTeleportToPosition = function() {
  let teleportTransformQuat = quat2_create();
  return function checkTeleportToPosition(teleportPosition, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults) {
    teleportTransformQuat.quat2_copy(currentTransformQuat);
    teleportTransformQuat.quat2_setPosition(teleportPosition);
    this.checkTeleportToTransform(teleportTransformQuat, currentTransformQuat, characterColliderSetup, prevCharacterCollisionResults, outCharacterCollisionResults);
  };
}();

// dist/pp/gameplay/experimental/character_controller/collision/components/character_collision_system_component.js
var CharacterCollisionSystemComponent = class extends Component13 {
  static TypeName = "pp-character-collision-system";
  start() {
    this._myCharacterCollisionSystem = new CharacterCollisionSystem(this.engine);
  }
  update(dt) {
    if (Globals.getCharacterCollisionSystem(this.engine) == this._myCharacterCollisionSystem) {
      this._myCharacterCollisionSystem.update(dt);
    }
  }
  onActivate() {
    if (!Globals.hasCharacterCollisionSystem(this.engine)) {
      Globals.setCharacterCollisionSystem(this._myCharacterCollisionSystem, this.engine);
    }
  }
  onDeactivate() {
    if (this._myCharacterCollisionSystem != null && Globals.getCharacterCollisionSystem(this.engine) == this._myCharacterCollisionSystem) {
      Globals.removeCharacterCollisionSystem(this.engine);
    }
  }
};

// dist/pp/input/cauldron/components/input_manager_component.js
import { Component as Component14, Property as Property8 } from "@wonderlandengine/api";

// dist/pp/input/gamepad/gamepad.js
import { Emitter as Emitter4 } from "@wonderlandengine/api";

// dist/pp/input/gamepad/gamepad_buttons.js
var GamepadButtonID;
(function(GamepadButtonID2) {
  GamepadButtonID2[GamepadButtonID2["SELECT"] = 0] = "SELECT";
  GamepadButtonID2[GamepadButtonID2["SQUEEZE"] = 1] = "SQUEEZE";
  GamepadButtonID2[GamepadButtonID2["THUMBSTICK"] = 2] = "THUMBSTICK";
  GamepadButtonID2[GamepadButtonID2["TOP_BUTTON"] = 3] = "TOP_BUTTON";
  GamepadButtonID2[GamepadButtonID2["BOTTOM_BUTTON"] = 4] = "BOTTOM_BUTTON";
  GamepadButtonID2[GamepadButtonID2["LEFT_BUTTON"] = 5] = "LEFT_BUTTON";
  GamepadButtonID2[GamepadButtonID2["RIGHT_BUTTON"] = 6] = "RIGHT_BUTTON";
  GamepadButtonID2[GamepadButtonID2["MENU"] = 7] = "MENU";
  GamepadButtonID2[GamepadButtonID2["TOUCHPAD"] = 8] = "TOUCHPAD";
  GamepadButtonID2[GamepadButtonID2["THUMB_REST"] = 9] = "THUMB_REST";
})(GamepadButtonID || (GamepadButtonID = {}));
var GamepadButtonEvent;
(function(GamepadButtonEvent2) {
  GamepadButtonEvent2[GamepadButtonEvent2["PRESS_START"] = 0] = "PRESS_START";
  GamepadButtonEvent2[GamepadButtonEvent2["PRESS_END"] = 1] = "PRESS_END";
  GamepadButtonEvent2[GamepadButtonEvent2["PRESSED"] = 2] = "PRESSED";
  GamepadButtonEvent2[GamepadButtonEvent2["NOT_PRESSED"] = 3] = "NOT_PRESSED";
  GamepadButtonEvent2[GamepadButtonEvent2["TOUCH_START"] = 4] = "TOUCH_START";
  GamepadButtonEvent2[GamepadButtonEvent2["TOUCH_END"] = 5] = "TOUCH_END";
  GamepadButtonEvent2[GamepadButtonEvent2["TOUCHED"] = 6] = "TOUCHED";
  GamepadButtonEvent2[GamepadButtonEvent2["NOT_TOUCHED"] = 7] = "NOT_TOUCHED";
  GamepadButtonEvent2[GamepadButtonEvent2["VALUE_CHANGED"] = 8] = "VALUE_CHANGED";
  GamepadButtonEvent2[GamepadButtonEvent2["ALWAYS"] = 9] = "ALWAYS";
})(GamepadButtonEvent || (GamepadButtonEvent = {}));
var GamepadAxesID;
(function(GamepadAxesID2) {
  GamepadAxesID2[GamepadAxesID2["THUMBSTICK"] = 0] = "THUMBSTICK";
})(GamepadAxesID || (GamepadAxesID = {}));
var GamepadAxesEvent;
(function(GamepadAxesEvent2) {
  GamepadAxesEvent2[GamepadAxesEvent2["X_CHANGED"] = 0] = "X_CHANGED";
  GamepadAxesEvent2[GamepadAxesEvent2["Y_CHANGED"] = 1] = "Y_CHANGED";
  GamepadAxesEvent2[GamepadAxesEvent2["AXES_CHANGED"] = 2] = "AXES_CHANGED";
  GamepadAxesEvent2[GamepadAxesEvent2["ALWAYS"] = 3] = "ALWAYS";
})(GamepadAxesEvent || (GamepadAxesEvent = {}));
var GamepadButtonInfo = class _GamepadButtonInfo {
  myID;
  myHandedness;
  myPressed = false;
  myPrevIsPressed = false;
  myTouched = false;
  myPrevIsTouched = false;
  myValue = 0;
  myPrevValue = 0;
  myTimePressed = 0;
  myPrevTimePressed = 0;
  myTimeNotPressed = 0;
  myPrevTimeNotPressed = 0;
  myTimeTouched = 0;
  myPrevTimeTouched = 0;
  myTimeNotTouched = 0;
  myPrevTimeNotTouched = 0;
  myMultiplePressStartCount = 0;
  myPrevMultiplePressStartCount = 0;
  myMultiplePressEndCount = 0;
  myPrevMultiplePressEndCount = 0;
  myMultipleTouchStartCount = 0;
  myPrevMultipleTouchStartCount = 0;
  myMultipleTouchEndCount = 0;
  myPrevMultipleTouchEndCount = 0;
  constructor(id, handedness) {
    this.myID = id;
    this.myHandedness = handedness;
  }
  getID() {
    return this.myID;
  }
  getHandedness() {
    return this.myHandedness;
  }
  getValue() {
    return this.myValue;
  }
  isPressed() {
    return this.myPressed;
  }
  isTouched() {
    return this.myTouched;
  }
  isPressStart(multiplePressCount = null) {
    return this.myPressed && !this.myPrevIsPressed && (multiplePressCount == null || this.myMultiplePressStartCount == multiplePressCount);
  }
  isPressEnd(multiplePressCount = null) {
    return !this.myPressed && this.myPrevIsPressed && (multiplePressCount == null || this.myMultiplePressEndCount == multiplePressCount);
  }
  isTouchStart(multipleTouchCount = null) {
    return this.myTouched && !this.myPrevIsTouched && (multipleTouchCount == null || this.myMultipleTouchStartCount == multipleTouchCount);
  }
  isTouchEnd(multipleTouchCount = null) {
    return !this.myTouched && this.myPrevIsTouched && (multipleTouchCount == null || this.myMultipleTouchEndCount == multipleTouchCount);
  }
  reset() {
    this.myPressed = false;
    this.myPrevIsPressed = false;
    this.myTouched = false;
    this.myPrevIsTouched = false;
    this.myValue = 0;
    this.myPrevValue = 0;
    this.myTimePressed = 0;
    this.myPrevTimePressed = 0;
    this.myTimeNotPressed = 0;
    this.myPrevTimeNotPressed = 0;
    this.myTimeTouched = 0;
    this.myPrevTimeTouched = 0;
    this.myTimeNotTouched = 0;
    this.myPrevTimeNotTouched = 0;
    this.myMultiplePressStartCount = 0;
    this.myPrevMultiplePressStartCount = 0;
    this.myMultiplePressEndCount = 0;
    this.myPrevMultiplePressEndCount = 0;
    this.myMultipleTouchStartCount = 0;
    this.myPrevMultipleTouchStartCount = 0;
    this.myMultipleTouchEndCount = 0;
    this.myPrevMultipleTouchEndCount = 0;
  }
  clone() {
    const value = new _GamepadButtonInfo(this.myID, this.myHandedness);
    value.myPressed = this.myPressed;
    value.myPrevIsPressed = this.myPrevIsPressed;
    value.myTouched = this.myTouched;
    value.myPrevIsTouched = this.myPrevIsTouched;
    value.myValue = this.myValue;
    value.myPrevValue = this.myPrevValue;
    value.myTimePressed = this.myTimePressed;
    value.myPrevTimePressed = this.myPrevTimePressed;
    value.myTimeNotPressed = this.myTimeNotPressed;
    value.myPrevTimeNotPressed = this.myPrevTimeNotPressed;
    value.myTimeTouched = this.myTimeTouched;
    value.myPrevTimeTouched = this.myPrevTimeTouched;
    value.myTimeNotTouched = this.myTimeNotTouched;
    value.myPrevTimeNotTouched = this.myPrevTimeNotTouched;
    value.myMultiplePressStartCount = this.myMultiplePressStartCount;
    value.myPrevMultiplePressStartCount = this.myPrevMultiplePressStartCount;
    value.myMultiplePressEndCount = this.myMultiplePressEndCount;
    value.myPrevMultiplePressEndCount = this.myPrevMultiplePressEndCount;
    value.myMultipleTouchStartCount = this.myMultipleTouchStartCount;
    value.myPrevMultipleTouchStartCount = this.myPrevMultipleTouchStartCount;
    value.myMultipleTouchEndCount = this.myMultipleTouchEndCount;
    value.myPrevMultipleTouchEndCount = this.myPrevMultipleTouchEndCount;
    return value;
  }
};
var GamepadAxesInfo = class _GamepadAxesInfo {
  myID;
  myHandedness;
  /** `myAxes[0]` is X, `myAxes[1]` is Y */
  myAxes = vec2_create(0);
  /** `myPrevAxes[0]` is X, `myPrevAxes[1]` is Y */
  myPrevAxes = vec2_create(0);
  constructor(id, handedness) {
    this.myID = id;
    this.myHandedness = handedness;
  }
  getID() {
    return this.myID;
  }
  getAxes() {
    return this.myAxes;
  }
  getHandedness() {
    return this.myHandedness;
  }
  reset() {
    this.myAxes.vec2_zero();
    this.myPrevAxes.vec2_zero();
  }
  clone() {
    const value = new _GamepadAxesInfo(this.myID, this.myHandedness);
    value.myAxes.vec2_copy(this.myAxes);
    value.myPrevAxes.vec2_copy(this.myPrevAxes);
    return value;
  }
};
var GamepadPulseInfo = class _GamepadPulseInfo {
  myIntensity = 0;
  myDuration = 0;
  /**  `true` if the gamepad actually sent a request to pulse to the device */
  myDevicePulsing = false;
  clone() {
    const value = new _GamepadPulseInfo();
    value.myIntensity = this.myIntensity;
    value.myDuration = this.myDuration;
    value.myDevicePulsing = this.myDevicePulsing;
    return value;
  }
};

// dist/pp/input/gamepad/gamepad.js
var GamepadRawButtonData = class {
  myValue = 0;
  myPressed = false;
  myTouched = false;
  reset() {
    this.myValue = 0;
    this.myPressed = false;
    this.myTouched = false;
  }
};
var GamepadRawAxesData = class {
  myAxes = vec2_create(0);
  reset() {
    this.myAxes.vec2_zero();
  }
};
var Gamepad = class {
  _myHandedness;
  // Switched to `object` instead of `Map` for memory optimization reasons since iterating allocates a lot
  _myButtonInfos = {};
  _myButtonInfosIDs = [];
  _myAxesInfos = {};
  _myAxesInfosIDs = [];
  _myButtonEmitters = {};
  _myAxesEmitters = {};
  _myPulseInfo = new GamepadPulseInfo();
  _myActive = true;
  // Config
  _myMultiplePressMaxDelay = 0.4;
  _myMultipleTouchMaxDelay = 0.4;
  _myDestroyed = false;
  constructor(handedness) {
    this._myHandedness = handedness;
    this._myButtonInfos = {};
    this._myButtonInfosIDs = [];
    for (const key in GamepadButtonID) {
      const gamepadButtonID = GamepadButtonID[key];
      this._myButtonInfos[gamepadButtonID] = new GamepadButtonInfo(gamepadButtonID, this._myHandedness);
      this._myButtonInfosIDs.push(gamepadButtonID);
    }
    this._myAxesInfos = {};
    this._myAxesInfosIDs = [];
    for (const key in GamepadAxesID) {
      const gamepadAxesID = GamepadAxesID[key];
      this._myAxesInfos[gamepadAxesID] = new GamepadAxesInfo(gamepadAxesID, this._myHandedness);
      this._myAxesInfosIDs.push(gamepadAxesID);
    }
    for (const key in GamepadButtonID) {
      const gamepadButtonID = GamepadButtonID[key];
      this._myButtonEmitters[gamepadButtonID] = {};
      for (const eventKey in GamepadButtonEvent) {
        const gamepadButtonEvent = GamepadButtonEvent[eventKey];
        this._myButtonEmitters[gamepadButtonID][gamepadButtonEvent] = new Emitter4();
      }
    }
    for (const key in GamepadAxesID) {
      const gamepadAxesID = GamepadAxesID[key];
      this._myAxesEmitters[gamepadAxesID] = {};
      for (const eventKey in GamepadAxesEvent) {
        const gamepadAxesEvent = GamepadAxesEvent[eventKey];
        this._myAxesEmitters[gamepadAxesID][gamepadAxesEvent] = new Emitter4();
      }
    }
  }
  setActive(active) {
    this._setActiveHook(active);
    if (this._myActive != active) {
      this._myActive = active;
      if (!this._myActive) {
        this._preUpdateButtonInfos();
        this._updateButtonInfos();
        this._postUpdateButtonInfos(0);
        this._preUpdateAxesInfos();
        this._updateAxesInfos();
        this._postUpdateAxesInfos();
        this.stopPulse();
        this._updatePulse(0);
        for (let i = 0; i < this._myButtonInfosIDs.length; i++) {
          const id = this._myButtonInfosIDs[i];
          const info2 = this._myButtonInfos[id];
          info2.reset();
        }
        for (let i = 0; i < this._myAxesInfosIDs.length; i++) {
          const id = this._myAxesInfosIDs[i];
          const info2 = this._myAxesInfos[id];
          info2.reset();
        }
      }
    }
  }
  isActive() {
    return this._myActive;
  }
  getHandedness() {
    return this._myHandedness;
  }
  getButtonInfo(buttonID) {
    return this._myButtonInfos[buttonID];
  }
  registerButtonEventListener(buttonID, buttonEvent, id, listener) {
    this._myButtonEmitters[buttonID][buttonEvent].add(listener, { id });
  }
  unregisterButtonEventListener(buttonID, buttonEvent, id) {
    this._myButtonEmitters[buttonID][buttonEvent].remove(id);
  }
  getAxesInfo(axesID) {
    return this._myAxesInfos[axesID];
  }
  registerAxesEventListener(axesID, axesEvent, id, listener) {
    this._myAxesEmitters[axesID][axesEvent].add(listener, { id });
  }
  unregisterAxesEventListener(axesID, axesEvent, id) {
    this._myAxesEmitters[axesID][axesEvent].remove(id);
  }
  pulse(intensity, duration = 0) {
    this._myPulseInfo.myIntensity = Math.pp_clamp(intensity, 0, 1);
    this._myPulseInfo.myDuration = Math.max(duration, 0);
  }
  stopPulse() {
    this._myPulseInfo.myIntensity = 0;
    this._myPulseInfo.myDuration = 0;
  }
  isPulsing() {
    return this._myPulseInfo.myIntensity > 0 || this._myPulseInfo.myDuration > 0;
  }
  getPulseInfo() {
    return this._myPulseInfo;
  }
  getMultiplePressMaxDelay() {
    return this._myMultiplePressMaxDelay;
  }
  setMultiplePressMaxDelay(maxDelay) {
    this._myMultiplePressMaxDelay = maxDelay;
  }
  getMultipleTouchMaxDelay() {
    return this._myMultipleTouchMaxDelay;
  }
  setMultipleTouchMaxDelay(maxDelay) {
    this._myMultipleTouchMaxDelay = maxDelay;
  }
  // Hooks
  getHandPose() {
    return null;
  }
  _setActiveHook(active) {
  }
  _startHook() {
  }
  _preUpdate(dt) {
  }
  _postUpdate(dt) {
  }
  _getButtonData(buttonID) {
    return new GamepadRawButtonData();
  }
  _getAxesData(axesID) {
    return new GamepadRawAxesData();
  }
  _getHapticActuators() {
    const hapticActuator = [];
    return hapticActuator;
  }
  _destroyHook() {
  }
  // Hooks End
  start() {
    this._startHook();
  }
  update(dt) {
    if (!this._myActive)
      return;
    this._preUpdate(dt);
    this._preUpdateButtonInfos();
    this._updateButtonInfos();
    this._postUpdateButtonInfos(dt);
    this._preUpdateAxesInfos();
    this._updateAxesInfos();
    this._postUpdateAxesInfos();
    this._updatePulse(dt);
    this._postUpdate(dt);
  }
  _preUpdateButtonInfos() {
    for (let i = 0; i < this._myButtonInfosIDs.length; i++) {
      const id = this._myButtonInfosIDs[i];
      const info2 = this._myButtonInfos[id];
      info2.myPrevIsPressed = info2.myPressed;
      info2.myPrevIsTouched = info2.myTouched;
      info2.myPrevValue = info2.myValue;
    }
  }
  _updateButtonInfos() {
    this._updateSingleButtonInfo(GamepadButtonID.SELECT);
    this._updateSingleButtonInfo(GamepadButtonID.SQUEEZE);
    this._updateSingleButtonInfo(GamepadButtonID.THUMBSTICK);
    this._updateSingleButtonInfo(GamepadButtonID.TOP_BUTTON);
    this._updateSingleButtonInfo(GamepadButtonID.BOTTOM_BUTTON);
    this._updateSingleButtonInfo(GamepadButtonID.LEFT_BUTTON);
    this._updateSingleButtonInfo(GamepadButtonID.RIGHT_BUTTON);
    this._updateSingleButtonInfo(GamepadButtonID.MENU);
    this._updateSingleButtonInfo(GamepadButtonID.TOUCHPAD);
    this._updateSingleButtonInfo(GamepadButtonID.THUMB_REST);
  }
  _updateSingleButtonInfo(buttonID) {
    const buttonInfo = this._myButtonInfos[buttonID];
    const buttonData = this._getButtonData(buttonID);
    buttonInfo.myPressed = buttonData.myPressed;
    buttonInfo.myTouched = buttonData.myTouched;
    buttonInfo.myValue = buttonData.myValue;
    if (buttonInfo.myPressed) {
      buttonInfo.myTouched = true;
      if (buttonInfo.myValue == 0) {
        buttonInfo.myValue = 1;
      }
    }
  }
  _postUpdateButtonInfos(dt) {
    for (let i = 0; i < this._myButtonInfosIDs.length; i++) {
      const id = this._myButtonInfosIDs[i];
      const info2 = this._myButtonInfos[id];
      if (info2.myPressed) {
        info2.myTimePressed += dt;
        if (!info2.myPrevIsPressed) {
          info2.myMultiplePressStartCount += 1;
          info2.myPrevTimeNotPressed = info2.myTimeNotPressed;
          info2.myTimeNotPressed = 0;
        }
        if (info2.myPrevTimeNotPressed + info2.myTimePressed > this._myMultiplePressMaxDelay && info2.myMultiplePressEndCount > 0) {
          info2.myPrevMultiplePressEndCount = info2.myMultiplePressEndCount;
          info2.myMultiplePressEndCount = 0;
        }
        if (info2.myTimePressed > this._myMultiplePressMaxDelay && info2.myMultiplePressStartCount > 0) {
          info2.myPrevMultiplePressStartCount = info2.myMultiplePressStartCount;
          info2.myMultiplePressStartCount = 0;
        }
      } else {
        info2.myTimeNotPressed += dt;
        if (info2.myPrevIsPressed) {
          info2.myMultiplePressEndCount += 1;
          info2.myPrevTimePressed = info2.myTimePressed;
          info2.myTimePressed = 0;
        }
        if (info2.myPrevTimePressed + info2.myTimeNotPressed > this._myMultiplePressMaxDelay && info2.myMultiplePressStartCount > 0) {
          info2.myPrevMultiplePressStartCount = info2.myMultiplePressStartCount;
          info2.myMultiplePressStartCount = 0;
        }
        if (info2.myTimeNotPressed > this._myMultiplePressMaxDelay && info2.myMultiplePressEndCount > 0) {
          info2.myPrevMultiplePressEndCount = info2.myMultiplePressEndCount;
          info2.myMultiplePressEndCount = 0;
        }
      }
      if (info2.myTouched) {
        info2.myTimeTouched += dt;
        if (!info2.myPrevIsTouched) {
          info2.myMultipleTouchStartCount += 1;
          info2.myPrevTimeNotTouched = info2.myTimeNotTouched;
          info2.myTimeNotTouched = 0;
        }
        if (info2.myPrevTimeNotTouched + info2.myTimeTouched > this._myMultipleTouchMaxDelay && info2.myMultipleTouchEndCount > 0) {
          info2.myPrevMultipleTouchEndCount = info2.myMultipleTouchEndCount;
          info2.myMultipleTouchEndCount = 0;
        }
        if (info2.myTimeTouched > this._myMultipleTouchMaxDelay && info2.myMultipleTouchStartCount > 0) {
          info2.myPrevMultipleTouchStartCount = info2.myMultipleTouchStartCount;
          info2.myMultipleTouchStartCount = 0;
        }
      } else {
        info2.myTimeNotTouched += dt;
        if (info2.myPrevIsTouched) {
          info2.myMultipleTouchEndCount += 1;
          info2.myPrevTimeTouched = info2.myTimeTouched;
          info2.myTimeTouched = 0;
        }
        if (info2.myPrevTimeTouched + info2.myTimeNotTouched > this._myMultipleTouchMaxDelay && info2.myMultipleTouchStartCount > 0) {
          info2.myPrevMultipleTouchStartCount = info2.myMultipleTouchStartCount;
          info2.myMultipleTouchStartCount = 0;
        }
        if (info2.myTimeNotTouched > this._myMultipleTouchMaxDelay && info2.myMultipleTouchEndCount > 0) {
          info2.myPrevMultipleTouchEndCount = info2.myMultipleTouchEndCount;
          info2.myMultipleTouchEndCount = 0;
        }
      }
    }
    for (let i = 0; i < this._myButtonInfosIDs.length; i++) {
      const id = this._myButtonInfosIDs[i];
      const buttonInfo = this._myButtonInfos[id];
      const buttonEventEmitters = this._myButtonEmitters[id];
      if (buttonInfo.myPressed && !buttonInfo.myPrevIsPressed) {
        const emitter2 = buttonEventEmitters[GamepadButtonEvent.PRESS_START];
        emitter2.notify(buttonInfo, this);
      }
      if (!buttonInfo.myPressed && buttonInfo.myPrevIsPressed) {
        const emitter2 = buttonEventEmitters[GamepadButtonEvent.PRESS_END];
        emitter2.notify(buttonInfo, this);
      }
      if (buttonInfo.myPressed) {
        const emitter2 = buttonEventEmitters[GamepadButtonEvent.PRESSED];
        emitter2.notify(buttonInfo, this);
      } else {
        const emitter2 = buttonEventEmitters[GamepadButtonEvent.NOT_PRESSED];
        emitter2.notify(buttonInfo, this);
      }
      if (buttonInfo.myTouched && !buttonInfo.myPrevIsTouched) {
        const emitter2 = buttonEventEmitters[GamepadButtonEvent.TOUCH_START];
        emitter2.notify(buttonInfo, this);
      }
      if (!buttonInfo.myTouched && buttonInfo.myPrevIsTouched) {
        const emitter2 = buttonEventEmitters[GamepadButtonEvent.TOUCH_END];
        emitter2.notify(buttonInfo, this);
      }
      if (buttonInfo.myTouched) {
        const emitter2 = buttonEventEmitters[GamepadButtonEvent.TOUCHED];
        emitter2.notify(buttonInfo, this);
      } else {
        const emitter2 = buttonEventEmitters[GamepadButtonEvent.NOT_TOUCHED];
        emitter2.notify(buttonInfo, this);
      }
      if (buttonInfo.myValue != buttonInfo.myPrevValue) {
        const emitter2 = buttonEventEmitters[GamepadButtonEvent.VALUE_CHANGED];
        emitter2.notify(buttonInfo, this);
      }
      const emitter = buttonEventEmitters[GamepadButtonEvent.ALWAYS];
      emitter.notify(buttonInfo, this);
    }
  }
  _preUpdateAxesInfos() {
    for (let i = 0; i < this._myAxesInfosIDs.length; i++) {
      const id = this._myAxesInfosIDs[i];
      const info2 = this._myAxesInfos[id];
      info2.myPrevAxes[0] = info2.myAxes[0];
      info2.myPrevAxes[1] = info2.myAxes[1];
    }
  }
  _updateAxesInfos() {
    this._updateSingleAxesInfo(GamepadAxesID.THUMBSTICK);
  }
  _updateSingleAxesInfo(axesID) {
    const axesInfo = this._myAxesInfos[axesID];
    const axesData = this._getAxesData(axesID);
    axesInfo.myAxes[0] = axesData.myAxes[0];
    axesInfo.myAxes[1] = axesData.myAxes[1];
  }
  _postUpdateAxesInfos() {
    for (const key in GamepadAxesID) {
      const gamepadAxesID = GamepadAxesID[key];
      const axesInfo = this._myAxesInfos[gamepadAxesID];
      const axesEventEmitters = this._myAxesEmitters[gamepadAxesID];
      if (axesInfo.myAxes[0] != axesInfo.myPrevAxes[0]) {
        const emitter2 = axesEventEmitters[GamepadAxesEvent.X_CHANGED];
        emitter2.notify(axesInfo, this);
      }
      if (axesInfo.myAxes[1] != axesInfo.myPrevAxes[1]) {
        const emitter2 = axesEventEmitters[GamepadAxesEvent.Y_CHANGED];
        emitter2.notify(axesInfo, this);
      }
      if (axesInfo.myAxes[0] != axesInfo.myPrevAxes[0] || axesInfo.myAxes[1] != axesInfo.myPrevAxes[1]) {
        const emitter2 = axesEventEmitters[GamepadAxesEvent.AXES_CHANGED];
        emitter2.notify(axesInfo, this);
      }
      const emitter = axesEventEmitters[GamepadAxesEvent.ALWAYS];
      emitter.notify(axesInfo, this);
    }
  }
  _updatePulse(dt) {
    if (this._myPulseInfo.myDevicePulsing || this._myPulseInfo.myIntensity > 0) {
      const hapticActuators = this._getHapticActuators();
      if (hapticActuators.length > 0) {
        if (this._myPulseInfo.myIntensity > 0) {
          for (let i = 0; i < hapticActuators.length; i++) {
            const hapticActuator = hapticActuators[i];
            hapticActuator.playEffect("dual-rumble", {
              startDelay: 0,
              duration: Math.max(250, this._myPulseInfo.myDuration * 1e3),
              weakMagnitude: this._myPulseInfo.myIntensity,
              strongMagnitude: this._myPulseInfo.myIntensity
            });
          }
          this._myPulseInfo.myDevicePulsing = true;
        } else if (this._myPulseInfo.myDevicePulsing) {
          for (let i = 0; i < hapticActuators.length; i++) {
            const hapticActuator = hapticActuators[i];
            try {
              if (hapticActuator.reset != null) {
                hapticActuator.reset();
              }
            } catch (error4) {
            }
          }
          this._myPulseInfo.myDevicePulsing = false;
        }
      } else {
        this._myPulseInfo.myDevicePulsing = false;
      }
    }
    this._myPulseInfo.myDuration -= dt;
    if (this._myPulseInfo.myDuration <= 0) {
      this._myPulseInfo.myIntensity = 0;
      this._myPulseInfo.myDuration = 0;
    }
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
    this._destroyHook();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/input/gamepad/gamepad_cores/gamepad_core.js
var GamepadCore = class {
  constructor(handPose) {
    this._myHandPose = handPose;
    this._myManagingHandPose = false;
    this._myActive = true;
    this._myStarted = false;
    this._myDestroyed = false;
  }
  setActive(active) {
    this._setActiveHook(active);
    this._myActive = active;
  }
  isActive() {
    return this._myActive;
  }
  getHandedness() {
    return this.getHandPose().getHandedness();
  }
  getHandPose() {
    return this._myHandPose;
  }
  getEngine() {
    return this.getHandPose().getEngine();
  }
  isGamepadCoreActive() {
    return true;
  }
  setManageHandPose(manageHandPose) {
    this._myManagingHandPose = manageHandPose;
  }
  isManagingHandPose() {
    return this._myManagingHandPose;
  }
  start() {
    if (this._myStarted)
      return;
    this._myStarted = true;
    if (this.getHandPose() && this.isManagingHandPose()) {
      this.getHandPose().start();
    }
    this._startHook();
    this._myActive = false;
    this.setActive(true);
  }
  preUpdate(dt) {
    if (!this._myActive)
      return;
    if (this.getHandPose() && this.isManagingHandPose()) {
      this.getHandPose().update(dt);
    }
    this._preUpdateHook(dt);
  }
  postUpdate(dt) {
    if (!this._myActive)
      return;
    this._postUpdateHook(dt);
  }
  getButtonData(buttonID) {
    return new GamepadRawButtonData();
  }
  getAxesData(axesID) {
    return new GamepadRawAxesData();
  }
  getHapticActuators() {
    let hapticActuators = [];
    return hapticActuators;
  }
  // Hooks
  _setActiveHook(active) {
  }
  _startHook() {
  }
  _preUpdateHook(dt) {
  }
  _postUpdateHook(dt) {
  }
  _destroyHook() {
  }
  // Hooks end
  destroy() {
    if (this._myDestroyed)
      return;
    this._myDestroyed = true;
    this.setActive(false);
    this._destroyHook();
    if (this.isManagingHandPose()) {
      this.getHandPose().destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/input/gamepad/gamepad_cores/classic_gamepad_core.js
var ClassicGamepadCore = class extends GamepadCore {
  constructor(gamepadIndex, handPose) {
    super(handPose);
    this._myGamepadIndex = gamepadIndex;
    this._myCurrentGamepads = null;
    this._myButtonData = new GamepadRawButtonData();
    this._myAxesData = new GamepadRawAxesData();
    this._myHapticActuators = [];
  }
  _preUpdateHook(dt) {
    this._myCurrentGamepads = navigator.getGamepads();
  }
  _setActiveHook(active) {
    if (this.isActive() != active) {
      if (!active) {
        this._myCurrentGamepads = null;
      }
    }
  }
  isGamepadCoreActive() {
    let classicGamepad = this._getClassicGamepad();
    return this.isActive() && classicGamepad != null && (classicGamepad.connected == null || classicGamepad.connected);
  }
  getButtonData(buttonID) {
    this._myButtonData.reset();
    let classicGamepad = this._getClassicGamepad();
    if (classicGamepad != null && this.isGamepadCoreActive()) {
      let button = null;
      if (this.getHandedness() == Handedness.LEFT) {
        switch (buttonID) {
          case GamepadButtonID.SELECT:
            button = classicGamepad.buttons[4];
            break;
          case GamepadButtonID.SQUEEZE:
            button = classicGamepad.buttons[6];
            break;
          case GamepadButtonID.THUMBSTICK:
            button = classicGamepad.buttons[10];
            break;
          case GamepadButtonID.TOP_BUTTON:
            button = classicGamepad.buttons[12];
            break;
          case GamepadButtonID.BOTTOM_BUTTON:
            button = classicGamepad.buttons[13];
            break;
          case GamepadButtonID.LEFT_BUTTON:
            button = classicGamepad.buttons[14];
            break;
          case GamepadButtonID.RIGHT_BUTTON:
            button = classicGamepad.buttons[15];
            break;
          case GamepadButtonID.MENU:
            button = classicGamepad.buttons[8];
            break;
          case GamepadButtonID.TOUCHPAD:
            button = null;
            break;
          case GamepadButtonID.THUMB_REST:
            button = null;
            break;
        }
      } else {
        switch (buttonID) {
          case GamepadButtonID.SELECT:
            button = classicGamepad.buttons[5];
            break;
          case GamepadButtonID.SQUEEZE:
            button = classicGamepad.buttons[7];
            break;
          case GamepadButtonID.THUMBSTICK:
            button = classicGamepad.buttons[11];
            break;
          case GamepadButtonID.TOP_BUTTON:
            button = classicGamepad.buttons[3];
            break;
          case GamepadButtonID.BOTTOM_BUTTON:
            button = classicGamepad.buttons[0];
            break;
          case GamepadButtonID.LEFT_BUTTON:
            button = classicGamepad.buttons[2];
            break;
          case GamepadButtonID.RIGHT_BUTTON:
            button = classicGamepad.buttons[1];
            break;
          case GamepadButtonID.MENU:
            button = classicGamepad.buttons[9];
            break;
          case GamepadButtonID.TOUCHPAD:
            button = null;
            break;
          case GamepadButtonID.THUMB_REST:
            button = null;
            break;
        }
      }
      if (button != null) {
        this._myButtonData.myPressed = button.pressed;
        this._myButtonData.myTouched = button.touched;
        this._myButtonData.myValue = button.value;
      }
    }
    return this._myButtonData;
  }
  getAxesData(axesID) {
    this._myAxesData.reset();
    let classicGamepad = this._getClassicGamepad();
    if (classicGamepad != null && this.isGamepadCoreActive()) {
      if (this.getHandedness() == Handedness.LEFT) {
        this._myAxesData.myAxes[0] = classicGamepad.axes[0];
        this._myAxesData.myAxes[1] = classicGamepad.axes[1];
      } else {
        this._myAxesData.myAxes[0] = classicGamepad.axes[2];
        this._myAxesData.myAxes[1] = classicGamepad.axes[3];
      }
      this._myAxesData.myAxes[1] = -this._myAxesData.myAxes[1];
    }
    return this._myAxesData;
  }
  getHapticActuators() {
    this._myHapticActuators.pp_clear();
    let classicGamepad = this._getClassicGamepad();
    if (classicGamepad != null && this.isGamepadCoreActive()) {
      if (classicGamepad.hapticActuators != null) {
        for (let i = 0; i < classicGamepad.hapticActuators.length; i++) {
          this._myHapticActuators.push(classicGamepad.hapticActuators[i]);
        }
      }
      if (classicGamepad.vibrationActuator != null) {
        this._myHapticActuators.push(classicGamepad.vibrationActuator);
      }
    }
    return this._myHapticActuators;
  }
  _getClassicGamepad() {
    if (this._myCurrentGamepads == null)
      return null;
    let classicGamepad = null;
    if (this._myGamepadIndex != null) {
      if (this._myGamepadIndex < this._myCurrentGamepads.length) {
        classicGamepad = this._myCurrentGamepads[this._myGamepadIndex];
      }
    } else {
      for (let i = 0; i < this._myCurrentGamepads.length; i++) {
        let gamepad = this._myCurrentGamepads[i];
        if (gamepad != null && (gamepad.connected == null || gamepad.connected)) {
          classicGamepad = gamepad;
          break;
        }
      }
    }
    return classicGamepad;
  }
};

// dist/pp/input/cauldron/keyboard.js
var KeyID = {
  /** These are when the number is pressed in some way */
  Number0: "0",
  Number1: "1",
  Number2: "2",
  Number3: "3",
  Number4: "4",
  Number5: "5",
  Number6: "6",
  Number7: "7",
  Number8: "8",
  Number9: "9",
  /** These are just the numbers above the letters on the keyboard */
  Digit0: "Digit0",
  Digit1: "Digit1",
  Digit2: "Digit2",
  Digit3: "Digit3",
  Digit4: "Digit4",
  Digit5: "Digit5",
  Digit6: "Digit6",
  Digit7: "Digit7",
  Digit8: "Digit8",
  Digit9: "Digit9",
  /** These are just the numbers on the numpad, but works even is num lock is disabled */
  Numpad0: "Numpad0",
  Numpad1: "Numpad1",
  Numpad2: "Numpad2",
  Numpad3: "Numpad3",
  Numpad4: "Numpad4",
  Numpad5: "Numpad5",
  Numpad6: "Numpad6",
  Numpad7: "Numpad7",
  Numpad8: "Numpad8",
  Numpad9: "Numpad9",
  KeyA: "KeyA",
  KeyB: "KeyB",
  KeyC: "KeyC",
  KeyD: "KeyD",
  KeyE: "KeyE",
  KeyF: "KeyF",
  KeyG: "KeyG",
  KeyH: "KeyH",
  KeyI: "KeyI",
  KeyJ: "KeyJ",
  KeyK: "KeyK",
  KeyL: "KeyL",
  KeyM: "KeyM",
  KeyN: "KeyN",
  KeyO: "KeyO",
  KeyP: "KeyP",
  KeyQ: "KeyQ",
  KeyR: "KeyR",
  KeyS: "KeyS",
  KeyT: "KeyT",
  KeyU: "KeyU",
  KeyV: "KeyV",
  KeyW: "KeyW",
  KeyX: "KeyX",
  KeyY: "KeyY",
  KeyZ: "KeyZ",
  A: "A",
  B: "B",
  C: "C",
  D: "D",
  E: "E",
  F: "F",
  G: "G",
  H: "H",
  I: "I",
  J: "J",
  K: "K",
  L: "L",
  M: "M",
  N: "N",
  O: "O",
  P: "P",
  Q: "Q",
  R: "R",
  S: "S",
  T: "T",
  U: "U",
  V: "V",
  W: "W",
  X: "X",
  Y: "Y",
  Z: "Z",
  a: "a",
  b: "b",
  c: "c",
  d: "d",
  e: "e",
  f: "f",
  g: "g",
  h: "h",
  i: "i",
  j: "j",
  k: "k",
  l: "l",
  m: "m",
  n: "n",
  o: "o",
  p: "p",
  q: "q",
  r: "r",
  s: "s",
  t: "t",
  u: "u",
  v: "v",
  w: "w",
  x: "x",
  y: "y",
  z: "z",
  UP: "ArrowUp",
  DOWN: "ArrowDown",
  LEFT: "ArrowLeft",
  RIGHT: "ArrowRight",
  SPACE: "Space",
  ENTER: "Enter",
  BACKSPACE: "Backspace",
  ESC: "Escape",
  SHIFT_LEFT: "ShiftLeft",
  SHIFT_RIGHT: "ShiftRight",
  CONTROL_LEFT: "ControlLeft",
  CONTROL_RIGHT: "ControlRight",
  ALT_LEFT: "AltLeft",
  ALT_RIGHT: "AltRight"
};
var Keyboard = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myKeyInfos = {};
    this._myKeyInfosIDs = [];
    for (let key in KeyID) {
      this.addKey(KeyID[key]);
    }
    this._myOnKeyDownEventListener = null;
    this._myOnKeyUpEventListener = null;
    this._myActive = true;
    this._myDestroyed = false;
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      if (this._myActive) {
        this._myOnKeyDownEventListener = this._keyDown.bind(this);
        window.addEventListener("keydown", this._myOnKeyDownEventListener);
        this._myOnKeyUpEventListener = this._keyUp.bind(this);
        window.addEventListener("keyup", this._myOnKeyUpEventListener);
      } else {
        for (let i = 0; i < this._myKeyInfosIDs.length; i++) {
          let id = this._myKeyInfosIDs[i];
          let keyInfo = this._myKeyInfos[id];
          keyInfo.myPressed = false;
          keyInfo.myPressStart = false;
          keyInfo.myPressEnd = false;
          keyInfo.myPressStartToProcess = false;
          keyInfo.myPressEndToProcess = false;
        }
        window.removeEventListener("keydown", this._myOnKeyDownEventListener);
        window.removeEventListener("keyup", this._myOnKeyUpEventListener);
        this._myOnKeyDownEventListener = null;
        this._myOnKeyUpEventListener = null;
      }
    }
  }
  isActive() {
    return this._myActive;
  }
  isKeyPressed(keyID) {
    let pressed = false;
    if (this._myKeyInfos[keyID] != null) {
      pressed = this._myKeyInfos[keyID].myPressed;
    }
    return pressed;
  }
  isAnyKeyPressed() {
    let pressed = false;
    for (let i = 0; i < this._myKeyInfosIDs.length; i++) {
      let id = this._myKeyInfosIDs[i];
      let keyInfo = this._myKeyInfos[id];
      if (keyInfo.myPressed) {
        pressed = true;
        break;
      }
    }
    return pressed;
  }
  isKeyPressStart(keyID) {
    let pressStart = false;
    if (this._myKeyInfos[keyID] != null) {
      pressStart = this._myKeyInfos[keyID].myPressStart;
    }
    return pressStart;
  }
  isKeyPressEnd(keyID) {
    let pressEnd = false;
    if (this._myKeyInfos[keyID] != null) {
      pressEnd = this._myKeyInfos[keyID].myPressEnd;
    }
    return pressEnd;
  }
  addKey(keyID) {
    this._myKeyInfos[keyID] = this._createKeyInfo();
    this._myKeyInfosIDs.push(keyID);
  }
  start() {
    this._myActive = false;
    this.setActive(true);
  }
  update(dt) {
    if (!this._myActive)
      return;
    if (!document.hasFocus()) {
      for (let i = 0; i < this._myKeyInfosIDs.length; i++) {
        let id = this._myKeyInfosIDs[i];
        let keyInfo = this._myKeyInfos[id];
        if (keyInfo.myPressed) {
          keyInfo.myPressed = false;
          keyInfo.myPressEndToProcess = true;
        }
      }
    }
    for (let i = 0; i < this._myKeyInfosIDs.length; i++) {
      let id = this._myKeyInfosIDs[i];
      let keyInfo = this._myKeyInfos[id];
      keyInfo.myPressStart = keyInfo.myPressStartToProcess;
      keyInfo.myPressEnd = keyInfo.myPressEndToProcess;
      keyInfo.myPressStartToProcess = false;
      keyInfo.myPressEndToProcess = false;
    }
  }
  _keyDown(event) {
    if (event.repeat)
      return;
    this._keyPressedChanged(event.key, true);
    if (event.key != event.code) {
      this._keyPressedChanged(event.code, true);
    }
  }
  _keyUp(event) {
    this._keyPressedChanged(event.key, false);
    if (event.key != event.code) {
      this._keyPressedChanged(event.code, false);
    }
  }
  _keyPressedChanged(keyID, pressed) {
    if (this._myKeyInfos[keyID] != null) {
      let keyInfo = this._myKeyInfos[keyID];
      if (pressed != keyInfo.myPressed) {
        if (pressed) {
          keyInfo.myPressed = true;
          keyInfo.myPressStartToProcess = true;
        } else {
          keyInfo.myPressed = false;
          keyInfo.myPressEndToProcess = true;
        }
      }
    }
  }
  _createKeyInfo() {
    return { myPressed: false, myPressStart: false, myPressStartToProcess: false, myPressEnd: false, myPressEndToProcess: false };
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/input/gamepad/gamepad_cores/keyboard_gamepad_core.js
var KeyboardGamepadCore = class extends GamepadCore {
  constructor(handPose) {
    super(handPose);
    this._myButtonData = new GamepadRawButtonData();
    this._myAxesData = new GamepadRawAxesData();
    this._myHapticActuators = [];
  }
  isGamepadCoreActive() {
    return this.isActive();
  }
  getButtonData(buttonID) {
    this._myButtonData.reset();
    let keyboard = Globals.getKeyboard(this.getEngine());
    if (this.isGamepadCoreActive()) {
      if (this.getHandedness() == Handedness.LEFT) {
        switch (buttonID) {
          case GamepadButtonID.SELECT:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyE);
            break;
          case GamepadButtonID.SQUEEZE:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyQ);
            break;
          case GamepadButtonID.THUMBSTICK:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyR);
            break;
          case GamepadButtonID.TOP_BUTTON:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyF);
            break;
          case GamepadButtonID.BOTTOM_BUTTON:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyC);
            break;
          case GamepadButtonID.LEFT_BUTTON:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyX);
            break;
          case GamepadButtonID.RIGHT_BUTTON:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyV);
            break;
          case GamepadButtonID.MENU:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.Digit3);
            break;
          case GamepadButtonID.TOUCHPAD:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.Digit2);
            break;
          case GamepadButtonID.THUMB_REST:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.Digit1);
            break;
        }
      } else {
        switch (buttonID) {
          case GamepadButtonID.SELECT:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyU);
            break;
          case GamepadButtonID.SQUEEZE:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyO);
            break;
          case GamepadButtonID.THUMBSTICK:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyY);
            break;
          case GamepadButtonID.TOP_BUTTON:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyH);
            break;
          case GamepadButtonID.BOTTOM_BUTTON:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyN);
            break;
          case GamepadButtonID.LEFT_BUTTON:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyB);
            break;
          case GamepadButtonID.RIGHT_BUTTON:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.KeyM);
            break;
          case GamepadButtonID.MENU:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.Digit8);
            break;
          case GamepadButtonID.TOUCHPAD:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.Digit9);
            break;
          case GamepadButtonID.THUMB_REST:
            this._myButtonData.myPressed = keyboard.isKeyPressed(KeyID.Digit0);
            break;
        }
      }
    }
    if (this._myButtonData.myPressed) {
      this._myButtonData.myTouched = true;
      this._myButtonData.myValue = 1;
    }
    return this._myButtonData;
  }
  getAxesData(axesID) {
    this._myAxesData.reset();
    let keyboard = Globals.getKeyboard(this.getEngine());
    if (this.isGamepadCoreActive()) {
      if (this.getHandedness() == Handedness.LEFT) {
        if (keyboard.isKeyPressed(KeyID.KeyW))
          this._myAxesData.myAxes[1] += 1;
        if (keyboard.isKeyPressed(KeyID.KeyS))
          this._myAxesData.myAxes[1] += -1;
        if (keyboard.isKeyPressed(KeyID.KeyD))
          this._myAxesData.myAxes[0] += 1;
        if (keyboard.isKeyPressed(KeyID.KeyA))
          this._myAxesData.myAxes[0] += -1;
      } else {
        if (keyboard.isKeyPressed(KeyID.KeyI) || keyboard.isKeyPressed(KeyID.UP))
          this._myAxesData.myAxes[1] += 1;
        if (keyboard.isKeyPressed(KeyID.KeyK) || keyboard.isKeyPressed(KeyID.DOWN))
          this._myAxesData.myAxes[1] += -1;
        if (keyboard.isKeyPressed(KeyID.KeyL) || keyboard.isKeyPressed(KeyID.RIGHT))
          this._myAxesData.myAxes[0] += 1;
        if (keyboard.isKeyPressed(KeyID.KeyJ) || keyboard.isKeyPressed(KeyID.LEFT))
          this._myAxesData.myAxes[0] += -1;
      }
    }
    return this._myAxesData;
  }
  getHapticActuators() {
    return this._myHapticActuators;
  }
};

// dist/pp/input/gamepad/gamepad_cores/xr_gamepad_core.js
var XRGamepadCore = class extends GamepadCore {
  constructor(handPose) {
    super(handPose);
    this._mySelectPressed = false;
    this._mySqueezePressed = false;
    this._myXRSessionActive = false;
    this._myInputSource = null;
    this._myGamepad = null;
    this._mySelectStartEventListener = null;
    this._mySelectEndEventListener = null;
    this._mySqueezeStartEventListener = null;
    this._mySqueezeEndEventListener = null;
    this._myButtonData = new GamepadRawButtonData();
    this._myAxesData = new GamepadRawAxesData();
    this._myHapticActuators = [];
  }
  isGamepadCoreActive() {
    return this.isActive() && this._myXRSessionActive && this._myGamepad != null && (this._myGamepad.connected == null || this._myGamepad.connected);
  }
  _setActiveHook(active) {
    if (this.isActive() != active) {
      if (active) {
        XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this.getEngine());
      } else {
        this._mySelectPressed = false;
        this._mySqueezePressed = false;
        this._myXRSessionActive = false;
        this._myInputSource = null;
        this._myGamepad = null;
        XRUtils.getSession(this.getEngine())?.removeEventListener("selectstart", this._mySelectStartEventListener);
        XRUtils.getSession(this.getEngine())?.removeEventListener("selectend", this._mySelectEndEventListener);
        XRUtils.getSession(this.getEngine())?.removeEventListener("squeezestart", this._mySqueezeStartEventListener);
        XRUtils.getSession(this.getEngine())?.removeEventListener("squeezeend", this._mySqueezeEndEventListener);
        XRUtils.unregisterSessionStartEndEventListeners(this, this.getEngine());
        this._mySelectStartEventListener = null;
        this._mySelectEndEventListener = null;
        this._mySqueezeStartEventListener = null;
        this._mySqueezeEndEventListener = null;
      }
    }
  }
  _preUpdateHook(dt) {
    let prevInputSource = this._myInputSource;
    this._myInputSource = this.getHandPose().getInputSource();
    if (prevInputSource != this._myInputSource) {
      this._mySelectPressed = false;
      this._mySqueezePressed = false;
    }
    if (this._myInputSource != null) {
      this._myGamepad = this._myInputSource.gamepad;
    } else {
      this._myGamepad = null;
    }
  }
  getButtonData(buttonID) {
    this._myButtonData.reset();
    if (this.isGamepadCoreActive()) {
      let button = null;
      switch (buttonID) {
        case GamepadButtonID.SELECT:
          button = this._myGamepad.buttons[0];
          break;
        case GamepadButtonID.SQUEEZE:
          button = this._myGamepad.buttons[1];
          break;
        case GamepadButtonID.THUMBSTICK:
          button = this._myGamepad.buttons[3];
          break;
        case GamepadButtonID.TOP_BUTTON:
          button = this._myGamepad.buttons[5];
          break;
        case GamepadButtonID.BOTTOM_BUTTON:
          button = this._myGamepad.buttons[4];
          break;
        case GamepadButtonID.LEFT_BUTTON:
          button = null;
          break;
        case GamepadButtonID.RIGHT_BUTTON:
          button = null;
          break;
        case GamepadButtonID.MENU: {
          const inputSourceProfiles = this._myInputSource.profiles;
          if (inputSourceProfiles.includes("oculus-touch-v3") || inputSourceProfiles.includes("meta-quest-touch-pro")) {
            button = this._myGamepad.buttons[this._myGamepad.buttons.length - 1];
          }
          break;
        }
        case GamepadButtonID.TOUCHPAD:
          button = this._myGamepad.buttons[2];
          break;
        case GamepadButtonID.THUMB_REST:
          button = this._myGamepad.buttons[6];
          break;
      }
      if (button != null) {
        this._myButtonData.myPressed = button.pressed;
        this._myButtonData.myTouched = button.touched;
        this._myButtonData.myValue = button.value;
      }
    }
    return this._myButtonData;
  }
  getAxesData(axesID) {
    this._myAxesData.reset();
    if (this.isGamepadCoreActive()) {
      let internalAxes = this._myGamepad.axes;
      if (internalAxes.length == 4) {
        if (Math.abs(internalAxes[0]) > Math.abs(internalAxes[2])) {
          this._myAxesData.myAxes[0] = internalAxes[0];
        } else {
          this._myAxesData.myAxes[0] = internalAxes[2];
        }
        if (Math.abs(internalAxes[1]) > Math.abs(internalAxes[3])) {
          this._myAxesData.myAxes[1] = internalAxes[1];
        } else {
          this._myAxesData.myAxes[1] = internalAxes[3];
        }
      } else if (internalAxes.length == 2) {
        this._myAxesData.myAxes[0] = internalAxes[0];
        this._myAxesData.myAxes[1] = internalAxes[1];
      }
      this._myAxesData.myAxes[1] = -this._myAxesData.myAxes[1];
    }
    return this._myAxesData;
  }
  getHapticActuators() {
    this._myHapticActuators.pp_clear();
    if (this.isGamepadCoreActive()) {
      if (this._myGamepad.hapticActuators != null) {
        for (let i = 0; i < this._myGamepad.hapticActuators.length; i++) {
          this._myHapticActuators.push(this._myGamepad.hapticActuators[i]);
        }
      }
      if (this._myGamepad.vibrationActuator != null) {
        this._myHapticActuators.push(this._myGamepad.vibrationActuator);
      }
    }
    return this._myHapticActuators;
  }
  // This is to be more compatible
  _getSpecialButtonPressed(buttonID) {
    let pressed = false;
    if (this.isGamepadCoreActive()) {
      if (buttonID == GamepadButtonID.SELECT) {
        pressed = this._mySelectPressed;
      } else if (buttonID == GamepadButtonID.SQUEEZE) {
        pressed = this._mySqueezePressed;
      }
    }
    return pressed;
  }
  _onXRSessionStart(session) {
    this._mySelectStartEventListener = this._selectStart.bind(this);
    this._mySelectEndEventListener = this._selectEnd.bind(this);
    this._mySqueezeStartEventListener = this._squeezeStart.bind(this);
    this._mySqueezeEndEventListener = this._squeezeEnd.bind(this);
    session.addEventListener("selectstart", this._mySelectStartEventListener);
    session.addEventListener("selectend", this._mySelectEndEventListener);
    session.addEventListener("squeezestart", this._mySqueezeStartEventListener);
    session.addEventListener("squeezeend", this._mySqueezeEndEventListener);
    this._myXRSessionActive = true;
  }
  _onXRSessionEnd(session) {
    this._mySelectStartEventListener = null;
    this._mySelectEndEventListener = null;
    this._mySqueezeStartEventListener = null;
    this._mySqueezeEndEventListener = null;
    this._mySelectPressed = false;
    this._mySqueezePressed = false;
    this._myXRSessionActive = false;
  }
  // Select and Squeeze are managed this way to be more compatible
  _selectStart(event) {
    if (this._myInputSource != null && this._myInputSource == event.inputSource) {
      this._mySelectPressed = true;
    }
  }
  _selectEnd(event) {
    if (this._myInputSource != null && this._myInputSource == event.inputSource) {
      this._mySelectPressed = false;
    }
  }
  _squeezeStart(event) {
    if (this._myInputSource != null && this._myInputSource == event.inputSource) {
      this._mySqueezePressed = true;
    }
  }
  _squeezeEnd(event) {
    if (this._myInputSource != null && this._myInputSource == event.inputSource) {
      this._mySqueezePressed = false;
    }
  }
};

// dist/pp/input/cauldron/input_manager.js
import { Emitter as Emitter6 } from "@wonderlandengine/api";

// dist/pp/input/gamepad/universal_gamepad.js
var UniversalGamepad = class extends Gamepad {
  // Switched to `object` instead of `Map` for memory optimization reasons since iterating allocates a lot
  _myGamepadCores = {};
  _myGamepadCoresIDs = [];
  _myStarted = false;
  // Support Variables
  _myButtonData = new GamepadRawButtonData();
  _myAxesData = new GamepadRawAxesData();
  _myHapticActuators = [];
  constructor(handedness) {
    super(handedness);
  }
  addGamepadCore(id, gamepadCore) {
    if (gamepadCore.getHandedness() == this.getHandedness()) {
      this._myGamepadCores[id] = gamepadCore;
      this._myGamepadCoresIDs.pp_pushUnique(id);
      if (this._myStarted) {
        gamepadCore.start();
        gamepadCore.setActive(this.isActive());
      }
    }
  }
  getGamepadCore(id) {
    return this._myGamepadCores[id];
  }
  removeGamepadCore(id) {
    const gamepadCore = this._myGamepadCores[id];
    if (gamepadCore != null) {
      delete this._myGamepadCores[id];
      this._myGamepadCoresIDs.pp_removeEqual(id);
    }
  }
  removeAllGamepadCores() {
    this._myGamepadCores = {};
    this._myGamepadCoresIDs = [];
  }
  getHandPose() {
    let handPose = null;
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      const id = this._myGamepadCoresIDs[i];
      const core = this._myGamepadCores[id];
      if (core.isGamepadCoreActive()) {
        const currentCoreHandPose = core.getHandPose();
        if (handPose == null || currentCoreHandPose != null && currentCoreHandPose.isValid()) {
          handPose = currentCoreHandPose;
        }
      }
      if (handPose != null && handPose.isValid()) {
        break;
      }
    }
    return handPose;
  }
  _setActiveHook(active) {
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      const id = this._myGamepadCoresIDs[i];
      const core = this._myGamepadCores[id];
      core.setActive(active);
    }
  }
  _startHook() {
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      const id = this._myGamepadCoresIDs[i];
      const core = this._myGamepadCores[id];
      core.start();
      core.setActive(this.isActive());
    }
    this._myStarted = true;
  }
  _preUpdate(dt) {
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      const id = this._myGamepadCoresIDs[i];
      const core = this._myGamepadCores[id];
      core.preUpdate(dt);
    }
  }
  _postUpdate(dt) {
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      const id = this._myGamepadCoresIDs[i];
      const core = this._myGamepadCores[id];
      core.postUpdate(dt);
    }
  }
  _getButtonData(buttonID) {
    this._myButtonData.reset();
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      const id = this._myGamepadCoresIDs[i];
      const core = this._myGamepadCores[id];
      if (core.isGamepadCoreActive()) {
        const coreButtonData = core.getButtonData(buttonID);
        this._myButtonData.myPressed = this._myButtonData.myPressed || coreButtonData.myPressed;
        this._myButtonData.myTouched = this._myButtonData.myTouched || coreButtonData.myTouched;
        if (Math.abs(coreButtonData.myValue) > Math.abs(this._myButtonData.myValue)) {
          this._myButtonData.myValue = coreButtonData.myValue;
        }
      }
    }
    return this._myButtonData;
  }
  _getAxesData(axesID) {
    this._myAxesData.reset();
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      const id = this._myGamepadCoresIDs[i];
      const core = this._myGamepadCores[id];
      if (core.isGamepadCoreActive()) {
        const coreAxesData = core.getAxesData(axesID);
        if (Math.abs(coreAxesData.myAxes[0]) > Math.abs(this._myAxesData.myAxes[0])) {
          this._myAxesData.myAxes[0] = coreAxesData.myAxes[0];
        }
        if (Math.abs(coreAxesData.myAxes[1]) > Math.abs(this._myAxesData.myAxes[1])) {
          this._myAxesData.myAxes[1] = coreAxesData.myAxes[1];
        }
      }
    }
    return this._myAxesData;
  }
  _getHapticActuators() {
    this._myHapticActuators.pp_clear();
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      const id = this._myGamepadCoresIDs[i];
      const core = this._myGamepadCores[id];
      if (core.isGamepadCoreActive()) {
        const coreHapticActuators = core.getHapticActuators();
        for (let j = 0; j < coreHapticActuators.length; j++) {
          this._myHapticActuators.push(coreHapticActuators[j]);
        }
      }
    }
    return this._myHapticActuators;
  }
  _destroyHook() {
    for (let i = 0; i < this._myGamepadCoresIDs.length; i++) {
      const id = this._myGamepadCoresIDs[i];
      const core = this._myGamepadCores[id];
      core.destroy();
    }
  }
};

// dist/pp/input/gamepad/cauldron/gamepads_manager.js
var GamepadsManager = class {
  _myUniversalGamepads;
  _myActive = true;
  _myDestroyed = false;
  constructor() {
    this._myUniversalGamepads = {
      [Handedness.LEFT]: new UniversalGamepad(Handedness.LEFT),
      [Handedness.RIGHT]: new UniversalGamepad(Handedness.RIGHT)
    };
    this._myDestroyed = false;
  }
  setActive(active) {
    this._myActive = active;
    for (const rawHandedness in this._myUniversalGamepads) {
      const handedness = rawHandedness;
      this._myUniversalGamepads[handedness].setActive(active);
    }
  }
  isActive() {
    return this._myActive;
  }
  start() {
    for (const rawHandedness in this._myUniversalGamepads) {
      const handedness = rawHandedness;
      this._myUniversalGamepads[handedness].start();
    }
  }
  update(dt) {
    if (!this._myActive)
      return;
    for (const rawHandedness in this._myUniversalGamepads) {
      const handedness = rawHandedness;
      this._myUniversalGamepads[handedness].update(dt);
    }
  }
  getGamepad(handedness) {
    return this._myUniversalGamepads[handedness];
  }
  getGamepads() {
    return this._myUniversalGamepads;
  }
  getLeftGamepad() {
    return this._myUniversalGamepads[Handedness.LEFT];
  }
  getRightGamepad() {
    return this._myUniversalGamepads[Handedness.RIGHT];
  }
  getUniversalGamepad(handedness) {
    return this._myUniversalGamepads[handedness];
  }
  getUniversalGamepads() {
    return this._myUniversalGamepads;
  }
  getLeftUniversalGamepad() {
    return this._myUniversalGamepads[Handedness.LEFT];
  }
  getRightUniversalGamepad() {
    return this._myUniversalGamepads[Handedness.RIGHT];
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
    for (const rawHandedness in this._myUniversalGamepads) {
      const handedness = rawHandedness;
      this._myUniversalGamepads[handedness].destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/input/pose/base_pose.js
import { Emitter as Emitter5 } from "@wonderlandengine/api";
var BasePoseParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myReferenceObject = null;
    this.myForwardFixed = true;
    this.myUpdateOnViewReset = false;
    this.myForceEmulatedVelocities = false;
    this.myEngine = engine;
  }
};
var BasePose = class {
  constructor(basePoseParams = new BasePoseParams()) {
    this._myForwardFixed = basePoseParams.myForwardFixed;
    this._myForceEmulatedVelocities = basePoseParams.myForceEmulatedVelocities;
    this._myUpdateOnViewReset = basePoseParams.myUpdateOnViewReset;
    this._myReferenceObject = basePoseParams.myReferenceObject;
    this._myEngine = basePoseParams.myEngine;
    this._myPosition = vec3_create();
    this._myRotationQuat = quat_create();
    this._myPrevPosition = vec3_create();
    this._myPrevRotationQuat = quat_create();
    this._myLinearVelocity = vec3_create();
    this._myAngularVelocityRadians = vec3_create();
    this._myActive = true;
    this._myValid = false;
    this._myLinearVelocityEmulated = true;
    this._myAngularVelocityEmulated = true;
    this._myPrePoseUpdatedEventEmitter = new Emitter5();
    this._myPoseUpdatedEmitter = new Emitter5();
    this._myPostPoseUpdatedEventEmitter = new Emitter5();
    this._myViewResetEventListener = null;
    this._myDestroyed = false;
  }
  getEngine() {
    return this._myEngine;
  }
  setActive(active) {
    if (this._myActive != active) {
      if (active) {
        XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, true, this._myEngine);
      } else {
        this._myPosition.vec3_zero();
        this._myRotationQuat.quat_identity();
        this._myPrevPosition.vec3_zero();
        this._myPrevRotationQuat.quat_identity();
        this._myLinearVelocity.vec3_zero();
        this._myAngularVelocityRadians.vec3_zero();
        this._myValid = false;
        this._myLinearVelocityEmulated = true;
        this._myAngularVelocityEmulated = true;
        if (this._myViewResetEventListener != null) {
          XRUtils.getReferenceSpace(this._myEngine)?.removeEventListener?.("reset", this._myViewResetEventListener);
        }
        this._myViewResetEventListener = null;
        XRUtils.unregisterSessionStartEndEventListeners(this, this._myEngine);
      }
    }
    this._setActiveHook(active);
    this._myActive = active;
  }
  isActive() {
    return this._myActive;
  }
  // If the reference object is set, the transform will be converted using it as a parent,
  // otherwise the transform will be local, as if the parent/reference object was the identity transform
  setReferenceObject(referenceObject) {
    this._myReferenceObject = referenceObject;
  }
  getReferenceObject() {
    return this._myReferenceObject;
  }
  setForwardFixed(forwardFixed) {
    this._myForwardFixed = forwardFixed;
  }
  isForwardFixed() {
    return this._myForwardFixed;
  }
  setForceEmulatedVelocities(forceEmulatedVelocities) {
    this._myForceEmulatedVelocities = forceEmulatedVelocities;
  }
  isForceEmulatedVelocities() {
    return this._myForceEmulatedVelocities;
  }
  setUpdateOnViewReset(updateOnViewReset) {
    this._myUpdateOnViewReset = updateOnViewReset;
  }
  isUpdateOnViewReset() {
    return this._myUpdateOnViewReset;
  }
  getReferenceSpace() {
    return XRUtils.getReferenceSpace(this._myEngine);
  }
  getPosition(out = vec3_create(), referenceObjectOverride = void 0) {
  }
  getRotation(out = vec3_create(), referenceObjectOverride = void 0) {
    return this.getRotationDegrees(out, referenceObjectOverride);
  }
  getRotationDegrees(out = vec3_create(), referenceObjectOverride = void 0) {
  }
  getRotationRadians(out = vec3_create(), referenceObjectOverride = void 0) {
  }
  getRotationQuat(out = quat_create(), referenceObjectOverride = void 0) {
  }
  getTransform(out = mat4_create(), referenceObjectOverride = void 0) {
    return this.getTransformMatrix(out, referenceObjectOverride);
  }
  getTransformMatrix(out = mat4_create(), referenceObjectOverride = void 0) {
  }
  /**
   * TS type inference helper
   *
   * @param {any} referenceObjectOverride
   * @return {any}
   */
  getTransformQuat(out = quat2_create(), referenceObjectOverride = void 0) {
  }
  getLinearVelocity(out = vec3_create(), referenceObjectOverride = void 0) {
  }
  getAngularVelocity(out = vec3_create(), referenceObjectOverride = void 0) {
    return this.getAngularVelocityDegrees(out, referenceObjectOverride);
  }
  getAngularVelocityDegrees(out = vec3_create(), referenceObjectOverride = void 0) {
  }
  getAngularVelocityRadians(out = vec3_create(), referenceObjectOverride = void 0) {
  }
  isValid() {
    return this._myValid;
  }
  isLinearVelocityEmulated() {
    return this._myLinearVelocityEmulated;
  }
  isAngularVelocityEmulated() {
    return this._myAngularVelocityEmulated;
  }
  registerPrePoseUpdatedEventListener(id, listener) {
    this._myPrePoseUpdatedEventEmitter.add(listener, { id });
  }
  unregisterPrePoseUpdatedEventListener(id) {
    this._myPrePoseUpdatedEventEmitter.remove(id);
  }
  registerPoseUpdatedEventListener(id, listener) {
    this._myPoseUpdatedEmitter.add(listener, { id });
  }
  unregisterPoseUpdatedEventListener(id) {
    this._myPoseUpdatedEmitter.remove(id);
  }
  registerPostPoseUpdatedEventListener(id, listener) {
    this._myPostPoseUpdatedEventEmitter.add(listener, { id });
  }
  unregisterPostPoseUpdatedEventListener(id) {
    this._myPostPoseUpdatedEventEmitter.remove(id);
  }
  start() {
    this._myActive = false;
    this.setActive(true);
  }
  update(dt) {
    if (!this._myActive)
      return;
    this._update(dt, true, false);
  }
  // Hooks
  _isReadyToGetPose() {
    return true;
  }
  _getPose(xrFrame) {
    return null;
  }
  _preUpdate(dt, updateVelocity, manualUpdate) {
  }
  _postUpdate(dt, updateVelocity, manualUpdate, xrPose) {
  }
  _onXRSessionStartHook(manualCall, session) {
  }
  _onXRSessionEndHook() {
  }
  _onViewResetHook() {
  }
  _setActiveHook(active) {
  }
  _destroyHook() {
  }
  // Hooks End
  _update(dt, updateVelocity, manualUpdate) {
    this._preUpdate(dt, updateVelocity, manualUpdate);
    this._myPrevPosition.vec3_copy(this._myPosition);
    this._myPrevRotationQuat.quat_copy(this._myRotationQuat);
    let xrFrame = XRUtils.getFrame(this._myEngine);
    if (xrFrame && this._isReadyToGetPose()) {
      let xrPose = null;
      try {
        xrPose = this._getPose(xrFrame);
      } catch (error4) {
      }
      if (xrPose) {
        this._myPosition[0] = xrPose.transform.position.x;
        this._myPosition[1] = xrPose.transform.position.y;
        this._myPosition[2] = xrPose.transform.position.z;
        this._myRotationQuat[0] = xrPose.transform.orientation.x;
        this._myRotationQuat[1] = xrPose.transform.orientation.y;
        this._myRotationQuat[2] = xrPose.transform.orientation.z;
        this._myRotationQuat[3] = xrPose.transform.orientation.w;
        this._myRotationQuat.quat_normalize(this._myRotationQuat);
        if (updateVelocity) {
          if (xrPose.linearVelocity && !this._myForceEmulatedVelocities) {
            this._myLinearVelocity[0] = xrPose.linearVelocity.x;
            this._myLinearVelocity[1] = xrPose.linearVelocity.y;
            this._myLinearVelocity[2] = xrPose.linearVelocity.z;
            this._myLinearVelocityEmulated = false;
          } else {
            this._computeEmulatedLinearVelocity(dt);
            this._myLinearVelocityEmulated = true;
          }
          if (xrPose.angularVelocity && !this._myForceEmulatedVelocities) {
            this._myAngularVelocityRadians[0] = xrPose.angularVelocity.x;
            this._myAngularVelocityRadians[1] = xrPose.angularVelocity.y;
            this._myAngularVelocityRadians[2] = xrPose.angularVelocity.z;
            this._myAngularVelocityEmulated = false;
          } else {
            this._computeEmulatedAngularVelocity(dt);
            this._myAngularVelocityEmulated = true;
          }
        }
        this._myValid = true;
      } else {
        if (updateVelocity) {
          this._myLinearVelocity[0] = 0;
          this._myLinearVelocity[1] = 0;
          this._myLinearVelocity[2] = 0;
          this._myAngularVelocityRadians[0] = 0;
          this._myAngularVelocityRadians[1] = 0;
          this._myAngularVelocityRadians[2] = 0;
        }
        this._myValid = false;
        this._myLinearVelocityEmulated = true;
        this._myAngularVelocityEmulated = true;
      }
      this._postUpdate(dt, updateVelocity, manualUpdate, xrPose);
    } else {
      if (updateVelocity) {
        this._myLinearVelocity[0] = 0;
        this._myLinearVelocity[1] = 0;
        this._myLinearVelocity[2] = 0;
        this._myAngularVelocityRadians[0] = 0;
        this._myAngularVelocityRadians[1] = 0;
        this._myAngularVelocityRadians[2] = 0;
      }
      this._myValid = false;
      this._myLinearVelocityEmulated = true;
      this._myAngularVelocityEmulated = true;
      this._postUpdate(dt, updateVelocity, manualUpdate, null);
    }
    this._myPrePoseUpdatedEventEmitter.notify(dt, this, manualUpdate);
    this._myPoseUpdatedEmitter.notify(dt, this, manualUpdate);
    this._myPostPoseUpdatedEventEmitter.notify(dt, this, manualUpdate);
  }
  _computeEmulatedLinearVelocity(dt) {
    if (dt > 0) {
      this._myPosition.vec3_sub(this._myPrevPosition, this._myLinearVelocity);
      this._myLinearVelocity.vec3_scale(1 / dt, this._myLinearVelocity);
    } else {
      this._myLinearVelocity[0] = 0;
      this._myLinearVelocity[1] = 0;
      this._myLinearVelocity[2] = 0;
    }
  }
  _onXRSessionStart(manualCall, session) {
    let referenceSpace = XRUtils.getReferenceSpace(this._myEngine);
    if (referenceSpace.addEventListener != null) {
      this._myViewResetEventListener = this._onViewReset.bind(this);
      referenceSpace.addEventListener("reset", this._myViewResetEventListener);
    }
    this._onXRSessionStartHook(manualCall, session);
  }
  _onXRSessionEnd() {
    this._onXRSessionEndHook();
    this._myViewResetEventListener = null;
  }
  _onViewReset() {
    if (this._myUpdateOnViewReset) {
      this._update(0, false, true);
    }
    this._onViewResetHook();
  }
  _computeEmulatedAngularVelocity() {
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
    this._destroyHook();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
BasePose.prototype.getPosition = function() {
  let transform = mat4_create();
  return function getPosition4(out = vec3_create(), referenceObjectOverride = void 0) {
    let referenceObject = referenceObjectOverride === void 0 ? this._myReferenceObject : referenceObjectOverride;
    out.vec3_copy(this._myPosition);
    if (referenceObject == null) {
      return out;
    }
    return out.vec3_convertPositionToWorld(referenceObject.pp_getTransform(transform), out);
  };
}();
BasePose.prototype.getRotationDegrees = function() {
  let rotationQuat = quat_create();
  return function getRotationDegrees4(out = vec3_create(), referenceObjectOverride = void 0) {
    return this.getRotationQuat(rotationQuat, referenceObjectOverride).quat_toDegrees(out);
  };
}();
BasePose.prototype.getRotationRadians = function() {
  let rotationQuat = quat_create();
  return function getRotationRadians4(out = vec3_create(), referenceObjectOverride = void 0) {
    return this.getRotationQuat(rotationQuat, referenceObjectOverride).quat_toRadians(out);
  };
}();
BasePose.prototype.getRotationQuat = function() {
  let playerRotationQuat = quat_create();
  let up = vec3_create();
  return function getRotationQuat4(out = quat_create(), referenceObjectOverride = void 0) {
    let referenceObject = referenceObjectOverride === void 0 ? this._myReferenceObject : referenceObjectOverride;
    out.quat_copy(this._myRotationQuat);
    if (this._myForwardFixed) {
      out.quat_rotateAxisRadians(Math.PI, out.quat_getUp(up), out);
    }
    if (referenceObject == null) {
      return out;
    }
    return out.quat_toWorld(referenceObject.pp_getRotationQuat(playerRotationQuat), out);
  };
}();
BasePose.prototype.getTransformMatrix = function() {
  let transformQuat2 = quat2_create();
  return function getTransformMatrix2(out = mat4_create(), referenceObjectOverride = void 0) {
    return this.getTransformQuat(transformQuat2, referenceObjectOverride).quat2_toMatrix(out);
  };
}();
BasePose.prototype.getTransformQuat = function() {
  let rotationQuat = quat_create();
  let playerTransformQuat = quat2_create();
  return function getTransformQuat2(out = quat2_create(), referenceObjectOverride = void 0) {
    let referenceObject = referenceObjectOverride === void 0 ? this._myReferenceObject : referenceObjectOverride;
    out.quat2_identity();
    out.quat2_setPositionRotationQuat(this._myPosition, this.getRotationQuat(rotationQuat, referenceObjectOverride));
    if (referenceObject == null) {
      return out;
    }
    return out.quat_toWorld(referenceObject.pp_getTransformQuat(playerTransformQuat), out);
  };
}();
BasePose.prototype.getLinearVelocity = function() {
  let transform = mat4_create();
  return function getLinearVelocity(out = vec3_create(), referenceObjectOverride = void 0) {
    let referenceObject = referenceObjectOverride === void 0 ? this._myReferenceObject : referenceObjectOverride;
    out.vec3_copy(this._myLinearVelocity);
    if (referenceObject == null) {
      return out;
    }
    return out.vec3_convertDirectionToWorld(referenceObject.pp_getTransform(transform), out);
  };
}();
BasePose.prototype.getAngularVelocityDegrees = function() {
  let velocityRadians = vec3_create();
  return function getAngularVelocityDegrees(out = vec3_create(), referenceObjectOverride = void 0) {
    return this.getAngularVelocityRadians(velocityRadians, referenceObjectOverride).vec3_toDegrees(out);
  };
}();
BasePose.prototype.getAngularVelocityRadians = function() {
  let transform = mat4_create();
  return function getAngularVelocityRadians(out = vec3_create(), referenceObjectOverride = void 0) {
    let referenceObject = referenceObjectOverride === void 0 ? this._myReferenceObject : referenceObjectOverride;
    out.vec3_copy(this._myAngularVelocityRadians);
    if (referenceObject == null) {
      return out;
    }
    return out.vec3_convertDirectionToWorld(referenceObject.pp_getTransform(transform), out);
  };
}();
BasePose.prototype._computeEmulatedAngularVelocity = function() {
  let rotationRadians = vec3_create();
  let prevRotationRadians = vec3_create();
  return function _computeEmulatedAngularVelocity(dt) {
    if (dt > 0) {
      rotationRadians = this._myRotationQuat.quat_toRadians(rotationRadians);
      prevRotationRadians = this._myPrevRotationQuat.quat_toRadians(prevRotationRadians);
      rotationRadians.vec3_sub(prevRotationRadians, this._myAngularVelocityRadians);
      this._myAngularVelocityRadians.vec3_scale(1 / dt, this._myAngularVelocityRadians);
    } else {
      this._myAngularVelocityRadians[0] = 0;
      this._myAngularVelocityRadians[1] = 0;
      this._myAngularVelocityRadians[2] = 0;
    }
  };
}();

// dist/pp/input/cauldron/input_utils.js
function getHandednessByString(string) {
  let handedness = null;
  switch (string) {
    case Handedness.LEFT:
      handedness = Handedness.LEFT;
      break;
    case Handedness.RIGHT:
      handedness = Handedness.RIGHT;
      break;
  }
  return handedness;
}
function getHandednessByIndex(index) {
  let handedness = null;
  switch (index) {
    case HandednessIndex.LEFT:
      handedness = Handedness.LEFT;
      break;
    case HandednessIndex.RIGHT:
      handedness = Handedness.RIGHT;
      break;
  }
  return handedness;
}
function getInputSource(handedness, inputSourceType = null, engine = Globals.getMainEngine()) {
  let inputSource = null;
  const xrSession = XRUtils.getSession(engine);
  if (xrSession != null && xrSession.inputSources != null) {
    for (let i = 0; i < xrSession.inputSources.length; i++) {
      const input = xrSession.inputSources[i];
      const correctType = inputSourceType == null || inputSourceType == InputSourceType.GAMEPAD && !input.hand || inputSourceType == InputSourceType.TRACKED_HAND && input.hand;
      if (correctType && input.handedness == handedness) {
        inputSource = input;
        break;
      }
    }
  }
  return inputSource;
}
function getInputSourceTypeByHandedness(handedness, engine = Globals.getMainEngine()) {
  const inputSource = InputUtils.getInputSource(handedness, void 0, engine);
  return inputSource != null ? InputUtils.getInputSourceType(inputSource) : null;
}
function getInputSourceType(inputSource) {
  let inputSourceType = null;
  if (inputSource.hand) {
    inputSourceType = InputSourceType.TRACKED_HAND;
  } else {
    inputSourceType = InputSourceType.GAMEPAD;
  }
  return inputSourceType;
}
function getOppositeHandedness(handedness) {
  let oppositeHandedness = null;
  switch (handedness) {
    case Handedness.LEFT:
      oppositeHandedness = Handedness.RIGHT;
      break;
    case Handedness.RIGHT:
      oppositeHandedness = Handedness.LEFT;
      break;
  }
  return oppositeHandedness;
}
function getJointIDByIndex(index) {
  let jointID = null;
  let jointIDKey = null;
  for (const jointIDIndexKey in TrackedHandJointIDIndex) {
    if (TrackedHandJointIDIndex[jointIDIndexKey] == index) {
      jointIDKey = jointIDIndexKey;
      break;
    }
  }
  if (jointIDKey != null) {
    jointID = TrackedHandJointID[jointIDKey];
  }
  return jointID;
}
var InputUtils = {
  getHandednessByString,
  getHandednessByIndex,
  getInputSource,
  getInputSourceTypeByHandedness,
  getInputSourceType,
  getOppositeHandedness,
  getJointIDByIndex
};

// dist/pp/input/pose/hand_pose.js
var HandPoseParams = class extends BasePoseParams {
  constructor(engine) {
    super(engine);
    this.myFixTrackedHandRotation = true;
    this.mySwitchToTrackedHandDelayEnabled = false;
    this.mySwitchToTrackedHandDelay = 0;
    this._mySwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter = 3;
    this.mySwitchToTrackedHandDelayNoInputSourceRiskyFixEnabled = false;
  }
};
var HandPose = class extends BasePose {
  constructor(handedness, handPoseParams = new HandPoseParams()) {
    super(handPoseParams);
    this._myHandedness = handedness;
    this._myFixTrackedHandRotation = handPoseParams.myFixTrackedHandRotation;
    this._myRealInputSource = null;
    this._myInputSource = null;
    this._myTrackedHand = false;
    this._myInputSourcesChangeEventListener = null;
    this._myVisibilityChangeEventListener = null;
    this._mySwitchToTrackedHandDelayEnabled = handPoseParams.mySwitchToTrackedHandDelayEnabled;
    this._mySwitchToTrackedHandDelay = handPoseParams.mySwitchToTrackedHandDelay;
    this._mySwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter = handPoseParams._mySwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter;
    this._mySwitchToTrackedHandDelayNoInputSourceRiskyFixEnabled = handPoseParams.mySwitchToTrackedHandDelayNoInputSourceRiskyFixEnabled;
    this._myDisableSwitchToTrackedHandDelaySessionChangeFrameCounter = 0;
    this._myDisableSwitchToTrackedHandDelaySessionChangeTimer = new Timer(1, false);
    this._myCurrentSwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter = 0;
    this._mySwitchToTrackedHandTimer = new Timer(this._mySwitchToTrackedHandDelay, false);
  }
  getHandedness() {
    return this._myHandedness;
  }
  getInputSource() {
    return this._myInputSource;
  }
  getInputSourceType() {
    if (this._myInputSource == null) {
      return null;
    }
    return InputUtils.getInputSourceType(this._myInputSource);
  }
  getInputSourceReal() {
    return this._myRealInputSource;
  }
  getInputSourceTypeReal() {
    if (this._myRealInputSource == null) {
      return null;
    }
    return InputUtils.getInputSourceType(this._myRealInputSource);
  }
  isFixTrackedHandRotation() {
    return this._myFixTrackedHandRotation;
  }
  setFixTrackedHandRotation(fixTrackedHandRotation) {
    this._myFixTrackedHandRotation = fixTrackedHandRotation;
  }
  isSwitchToTrackedHandDelayEnabled() {
    return this._mySwitchToTrackedHandDelayEnabled;
  }
  setSwitchToTrackedHandDelayEnabled(switchToTrackedHandDelayEnabled) {
    this._mySwitchToTrackedHandDelayEnabled = switchToTrackedHandDelayEnabled;
  }
  getSwitchToTrackedHandDelay() {
    return this._mySwitchToTrackedHandDelay;
  }
  setSwitchToTrackedHandDelay(switchToTrackedHandDelay) {
    this._mySwitchToTrackedHandDelay = switchToTrackedHandDelay;
  }
  getSwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter() {
    return this._mySwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter;
  }
  setSwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter(switchToTrackedHandDelayKeepCheckingForGamepadFrameCounter) {
    this._mySwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter = switchToTrackedHandDelayKeepCheckingForGamepadFrameCounter;
  }
  isSwitchToTrackedHandDelayNoInputSourceRiskyFixEnabled() {
    return this._mySwitchToTrackedHandDelayNoInputSourceRiskyFixEnabled;
  }
  setSwitchToTrackedHandDelayNoInputSourceRiskyFixEnabled(switchToTrackedHandDelayNoInputSourceRiskyFixEnabled) {
    this._mySwitchToTrackedHandDelayNoInputSourceRiskyFixEnabled = switchToTrackedHandDelayNoInputSourceRiskyFixEnabled;
  }
  getRotationQuat(out = quat_create(), referenceObjectOverride = void 0) {
  }
  _isReadyToGetPose() {
    return this._myInputSource != null;
  }
  _getPose(xrFrame) {
    return xrFrame.getPose(this._myInputSource.gripSpace, this.getReferenceSpace());
  }
  _preUpdate(dt) {
    if (this._mySwitchToTrackedHandDelayEnabled) {
      if (this._myCurrentSwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter > 0) {
        this._myCurrentSwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter--;
        if (this._myCurrentSwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter == 0) {
          this._myCurrentSwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter = 0;
          this._mySwitchToTrackedHandTimer.reset();
        }
        this._myInputSourcesChangeEventListener();
      }
      if (this._mySwitchToTrackedHandTimer.isRunning()) {
        this._mySwitchToTrackedHandTimer.update(dt);
        if (this._mySwitchToTrackedHandTimer.isDone()) {
          if (this._myInputSourcesChangeEventListener != null) {
            this._myCurrentSwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter = 0;
            this._mySwitchToTrackedHandTimer.reset();
            this._myInputSourcesChangeEventListener();
          }
        }
      }
      if (this._myDisableSwitchToTrackedHandDelaySessionChangeFrameCounter > 0) {
        this._myDisableSwitchToTrackedHandDelaySessionChangeFrameCounter--;
      } else {
        this._myDisableSwitchToTrackedHandDelaySessionChangeTimer.update(dt);
      }
    }
  }
  _setActiveHook(active) {
    if (this.isActive() != active) {
      if (!active) {
        this._myRealInputSource = null;
        this._myInputSource = null;
        this._myTrackedHand = false;
        XRUtils.getSession(this.getEngine())?.removeEventListener("inputsourceschange", this._myInputSourcesChangeEventListener);
        XRUtils.getSession(this.getEngine())?.removeEventListener("visibilitychange", this._myVisibilityChangeEventListener);
        this._myCurrentSwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter = 0;
        this._mySwitchToTrackedHandTimer.reset();
        this._myDisableSwitchToTrackedHandDelaySessionChangeFrameCounter = 0;
        this._myDisableSwitchToTrackedHandDelaySessionChangeTimer.reset();
      }
    }
  }
  _onXRSessionStartHook(manualCall, session) {
    if (this._mySwitchToTrackedHandDelayEnabled) {
      this._myDisableSwitchToTrackedHandDelaySessionChangeFrameCounter = 10;
      this._myDisableSwitchToTrackedHandDelaySessionChangeTimer.start();
    }
    this._myInputSourcesChangeEventListener = () => {
      let wasUsingGamepad = false;
      let lastGamepadInputSource = null;
      if (this._mySwitchToTrackedHandDelayEnabled) {
        if ((this.getInputSourceTypeReal() == InputSourceType.GAMEPAD || this._mySwitchToTrackedHandTimer.isRunning()) && this._mySwitchToTrackedHandDelay > 0 && session.trackedSources != null && this._myDisableSwitchToTrackedHandDelaySessionChangeFrameCounter == 0 && !this._myDisableSwitchToTrackedHandDelaySessionChangeTimer.isRunning()) {
          wasUsingGamepad = true;
          if (this._mySwitchToTrackedHandDelayNoInputSourceRiskyFixEnabled) {
            lastGamepadInputSource = this._myInputSource;
          }
        }
      }
      this._myRealInputSource = null;
      this._myInputSource = null;
      this._myTrackedHand = false;
      if (session.inputSources != null) {
        for (const inputSource of session.inputSources) {
          if (inputSource.handedness == this._myHandedness) {
            this._myRealInputSource = inputSource;
            this._myInputSource = inputSource;
            this._myTrackedHand = InputUtils.getInputSourceType(this._myInputSource) == InputSourceType.TRACKED_HAND;
            break;
          }
        }
      }
      if (this._mySwitchToTrackedHandDelayEnabled) {
        if (wasUsingGamepad && (this._myInputSource == null || this._myTrackedHand)) {
          const inputSourcesToCheck = [];
          if (session.inputSources != null) {
            inputSourcesToCheck.push(...session.inputSources);
          }
          if (session.trackedSources != null) {
            inputSourcesToCheck.push(...session.trackedSources);
          }
          let gamepadFound = false;
          for (const inputSourceToCheck of inputSourcesToCheck) {
            if (inputSourceToCheck.handedness == this._myHandedness) {
              const inputSourceToCheckType = InputUtils.getInputSourceType(inputSourceToCheck);
              if (inputSourceToCheckType == InputSourceType.GAMEPAD) {
                this._myInputSource = inputSourceToCheck;
                this._myTrackedHand = false;
                this._myCurrentSwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter = 0;
                if (!this._mySwitchToTrackedHandTimer.isRunning()) {
                  this._mySwitchToTrackedHandTimer.start(this._mySwitchToTrackedHandDelay);
                }
                gamepadFound = true;
                break;
              }
            }
          }
          if (!gamepadFound) {
            if (this._mySwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter > 0) {
              if (this._mySwitchToTrackedHandDelayNoInputSourceRiskyFixEnabled) {
                this._myInputSource = lastGamepadInputSource;
                this._myTrackedHand = false;
              } else {
                this._myInputSource = null;
                this._myTrackedHand = false;
              }
              if (this._myCurrentSwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter == 0) {
                this._myCurrentSwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter = this._mySwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter;
              }
              if (!this._mySwitchToTrackedHandTimer.isRunning()) {
                this._mySwitchToTrackedHandTimer.start(this._mySwitchToTrackedHandDelay);
              }
            } else {
              this._myCurrentSwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter = 0;
              this._mySwitchToTrackedHandTimer.reset();
            }
          }
        } else {
          this._myCurrentSwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter = 0;
          this._mySwitchToTrackedHandTimer.reset();
        }
      }
    };
    this._myInputSourcesChangeEventListener();
    session.addEventListener("inputsourceschange", this._myInputSourcesChangeEventListener);
    this._myVisibilityChangeEventListener = () => {
      this._myCurrentSwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter = 0;
      this._mySwitchToTrackedHandTimer.reset();
      if (this._mySwitchToTrackedHandDelayEnabled) {
        this._myDisableSwitchToTrackedHandDelaySessionChangeFrameCounter = 10;
        this._myDisableSwitchToTrackedHandDelaySessionChangeTimer.start();
      }
    };
    session.addEventListener("visibilitychange", this._myVisibilityChangeEventListener);
  }
  _onXRSessionEndHook() {
    this._myRealInputSource = null;
    this._myInputSource = null;
    this._myTrackedHand = false;
    this._myInputSourcesChangeEventListener = null;
    this._myVisibilityChangeEventListener = null;
    this._myCurrentSwitchToTrackedHandDelayKeepCheckingForGamepadFrameCounter = 0;
    this._mySwitchToTrackedHandTimer.reset();
    this._myDisableSwitchToTrackedHandDelaySessionChangeFrameCounter = 0;
    this._myDisableSwitchToTrackedHandDelaySessionChangeTimer.reset();
  }
};
HandPose.prototype.getRotationQuat = function() {
  let playerRotationQuat = quat_create();
  let up = vec3_create();
  let right = vec3_create();
  let forward = vec3_create();
  return function getRotationQuat4(out = quat_create(), referenceObjectOverride = void 0) {
    let referenceObject = referenceObjectOverride === void 0 ? this._myReferenceObject : referenceObjectOverride;
    out.quat_copy(this._myRotationQuat);
    if (this._myForwardFixed) {
      out.quat_rotateAxisRadians(Math.PI, out.quat_getUp(up), out);
    }
    if (this._myFixTrackedHandRotation && this._myTrackedHand) {
      out.quat_rotateAxis(-60, out.quat_getRight(right), out);
      let forwardRotation = 20;
      forwardRotation = this._myHandedness == Handedness.LEFT ? forwardRotation : -forwardRotation;
      out.quat_rotateAxis(forwardRotation, out.quat_getForward(forward), out);
    }
    if (referenceObject == null) {
      return out;
    }
    return out.quat_toWorld(referenceObject.pp_getRotationQuat(playerRotationQuat), out);
  };
}();

// dist/pp/input/pose/hand_ray_pose.js
var HandRayPoseParams = class extends HandPoseParams {
};
var HandRayPose = class extends HandPose {
  constructor(handedness, handRayPoseParams = new HandRayPoseParams()) {
    super(handedness, handRayPoseParams);
  }
  _getPose(xrFrame) {
    return xrFrame.getPose(this._myInputSource.targetRaySpace, this.getReferenceSpace());
  }
};

// dist/pp/input/pose/head_pose.js
var HeadPose = class extends BasePose {
  _getPose(xrFrame) {
    return xrFrame.getViewerPose(this.getReferenceSpace());
  }
};

// dist/pp/input/pose/tracked_hand_joint_pose.js
var TrackedHandJointPose = class extends BasePose {
  constructor(handedness, trackedHandJointID, basePoseParams = new BasePoseParams()) {
    super(basePoseParams);
    this._myInputSource = null;
    this._myHandedness = handedness;
    this._myTrackedHandJointID = trackedHandJointID;
    this._myJointRadius = 0;
    this._myInputSourcesChangeEventListener = null;
  }
  getHandedness() {
    return this._myHandedness;
  }
  getTrackedHandJointID() {
    return this._myTrackedHandJointID;
  }
  setTrackedHandJointID(trackedHandJointID) {
    this._myTrackedHandJointID = trackedHandJointID;
  }
  getJointRadius() {
    return this._myJointRadius;
  }
  _isReadyToGetPose() {
    return this._myInputSource != null;
  }
  _getPose(xrFrame) {
    return xrFrame.getJointPose(this._myInputSource.hand.get(this._myTrackedHandJointID), this.getReferenceSpace());
  }
  _postUpdate(dt, updateVelocity, manualUpdate, xrPose) {
    if (xrPose != null) {
      this._myJointRadius = xrPose.radius;
    }
  }
  _setActiveHook(active) {
    if (this.isActive() != active) {
      if (!active) {
        this._myInputSource = null;
        this._myJointRadius = 0;
        XRUtils.getSession(this.getEngine())?.removeEventListener("inputsourceschange", this._myInputSourcesChangeEventListener);
      }
    }
  }
  _onXRSessionStartHook(manualCall, session) {
    this._myInputSourcesChangeEventListener = () => {
      this._myInputSource = null;
      if (session.inputSources != null && session.inputSources.length > 0) {
        for (let i = 0; i < session.inputSources.length; i++) {
          let inputSource = session.inputSources[i];
          if (inputSource.handedness == this._myHandedness) {
            if (InputUtils.getInputSourceType(inputSource) == InputSourceType.TRACKED_HAND) {
              this._myInputSource = inputSource;
            }
          }
        }
      }
    };
    this._myInputSourcesChangeEventListener();
    session.addEventListener("inputsourceschange", this._myInputSourcesChangeEventListener);
  }
  _onXRSessionEndHook() {
    this._myInputSource = null;
    this._myInputSourcesChangeEventListener = null;
  }
};

// dist/pp/input/pose/tracked_hand_pose.js
var TrackedHandPoseParams = class extends BasePoseParams {
  constructor(addAllJointIDs = true, engine = Globals.getMainEngine()) {
    super(engine);
    this.myTrackedHandJointIDList = [];
    this._myActive = true;
    if (addAllJointIDs) {
      for (let key in TrackedHandJointID) {
        this.myTrackedHandJointIDList.push(TrackedHandJointID[key]);
      }
    }
  }
};
var TrackedHandPose = class {
  constructor(handedness, trackedHandPoseParams = new TrackedHandPoseParams()) {
    this._myHandedness = handedness;
    this._myForwardFixed = trackedHandPoseParams.myForwardFixed;
    this._myForceEmulatedVelocities = trackedHandPoseParams.myForceEmulatedVelocities;
    this._myReferenceObject = trackedHandPoseParams.myReferenceObject;
    this._myEngine = trackedHandPoseParams.myEngine;
    this._myActive = true;
    this._myTrackedHandJointPoseParams = new BasePoseParams(this._myEngine);
    this._myTrackedHandJointPoseParams.myForwardFixed = this._myForwardFixed;
    this._myTrackedHandJointPoseParams.myForceEmulatedVelocities = this._myForceEmulatedVelocities;
    this._myTrackedHandJointPoseParams.myReferenceObject = this._myReferenceObject;
    this._myTrackedHandJointPoses = [];
    for (let jointID of trackedHandPoseParams.myTrackedHandJointIDList) {
      let trackedHandJointPose = new TrackedHandJointPose(this._myHandedness, jointID, this._myTrackedHandJointPoseParams);
      this._myTrackedHandJointPoses[jointID] = trackedHandJointPose;
    }
  }
  setActive(active) {
    this._myActive = active;
    for (let jointPose of this._myTrackedHandJointPoses) {
      jointPose.setActive(active);
    }
  }
  isActive() {
    return this._myActive;
  }
  start() {
    for (let jointPoseKey in this._myTrackedHandJointPoses) {
      let jointPose = this._myTrackedHandJointPoses[jointPoseKey];
      jointPose.start();
    }
  }
  update(dt) {
    if (!this._myActive)
      return;
    for (let jointPoseKey in this._myTrackedHandJointPoses) {
      let jointPose = this._myTrackedHandJointPoses[jointPoseKey];
      jointPose.update(dt);
    }
  }
  getEngine() {
    return this._myEngine;
  }
  getHandedness() {
    return this._myHandedness;
  }
  getJointPose(jointID) {
    return this._myTrackedHandJointPoses[jointID];
  }
  getJointPoseByIndex(jointIDIndex) {
    return this._myTrackedHandJointPoses[InputUtils.getJointIDByIndex(jointIDIndex)];
  }
  getJointPoses() {
    return this._myTrackedHandJointPoses;
  }
  addTrackedHandJointID(jointID) {
    if (!this._myTrackedHandJointPoses.pp_has((element) => element.getTrackedHandJointID() == jointID)) {
      let trackedHandJointPose = new TrackedHandJointPose(this._myHandedness, jointID, this._myTrackedHandJointPoseParams);
      this._myTrackedHandJointPoses.push(trackedHandJointPose);
    }
  }
  removeTrackedHandJointID(jointID) {
    this._myTrackedHandJointPoses.pp_remove((element) => element.getTrackedHandJointID() == jointID);
  }
  setReferenceObject(referenceObject) {
    this._myReferenceObject = referenceObject;
    this._myTrackedHandJointPoseParams.myReferenceObject = this._myReferenceObject;
    for (let jointPoseKey in this._myTrackedHandJointPoses) {
      let jointPose = this._myTrackedHandJointPoses[jointPoseKey];
      jointPose.setReferenceObject(referenceObject);
    }
  }
  getReferenceObject() {
    return this._myReferenceObject;
  }
  setForwardFixed(forwardFixed) {
    this._myForwardFixed = forwardFixed;
    this._myTrackedHandJointPoseParams.myForwardFixed = this._myForwardFixed;
    for (let jointPoseKey in this._myTrackedHandJointPoses) {
      let jointPose = this._myTrackedHandJointPoses[jointPoseKey];
      jointPose.setForwardFixed(forwardFixed);
    }
  }
  isForwardFixed() {
    return this._myForwardFixed;
  }
  setForceEmulatedVelocities(forceEmulatedVelocities) {
    this._myForceEmulatedVelocities = forceEmulatedVelocities;
    this._myTrackedHandJointPoseParams.myForceEmulatedVelocities = this._myForceEmulatedVelocities;
    for (let jointPoseKey in this._myTrackedHandJointPoses) {
      let jointPose = this._myTrackedHandJointPoses[jointPoseKey];
      jointPose.setForceEmulatedVelocities(forceEmulatedVelocities);
    }
  }
  isForceEmulatedVelocities() {
    return this._myForceEmulatedVelocities;
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
    for (let jointPose of this._myTrackedHandJointPoses) {
      jointPose.destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/input/cauldron/mouse.js
import { ViewComponent as ViewComponent2 } from "@wonderlandengine/api";
var MouseButtonID = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2,
  BACK: 3,
  FORWARD: 4
};
var Mouse = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myButtonInfos = {};
    this._myButtonInfosIDs = [];
    for (let key in MouseButtonID) {
      this._myButtonInfos[MouseButtonID[key]] = this._createButtonInfo();
      this._myButtonInfosIDs.push(MouseButtonID[key]);
    }
    this._myPreventContextMenuEventListener = this._preventContextMenu.bind(this);
    this._myPreventMiddleButtonScrollEventListener = this._preventMiddleButtonScroll.bind(this);
    this._myInternalMousePosition = vec2_create();
    this._myScreenSize = vec2_create();
    this._myResetMovingDelay = 0.15;
    this._myResetMovingTimer = new Timer(this._myResetMovingDelay, false);
    this._myMoving = false;
    this._myInsideView = false;
    this._myValid = false;
    this._myActive = true;
    this._myPointerUpOnPointerLeave = true;
    this._myContextMenuActive = true;
    this._myMiddleButtonScrollActive = true;
    this._myPointerID = null;
    this._myLastValidPointerEvent = null;
    this._myPointerEventValidCallbacks = {};
    this._myPointerEventValidCallbacksIDs = [];
    this._myPointerMoveEventListener = null;
    this._myPointerDownEventListener = null;
    this._myPointerUpEventListener = null;
    this._myPointerLeaveEventListener = null;
    this._myPointerEnterEventListener = null;
    this._myMouseDownEventListener = null;
    this._myMouseUpEventListener = null;
    this._myWindowResizeEventListener = null;
    this._myDestroyed = false;
    this._myProjectionMatrixInverse = mat4_create();
    this._myRotationQuat = quat_create();
    this._myOriginWorld = vec3_create();
    this._myDirectionWorld = vec3_create();
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      if (this._myActive) {
        this._myPointerMoveEventListener = this._onPointerAction.bind(this, this._onPointerMove.bind(this));
        document.body.addEventListener("pointermove", this._myPointerMoveEventListener);
        this._myPointerDownEventListener = this._onPointerAction.bind(this, this._onPointerDown.bind(this));
        document.body.addEventListener("pointerdown", this._myPointerDownEventListener);
        this._myPointerUpEventListener = this._onPointerAction.bind(this, this._onPointerUp.bind(this));
        document.body.addEventListener("pointerup", this._myPointerUpEventListener);
        this._myPointerLeaveEventListener = this._onPointerLeave.bind(this);
        document.body.addEventListener("pointerleave", this._myPointerLeaveEventListener);
        this._myPointerEnterEventListener = this._onPointerEnter.bind(this);
        document.body.addEventListener("pointerenter", this._myPointerEnterEventListener);
        this._myMouseDownEventListener = this._onMouseAction.bind(this, this._onPointerDown.bind(this));
        document.body.addEventListener("mousedown", this._myMouseDownEventListener);
        this._myMouseUpEventListener = this._onMouseAction.bind(this, this._onPointerUp.bind(this));
        document.body.addEventListener("mouseup", this._myMouseUpEventListener);
        this._updateScreenSize();
        this._myWindowResizeEventListener = this._updateScreenSize.bind(this);
        window.addEventListener("resize", this._myWindowResizeEventListener);
        this._myContextMenuActive = !this._myContextMenuActive;
        this.setContextMenuActive(!this._myContextMenuActive);
        this._myMiddleButtonScrollActive = !this._myMiddleButtonScrollActive;
        this.setMiddleButtonScrollActive(!this._myMiddleButtonScrollActive);
      } else {
        for (let i = 0; i < this._myButtonInfosIDs.length; i++) {
          let id = this._myButtonInfosIDs[i];
          let buttonInfo = this._myButtonInfos[id];
          buttonInfo.myPressed = false;
          buttonInfo.myPressStart = false;
          buttonInfo.myPressEnd = false;
          buttonInfo.myPressStartToProcess = false;
          buttonInfo.myPressEndToProcess = false;
        }
        this._myInternalMousePosition.vec2_zero();
        this._myScreenSize.vec2_zero();
        this._myResetMovingTimer.reset();
        this._myMoving = false;
        this._myInsideView = false;
        this._myValid = false;
        this._myPointerID = null;
        this._myLastValidPointerEvent = null;
        document.body.removeEventListener("pointermove", this._myPointerMoveEventListener);
        document.body.removeEventListener("pointerdown", this._myPointerDownEventListener);
        document.body.removeEventListener("pointerup", this._myPointerUpEventListener);
        document.body.removeEventListener("pointerleave", this._myPointerLeaveEventListener);
        document.body.removeEventListener("pointerenter", this._myPointerEnterEventListener);
        document.body.removeEventListener("mousedown", this._myMouseDownEventListener);
        document.body.removeEventListener("mouseup", this._myMouseUpEventListener);
        document.body.removeEventListener("contextmenu", this._myPreventContextMenuEventListener);
        document.body.removeEventListener("mousedown", this._myPreventMiddleButtonScrollEventListener);
        window.removeEventListener("resize", this._myWindowResizeEventListener);
        this._myPointerMoveEventListener = null;
        this._myPointerDownEventListener = null;
        this._myPointerUpEventListener = null;
        this._myPointerLeaveEventListener = null;
        this._myPointerEnterEventListener = null;
        this._myMouseDownEventListener = null;
        this._myMouseUpEventListener = null;
        this._myWindowResizeEventListener = null;
      }
    }
  }
  isActive() {
    return this._myActive;
  }
  start() {
    this._myActive = false;
    this.setActive(true);
  }
  update(dt) {
    if (!this._myActive)
      return;
    if (this._myResetMovingTimer.isRunning()) {
      this._myResetMovingTimer.update(dt);
      if (this._myResetMovingTimer.isDone()) {
        this._myResetMovingTimer.reset();
        this._myMoving = false;
      }
    }
    for (let i = 0; i < this._myButtonInfosIDs.length; i++) {
      let id = this._myButtonInfosIDs[i];
      let buttonInfo = this._myButtonInfos[id];
      buttonInfo.myPressStart = buttonInfo.myPressStartToProcess;
      buttonInfo.myPressEnd = buttonInfo.myPressEndToProcess;
      buttonInfo.myPressStartToProcess = false;
      buttonInfo.myPressEndToProcess = false;
    }
    if (!this.isAnyButtonPressed() && !this._myMoving) {
      this._myPointerID = null;
    }
    if (this._myLastValidPointerEvent != null) {
      let lastValidPointerEventStillValid = this._isPointerEventValid(this._myLastValidPointerEvent);
      if (!lastValidPointerEventStillValid) {
        if (this._myInsideView) {
          this._onPointerLeave(this._myLastValidPointerEvent);
        }
        this._myLastValidPointerEvent = null;
      }
    }
  }
  isValid() {
    return this._myValid;
  }
  isButtonPressed(buttonID) {
    let pressed = false;
    if (this._myButtonInfos[buttonID] != null) {
      pressed = this._myButtonInfos[buttonID].myPressed;
    }
    return pressed;
  }
  isAnyButtonPressed() {
    let pressed = false;
    for (let i = 0; i < this._myButtonInfosIDs.length; i++) {
      let id = this._myButtonInfosIDs[i];
      let buttonInfo = this._myButtonInfos[id];
      if (buttonInfo.myPressed) {
        pressed = true;
        break;
      }
    }
    return pressed;
  }
  isButtonPressStart(buttonID) {
    let pressStart = false;
    if (this._myButtonInfos[buttonID] != null) {
      pressStart = this._myButtonInfos[buttonID].myPressStart;
    }
    return pressStart;
  }
  isButtonPressEnd(buttonID = null) {
    let pressEnd = false;
    if (this._myButtonInfos[buttonID] != null) {
      pressEnd = this._myButtonInfos[buttonID].myPressEnd;
    }
    return pressEnd;
  }
  isMoving() {
    return this._myMoving;
  }
  isInsideView() {
    return this._myInsideView;
  }
  isTargetingRenderCanvas() {
    return this.isInsideView() && this._myLastValidPointerEvent != null && this._myLastValidPointerEvent.target == Globals.getCanvas(this._myEngine);
  }
  // The origin and direction are set by the mouse
  raycastWorld(raycastParams, raycastResults = new RaycastResults()) {
    this.getOriginWorld(raycastParams.myOrigin);
    this.getDirectionWorld(raycastParams.myDirection);
    raycastResults = PhysicsUtils.raycast(raycastParams, raycastResults, Globals.getPhysics(this._myEngine));
    return raycastResults;
  }
  getPositionScreen(out = vec2_create()) {
    let mousePosition = out;
    mousePosition[0] = this._myInternalMousePosition[0];
    mousePosition[1] = this._myScreenSize[1] - 1 - this._myInternalMousePosition[1];
    return mousePosition;
  }
  getPositionScreenNormalized(out = vec2_create()) {
    let mousePosition = out;
    mousePosition[0] = this._myScreenSize[0] == 0 ? 0 : this._myInternalMousePosition[0] / this._myScreenSize[0] * 2 - 1;
    mousePosition[1] = this._myScreenSize[1] == 0 ? 0 : (this._myScreenSize[1] - 1 - this._myInternalMousePosition[1]) / this._myScreenSize[1] * 2 - 1;
    return mousePosition;
  }
  getScreenSize() {
    return this._myScreenSize;
  }
  getPositionWorld(distanceFromCamera, out = vec3_create()) {
    let originWorld = this.getOriginWorld(this._myOriginWorld);
    let directionWorld = this.getDirectionWorld(this._myDirectionWorld);
    out = originWorld.vec3_add(directionWorld.vec3_scale(distanceFromCamera, out), out);
    return out;
  }
  getOriginWorld(out = vec3_create()) {
    if (XRUtils.isSessionActive(this._myEngine)) {
      Globals.getPlayerObjects(this._myEngine).myEyeLeft.pp_getPosition(out);
    } else {
      Globals.getPlayerObjects(this._myEngine).myCameraNonXR.pp_getPosition(out);
    }
    return out;
  }
  getDirectionWorld(out = vec3_create()) {
    let right = this._myInternalMousePosition[0] / this._myScreenSize[0];
    let up = this._myInternalMousePosition[1] / this._myScreenSize[1];
    let directionLocal = out;
    directionLocal.vec3_set(right * 2 - 1, -up * 2 + 1, -1);
    let projectionMatrixInvert = this._myProjectionMatrixInverse;
    if (XRUtils.isSessionActive(this._myEngine)) {
      projectionMatrixInvert = Globals.getPlayerObjects(this._myEngine).myEyeLeft.pp_getComponent(ViewComponent2).projectionMatrix.mat4_invert(projectionMatrixInvert);
    } else {
      projectionMatrixInvert = Globals.getPlayerObjects(this._myEngine).myCameraNonXR.pp_getComponent(ViewComponent2).projectionMatrix.mat4_invert(projectionMatrixInvert);
    }
    directionLocal.vec3_transformMat4(projectionMatrixInvert, directionLocal);
    directionLocal.vec3_normalize(directionLocal);
    let directionWorld = directionLocal;
    if (XRUtils.isSessionActive(this._myEngine)) {
      directionWorld = directionLocal.vec3_transformQuat(Globals.getPlayerObjects(this._myEngine).myEyeLeft.pp_getRotationQuat(this._myRotationQuat), directionLocal);
    } else {
      directionWorld = directionLocal.vec3_transformQuat(Globals.getPlayerObjects(this._myEngine).myCameraNonXR.pp_getRotationQuat(this._myRotationQuat), directionLocal);
    }
    directionWorld.vec3_normalize(directionWorld);
    return out;
  }
  setTouchValid(touchValid) {
    let callbackID = "pp_internal_touch_valid_callback";
    if (touchValid) {
      this.removePointerEventValidCallback(callbackID);
    } else {
      this.addPointerEventValidCallback(callbackID, function(event) {
        return event.pointerType == "mouse";
      });
    }
  }
  setTargetOnlyRenderCanvas(targetOnlyRenderCanvas) {
    let callbackID = "pp_internal_target_only_render_canvas_callback";
    if (targetOnlyRenderCanvas) {
      this.addPointerEventValidCallback(callbackID, function(event) {
        return event.target == Globals.getCanvas(this._myEngine);
      });
    } else {
      this.removePointerEventValidCallback(callbackID);
    }
  }
  getLastValidPointerEvent() {
    return this._myLastValidPointerEvent;
  }
  // Can be used to specify that only some pointerType are valid (eg: mouse, touch, pen) or just some target (eg: Globals.getCanvas(this._myEngine))
  addPointerEventValidCallback(id, callback) {
    this._myPointerEventValidCallbacks[id] = callback;
    this._myPointerEventValidCallbacksIDs.push(id);
  }
  removePointerEventValidCallback(id) {
    delete this._myPointerEventValidCallbacks[id];
    this._myPointerEventValidCallbacksIDs.pp_removeEqual(id);
  }
  isPointerUpOnPointerLeave() {
    return this._myPointerUpOnPointerLeave;
  }
  setPointerUpOnPointerLeave(pointerUpOnPointerLeave) {
    this._myPointerUpOnPointerLeave = pointerUpOnPointerLeave;
  }
  isContextMenuActive() {
    return this._myContextMenuActive;
  }
  setContextMenuActive(active) {
    if (this._myContextMenuActive != active) {
      this._myContextMenuActive = active;
      if (this._myActive) {
        if (active) {
          document.body.removeEventListener("contextmenu", this._myPreventContextMenuEventListener);
        } else {
          document.body.addEventListener("contextmenu", this._myPreventContextMenuEventListener, false);
        }
      }
    }
  }
  isMiddleButtonScrollActive() {
    return this._myMiddleButtonScrollActive;
  }
  setMiddleButtonScrollActive(active) {
    if (this._myMiddleButtonScrollActive != active) {
      this._myMiddleButtonScrollActive = active;
      if (this._myActive) {
        if (active) {
          document.body.removeEventListener("mousedown", this._myPreventMiddleButtonScrollEventListener);
        } else {
          document.body.addEventListener("mousedown", this._myPreventMiddleButtonScrollEventListener, false);
        }
      }
    }
  }
  setResetMovingDelay(delay) {
    this._myResetMovingDelay = delay;
  }
  getResetMovingDelay() {
    return this._myResetMovingDelay;
  }
  _onPointerAction(actionCallback, event) {
    if (!this._isPointerEventIDValid(event))
      return;
    if (!this._isPointerEventValid(event)) {
      if (this._myInsideView) {
        this._onPointerLeave(event);
      }
      return;
    }
    if (!this._myInsideView) {
      this._onPointerEnter(event);
    }
    actionCallback(event);
    this._updatePosition(event);
    this._updatePointerData(event);
  }
  _onMouseAction(actionCallback, event) {
    if (!this._myInsideView)
      return;
    if (!this._isMouseAllowed())
      return;
    if (!this._isPointerEventIDValid(this._myLastValidPointerEvent))
      return;
    if (!this._isPointerEventValid(this._myLastValidPointerEvent))
      return;
    actionCallback(event);
  }
  _onPointerMove(event) {
    this._myResetMovingTimer.start(this._myResetMovingDelay);
    this._myMoving = true;
  }
  _onPointerDown(event) {
    let buttonInfo = this._myButtonInfos[event.button];
    if (buttonInfo != null && !buttonInfo.myPressed) {
      buttonInfo.myPressed = true;
      buttonInfo.myPressStartToProcess = true;
    }
  }
  _onPointerUp(event) {
    let buttonInfo = this._myButtonInfos[event.button];
    if (buttonInfo != null && buttonInfo.myPressed) {
      buttonInfo.myPressed = false;
      buttonInfo.myPressEndToProcess = true;
    }
  }
  _onPointerLeave(event) {
    if (!this._myInsideView || this._myLastValidPointerEvent == null || event.pointerId != this._myLastValidPointerEvent.pointerId)
      return;
    this._myInsideView = false;
    this._myMoving = false;
    if (this._myPointerUpOnPointerLeave) {
      for (let i = 0; i < this._myButtonInfosIDs.length; i++) {
        let id = this._myButtonInfosIDs[i];
        let buttonInfo = this._myButtonInfos[id];
        if (buttonInfo.myPressed) {
          buttonInfo.myPressed = false;
          buttonInfo.myPressEndToProcess = true;
        }
      }
    }
    this._myPointerID = null;
  }
  _onPointerEnter(event) {
    if (this._myInsideView && this._myPointerID != null || !this._isPointerEventIDValid(event) || !this._isPointerEventValid(event))
      return;
    this._myInsideView = true;
    this._updatePosition(event);
    this._updatePointerData(event);
  }
  _preventContextMenu(event) {
    if (!this._isPointerEventIDValid(event) || !this._isPointerEventValid(event))
      return;
    event.preventDefault();
  }
  _preventMiddleButtonScroll(event) {
    if (!this._isPointerEventIDValid(event) || !this._isPointerEventValid(event))
      return;
    if (event.button == 1) {
      event.preventDefault();
      return false;
    }
  }
  _updatePosition(event) {
    this._myInternalMousePosition[0] = event.clientX;
    this._myInternalMousePosition[1] = event.clientY;
    this._myValid = true;
  }
  _updateScreenSize() {
    let bounds = document.body.getBoundingClientRect();
    this._myScreenSize[0] = bounds.width;
    this._myScreenSize[1] = bounds.height;
  }
  _updatePointerData(event) {
    this._myPointerID = event.pointerId;
    this._myLastValidPointerEvent = event;
  }
  _isPointerEventIDValid(event) {
    if (event == null)
      return false;
    return this._myPointerID == null || this._myPointerID == event.pointerId;
  }
  _isPointerEventValid(event) {
    if (event == null)
      return false;
    let valid = true;
    for (let i = 0; i < this._myPointerEventValidCallbacksIDs.length; i++) {
      let id = this._myPointerEventValidCallbacksIDs[i];
      let callback = this._myPointerEventValidCallbacks[id];
      if (!callback(event)) {
        valid = false;
        break;
      }
    }
    return valid;
  }
  _isMouseAllowed() {
    return this._myLastValidPointerEvent != null && this._myLastValidPointerEvent.pointerId == 1;
  }
  _createButtonInfo() {
    return { myPressed: false, myPressStart: false, myPressStartToProcess: false, myPressEnd: false, myPressEndToProcess: false };
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/input/cauldron/input_manager.js
var InputManager = class {
  _myMouse;
  _myKeyboard;
  _myHeadPose;
  _myHandPoses;
  _myHandRayPoses;
  _myTrackedHandPoses;
  _myGamepadsManager = new GamepadsManager();
  _myStarted = false;
  _myActive = false;
  _myTrackedHandPosesEnabled = true;
  _myTrackedHandPosesStarted = false;
  _myPreUpdateEmitter = new Emitter6();
  _myPostUpdateEmitter = new Emitter6();
  _myEngine;
  _myDestroyed = false;
  constructor(engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myMouse = new Mouse(this._myEngine);
    this._myKeyboard = new Keyboard(this._myEngine);
    this._myHeadPose = new HeadPose(new BasePoseParams(this._myEngine));
    this._myHeadPose.setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myHeadPose.setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myHandPoses = {
      [Handedness.LEFT]: new HandPose(Handedness.LEFT, new HandPoseParams(this._myEngine)),
      [Handedness.RIGHT]: new HandPose(Handedness.RIGHT, new HandPoseParams(this._myEngine))
    };
    this._myHandPoses[Handedness.LEFT].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myHandPoses[Handedness.RIGHT].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myHandPoses[Handedness.LEFT].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myHandPoses[Handedness.RIGHT].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myHandRayPoses = {
      [Handedness.LEFT]: new HandRayPose(Handedness.LEFT, new HandRayPoseParams(this._myEngine)),
      [Handedness.RIGHT]: new HandRayPose(Handedness.RIGHT, new HandRayPoseParams(this._myEngine))
    };
    this._myHandRayPoses[Handedness.LEFT].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myHandRayPoses[Handedness.RIGHT].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myHandRayPoses[Handedness.LEFT].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myHandRayPoses[Handedness.RIGHT].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myTrackedHandPoses = {
      [Handedness.LEFT]: new TrackedHandPose(Handedness.LEFT, new TrackedHandPoseParams(true, this._myEngine)),
      [Handedness.RIGHT]: new TrackedHandPose(Handedness.RIGHT, new TrackedHandPoseParams(true, this._myEngine))
    };
    this._myTrackedHandPoses[Handedness.LEFT].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myTrackedHandPoses[Handedness.RIGHT].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myTrackedHandPoses[Handedness.LEFT].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myTrackedHandPoses[Handedness.RIGHT].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
  }
  setActive(active) {
    this._myActive = active;
    this._myMouse.setActive(active);
    this._myKeyboard.setActive(active);
    this._myHeadPose.setActive(active);
    for (const rawHandedness in this._myHandPoses) {
      const handedness = rawHandedness;
      this._myHandPoses[handedness].setActive(active);
    }
    for (const rawHandedness in this._myHandRayPoses) {
      const handedness = rawHandedness;
      this._myHandRayPoses[handedness].setActive(active);
    }
    for (const rawHandedness in this._myTrackedHandPoses) {
      const handedness = rawHandedness;
      this._myTrackedHandPoses[handedness].setActive(active);
    }
    this._myGamepadsManager.setActive(active);
  }
  isActive() {
    return this._myActive;
  }
  start() {
    this._myMouse.start();
    this._myKeyboard.start();
    this._myHeadPose.setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myHeadPose.setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myHeadPose.start();
    for (const rawHandedness in this._myHandPoses) {
      const handedness = rawHandedness;
      this._myHandPoses[handedness].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
      this._myHandPoses[handedness].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
      this._myHandPoses[handedness].start();
    }
    for (const rawHandedness in this._myHandRayPoses) {
      const handedness = rawHandedness;
      this._myHandRayPoses[handedness].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
      this._myHandRayPoses[handedness].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
      this._myHandRayPoses[handedness].start();
    }
    if (this._myTrackedHandPosesEnabled) {
      this._startTrackedHandPoses();
    }
    this._myGamepadsManager.start();
    this._myStarted = true;
    const currentActive = this._myActive;
    this._myActive = !this._myActive;
    this.setActive(currentActive);
  }
  update(dt) {
    if (!this._myActive)
      return;
    this._myPreUpdateEmitter.notify(dt, this);
    this._myMouse.update(dt);
    this._myKeyboard.update(dt);
    this._myHeadPose.setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
    this._myHeadPose.setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
    this._myHeadPose.update(dt);
    for (const rawHandedness in this._myHandPoses) {
      const handedness = rawHandedness;
      this._myHandPoses[handedness].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
      this._myHandPoses[handedness].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
      this._myHandPoses[handedness].update(dt);
    }
    for (const rawHandedness in this._myHandRayPoses) {
      const handedness = rawHandedness;
      this._myHandRayPoses[handedness].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
      this._myHandRayPoses[handedness].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
      this._myHandRayPoses[handedness].update(dt);
    }
    this._updateTrackedHandPoses(dt);
    this._myGamepadsManager.update(dt);
    this._myPostUpdateEmitter.notify(dt, this);
  }
  getMouse() {
    return this._myMouse;
  }
  getKeyboard() {
    return this._myKeyboard;
  }
  getGamepadsManager() {
    return this._myGamepadsManager;
  }
  getHeadPose() {
    return this._myHeadPose;
  }
  getLeftHandPose() {
    return this._myHandPoses[Handedness.LEFT];
  }
  getRightHandPose() {
    return this._myHandPoses[Handedness.RIGHT];
  }
  getHandPose(handedness) {
    return this._myHandPoses[handedness];
  }
  getHandPoses() {
    return this._myHandPoses;
  }
  getLeftHandRayPose() {
    return this._myHandRayPoses[Handedness.LEFT];
  }
  getRightHandRayPose() {
    return this._myHandRayPoses[Handedness.RIGHT];
  }
  getHandRayPose(handedness) {
    return this._myHandRayPoses[handedness];
  }
  getHandRayPoses() {
    return this._myHandRayPoses;
  }
  getLeftTrackedHandPose() {
    return this._myTrackedHandPoses[Handedness.LEFT];
  }
  getRightTrackedHandPose() {
    return this._myTrackedHandPoses[Handedness.RIGHT];
  }
  getTrackedHandPose(handedness) {
    return this._myTrackedHandPoses[handedness];
  }
  getTrackedHandPoses() {
    return this._myTrackedHandPoses;
  }
  areTrackedHandPosesEnabled() {
    return this._myTrackedHandPosesEnabled;
  }
  setTrackedHandPosesEnabled(enabled) {
    this._myTrackedHandPosesEnabled = enabled;
    if (this._myStarted && this._myTrackedHandPosesEnabled) {
      this._startTrackedHandPoses();
    }
  }
  registerPreUpdateCallback(id, callback) {
    this._myPreUpdateEmitter.add(callback, { id });
  }
  unregisterPreUpdateCallback(id) {
    this._myPreUpdateEmitter.remove(id);
  }
  registerPostUpdateCallback(id, callback) {
    this._myPostUpdateEmitter.add(callback, { id });
  }
  unregisterPostUpdateCallback(id) {
    this._myPostUpdateEmitter.remove(id);
  }
  _startTrackedHandPoses() {
    if (!this._myTrackedHandPosesStarted) {
      for (const rawHandedness in this._myTrackedHandPoses) {
        const handedness = rawHandedness;
        this._myTrackedHandPoses[handedness].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
        this._myTrackedHandPoses[handedness].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
        this._myTrackedHandPoses[handedness].start();
        if (this._myStarted) {
          this._myTrackedHandPoses[handedness].setActive(this._myActive);
        }
      }
      this._myTrackedHandPosesStarted = true;
    }
  }
  _updateTrackedHandPoses(dt) {
    if (this._myTrackedHandPosesEnabled && this._myTrackedHandPosesStarted) {
      for (const rawHandedness in this._myTrackedHandPoses) {
        const handedness = rawHandedness;
        this._myTrackedHandPoses[handedness].setReferenceObject(Globals.getPlayerObjects(this._myEngine).myReferenceSpace);
        this._myTrackedHandPoses[handedness].setForwardFixed(Globals.isPoseForwardFixed(this._myEngine));
        this._myTrackedHandPoses[handedness].update(dt);
      }
    }
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
    this._myMouse.destroy();
    this._myKeyboard.destroy();
    this._myHeadPose.destroy();
    for (const rawHandedness in this._myHandPoses) {
      const handedness = rawHandedness;
      this._myHandPoses[handedness].destroy();
    }
    for (const rawHandedness in this._myHandRayPoses) {
      const handedness = rawHandedness;
      this._myHandRayPoses[handedness].destroy();
    }
    for (const rawHandedness in this._myTrackedHandPoses) {
      const handedness = rawHandedness;
      this._myTrackedHandPoses[handedness].destroy();
    }
    this._myGamepadsManager.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/input/cauldron/components/input_manager_component.js
var InputManagerComponent = class extends Component14 {
  static TypeName = "pp-input-manager";
  static Properties = {
    _myPoseForwardFixed: Property8.bool(true),
    _myPreventMouseContextMenu: Property8.bool(true),
    _myPreventMouseMiddleButtonScroll: Property8.bool(true),
    _myEnableTrackedHandPoses: Property8.bool(true)
  };
  init() {
    this._myHasPoseForwardFixed = true;
    this._myCurrentPoseForwardFixed = this._myPoseForwardFixed;
    this._myInputManager = null;
  }
  update(dt) {
    if (Globals.getInputManager(this.engine) == this._myInputManager) {
      this._myInputManager.update(dt);
    }
  }
  _setupMousePrevent() {
    if (this._myPreventMouseContextMenu) {
      this._myInputManager.getMouse().setContextMenuActive(false);
    }
    if (this._myPreventMouseMiddleButtonScroll) {
      this._myInputManager.getMouse().setMiddleButtonScrollActive(false);
    }
  }
  _addGamepadCores() {
    let leftHandPose = this._myInputManager.getLeftHandPose();
    let rightHandPose = this._myInputManager.getRightHandPose();
    let leftXRGamepadCore = new XRGamepadCore(leftHandPose);
    let rightXRGamepadCore = new XRGamepadCore(rightHandPose);
    this._myInputManager.getGamepadsManager().getLeftGamepad().addGamepadCore("pp_left_xr_gamepad", leftXRGamepadCore);
    this._myInputManager.getGamepadsManager().getRightGamepad().addGamepadCore("pp_right_xr_gamepad", rightXRGamepadCore);
    let leftKeyboardGamepadCore = new KeyboardGamepadCore(leftHandPose);
    let rightKeyboardGamepadCore = new KeyboardGamepadCore(rightHandPose);
    this._myInputManager.getGamepadsManager().getLeftGamepad().addGamepadCore("pp_left_keyboard_gamepad", leftKeyboardGamepadCore);
    this._myInputManager.getGamepadsManager().getRightGamepad().addGamepadCore("pp_right_keyboard_gamepad", rightKeyboardGamepadCore);
    let leftClassicGamepadCore = new ClassicGamepadCore(null, leftHandPose);
    let rightClassicGamepadCore = new ClassicGamepadCore(null, rightHandPose);
    this._myInputManager.getGamepadsManager().getLeftGamepad().addGamepadCore("pp_left_classic_gamepad", leftClassicGamepadCore);
    this._myInputManager.getGamepadsManager().getRightGamepad().addGamepadCore("pp_right_classic_gamepad", rightClassicGamepadCore);
  }
  onActivate() {
    if (this._myInputManager == null) {
      this._myInputManager = new InputManager(this.engine);
      this._myInputManager.setTrackedHandPosesEnabled(this._myEnableTrackedHandPoses);
      this._myInputManager.start();
      this._setupMousePrevent();
      this._addGamepadCores();
    }
    if (!Globals.hasInputManager(this.engine)) {
      this._myInputManager.setActive(true);
      Globals.setInputManager(this._myInputManager, this.engine);
    }
    if (this._myHasPoseForwardFixed) {
      Globals.setPoseForwardFixed(this._myCurrentPoseForwardFixed, this.engine);
    }
  }
  onDeactivate() {
    if (this._myInputManager != null) {
      this._myInputManager.setActive(false);
      if (Globals.getInputManager(this.engine) == this._myInputManager) {
        Globals.removeInputManager(this.engine);
      }
    }
    this._myHasPoseForwardFixed = Globals.hasPoseForwardFixed();
    this._myCurrentPoseForwardFixed = Globals.isPoseForwardFixed();
    Globals.removePoseForwardFixed(this.engine);
  }
  onDestroy() {
    if (this._myInputManager != null) {
      this._myInputManager.destroy();
    }
  }
};

// dist/pp/tool/cauldron/components/enable_tool_component.js
import { Component as Component15, Property as Property9 } from "@wonderlandengine/api";
var EnableToolComponent = class extends Component15 {
  static TypeName = "pp-enable-tool";
  static Properties = {
    _myEnable: Property9.bool(true)
  };
  start() {
    this._myHasToolEnabled = this._myEnable;
    this._myToolEnabled = this._myEnable;
  }
  onActivate() {
    if (this._myHasToolEnabled) {
      Globals.setToolEnabled(this._myToolEnabled, this.engine);
    }
  }
  onDeactivate() {
    this._myHasToolEnabled = Globals.hasToolEnabled();
    this._myToolEnabled = Globals.isToolEnabled();
    Globals.removeToolEnabled(this.engine);
  }
};

// dist/pp/tool/console_vr/components/init_console_vr_component.js
import { Component as Component16, Property as Property10 } from "@wonderlandengine/api";

// dist/pp/tool/console_vr/console_original_functions.js
var _myConsoleOriginalLog = console.log;
var _myConsoleOriginalError = console.error;
var _myConsoleOriginalWarn = console.warn;
var _myConsoleOriginalInfo = console.info;
var _myConsoleOriginalDebug = console.debug;
var _myConsoleOriginalAssert = console.assert;
var _myConsoleOriginalClear = console.clear;
function log3(engine = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getLog(engine).apply(console, args);
}
function error3(engine = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getError(engine).apply(console, args);
}
function warn3(engine = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getWarn(engine).apply(console, args);
}
function info(engine = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getInfo(engine).apply(console, args);
}
function debug(engine = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getDebug(engine).apply(console, args);
}
function assert(engine = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getAssert(engine).apply(console, args);
}
function clear3(engine = Globals.getMainEngine(), ...args) {
  return ConsoleOriginalFunctions.getClear(engine).apply(console, args);
}
function getLog(engine = Globals.getMainEngine()) {
  return _myConsoleOriginalLog;
}
function getError(engine = Globals.getMainEngine()) {
  return _myConsoleOriginalError;
}
function getWarn(engine = Globals.getMainEngine()) {
  return _myConsoleOriginalWarn;
}
function getInfo(engine = Globals.getMainEngine()) {
  return _myConsoleOriginalInfo;
}
function getDebug(engine = Globals.getMainEngine()) {
  return _myConsoleOriginalDebug;
}
function getAssert(engine = Globals.getMainEngine()) {
  return _myConsoleOriginalAssert;
}
function getClear(engine = Globals.getMainEngine()) {
  return _myConsoleOriginalClear;
}
var ConsoleOriginalFunctions = {
  log: log3,
  error: error3,
  warn: warn3,
  info,
  debug,
  assert,
  clear: clear3,
  getLog,
  getError,
  getWarn,
  getInfo,
  getDebug,
  getAssert,
  getClear
};

// dist/pp/tool/console_vr/console_vr.js
var ConsoleVR = class _ConsoleVR {
  static myOriginalLog = _ConsoleVR.prototype.log;
  static myOriginalError = _ConsoleVR.prototype.error;
  static myOriginalWarn = _ConsoleVR.prototype.warn;
  static myOriginalInfo = _ConsoleVR.prototype.info;
  static myOriginalDebug = _ConsoleVR.prototype.debug;
  static myOriginalAssert = _ConsoleVR.prototype.assert;
  static myOriginalClear = _ConsoleVR.prototype.clear;
  constructor(engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myForwardToBrowserConsole = true;
  }
  log(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.log(this._myEngine, ...args);
    }
  }
  error(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.error(this._myEngine, ...args);
    }
  }
  warn(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.warn(this._myEngine, ...args);
    }
  }
  info(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.info(this._myEngine, ...args);
    }
  }
  debug(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.debug(this._myEngine, ...args);
    }
  }
  assert(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.assert(this._myEngine, ...args);
    }
  }
  clear(...args) {
    if (this._myForwardToBrowserConsole) {
      ConsoleOriginalFunctions.clear(this._myEngine, ...args);
    }
  }
  setForwardToBrowserConsole(forwardToBrowserConsole) {
    this._myForwardToBrowserConsole = forwardToBrowserConsole;
  }
  isForwardToBrowserConsole() {
    return this._myForwardToBrowserConsole;
  }
};

// dist/pp/tool/console_vr/components/init_console_vr_component.js
var InitConsoleVRComponent = class extends Component16 {
  static TypeName = "pp-init-console-vr";
  static Properties = {
    _myInit: Property10.bool(true)
  };
  start() {
    this._myConsoleVR = null;
    if (this._myInit) {
      this._myConsoleVR = new ConsoleVR(this.engine);
    }
  }
  onActivate() {
    if (this._myConsoleVR != null && !Globals.hasConsoleVR(this.engine)) {
      Globals.setConsoleVR(this._myConsoleVR, this.engine);
    }
  }
  onDeactivate() {
    if (this._myConsoleVR != null && Globals.getConsoleVR(this.engine) == this._myConsoleVR) {
      Globals.removeConsoleVR(this.engine);
    }
  }
};

// dist/pp/tool/easy_tune/components/init_easy_tune_variables_component.js
import { Component as Component17, Property as Property11 } from "@wonderlandengine/api";

// dist/pp/tool/easy_tune/easy_tune_variables.js
var EasyTuneVariables = class {
  _myVariables = /* @__PURE__ */ new Map();
  add(variable, overwriteCurrentOne = false) {
    if (overwriteCurrentOne || !this._myVariables.has(variable.getName())) {
      this._myVariables.set(variable.getName(), variable);
    }
  }
  remove(variableName) {
    this._myVariables.delete(variableName);
  }
  get(variableName) {
    const variable = this._myVariables.get(variableName);
    if (variable != null) {
      return variable.getValue();
    }
    return null;
  }
  set(variableName, value, resetDefaultValue = false, skipValueChangedNotify = false) {
    const variable = this._myVariables.get(variableName);
    if (variable != null) {
      variable.setValue(value, resetDefaultValue, skipValueChangedNotify);
    }
  }
  has(variableName) {
    return this._myVariables.has(variableName);
  }
  length() {
    return this._myVariables.size;
  }
  isWidgetCurrentVariable(variableName) {
    const variable = this._myVariables.get(variableName);
    if (variable != null) {
      return variable.isWidgetCurrentVariable();
    }
    return false;
  }
  getEasyTuneVariable(variableName) {
    return this._myVariables.get(variableName) ?? null;
  }
  getEasyTuneVariablesList() {
    return Array.from(this._myVariables.values());
  }
  getEasyTuneVariablesNames() {
    return Array.from(this._myVariables.keys());
  }
  changeEasyTuneVariableName(oldName, newName) {
    const variableToChange = this._myVariables.get(oldName);
    if (variableToChange != null) {
      const oldVariables = new Map(this._myVariables);
      this._myVariables.clear();
      for (const [name, variable] of oldVariables) {
        if (name != oldName) {
          this._myVariables.set(name, variable);
        } else {
          this._myVariables.set(newName, variable);
        }
      }
      variableToChange.setName(newName);
    }
  }
  fromJSON(json, resetDefaultValue = false, skipValueChangedNotify = false, manualImport = false) {
    const objectJSON = JSON.parse(json);
    for (const variable of this._myVariables.values()) {
      if (variable.isManualImportEnabled() && manualImport || variable.isAutoImportEnabled() && !manualImport) {
        const variableName = variable.getName();
        if (Object.hasOwn(objectJSON, variableName)) {
          const variableValueJSON = objectJSON[variableName];
          variable.fromJSON(variableValueJSON, resetDefaultValue, skipValueChangedNotify);
        }
      }
    }
  }
  toJSON(excludeVariablesWithValueAsDefault = false) {
    const objectJSON = {};
    for (const variable of this._myVariables.values()) {
      if (variable.isExportEnabled()) {
        if (!excludeVariablesWithValueAsDefault || !variable.isValueEqual(variable.getDefaultValue())) {
          objectJSON[variable.getName()] = variable.toJSON();
        }
      }
    }
    return JSON.stringify(objectJSON);
  }
  /**
   * @param id if `undefined` is used as id, it will overwrite the default variable listener
   */
  registerValueChangedEventListener(variableName, id, callback) {
    this._myVariables.get(variableName).registerValueChangedEventListener(id, callback);
  }
  /**
   * @param id if `undefined` is used as id, it will unregister the default variable listener
   */
  unregisterValueChangedEventListener(variableName, id) {
    this._myVariables.get(variableName).unregisterValueChangedEventListener(id);
  }
};

// dist/pp/tool/easy_tune/components/init_easy_tune_variables_component.js
var InitEasyTuneVariablesComponent = class extends Component17 {
  static TypeName = "pp-init-easy-tune-variables";
  static Properties = {
    _myInit: Property11.bool(true)
  };
  start() {
    this._myEasyTuneVariables = null;
    if (this._myInit) {
      this._myEasyTuneVariables = new EasyTuneVariables();
    }
  }
  onActivate() {
    if (this._myEasyTuneVariables != null && !Globals.hasEasyTuneVariables(this.engine)) {
      Globals.setEasyTuneVariables(this._myEasyTuneVariables, this.engine);
    }
  }
  onDeactivate() {
    if (this._myEasyTuneVariables != null && Globals.getEasyTuneVariables(this.engine) == this._myEasyTuneVariables) {
      Globals.removeEasyTuneVariables(this.engine);
    }
  }
};

// dist/pp/cauldron/wl/register_wl_components.js
import { ARCamera8thwall as ARCamera8thwall2, Cursor as Cursor2, CursorTarget as CursorTarget2, DebugObject as DebugObject2, DeviceOrientationLook as DeviceOrientationLook2, FingerCursor as FingerCursor2, FixedFoveation as FixedFoveation2, HandTracking as HandTracking2, HitTestLocation as HitTestLocation2, HowlerAudioListener as HowlerAudioListener2, HowlerAudioSource as HowlerAudioSource2, ImageTexture as ImageTexture2, MouseLookComponent as MouseLookComponent2, PlayerHeight as PlayerHeight2, TargetFramerate as TargetFramerate2, TeleportComponent as TeleportComponent2, Trail as Trail2, TwoJointIkSolver as TwoJointIkSolver2, VideoTexture as VideoTexture2, VrModeActiveSwitch as VrModeActiveSwitch2, Vrm as Vrm2, WasdControlsComponent as WasdControlsComponent2 } from "@wonderlandengine/components";
function registerWLComponents(engine) {
  engine.registerComponent(ARCamera8thwall2, Cursor2, CursorTarget2, DebugObject2, DeviceOrientationLook2, FingerCursor2, FixedFoveation2, HandTracking2, HitTestLocation2, HowlerAudioListener2, HowlerAudioSource2, ImageTexture2, MouseLookComponent2, PlayerHeight2, TargetFramerate2, TeleportComponent2, Trail2, TwoJointIkSolver2, VideoTexture2, VrModeActiveSwitch2, Vrm2, WasdControlsComponent2);
}

// dist/pp/cauldron/utils/js_utils.js
function getObjectPrototypes(object) {
  let prototypes = [];
  prototypes.push(object);
  let objectProto = Object.getPrototypeOf(object);
  while (objectProto != null) {
    ArrayUtils.pushUnique(prototypes, objectProto);
    objectProto = Object.getPrototypeOf(objectProto);
  }
  let prototypesToCheck = [object];
  while (prototypesToCheck.length > 0) {
    let prototypeToCheck = prototypesToCheck.shift();
    if (prototypeToCheck != null) {
      ArrayUtils.pushUnique(prototypes, prototypeToCheck);
      ArrayUtils.pushUnique(prototypesToCheck, Object.getPrototypeOf(prototypeToCheck));
      try {
        ArrayUtils.pushUnique(prototypesToCheck, prototypeToCheck.prototype);
      } catch (error4) {
      }
    }
  }
  return prototypes;
}
function getObjectPropertyNames(object) {
  let propertyNames = [];
  let prototypes = JSUtils.getObjectPrototypes(object);
  for (let prototype of prototypes) {
    if (prototype != null) {
      let ownPropertyNames = Object.getOwnPropertyNames(prototype);
      for (let ownPropertyName of ownPropertyNames) {
        ArrayUtils.pushUnique(propertyNames, ownPropertyName);
      }
    }
  }
  return propertyNames;
}
function getObjectPropertyDescriptor(object, propertyName) {
  let propertyDescriptor = null;
  let propertyParent = JSUtils.getObjectPropertyOwnParent(object, propertyName);
  if (propertyParent != null) {
    propertyDescriptor = Object.getOwnPropertyDescriptor(propertyParent, propertyName);
  }
  return propertyDescriptor;
}
function getObjectProperty(object, propertyName) {
  let property19 = void 0;
  let propertyDescriptor = JSUtils.getObjectPropertyDescriptor(object, propertyName);
  if (propertyDescriptor != null) {
    if (propertyDescriptor.get != null) {
      property19 = propertyDescriptor.get.bind(object)();
    } else {
      property19 = propertyDescriptor.value;
    }
  }
  return property19;
}
function setObjectProperty(valueToSet, object, propertyName) {
  let propertyDescriptor = JSUtils.getObjectPropertyDescriptor(object, propertyName);
  let setUsed = false;
  if (propertyDescriptor != null) {
    if (propertyDescriptor.set != null) {
      setUsed = true;
      propertyDescriptor.set.bind(object)(valueToSet);
    }
  }
  if (!setUsed) {
    let propertyParent = JSUtils.getObjectPropertyOwnParent(object, propertyName);
    if (propertyParent == null) {
      propertyParent = object;
    }
    Object.defineProperty(propertyParent, propertyName, {
      value: valueToSet
    });
  }
}
function getObjectPropertyOwnParent(object, propertyName) {
  let parent = null;
  let parents = JSUtils.getObjectPropertyOwnParents(object, propertyName);
  if (parents.length > 0) {
    parent = parents[0];
  }
  return parent;
}
function getObjectPropertyOwnParents(object, propertyName) {
  let parents = [];
  let possibleParents = JSUtils.getObjectPrototypes(object);
  for (let possibleParent of possibleParents) {
    let propertyNames = Object.getOwnPropertyNames(possibleParent);
    if (ArrayUtils.hasEqual(propertyNames, propertyName)) {
      parents.push(possibleParent);
    }
  }
  return parents;
}
function getObjectFromPath(path, pathStartObject = window) {
  let object = null;
  let objectName = JSUtils.getObjectNameFromPath(path);
  if (objectName != null) {
    object = JSUtils.getObjectProperty(JSUtils.getObjectParentFromPath(path, pathStartObject), objectName);
  }
  return object;
}
function getObjectNameFromPath(path) {
  let objectName = null;
  if (path != null) {
    let pathSplit = path.split(".");
    if (pathSplit.length > 0) {
      objectName = pathSplit[pathSplit.length - 1];
    }
  }
  return objectName;
}
function getObjectParentFromPath(path, pathStartObject = window) {
  let pathSplit = path.split(".");
  let currentParent = pathStartObject;
  for (let i = 0; i < pathSplit.length - 1; i++) {
    currentParent = JSUtils.getObjectProperty(currentParent, pathSplit[i]);
  }
  return currentParent;
}
function overwriteObjectProperty(newProperty, object, propertyName, overwriteOnOwnParent = true, jsObjectFunctionsSpecialOverwrite = false, logEnabled = false) {
  let success = false;
  try {
    let propertyOwnParent = JSUtils.getObjectPropertyOwnParent(object, propertyName);
    if (propertyOwnParent != null) {
      let originalPropertyDescriptor = Object.getOwnPropertyDescriptor(propertyOwnParent, propertyName);
      if (originalPropertyDescriptor != null) {
        let originalProperty = JSUtils.getObjectProperty(propertyOwnParent, propertyName);
        JSUtils.copyObjectProperties(originalProperty, newProperty, true, jsObjectFunctionsSpecialOverwrite, logEnabled);
        let overwriteTarget = object;
        if (overwriteOnOwnParent) {
          overwriteTarget = propertyOwnParent;
        }
        Object.defineProperty(overwriteTarget, propertyName, {
          value: newProperty,
          enumerable: originalPropertyDescriptor.enumerable,
          writable: originalPropertyDescriptor.writable,
          configurable: originalPropertyDescriptor.configurable
        });
        success = true;
      } else {
        Object.defineProperty(object, propertyName, {
          value: newProperty
        });
        success = true;
      }
    } else {
      Object.defineProperty(object, propertyName, {
        value: newProperty
      });
      success = true;
    }
  } catch (error4) {
    if (logEnabled) {
      console.error("Property:", propertyName, "of:", object, "can't be overwritten.");
    }
  }
  return success;
}
function copyObjectProperties(fromObject, toObject, cleanCopy = false, jsObjectFunctionsSpecialCopy = false, logEnabled = false) {
  if (fromObject != null) {
    if (cleanCopy) {
      JSUtils.cleanObjectProperties(toObject);
    }
    Object.setPrototypeOf(toObject, Object.getPrototypeOf(fromObject));
    let fromObjectPropertyNames = Object.getOwnPropertyNames(fromObject);
    for (let fromObjectPropertyName of fromObjectPropertyNames) {
      try {
        let fromObjectPropertyDescriptor = Object.getOwnPropertyDescriptor(fromObject, fromObjectPropertyName);
        Object.defineProperty(toObject, fromObjectPropertyName, {
          value: fromObjectPropertyDescriptor.value,
          enumerable: fromObjectPropertyDescriptor.enumerable,
          writable: fromObjectPropertyDescriptor.writable,
          configurable: fromObjectPropertyDescriptor.configurable
        });
      } catch (error4) {
        if (logEnabled) {
          console.error("Property:", fromObjectPropertyName, "of:", fromObject.name, "can't be overwritten.");
        }
      }
    }
    if (jsObjectFunctionsSpecialCopy) {
      _jsObjectFunctionsSpecialCopy(fromObject, toObject);
    }
  }
}
function cleanObjectProperties(object) {
  let objectNames = Object.getOwnPropertyNames(object);
  ArrayUtils.pushUnique(objectNames, "__proto__");
  for (let objectName of objectNames) {
    try {
      Object.defineProperty(object, objectName, {
        value: void 0
      });
    } catch (error4) {
    }
    try {
      delete object[objectName];
    } catch (error4) {
    }
  }
  Object.setPrototypeOf(object, null);
}
function doesObjectPropertyUseAccessors(object, propertyName) {
  let propertyUseAccessors = false;
  let propertyDescriptor = JSUtils.getObjectPropertyDescriptor(object, propertyName);
  if (propertyDescriptor != null && (propertyDescriptor.get != null || propertyDescriptor.set != null)) {
    propertyUseAccessors = true;
  }
  return propertyUseAccessors;
}
function isFunctionByName(functionParent, functionName) {
  let isFunctionResult = false;
  let functionProperty = JSUtils.getObjectProperty(functionParent, functionName);
  if (functionProperty != null) {
    isFunctionResult = JSUtils.isFunction(functionProperty);
  }
  return isFunctionResult;
}
function isClassByName(classParent, className) {
  let isClassResult = false;
  let classProperty = JSUtils.getObjectProperty(classParent, className);
  if (classProperty != null) {
    isClassResult = JSUtils.isClass(classProperty);
  }
  return isClassResult;
}
function isObjectByName(objectParent, objectName) {
  let isObjectResult = false;
  let objectProperty = JSUtils.getObjectProperty(objectParent, objectName);
  if (objectProperty != null) {
    isObjectResult = JSUtils.isObject(objectProperty);
  }
  return isObjectResult;
}
function isFunction(property19) {
  return typeof property19 == "function" && !JSUtils.isClass(property19);
}
var isClass = function() {
  let checkClassRegex = new RegExp("^class");
  return function isClass2(property19) {
    return typeof property19 == "function" && property19.prototype != null && typeof property19.prototype.constructor == "function" && property19.toString != null && typeof property19.toString == "function" && property19.toString()?.match(checkClassRegex) != null;
  };
}();
function isObject(property19) {
  return typeof property19 == "object";
}
var JSUtils = {
  getObjectPrototypes,
  getObjectPropertyNames,
  getObjectPropertyDescriptor,
  getObjectProperty,
  setObjectProperty,
  getObjectPropertyOwnParent,
  getObjectPropertyOwnParents,
  getObjectFromPath,
  getObjectNameFromPath,
  getObjectParentFromPath,
  overwriteObjectProperty,
  copyObjectProperties,
  cleanObjectProperties,
  doesObjectPropertyUseAccessors,
  isFunctionByName,
  isClassByName,
  isObjectByName,
  isFunction,
  isClass,
  isObject
};
function _jsObjectFunctionsSpecialCopy(fromObject, toObject) {
  try {
    if (typeof toObject == "function" && typeof fromObject == "function") {
      let functionsToOverwrite = ["toString", "toLocaleString", "valueOf"];
      for (let functionToOverwrite of functionsToOverwrite) {
        let propertyDescriptorToOverwrite = JSUtils.getObjectPropertyDescriptor(fromObject, functionToOverwrite);
        if (propertyDescriptorToOverwrite != null && propertyDescriptorToOverwrite.value != null && propertyDescriptorToOverwrite.value == Object[functionToOverwrite]) {
          let valueToReturn = Object[functionToOverwrite].bind(fromObject)();
          let overwrittenFunction = function() {
            return valueToReturn;
          };
          JSUtils.overwriteObjectProperty(overwrittenFunction, toObject, functionToOverwrite, false, false);
        }
      }
    }
  } catch (error4) {
  }
}

// dist/pp/plugin/utils/plugin_utils.js
function injectOwnProperties(fromReference, toReference, enumerable = true, writable = true, configurable = true, keepOriginalDescriptorAttributes = true, bindThisAsFirstParam = false, prefix, functionNamesToExclude = []) {
  const ownPropertyNames = Object.getOwnPropertyNames(fromReference);
  const fromReferenceAsRecord = fromReference;
  for (const ownPropertyName of ownPropertyNames) {
    if (functionNamesToExclude.includes(ownPropertyName))
      continue;
    let enumerableToUse = enumerable;
    let writableToUse = writable;
    let configurableToUse = configurable;
    if (keepOriginalDescriptorAttributes) {
      const originalDescriptor = Object.getOwnPropertyDescriptor(toReference, ownPropertyName);
      if (originalDescriptor != null) {
        enumerableToUse = originalDescriptor.enumerable;
        writableToUse = originalDescriptor.writable;
        configurableToUse = originalDescriptor.configurable;
      }
    }
    let adjustedPropertyName = ownPropertyName;
    if (prefix != null) {
      if (adjustedPropertyName.length > 0 && adjustedPropertyName[0] == adjustedPropertyName[0].toUpperCase()) {
        adjustedPropertyName = prefix.toUpperCase() + adjustedPropertyName;
      } else {
        adjustedPropertyName = prefix + adjustedPropertyName;
      }
    }
    const propertyDescriptor = Object.getOwnPropertyDescriptor(fromReference, ownPropertyName);
    const useAccessors = propertyDescriptor != null && (propertyDescriptor.get != null || propertyDescriptor.set != null);
    if (!useAccessors) {
      let adjustedProperyValue = fromReferenceAsRecord[ownPropertyName];
      if (bindThisAsFirstParam && JSUtils.isFunction(adjustedProperyValue)) {
        const originalFunction = fromReferenceAsRecord[ownPropertyName];
        adjustedProperyValue = function(...args) {
          return originalFunction(this, ...args);
        };
        Object.defineProperty(adjustedProperyValue, "name", {
          value: adjustedPropertyName
        });
      }
      Object.defineProperty(toReference, adjustedPropertyName, {
        value: adjustedProperyValue,
        enumerable: enumerableToUse,
        writable: writableToUse,
        configurable: configurableToUse
      });
    } else {
      Object.defineProperty(toReference, adjustedPropertyName, {
        get: propertyDescriptor.get,
        set: propertyDescriptor.set,
        enumerable: enumerableToUse,
        configurable: configurableToUse
      });
    }
  }
}
var PluginUtils = {
  injectOwnProperties
};

// dist/pp/plugin/js/extensions/array/array_extension_utils.js
var ARRAY_LIKE_CLASSES = [
  Array,
  Uint8ClampedArray,
  Uint8Array,
  Uint16Array,
  Uint32Array,
  Int8Array,
  Int16Array,
  Int32Array,
  Float32Array,
  Float64Array
];
var MUTABLE_ARRAY_LIKE_CLASSES = [
  Array
];
var ArrayExtensionUtils = {
  ARRAY_LIKE_CLASSES,
  MUTABLE_ARRAY_LIKE_CLASSES
};

// dist/pp/plugin/js/extensions/array/array_extension.js
function initArrayExtension() {
  _initArrayLikeExtensionProtoypes();
  _initDynamicArrayOwnExtensionProtoype();
}
function _initArrayLikeExtensionProtoypes() {
  const arrayLikeExtension = {
    pp_copy(array, copyCallback) {
      return ArrayUtils.copy(array, this, copyCallback);
    },
    pp_clone(cloneCallback) {
      return ArrayUtils.clone(this, cloneCallback);
    },
    pp_equals(array, elementsEqualCallback) {
      return ArrayUtils.equals(this, array, elementsEqualCallback);
    },
    pp_first() {
      return ArrayUtils.first(this);
    },
    pp_last() {
      return ArrayUtils.last(this);
    },
    pp_has(callback) {
      return ArrayUtils.has(this, callback);
    },
    pp_hasEqual(elementToFind, elementsEqualCallback) {
      return ArrayUtils.hasEqual(this, elementToFind, elementsEqualCallback);
    },
    pp_find(callback) {
      return ArrayUtils.find(this, callback);
    },
    pp_findIndex(callback) {
      return ArrayUtils.findIndex(this, callback);
    },
    pp_findAll(callback) {
      return ArrayUtils.findAll(this, callback);
    },
    pp_findAllIndexes(callback) {
      return ArrayUtils.findAllIndexes(this, callback);
    },
    pp_findEqual(elementToFind, elementsEqualCallback) {
      return ArrayUtils.findEqual(this, elementToFind, elementsEqualCallback);
    },
    pp_findAllEqual(elementToFind, elementsEqualCallback) {
      return ArrayUtils.findAllEqual(this, elementToFind, elementsEqualCallback);
    },
    pp_findIndexEqual(elementToFind, elementsEqualCallback) {
      return ArrayUtils.findIndexEqual(this, elementToFind, elementsEqualCallback);
    },
    pp_findAllIndexesEqual(elementToFind, elementsEqualCallback) {
      return ArrayUtils.findAllIndexesEqual(this, elementToFind, elementsEqualCallback);
    }
  };
  for (const arrayLikeClassToExtend of ArrayExtensionUtils.ARRAY_LIKE_CLASSES) {
    PluginUtils.injectOwnProperties(arrayLikeExtension, arrayLikeClassToExtend.prototype, false, true, true);
  }
}
function _initDynamicArrayOwnExtensionProtoype() {
  const dynamicArrayOwnExtension = {
    pp_remove(callback) {
      return ArrayUtils.remove(this, callback);
    },
    pp_removeIndex(index) {
      return ArrayUtils.removeIndex(this, index);
    },
    pp_removeAll(callback) {
      return ArrayUtils.removeAll(this, callback);
    },
    pp_removeAllIndexes(indexes) {
      return ArrayUtils.removeAllIndexes(this, indexes);
    },
    pp_removeEqual(elementToRemove, elementsEqualCallback) {
      return ArrayUtils.removeEqual(this, elementToRemove, elementsEqualCallback);
    },
    pp_removeAllEqual(elementToRemove, elementsEqualCallback) {
      return ArrayUtils.removeAllEqual(this, elementToRemove, elementsEqualCallback);
    },
    pp_clear() {
      return ArrayUtils.clear(this);
    },
    pp_pushUnique(elementToAdd, elementsEqualCallback) {
      return ArrayUtils.pushUnique(this, elementToAdd, elementsEqualCallback);
    },
    pp_unshiftUnique(elementToAdd, elementsEqualCallback) {
      return ArrayUtils.unshiftUnique(this, elementToAdd, elementsEqualCallback);
    }
  };
  for (const dynamicArrayLikeClassToExtend of ArrayExtensionUtils.MUTABLE_ARRAY_LIKE_CLASSES) {
    PluginUtils.injectOwnProperties(dynamicArrayOwnExtension, dynamicArrayLikeClassToExtend.prototype, false, true, true);
  }
}

// dist/pp/plugin/js/extensions/array/mat3_extension.js
function initMat3Extension() {
  _initMat3ExtensionProtoype();
}
function _initMat3ExtensionProtoype() {
  const mat3Extension = {
    mat3_set(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
      return Mat3Utils.set(this, m00, m01, m02, m10, m11, m12, m20, m21, m22);
    },
    mat3_copy(matrix) {
      return Mat3Utils.copy(matrix, this);
    },
    mat3_clone() {
      return Mat3Utils.clone(this);
    },
    mat3_equals(matrix, epsilon) {
      return Mat3Utils.equals(this, matrix, epsilon);
    },
    mat3_toDegrees(out) {
      return Mat3Utils.toDegrees(this, out);
    },
    mat3_toRadians(out) {
      return Mat3Utils.toRadians(this, out);
    },
    mat3_toQuat(out) {
      return Mat3Utils.toQuat(this, out);
    },
    mat3_fromAxes(left, up, forward) {
      return Mat3Utils.fromAxes(left, up, forward, this);
    }
  };
  for (const arrayLikeClassToExtend of ArrayExtensionUtils.ARRAY_LIKE_CLASSES) {
    PluginUtils.injectOwnProperties(mat3Extension, arrayLikeClassToExtend.prototype, false, true, true);
  }
}

// dist/pp/plugin/js/extensions/array/mat4_extension.js
function initMat4Extension() {
  _initMat4ExtensionProtoype();
}
function _initMat4ExtensionProtoype() {
  const matrix4Extension = {
    mat4_set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      return Mat4Utils.set(this, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    },
    mat4_copy(matrix) {
      return Mat4Utils.copy(matrix, this);
    },
    mat4_clone() {
      return Mat4Utils.clone(this);
    },
    mat4_equals(matrix, epsilon) {
      return Mat4Utils.equals(this, matrix, epsilon);
    },
    mat4_identity() {
      return Mat4Utils.identity(this);
    },
    mat4_invert(out) {
      return Mat4Utils.invert(this, out);
    },
    mat4_mul(matrix, out) {
      return Mat4Utils.mul(this, matrix, out);
    },
    mat4_scale(vector, out) {
      return Mat4Utils.scale(this, vector, out);
    },
    mat4_getPosition(out) {
      return Mat4Utils.getPosition(this, out);
    },
    mat4_getRotation(out) {
      return Mat4Utils.getRotation(this, out);
    },
    mat4_getRotationDegrees(out) {
      return Mat4Utils.getRotationDegrees(this, out);
    },
    mat4_getRotationRadians(out) {
      return Mat4Utils.getRotationRadians(this, out);
    },
    mat4_getRotationQuat(out) {
      return Mat4Utils.getRotationQuat(this, out);
    },
    mat4_getScale(out) {
      return Mat4Utils.getScale(this, out);
    },
    mat4_setPosition(position) {
      return Mat4Utils.setPosition(this, position);
    },
    mat4_setRotation(rotation) {
      return Mat4Utils.setRotation(this, rotation);
    },
    mat4_setRotationDegrees(rotation) {
      return Mat4Utils.setRotationDegrees(this, rotation);
    },
    mat4_setRotationRadians(rotation) {
      return Mat4Utils.setRotationRadians(this, rotation);
    },
    mat4_setRotationQuat(rotation) {
      return Mat4Utils.setRotationQuat(this, rotation);
    },
    mat4_setScale(scale4) {
      return Mat4Utils.setScale(this, scale4);
    },
    mat4_setPositionRotationScale(position, rotation, scale4) {
      return Mat4Utils.setPositionRotationScale(this, position, rotation, scale4);
    },
    mat4_setPositionRotationDegreesScale(position, rotation, scale4) {
      return Mat4Utils.setPositionRotationDegreesScale(this, position, rotation, scale4);
    },
    mat4_setPositionRotationRadiansScale(position, rotation, scale4) {
      return Mat4Utils.setPositionRotationRadiansScale(this, position, rotation, scale4);
    },
    mat4_setPositionRotationQuatScale(position, rotation, scale4) {
      return Mat4Utils.setPositionRotationQuatScale(this, position, rotation, scale4);
    },
    mat4_setPositionRotation(position, rotation) {
      return Mat4Utils.setPositionRotation(this, position, rotation);
    },
    mat4_setPositionRotationDegrees(position, rotation) {
      return Mat4Utils.setPositionRotationDegrees(this, position, rotation);
    },
    mat4_setPositionRotationRadians(position, rotation) {
      return Mat4Utils.setPositionRotationRadians(this, position, rotation);
    },
    mat4_setPositionRotationQuat(position, rotation) {
      return Mat4Utils.setPositionRotationQuat(this, position, rotation);
    },
    mat4_getAxes(out) {
      return Mat4Utils.getAxes(this, out);
    },
    mat4_getForward(out) {
      return Mat4Utils.getForward(this, out);
    },
    mat4_getBackward(out) {
      return Mat4Utils.getBackward(this, out);
    },
    mat4_getLeft(out) {
      return Mat4Utils.getLeft(this, out);
    },
    mat4_getRight(out) {
      return Mat4Utils.getRight(this, out);
    },
    mat4_getUp(out) {
      return Mat4Utils.getUp(this, out);
    },
    mat4_getDown(out) {
      return Mat4Utils.getDown(this, out);
    },
    mat4_hasUniformScale() {
      return Mat4Utils.hasUniformScale(this);
    },
    mat4_toWorld(parentTransformMatrix, out) {
      return Mat4Utils.toWorld(this, parentTransformMatrix, out);
    },
    mat4_toLocal(parentTransformMatrix, out) {
      return Mat4Utils.toLocal(this, parentTransformMatrix, out);
    },
    mat4_toQuat(out) {
      return Mat4Utils.toQuat(this, out);
    },
    mat4_fromQuat(quat) {
      return Mat4Utils.fromQuat(quat, this);
    }
  };
  for (const arrayLikeClassToExtend of ArrayExtensionUtils.ARRAY_LIKE_CLASSES) {
    PluginUtils.injectOwnProperties(matrix4Extension, arrayLikeClassToExtend.prototype, false, true, true);
  }
}

// dist/pp/plugin/js/extensions/array/quat2_extension.js
function initQuat2Extension() {
  _initQuat2ExtensionProtoype();
}
function _initQuat2ExtensionProtoype() {
  const quat2Extension = {
    quat2_set(x1, y1, z1, w1, x2, y2, z2, w2) {
      return Quat2Utils.set(this, x1, y1, z1, w1, x2, y2, z2, w2);
    },
    quat2_copy(quat) {
      return Quat2Utils.copy(quat, this);
    },
    quat2_clone() {
      return Quat2Utils.clone(this);
    },
    quat2_equals(quat, epsilon) {
      return Quat2Utils.equals(this, quat, epsilon);
    },
    quat2_isNormalized(epsilon) {
      return Quat2Utils.isNormalized(this, epsilon);
    },
    quat2_normalize(out) {
      return Quat2Utils.normalize(this, out);
    },
    quat2_length() {
      return Quat2Utils.length(this);
    },
    quat2_lengthSquared() {
      return Quat2Utils.lengthSquared(this);
    },
    quat2_identity() {
      return Quat2Utils.identity(this);
    },
    quat2_mul(quat, out) {
      return Quat2Utils.mul(this, quat, out);
    },
    quat2_invert(out) {
      return Quat2Utils.invert(this, out);
    },
    quat2_conjugate(out) {
      return Quat2Utils.conjugate(this, out);
    },
    quat2_lerp(to, interpolationFactor, out) {
      return Quat2Utils.lerp(this, to, interpolationFactor, out);
    },
    quat2_interpolate(to, interpolationFactor, easingFunction, out) {
      return Quat2Utils.interpolate(this, to, interpolationFactor, easingFunction, out);
    },
    quat2_slerp(to, interpolationFactor, out) {
      return Quat2Utils.slerp(this, to, interpolationFactor, out);
    },
    quat2_interpolateSpherical(to, interpolationFactor, easingFunction, out) {
      return Quat2Utils.interpolateSpherical(this, to, interpolationFactor, easingFunction, out);
    },
    quat2_getPosition(out) {
      return Quat2Utils.getPosition(this, out);
    },
    quat2_getRotation(out) {
      return Quat2Utils.getRotation(this, out);
    },
    quat2_getRotationDegrees(out) {
      return Quat2Utils.getRotationDegrees(this, out);
    },
    quat2_getRotationRadians(out) {
      return Quat2Utils.getRotationRadians(this, out);
    },
    quat2_getRotationQuat(out) {
      return Quat2Utils.getRotationQuat(this, out);
    },
    quat2_setPosition(position) {
      return Quat2Utils.setPosition(this, position);
    },
    quat2_setRotation(rotation) {
      return Quat2Utils.setRotation(this, rotation);
    },
    quat2_setRotationDegrees(rotation) {
      return Quat2Utils.setRotationDegrees(this, rotation);
    },
    quat2_setRotationRadians(rotation) {
      return Quat2Utils.setRotationRadians(this, rotation);
    },
    quat2_setRotationQuat(rotation) {
      return Quat2Utils.setRotationQuat(this, rotation);
    },
    quat2_setPositionRotation(position, rotation) {
      return Quat2Utils.setPositionRotation(this, position, rotation);
    },
    quat2_setPositionRotationDegrees(position, rotation) {
      return Quat2Utils.setPositionRotationDegrees(this, position, rotation);
    },
    quat2_setPositionRotationRadians(position, rotation) {
      return Quat2Utils.setPositionRotationRadians(this, position, rotation);
    },
    quat2_setPositionRotationQuat(position, rotation) {
      return Quat2Utils.setPositionRotationQuat(this, position, rotation);
    },
    quat2_getAxes(out) {
      return Quat2Utils.getAxes(this, out);
    },
    quat2_getForward(out) {
      return Quat2Utils.getForward(this, out);
    },
    quat2_getBackward(out) {
      return Quat2Utils.getBackward(this, out);
    },
    quat2_getLeft(out) {
      return Quat2Utils.getLeft(this, out);
    },
    quat2_getRight(out) {
      return Quat2Utils.getRight(this, out);
    },
    quat2_getUp(out) {
      return Quat2Utils.getUp(this, out);
    },
    quat2_getDown(out) {
      return Quat2Utils.getDown(this, out);
    },
    quat2_rotateAxis(angle2, axis, out) {
      return Quat2Utils.rotateAxis(this, angle2, axis, out);
    },
    quat2_rotateAxisDegrees(angle2, axis, out) {
      return Quat2Utils.rotateAxisDegrees(this, angle2, axis, out);
    },
    quat2_rotateAxisRadians(angle2, axis, out) {
      return Quat2Utils.rotateAxisRadians(this, angle2, axis, out);
    },
    quat2_toWorld(parentTransformQuat, out) {
      return Quat2Utils.toWorld(this, parentTransformQuat, out);
    },
    quat2_toLocal(parentTransformQuat, out) {
      return Quat2Utils.toLocal(this, parentTransformQuat, out);
    },
    quat2_toMatrix(out) {
      return Quat2Utils.toMatrix(this, out);
    },
    quat2_fromMatrix(matrix) {
      return Quat2Utils.fromMatrix(matrix, this);
    }
  };
  for (const arrayLikeClassToExtend of ArrayExtensionUtils.ARRAY_LIKE_CLASSES) {
    PluginUtils.injectOwnProperties(quat2Extension, arrayLikeClassToExtend.prototype, false, true, true);
  }
}

// dist/pp/plugin/js/extensions/array/quat_extension.js
function initQuatExtension() {
  _initQuatExtensionProtoype();
}
function _initQuatExtensionProtoype() {
  const quatExtension = {
    quat_set(x, y, z, w) {
      return QuatUtils.set(this, x, y, z, w);
    },
    quat_copy(quat) {
      return QuatUtils.copy(quat, this);
    },
    quat_clone() {
      return QuatUtils.clone(this);
    },
    quat_equals(quat, epsilon) {
      return QuatUtils.equals(this, quat, epsilon);
    },
    quat_isNormalized(epsilon) {
      return QuatUtils.isNormalized(this, epsilon);
    },
    quat_normalize(out) {
      return QuatUtils.normalize(this, out);
    },
    quat_length() {
      return QuatUtils.length(this);
    },
    quat_lengthSquared() {
      return QuatUtils.lengthSquared(this);
    },
    quat_identity() {
      return QuatUtils.identity(this);
    },
    quat_mul(quat, out) {
      return QuatUtils.mul(this, quat, out);
    },
    quat_invert(out) {
      return QuatUtils.invert(this, out);
    },
    quat_conjugate(out) {
      return QuatUtils.conjugate(this, out);
    },
    quat_lerp(to, interpolationFactor, out) {
      return QuatUtils.lerp(this, to, interpolationFactor, out);
    },
    quat_interpolate(to, interpolationFactor, easingFunction, out) {
      return QuatUtils.interpolate(this, to, interpolationFactor, easingFunction, out);
    },
    quat_slerp(to, interpolationFactor, out) {
      return QuatUtils.slerp(this, to, interpolationFactor, out);
    },
    quat_interpolateSpherical(to, interpolationFactor, easingFunction, out) {
      return QuatUtils.interpolateSpherical(this, to, interpolationFactor, easingFunction, out);
    },
    quat_getAngle() {
      return QuatUtils.getAngle(this);
    },
    quat_getAngleDegrees() {
      return QuatUtils.getAngleDegrees(this);
    },
    quat_getAngleRadians() {
      return QuatUtils.getAngleRadians(this);
    },
    quat_getAxis(out) {
      return QuatUtils.getAxis(this, out);
    },
    quat_getAxisScaled(out) {
      return QuatUtils.getAxisScaled(this, out);
    },
    quat_getAxisScaledDegrees(out) {
      return QuatUtils.getAxisScaledDegrees(this, out);
    },
    quat_getAxisScaledRadians(out) {
      return QuatUtils.getAxisScaledRadians(this, out);
    },
    quat_getAxes(out) {
      return QuatUtils.getAxes(this, out);
    },
    quat_getForward(out) {
      return QuatUtils.getForward(this, out);
    },
    quat_getBackward(out) {
      return QuatUtils.getBackward(this, out);
    },
    quat_getLeft(out) {
      return QuatUtils.getLeft(this, out);
    },
    quat_getRight(out) {
      return QuatUtils.getRight(this, out);
    },
    quat_getUp(out) {
      return QuatUtils.getUp(this, out);
    },
    quat_getDown(out) {
      return QuatUtils.getDown(this, out);
    },
    quat_setAxes(left, up, forward) {
      return QuatUtils.setAxes(this, left, up, forward);
    },
    quat_setForward(forward, up, left) {
      return QuatUtils.setForward(this, forward, up, left);
    },
    quat_setBackward(backward, up, left) {
      return QuatUtils.setBackward(this, backward, up, left);
    },
    quat_setUp(up, forward, left) {
      return QuatUtils.setUp(this, up, forward, left);
    },
    quat_setDown(down, forward, left) {
      return QuatUtils.setDown(this, down, forward, left);
    },
    quat_setLeft(left, up, forward) {
      return QuatUtils.setLeft(this, left, up, forward);
    },
    quat_setRight(right, up, forward) {
      return QuatUtils.setRight(this, right, up, forward);
    },
    quat_toWorld(parentRotationQuat, out) {
      return QuatUtils.toWorld(this, parentRotationQuat, out);
    },
    quat_toLocal(parentRotationQuat, out) {
      return QuatUtils.toLocal(this, parentRotationQuat, out);
    },
    quat_addRotation(rotation, out) {
      return QuatUtils.addRotation(this, rotation, out);
    },
    quat_addRotationDegrees(rotation, out) {
      return QuatUtils.addRotationDegrees(this, rotation, out);
    },
    quat_addRotationRadians(rotation, out) {
      return QuatUtils.addRotationRadians(this, rotation, out);
    },
    quat_addRotationQuat(rotation, out) {
      return QuatUtils.addRotationQuat(this, rotation, out);
    },
    quat_subRotation(rotation, out) {
      return QuatUtils.subRotation(this, rotation, out);
    },
    quat_subRotationDegrees(rotation, out) {
      return QuatUtils.subRotationDegrees(this, rotation, out);
    },
    quat_subRotationRadians(rotation, out) {
      return QuatUtils.subRotationRadians(this, rotation, out);
    },
    quat_subRotationQuat(rotation, out) {
      return QuatUtils.subRotationQuat(this, rotation, out);
    },
    quat_rotationTo(to, out) {
      return QuatUtils.rotationTo(this, to, out);
    },
    quat_rotationToDegrees(to, out) {
      return QuatUtils.rotationToDegrees(this, to, out);
    },
    quat_rotationToRadians(to, out) {
      return QuatUtils.rotationToRadians(this, to, out);
    },
    quat_rotationToQuat(to, out) {
      return QuatUtils.rotationToQuat(this, to, out);
    },
    quat_rotationAroundAxis(axis, out) {
      return QuatUtils.rotationAroundAxis(this, axis, out);
    },
    quat_rotationAroundAxisDegrees(axis, out) {
      return QuatUtils.rotationAroundAxisDegrees(this, axis, out);
    },
    quat_rotationAroundAxisRadians(axis, out) {
      return QuatUtils.rotationAroundAxisRadians(this, axis, out);
    },
    quat_rotationAroundAxisQuat(axis, out) {
      return QuatUtils.rotationAroundAxisQuat(this, axis, out);
    },
    quat_getTwist(axis, out) {
      return QuatUtils.getTwist(this, axis, out);
    },
    quat_getSwing(axis, out) {
      return QuatUtils.getSwing(this, axis, out);
    },
    quat_getSwingFromTwist(twist, out) {
      return QuatUtils.getSwingFromTwist(this, twist, out);
    },
    quat_getTwistFromSwing(swing, out) {
      return QuatUtils.getTwistFromSwing(this, swing, out);
    },
    quat_fromTwistSwing(twist, swing) {
      return QuatUtils.fromTwistSwing(twist, swing, this);
    },
    quat_rotate(rotation, out) {
      return QuatUtils.rotate(this, rotation, out);
    },
    quat_rotateDegrees(rotation, out) {
      return QuatUtils.rotateDegrees(this, rotation, out);
    },
    quat_rotateRadians(rotation, out) {
      return QuatUtils.rotateRadians(this, rotation, out);
    },
    quat_rotateQuat(rotation, out) {
      return QuatUtils.rotateQuat(this, rotation, out);
    },
    quat_rotateAxis(angle2, axis, out) {
      return QuatUtils.rotateAxis(this, angle2, axis, out);
    },
    quat_rotateAxisDegrees(angle2, axis, out) {
      return QuatUtils.rotateAxisDegrees(this, angle2, axis, out);
    },
    quat_rotateAxisRadians(angle2, axis, out) {
      return QuatUtils.rotateAxisRadians(this, angle2, axis, out);
    },
    quat_fromDegrees(rotation) {
      return QuatUtils.fromDegrees(rotation, this);
    },
    quat_fromRadians(rotation) {
      return QuatUtils.fromRadians(rotation, this);
    },
    quat_fromAxis(angle2, axis) {
      return QuatUtils.fromAxis(angle2, axis, this);
    },
    quat_fromAxisDegrees(angle2, axis) {
      return QuatUtils.fromAxisDegrees(angle2, axis, this);
    },
    quat_fromAxisRadians(angle2, axis) {
      return QuatUtils.fromAxisRadians(angle2, axis, this);
    },
    quat_fromAxes(left, up, forward) {
      return QuatUtils.fromAxes(left, up, forward, this);
    },
    quat_toDegrees(out) {
      return QuatUtils.toDegrees(this, out);
    },
    quat_toRadians(out) {
      return QuatUtils.toRadians(this, out);
    },
    quat_toMatrix(out) {
      return QuatUtils.toMatrix(this, out);
    }
  };
  for (const arrayLikeClassToExtend of ArrayExtensionUtils.ARRAY_LIKE_CLASSES) {
    PluginUtils.injectOwnProperties(quatExtension, arrayLikeClassToExtend.prototype, false, true, true);
  }
}

// dist/pp/plugin/js/extensions/array/vec2_extension.js
function initVec2Extension() {
  _initVec2ExtensionProtoype();
}
function _initVec2ExtensionProtoype() {
  const vec2Extension = {
    vec2_set(x, y) {
      return Vec2Utils.set(this, x, y);
    },
    vec2_copy(vector) {
      return Vec2Utils.copy(vector, this);
    },
    vec2_clone() {
      return Vec2Utils.clone(this);
    },
    vec2_equals(vector, epsilon) {
      return Vec2Utils.equals(this, vector, epsilon);
    },
    vec2_length() {
      return Vec2Utils.length(this);
    },
    vec2_normalize(out) {
      return Vec2Utils.normalize(this, out);
    },
    vec2_zero() {
      return Vec2Utils.zero(this);
    },
    vec2_isZero(epsilon) {
      return Vec2Utils.isZero(this, epsilon);
    },
    vec2_lerp(to, interpolationFactor, out) {
      return Vec2Utils.lerp(this, to, interpolationFactor, out);
    },
    vec2_interpolate(to, interpolationFactor, easingFunction, out) {
      return Vec2Utils.interpolate(this, to, interpolationFactor, easingFunction, out);
    }
  };
  for (const arrayLikeClassToExtend of ArrayExtensionUtils.ARRAY_LIKE_CLASSES) {
    PluginUtils.injectOwnProperties(vec2Extension, arrayLikeClassToExtend.prototype, false, true, true);
  }
}

// dist/pp/plugin/js/extensions/array/vec3_extension.js
function initVec3Extension() {
  _initVec3ExtensionProtoype();
}
function _initVec3ExtensionProtoype() {
  const vec3Extension = {
    vec3_set(x, y, z) {
      return Vec3Utils.set(this, x, y, z);
    },
    vec3_copy(vector) {
      return Vec3Utils.copy(vector, this);
    },
    vec3_clone() {
      return Vec3Utils.clone(this);
    },
    vec3_equals(vector, epsilon) {
      return Vec3Utils.equals(this, vector, epsilon);
    },
    vec3_isNormalized(epsilon) {
      return Vec3Utils.isNormalized(this, epsilon);
    },
    vec3_normalize(out) {
      return Vec3Utils.normalize(this, out);
    },
    vec3_isZero(epsilon) {
      return Vec3Utils.isZero(this, epsilon);
    },
    vec3_zero() {
      return Vec3Utils.zero(this);
    },
    vec3_length() {
      return Vec3Utils.length(this);
    },
    vec3_lengthSquared() {
      return Vec3Utils.lengthSquared(this);
    },
    vec3_lengthSigned(positiveDirection) {
      return Vec3Utils.lengthSigned(this, positiveDirection);
    },
    vec3_distance(vector) {
      return Vec3Utils.distance(this, vector);
    },
    vec3_distanceSquared(vector) {
      return Vec3Utils.distanceSquared(this, vector);
    },
    vec3_add(vector, out) {
      return Vec3Utils.add(this, vector, out);
    },
    vec3_sub(vector, out) {
      return Vec3Utils.sub(this, vector, out);
    },
    vec3_mul(vector, out) {
      return Vec3Utils.mul(this, vector, out);
    },
    vec3_div(vector, out) {
      return Vec3Utils.div(this, vector, out);
    },
    vec3_scale(value, out) {
      return Vec3Utils.scale(this, value, out);
    },
    vec3_negate(out) {
      return Vec3Utils.negate(this, out);
    },
    vec3_dot(vector) {
      return Vec3Utils.dot(this, vector);
    },
    vec3_cross(vector, out) {
      return Vec3Utils.cross(this, vector, out);
    },
    vec3_transformQuat(quat, out) {
      return Vec3Utils.transformQuat(this, quat, out);
    },
    vec3_transformMat3(matrix, out) {
      return Vec3Utils.transformMat3(this, matrix, out);
    },
    vec3_transformMat4(matrix, out) {
      return Vec3Utils.transformMat4(this, matrix, out);
    },
    vec3_lerp(to, interpolationFactor, out) {
      return Vec3Utils.lerp(this, to, interpolationFactor, out);
    },
    vec3_interpolate(to, interpolationFactor, easingFunction, out) {
      return Vec3Utils.interpolate(this, to, interpolationFactor, easingFunction, out);
    },
    vec3_angle(vector) {
      return Vec3Utils.angle(this, vector);
    },
    vec3_angleDegrees(vector) {
      return Vec3Utils.angleDegrees(this, vector);
    },
    vec3_angleRadians(vector) {
      return Vec3Utils.angleRadians(this, vector);
    },
    vec3_angleSigned(vector, referenceAxis) {
      return Vec3Utils.angleSigned(this, vector, referenceAxis);
    },
    vec3_angleSignedDegrees(vector, referenceAxis) {
      return Vec3Utils.angleSignedDegrees(this, vector, referenceAxis);
    },
    vec3_angleSignedRadians(vector, referenceAxis) {
      return Vec3Utils.angleSignedRadians(this, vector, referenceAxis);
    },
    vec3_anglePivoted(vector, referenceAxis) {
      return Vec3Utils.anglePivoted(this, vector, referenceAxis);
    },
    vec3_anglePivotedDegrees(vector, referenceAxis) {
      return Vec3Utils.anglePivotedDegrees(this, vector, referenceAxis);
    },
    vec3_anglePivotedRadians(vector, referenceAxis) {
      return Vec3Utils.anglePivotedRadians(this, vector, referenceAxis);
    },
    vec3_anglePivotedSigned(vector, referenceAxis) {
      return Vec3Utils.anglePivotedSigned(this, vector, referenceAxis);
    },
    vec3_anglePivotedSignedDegrees(vector, referenceAxis) {
      return Vec3Utils.anglePivotedSignedDegrees(this, vector, referenceAxis);
    },
    vec3_anglePivotedSignedRadians(vector, referenceAxis) {
      return Vec3Utils.anglePivotedSignedRadians(this, vector, referenceAxis);
    },
    vec3_valueAlongAxis(axis) {
      return Vec3Utils.valueAlongAxis(this, axis);
    },
    vec3_valueAlongPlane(planeNormal) {
      return Vec3Utils.valueAlongPlane(this, planeNormal);
    },
    vec3_componentAlongAxis(axis, out) {
      return Vec3Utils.componentAlongAxis(this, axis, out);
    },
    vec3_removeComponentAlongAxis(axis, out) {
      return Vec3Utils.removeComponentAlongAxis(this, axis, out);
    },
    vec3_copyComponentAlongAxis(vector, axis, out) {
      return Vec3Utils.copyComponentAlongAxis(vector, this, axis, out);
    },
    vec3_isConcordant(vector) {
      return Vec3Utils.isConcordant(this, vector);
    },
    vec3_isFartherAlongAxis(vector, axis) {
      return Vec3Utils.isFartherAlongAxis(this, vector, axis);
    },
    vec3_isToTheRight(vector, referenceAxis) {
      return Vec3Utils.isToTheRight(this, vector, referenceAxis);
    },
    vec3_signTo(vector, referenceAxis, zeroSign) {
      return Vec3Utils.signTo(this, vector, referenceAxis, zeroSign);
    },
    vec3_projectOnAxis(axis, out) {
      return Vec3Utils.projectOnAxis(this, axis, out);
    },
    vec3_projectOnAxisAlongAxis(axis, projectAlongAxis, out) {
      return Vec3Utils.projectOnAxisAlongAxis(this, axis, projectAlongAxis, out);
    },
    vec3_projectOnPlane(planeNormal, out) {
      return Vec3Utils.projectOnPlane(this, planeNormal, out);
    },
    vec3_projectOnPlaneAlongAxis(planeNormal, projectAlongAxis, out) {
      return Vec3Utils.projectOnPlaneAlongAxis(this, planeNormal, projectAlongAxis, out);
    },
    vec3_isOnAxis(axis) {
      return Vec3Utils.isOnAxis(this, axis);
    },
    vec3_isOnPlane(planeNormal) {
      return Vec3Utils.isOnPlane(this, planeNormal);
    },
    vec3_perpendicularAny(out) {
      return Vec3Utils.perpendicularAny(this, out);
    },
    vec3_rotate(rotation, out) {
      return Vec3Utils.rotate(this, rotation, out);
    },
    vec3_rotateDegrees(rotation, out) {
      return Vec3Utils.rotateDegrees(this, rotation, out);
    },
    vec3_rotateRadians(rotation, out) {
      return Vec3Utils.rotateRadians(this, rotation, out);
    },
    vec3_rotateQuat(rotation, out) {
      return Vec3Utils.rotateQuat(this, rotation, out);
    },
    vec3_rotateAxis(angle2, axis, out) {
      return Vec3Utils.rotateAxis(this, angle2, axis, out);
    },
    vec3_rotateAxisDegrees(angle2, axis, out) {
      return Vec3Utils.rotateAxisDegrees(this, angle2, axis, out);
    },
    vec3_rotateAxisRadians(angle2, axis, out) {
      return Vec3Utils.rotateAxisRadians(this, angle2, axis, out);
    },
    vec3_rotateAround(rotation, origin, out) {
      return Vec3Utils.rotateAround(this, rotation, origin, out);
    },
    vec3_rotateAroundDegrees(rotation, origin, out) {
      return Vec3Utils.rotateAroundDegrees(this, rotation, origin, out);
    },
    vec3_rotateAroundRadians(rotation, origin, out) {
      return Vec3Utils.rotateAroundRadians(this, rotation, origin, out);
    },
    vec3_rotateAroundQuat(rotation, origin, out) {
      return Vec3Utils.rotateAroundQuat(this, rotation, origin, out);
    },
    vec3_rotateAroundAxis(angle2, axis, origin, out) {
      return Vec3Utils.rotateAroundAxis(this, angle2, axis, origin, out);
    },
    vec3_rotateAroundAxisDegrees(angle2, axis, origin, out) {
      return Vec3Utils.rotateAroundAxisDegrees(this, angle2, axis, origin, out);
    },
    vec3_rotateAroundAxisRadians(angle2, axis, origin, out) {
      return Vec3Utils.rotateAroundAxisRadians(this, angle2, axis, origin, out);
    },
    vec3_addRotation(rotation, out) {
      return Vec3Utils.addRotation(this, rotation, out);
    },
    vec3_addRotationDegrees(rotation, out) {
      return Vec3Utils.addRotationDegrees(this, rotation, out);
    },
    vec3_addRotationRadians(rotation, out) {
      return Vec3Utils.addRotationRadians(this, rotation, out);
    },
    vec3_addRotationQuat(rotation, out) {
      return Vec3Utils.addRotationQuat(this, rotation, out);
    },
    vec3_degreesAddRotation(rotation, out) {
      return Vec3Utils.degreesAddRotation(this, rotation, out);
    },
    vec3_degreesAddRotationDegrees(rotation, out) {
      return Vec3Utils.degreesAddRotationDegrees(this, rotation, out);
    },
    vec3_degreesAddRotationRadians(rotation, out) {
      return Vec3Utils.degreesAddRotationRadians(this, rotation, out);
    },
    vec3_degreesAddRotationQuat(rotation, out) {
      return Vec3Utils.degreesAddRotationQuat(this, rotation, out);
    },
    vec3_radiansAddRotation(rotation, out) {
      return Vec3Utils.radiansAddRotation(this, rotation, out);
    },
    vec3_radiansAddRotationDegrees(rotation, out) {
      return Vec3Utils.radiansAddRotationDegrees(this, rotation, out);
    },
    vec3_radiansAddRotationRadians(rotation, out) {
      return Vec3Utils.radiansAddRotationRadians(this, rotation, out);
    },
    vec3_radiansAddRotationQuat(rotation, out) {
      return Vec3Utils.radiansAddRotationQuat(this, rotation, out);
    },
    vec3_rotationTo(to, out) {
      return Vec3Utils.rotationTo(this, to, out);
    },
    vec3_rotationToDegrees(to, out) {
      return Vec3Utils.rotationToDegrees(this, to, out);
    },
    vec3_rotationToRadians(to, out) {
      return Vec3Utils.rotationToRadians(this, to, out);
    },
    vec3_rotationToQuat(to, out) {
      return Vec3Utils.rotationToQuat(this, to, out);
    },
    vec3_rotationToPivoted(to, pivotAxis, out) {
      return Vec3Utils.rotationToPivoted(this, to, pivotAxis, out);
    },
    vec3_rotationToPivotedDegrees(to, pivotAxis, out) {
      return Vec3Utils.rotationToPivotedDegrees(this, to, pivotAxis, out);
    },
    vec3_rotationToPivotedRadians(to, pivotAxis, out) {
      return Vec3Utils.rotationToPivotedRadians(this, to, pivotAxis, out);
    },
    vec3_rotationToPivotedQuat(to, pivotAxis, out) {
      return Vec3Utils.rotationToPivotedQuat(this, to, pivotAxis, out);
    },
    vec3_convertPositionToWorld(parentTransform, out) {
      return Vec3Utils.convertPositionToWorld(this, parentTransform, out);
    },
    vec3_convertPositionToLocal(parentTransform, out) {
      return Vec3Utils.convertPositionToLocal(this, parentTransform, out);
    },
    vec3_convertPositionToWorldMatrix(parentTransform, out) {
      return Vec3Utils.convertPositionToWorldMatrix(this, parentTransform, out);
    },
    vec3_convertPositionToLocalMatrix(parentTransform, out) {
      return Vec3Utils.convertPositionToLocalMatrix(this, parentTransform, out);
    },
    vec3_convertPositionToWorldQuat(parentTransform, out) {
      return Vec3Utils.convertPositionToWorldQuat(this, parentTransform, out);
    },
    vec3_convertPositionToLocalQuat(parentTransform, out) {
      return Vec3Utils.convertPositionToLocalQuat(this, parentTransform, out);
    },
    vec3_convertDirectionToWorld(parentTransform, out) {
      return Vec3Utils.convertDirectionToWorld(this, parentTransform, out);
    },
    vec3_convertDirectionToLocal(parentTransform, out) {
      return Vec3Utils.convertDirectionToLocal(this, parentTransform, out);
    },
    vec3_convertDirectionToWorldMatrix(parentTransform, out) {
      return Vec3Utils.convertDirectionToWorldMatrix(this, parentTransform, out);
    },
    vec3_convertDirectionToLocalMatrix(parentTransform, out) {
      return Vec3Utils.convertDirectionToLocalMatrix(this, parentTransform, out);
    },
    vec3_convertDirectionToWorldQuat(parentTransform, out) {
      return Vec3Utils.convertDirectionToWorldQuat(this, parentTransform, out);
    },
    vec3_convertDirectionToLocalQuat(parentTransform, out) {
      return Vec3Utils.convertDirectionToLocalQuat(this, parentTransform, out);
    },
    vec3_toRadians(out) {
      return Vec3Utils.toRadians(this, out);
    },
    vec3_toDegrees(out) {
      return Vec3Utils.toDegrees(this, out);
    },
    vec3_toQuat(out) {
      return Vec3Utils.toQuat(this, out);
    },
    vec3_radiansToQuat(out) {
      return Vec3Utils.radiansToQuat(this, out);
    },
    vec3_degreesToQuat(out) {
      return Vec3Utils.degreesToQuat(this, out);
    },
    vec3_toMatrix(out) {
      return Vec3Utils.toMatrix(this, out);
    },
    vec3_degreesToMatrix(out) {
      return Vec3Utils.degreesToMatrix(this, out);
    },
    vec3_radiansToMatrix(out) {
      return Vec3Utils.radiansToMatrix(this, out);
    }
  };
  for (const arrayLikeClassToExtend of ArrayExtensionUtils.ARRAY_LIKE_CLASSES) {
    PluginUtils.injectOwnProperties(vec3Extension, arrayLikeClassToExtend.prototype, false, true, true);
  }
}

// dist/pp/plugin/js/extensions/array/vec4_extension.js
function initVec4Extension() {
  _initVec4ExtensionProtoype();
}
function _initVec4ExtensionProtoype() {
  const vec4Extension = {
    vec4_set(x, y, z, w) {
      return Vec4Utils.set(this, x, y, z, w);
    },
    vec4_copy(vector) {
      return Vec4Utils.copy(vector, this);
    },
    vec4_clone() {
      return Vec4Utils.clone(this);
    },
    vec4_equals(vector, epsilon) {
      return Vec4Utils.equals(this, vector, epsilon);
    },
    vec4_lerp(to, interpolationFactor, out) {
      return Vec4Utils.lerp(this, to, interpolationFactor, out);
    },
    vec4_interpolate(to, interpolationFactor, easingFunction, out) {
      return Vec4Utils.interpolate(this, to, interpolationFactor, easingFunction, out);
    }
  };
  for (const arrayLikeClassToExtend of ArrayExtensionUtils.ARRAY_LIKE_CLASSES) {
    PluginUtils.injectOwnProperties(vec4Extension, arrayLikeClassToExtend.prototype, false, true, true);
  }
}

// dist/pp/plugin/js/extensions/array/vec_extension.js
function initVecExtension() {
  _initVecExtensionProtoype();
}
function _initVecExtensionProtoype() {
  const vecExtension = {
    vec_set(firstValue, ...remainingValues) {
      return VecUtils.set(this, firstValue, ...remainingValues);
    },
    vec_copy(vector) {
      return VecUtils.copy(vector, this);
    },
    vec_clone() {
      return VecUtils.clone(this);
    },
    vec_equals(vector, epsilon) {
      return VecUtils.equals(this, vector, epsilon);
    },
    vec_zero() {
      return VecUtils.zero(this);
    },
    vec_isZero(epsilon) {
      return VecUtils.isZero(this, epsilon);
    },
    vec_scale(value, out) {
      return VecUtils.scale(this, value, out);
    },
    vec_round(out) {
      return VecUtils.round(this, out);
    },
    vec_floor(out) {
      return VecUtils.floor(this, out);
    },
    vec_ceil(out) {
      return VecUtils.ceil(this, out);
    },
    vec_clamp(start, end, out) {
      return VecUtils.clamp(this, start, end, out);
    },
    vec_lerp(to, interpolationFactor, out) {
      return VecUtils.lerp(this, to, interpolationFactor, out);
    },
    vec_interpolate(to, interpolationFactor, easingFunction, out) {
      return VecUtils.interpolate(this, to, interpolationFactor, easingFunction, out);
    },
    vec_toString(decimalPlaces) {
      return VecUtils.toString(this, decimalPlaces);
    },
    vec_log(decimalPlaces) {
      return VecUtils.log(this, decimalPlaces);
    },
    vec_error(decimalPlaces) {
      return VecUtils.error(this, decimalPlaces);
    },
    vec_warn(decimalPlaces) {
      return VecUtils.warn(this, decimalPlaces);
    }
  };
  for (const arrayLikeClassToExtend of ArrayExtensionUtils.ARRAY_LIKE_CLASSES) {
    PluginUtils.injectOwnProperties(vecExtension, arrayLikeClassToExtend.prototype, false, true, true);
  }
}

// dist/pp/plugin/js/extensions/math_extension.js
function initMathExtension() {
  _initMathExtensionInstance();
}
function _initMathExtensionInstance() {
  const mathExtension = {
    get PP_EPSILON() {
      return MathUtils.EPSILON;
    },
    get PP_EPSILON_SQUARED() {
      return MathUtils.EPSILON_SQUARED;
    },
    get PP_EPSILON_DEGREES() {
      return MathUtils.EPSILON_DEGREES;
    },
    pp_clamp(value, start, end) {
      return MathUtils.clamp(value, start, end);
    },
    pp_sign(value, zeroSign) {
      return MathUtils.sign(value, zeroSign);
    },
    pp_toDegrees(angle2) {
      return MathUtils.toDegrees(angle2);
    },
    pp_toRadians(angle2) {
      return MathUtils.toRadians(angle2);
    },
    pp_roundDecimal(number, decimalPlaces) {
      return MathUtils.roundDecimal(number, decimalPlaces);
    },
    pp_mapToRange(value, originRangeStart, originRangeEnd, newRangeStart, newRangeEnd) {
      return MathUtils.mapToRange(value, originRangeStart, originRangeEnd, newRangeStart, newRangeEnd);
    },
    pp_random(start, end) {
      return MathUtils.random(start, end);
    },
    pp_randomInt(start, end) {
      return MathUtils.randomInt(start, end);
    },
    pp_randomBool() {
      return MathUtils.randomBool();
    },
    pp_randomSign() {
      return MathUtils.randomSign();
    },
    pp_randomPick(...args) {
      return MathUtils.randomPick(...args);
    },
    pp_randomUUID() {
      return MathUtils.randomUUID();
    },
    pp_lerp(from, to, interpolationFactor) {
      return MathUtils.lerp(from, to, interpolationFactor);
    },
    pp_interpolate(from, to, interpolationFactor, easingFunction) {
      return MathUtils.interpolate(from, to, interpolationFactor, easingFunction);
    },
    pp_interpolatePeriodic(from, to, interpolationFactor, easingFunction) {
      return MathUtils.interpolatePeriodic(from, to, interpolationFactor, easingFunction);
    },
    pp_getEasingFunctionByName(easingFunctionName) {
      return MathUtils.getEasingFunctionByName(easingFunctionName);
    },
    pp_getEasingFunctionNameByIndex(index) {
      return MathUtils.getEasingFunctionNameByIndex(index);
    },
    pp_angleDistance(from, to) {
      return MathUtils.angleDistance(from, to);
    },
    pp_angleDistanceDegrees(from, to) {
      return MathUtils.angleDistanceDegrees(from, to);
    },
    pp_angleDistanceRadians(from, to) {
      return MathUtils.angleDistanceRadians(from, to);
    },
    pp_angleDistanceSigned(from, to) {
      return MathUtils.angleDistanceSigned(from, to);
    },
    pp_angleDistanceSignedDegrees(from, to) {
      return MathUtils.angleDistanceSignedDegrees(from, to);
    },
    pp_angleDistanceSignedRadians(from, to) {
      return MathUtils.angleDistanceSignedRadians(from, to);
    },
    pp_angleClamp(angle2, usePositiveRange) {
      return MathUtils.angleClamp(angle2, usePositiveRange);
    },
    pp_angleClampDegrees(angle2, usePositiveRange) {
      return MathUtils.angleClampDegrees(angle2, usePositiveRange);
    },
    pp_angleClampRadians(angle2, usePositiveRange) {
      return MathUtils.angleClampRadians(angle2, usePositiveRange);
    },
    pp_isInsideAngleRange(angle2, start, end, useShortestAngle) {
      return MathUtils.isInsideAngleRange(angle2, start, end, useShortestAngle);
    },
    pp_isInsideAngleRangeDegrees(angle2, start, end, useShortestAngle) {
      return MathUtils.isInsideAngleRangeDegrees(angle2, start, end, useShortestAngle);
    },
    pp_isInsideAngleRangeRadians(angle2, start, end, useShortestAngle) {
      return MathUtils.isInsideAngleRangeRadians(angle2, start, end, useShortestAngle);
    }
  };
  PluginUtils.injectOwnProperties(mathExtension, Math, false, true, true);
}

// dist/pp/plugin/js/extensions/number_extension.js
function initNumberExtension() {
  _initNumberExtensionPrototype();
}
function _initNumberExtensionPrototype() {
  const numberExtension = {
    get(factor) {
      return this.valueOf();
    }
  };
  PluginUtils.injectOwnProperties(numberExtension, Number.prototype, false, true, true);
}

// dist/pp/plugin/js/extensions/init_js_extentions.js
function initJSExtensions() {
  initMathExtension();
  initArrayExtension();
  initVecExtension();
  initVec2Extension();
  initVec3Extension();
  initVec4Extension();
  initQuatExtension();
  initQuat2Extension();
  initMat3Extension();
  initMat4Extension();
  initNumberExtension();
}

// dist/pp/plugin/js/init_js_plugins.js
function initJSPlugins() {
  initJSExtensions();
}

// dist/pp/plugin/wl/extensions/number_array_extension.js
function initNumberArrayExtension() {
  _initNumberArrayExtensionPrototype();
}
function _initNumberArrayExtensionPrototype() {
}

// dist/pp/plugin/wl/extensions/object_extension.js
import { Object3D as Object3D2 } from "@wonderlandengine/api";
function initObjectExtension() {
  _initObjectExtensionProtoype();
}
function _initObjectExtensionProtoype() {
  const objectExtension = {
    pp_getPosition(outPosition) {
      return ObjectUtils.getPosition(this, outPosition);
    },
    pp_getPositionWorld(outPosition) {
      return ObjectUtils.getPositionWorld(this, outPosition);
    },
    pp_getPositionLocal(outPosition) {
      return ObjectUtils.getPositionLocal(this, outPosition);
    },
    pp_getRotation(outRotation) {
      return ObjectUtils.getRotation(this, outRotation);
    },
    pp_getRotationDegrees(outRotation) {
      return ObjectUtils.getRotationDegrees(this, outRotation);
    },
    pp_getRotationRadians(outRotation) {
      return ObjectUtils.getRotationRadians(this, outRotation);
    },
    pp_getRotationMatrix(outRotation) {
      return ObjectUtils.getRotationMatrix(this, outRotation);
    },
    pp_getRotationQuat(outRotation) {
      return ObjectUtils.getRotationQuat(this, outRotation);
    },
    pp_getRotationWorld(outRotation) {
      return ObjectUtils.getRotationWorld(this, outRotation);
    },
    pp_getRotationWorldDegrees(outRotation) {
      return ObjectUtils.getRotationWorldDegrees(this, outRotation);
    },
    pp_getRotationWorldRadians(outRotation) {
      return ObjectUtils.getRotationWorldRadians(this, outRotation);
    },
    pp_getRotationWorldMatrix(outRotation) {
      return ObjectUtils.getRotationWorldMatrix(this, outRotation);
    },
    pp_getRotationWorldQuat(outRotation) {
      return ObjectUtils.getRotationWorldQuat(this, outRotation);
    },
    pp_getRotationLocal(outRotation) {
      return ObjectUtils.getRotationLocal(this, outRotation);
    },
    pp_getRotationLocalDegrees(outRotation) {
      return ObjectUtils.getRotationLocalDegrees(this, outRotation);
    },
    pp_getRotationLocalRadians(outRotation) {
      return ObjectUtils.getRotationLocalRadians(this, outRotation);
    },
    pp_getRotationLocalMatrix(outRotation) {
      return ObjectUtils.getRotationLocalMatrix(this, outRotation);
    },
    pp_getRotationLocalQuat(outRotation) {
      return ObjectUtils.getRotationLocalQuat(this, outRotation);
    },
    pp_getScale(outScale) {
      return ObjectUtils.getScale(this, outScale);
    },
    pp_getScaleWorld(outScale) {
      return ObjectUtils.getScaleWorld(this, outScale);
    },
    pp_getScaleLocal(outScale) {
      return ObjectUtils.getScaleLocal(this, outScale);
    },
    pp_getTransform(outTransform) {
      return ObjectUtils.getTransform(this, outTransform);
    },
    pp_getTransformMatrix(outTransform) {
      return ObjectUtils.getTransformMatrix(this, outTransform);
    },
    pp_getTransformQuat(outTransform) {
      return ObjectUtils.getTransformQuat(this, outTransform);
    },
    pp_getTransformWorld(outTransform) {
      return ObjectUtils.getTransformWorld(this, outTransform);
    },
    pp_getTransformWorldMatrix(outTransform) {
      return ObjectUtils.getTransformWorldMatrix(this, outTransform);
    },
    pp_getTransformWorldQuat(outTransform) {
      return ObjectUtils.getTransformWorldQuat(this, outTransform);
    },
    pp_getTransformLocal(outTransform) {
      return ObjectUtils.getTransformLocal(this, outTransform);
    },
    pp_getTransformLocalMatrix(outTransform) {
      return ObjectUtils.getTransformLocalMatrix(this, outTransform);
    },
    pp_getTransformLocalQuat(outTransform) {
      return ObjectUtils.getTransformLocalQuat(this, outTransform);
    },
    pp_getAxes(outAxes) {
      return ObjectUtils.getAxes(this, outAxes);
    },
    pp_getAxesWorld(outAxes) {
      return ObjectUtils.getAxesWorld(this, outAxes);
    },
    pp_getAxesLocal(outAxes) {
      return ObjectUtils.getAxesLocal(this, outAxes);
    },
    pp_getForward(outForward) {
      return ObjectUtils.getForward(this, outForward);
    },
    pp_getForwardWorld(outForward) {
      return ObjectUtils.getForwardWorld(this, outForward);
    },
    pp_getForwardLocal(outForward) {
      return ObjectUtils.getForwardLocal(this, outForward);
    },
    pp_getBackward(outBackward) {
      return ObjectUtils.getBackward(this, outBackward);
    },
    pp_getBackwardWorld(outBackward) {
      return ObjectUtils.getBackwardWorld(this, outBackward);
    },
    pp_getBackwardLocal(outBackward) {
      return ObjectUtils.getBackwardLocal(this, outBackward);
    },
    pp_getUp(outUp) {
      return ObjectUtils.getUp(this, outUp);
    },
    pp_getUpWorld(outUp) {
      return ObjectUtils.getUpWorld(this, outUp);
    },
    pp_getUpLocal(outUp) {
      return ObjectUtils.getUpLocal(this, outUp);
    },
    pp_getDown(outDown) {
      return ObjectUtils.getDown(this, outDown);
    },
    pp_getDownWorld(outDown) {
      return ObjectUtils.getDownWorld(this, outDown);
    },
    pp_getDownLocal(outDown) {
      return ObjectUtils.getDownLocal(this, outDown);
    },
    pp_getLeft(outLeft) {
      return ObjectUtils.getLeft(this, outLeft);
    },
    pp_getLeftWorld(outLeft) {
      return ObjectUtils.getLeftWorld(this, outLeft);
    },
    pp_getLeftLocal(outLeft) {
      return ObjectUtils.getLeftLocal(this, outLeft);
    },
    pp_getRight(outRight) {
      return ObjectUtils.getRight(this, outRight);
    },
    pp_getRightWorld(outRight) {
      return ObjectUtils.getRightWorld(this, outRight);
    },
    pp_getRightLocal(outRight) {
      return ObjectUtils.getRightLocal(this, outRight);
    },
    pp_setPosition(position) {
      return ObjectUtils.setPosition(this, position);
    },
    pp_setPositionWorld(position) {
      return ObjectUtils.setPositionWorld(this, position);
    },
    pp_setPositionLocal(position) {
      return ObjectUtils.setPositionLocal(this, position);
    },
    pp_setRotation(rotation) {
      return ObjectUtils.setRotation(this, rotation);
    },
    pp_setRotationDegrees(rotation) {
      return ObjectUtils.setRotationDegrees(this, rotation);
    },
    pp_setRotationRadians(rotation) {
      return ObjectUtils.setRotationRadians(this, rotation);
    },
    pp_setRotationMatrix(rotation) {
      return ObjectUtils.setRotationMatrix(this, rotation);
    },
    pp_setRotationQuat(rotation) {
      return ObjectUtils.setRotationQuat(this, rotation);
    },
    pp_setRotationWorld(rotation) {
      return ObjectUtils.setRotationWorld(this, rotation);
    },
    pp_setRotationWorldDegrees(rotation) {
      return ObjectUtils.setRotationWorldDegrees(this, rotation);
    },
    pp_setRotationWorldRadians(rotation) {
      return ObjectUtils.setRotationWorldRadians(this, rotation);
    },
    pp_setRotationWorldMatrix(rotation) {
      return ObjectUtils.setRotationWorldMatrix(this, rotation);
    },
    pp_setRotationWorldQuat(rotation) {
      return ObjectUtils.setRotationWorldQuat(this, rotation);
    },
    pp_setRotationLocal(rotation) {
      return ObjectUtils.setRotationLocal(this, rotation);
    },
    pp_setRotationLocalDegrees(rotation) {
      return ObjectUtils.setRotationLocalDegrees(this, rotation);
    },
    pp_setRotationLocalRadians(rotation) {
      return ObjectUtils.setRotationLocalRadians(this, rotation);
    },
    pp_setRotationLocalMatrix(rotation) {
      return ObjectUtils.setRotationLocalMatrix(this, rotation);
    },
    pp_setRotationLocalQuat(rotation) {
      return ObjectUtils.setRotationLocalQuat(this, rotation);
    },
    pp_setScale(scale4) {
      return ObjectUtils.setScale(this, scale4);
    },
    pp_setScaleWorld(scale4) {
      return ObjectUtils.setScaleWorld(this, scale4);
    },
    pp_setScaleLocal(scale4) {
      return ObjectUtils.setScaleLocal(this, scale4);
    },
    pp_setAxes(left, up, forward) {
      return ObjectUtils.setAxes(this, left, up, forward);
    },
    pp_setAxesWorld(left, up, forward) {
      return ObjectUtils.setAxesWorld(this, left, up, forward);
    },
    pp_setAxesLocal(left, up, forward) {
      return ObjectUtils.setAxesLocal(this, left, up, forward);
    },
    pp_setForward(forward, up, left) {
      return ObjectUtils.setForward(this, forward, up, left);
    },
    pp_setForwardWorld(forward, up, left) {
      return ObjectUtils.setForwardWorld(this, forward, up, left);
    },
    pp_setForwardLocal(forward, up, left) {
      return ObjectUtils.setForwardLocal(this, forward, up, left);
    },
    pp_setBackward(backward, up, left) {
      return ObjectUtils.setBackward(this, backward, up, left);
    },
    pp_setBackwardWorld(backward, up, left) {
      return ObjectUtils.setBackwardWorld(this, backward, up, left);
    },
    pp_setBackwardLocal(backward, up, left) {
      return ObjectUtils.setBackwardLocal(this, backward, up, left);
    },
    pp_setUp(up, forward, left) {
      return ObjectUtils.setUp(this, up, forward, left);
    },
    pp_setUpWorld(up, forward, left) {
      return ObjectUtils.setUpWorld(this, up, forward, left);
    },
    pp_setUpLocal(up, forward, left) {
      return ObjectUtils.setUpLocal(this, up, forward, left);
    },
    pp_setDown(down, forward, left) {
      return ObjectUtils.setDown(this, down, forward, left);
    },
    pp_setDownWorld(down, forward, left) {
      return ObjectUtils.setDownWorld(this, down, forward, left);
    },
    pp_setDownLocal(down, forward, left) {
      return ObjectUtils.setDownLocal(this, down, forward, left);
    },
    pp_setLeft(left, up, forward) {
      return ObjectUtils.setLeft(this, left, up, forward);
    },
    pp_setLeftWorld(left, up, forward) {
      return ObjectUtils.setLeftWorld(this, left, up, forward);
    },
    pp_setLeftLocal(left, up, forward) {
      return ObjectUtils.setLeftLocal(this, left, up, forward);
    },
    pp_setRight(right, up, forward) {
      return ObjectUtils.setRight(this, right, up, forward);
    },
    pp_setRightWorld(right, up, forward) {
      return ObjectUtils.setRightWorld(this, right, up, forward);
    },
    pp_setRightLocal(right, up, forward) {
      return ObjectUtils.setRightLocal(this, right, up, forward);
    },
    pp_setTransform(transform) {
      return ObjectUtils.setTransform(this, transform);
    },
    pp_setTransformMatrix(transform) {
      return ObjectUtils.setTransformMatrix(this, transform);
    },
    pp_setTransformQuat(transform) {
      return ObjectUtils.setTransformQuat(this, transform);
    },
    pp_setTransformWorld(transform) {
      return ObjectUtils.setTransformWorld(this, transform);
    },
    pp_setTransformWorldMatrix(transform) {
      return ObjectUtils.setTransformWorldMatrix(this, transform);
    },
    pp_setTransformWorldQuat(transform) {
      return ObjectUtils.setTransformWorldQuat(this, transform);
    },
    pp_setTransformLocal(transform) {
      return ObjectUtils.setTransformLocal(this, transform);
    },
    pp_setTransformLocalMatrix(transform) {
      return ObjectUtils.setTransformLocalMatrix(this, transform);
    },
    pp_setTransformLocalQuat(transform) {
      return ObjectUtils.setTransformLocalQuat(this, transform);
    },
    pp_resetPosition() {
      return ObjectUtils.resetPosition(this);
    },
    pp_resetPositionWorld() {
      return ObjectUtils.resetPositionWorld(this);
    },
    pp_resetPositionLocal() {
      return ObjectUtils.resetPositionLocal(this);
    },
    pp_resetRotation() {
      return ObjectUtils.resetRotation(this);
    },
    pp_resetRotationWorld() {
      return ObjectUtils.resetRotationWorld(this);
    },
    pp_resetRotationLocal() {
      return ObjectUtils.resetRotationLocal(this);
    },
    pp_resetScale() {
      return ObjectUtils.resetScale(this);
    },
    pp_resetScaleWorld() {
      return ObjectUtils.resetScaleWorld(this);
    },
    pp_resetScaleLocal() {
      return ObjectUtils.resetScaleLocal(this);
    },
    pp_resetTransform() {
      return ObjectUtils.resetTransform(this);
    },
    pp_resetTransformWorld() {
      return ObjectUtils.resetTransformWorld(this);
    },
    pp_resetTransformLocal() {
      return ObjectUtils.resetTransformLocal(this);
    },
    pp_translate(translation) {
      return ObjectUtils.translate(this, translation);
    },
    pp_translateWorld(translation) {
      return ObjectUtils.translateWorld(this, translation);
    },
    pp_translateLocal(translation) {
      return ObjectUtils.translateLocal(this, translation);
    },
    pp_translateObject(translation) {
      return ObjectUtils.translateObject(this, translation);
    },
    pp_translateAxis(amount, direction) {
      return ObjectUtils.translateAxis(this, amount, direction);
    },
    pp_translateAxisWorld(amount, direction) {
      return ObjectUtils.translateAxisWorld(this, amount, direction);
    },
    pp_translateAxisLocal(amount, direction) {
      return ObjectUtils.translateAxisLocal(this, amount, direction);
    },
    pp_translateAxisObject(amount, direction) {
      return ObjectUtils.translateAxisObject(this, amount, direction);
    },
    pp_rotate(rotation) {
      return ObjectUtils.rotate(this, rotation);
    },
    pp_rotateDegrees(rotation) {
      return ObjectUtils.rotateDegrees(this, rotation);
    },
    pp_rotateRadians(rotation) {
      return ObjectUtils.rotateRadians(this, rotation);
    },
    pp_rotateMatrix(rotation) {
      return ObjectUtils.rotateMatrix(this, rotation);
    },
    pp_rotateQuat(rotation) {
      return ObjectUtils.rotateQuat(this, rotation);
    },
    pp_rotateWorld(rotation) {
      return ObjectUtils.rotateWorld(this, rotation);
    },
    pp_rotateWorldDegrees(rotation) {
      return ObjectUtils.rotateWorldDegrees(this, rotation);
    },
    pp_rotateWorldRadians(rotation) {
      return ObjectUtils.rotateWorldRadians(this, rotation);
    },
    pp_rotateWorldMatrix(rotation) {
      return ObjectUtils.rotateWorldMatrix(this, rotation);
    },
    pp_rotateWorldQuat(rotation) {
      return ObjectUtils.rotateWorldQuat(this, rotation);
    },
    pp_rotateLocal(rotation) {
      return ObjectUtils.rotateLocal(this, rotation);
    },
    pp_rotateLocalDegrees(rotation) {
      return ObjectUtils.rotateLocalDegrees(this, rotation);
    },
    pp_rotateLocalRadians(rotation) {
      return ObjectUtils.rotateLocalRadians(this, rotation);
    },
    pp_rotateLocalMatrix(rotation) {
      return ObjectUtils.rotateLocalMatrix(this, rotation);
    },
    pp_rotateLocalQuat(rotation) {
      return ObjectUtils.rotateLocalQuat(this, rotation);
    },
    pp_rotateObject(rotation) {
      return ObjectUtils.rotateObject(this, rotation);
    },
    pp_rotateObjectDegrees(rotation) {
      return ObjectUtils.rotateObjectDegrees(this, rotation);
    },
    pp_rotateObjectRadians(rotation) {
      return ObjectUtils.rotateObjectRadians(this, rotation);
    },
    pp_rotateObjectMatrix(rotation) {
      return ObjectUtils.rotateObjectMatrix(this, rotation);
    },
    pp_rotateObjectQuat(rotation) {
      return ObjectUtils.rotateObjectQuat(this, rotation);
    },
    pp_rotateAxis(angle2, axis) {
      return ObjectUtils.rotateAxis(this, angle2, axis);
    },
    pp_rotateAxisDegrees(angle2, axis) {
      return ObjectUtils.rotateAxisDegrees(this, angle2, axis);
    },
    pp_rotateAxisRadians(angle2, axis) {
      return ObjectUtils.rotateAxisRadians(this, angle2, axis);
    },
    pp_rotateAxisWorld(angle2, axis) {
      return ObjectUtils.rotateAxisWorld(this, angle2, axis);
    },
    pp_rotateAxisWorldDegrees(angle2, axis) {
      return ObjectUtils.rotateAxisWorldDegrees(this, angle2, axis);
    },
    pp_rotateAxisWorldRadians(angle2, axis) {
      return ObjectUtils.rotateAxisWorldRadians(this, angle2, axis);
    },
    pp_rotateAxisLocal(angle2, axis) {
      return ObjectUtils.rotateAxisLocal(this, angle2, axis);
    },
    pp_rotateAxisLocalDegrees(angle2, axis) {
      return ObjectUtils.rotateAxisLocalDegrees(this, angle2, axis);
    },
    pp_rotateAxisLocalRadians(angle2, axis) {
      return ObjectUtils.rotateAxisLocalRadians(this, angle2, axis);
    },
    pp_rotateAxisObject(angle2, axis) {
      return ObjectUtils.rotateAxisObject(this, angle2, axis);
    },
    pp_rotateAxisObjectDegrees(angle2, axis) {
      return ObjectUtils.rotateAxisObjectDegrees(this, angle2, axis);
    },
    pp_rotateAxisObjectRadians(angle2, axis) {
      return ObjectUtils.rotateAxisObjectRadians(this, angle2, axis);
    },
    pp_rotateAround(rotation, origin) {
      return ObjectUtils.rotateAround(this, rotation, origin);
    },
    pp_rotateAroundDegrees(rotation, origin) {
      return ObjectUtils.rotateAroundDegrees(this, rotation, origin);
    },
    pp_rotateAroundRadians(rotation, origin) {
      return ObjectUtils.rotateAroundRadians(this, rotation, origin);
    },
    pp_rotateAroundMatrix(rotation, origin) {
      return ObjectUtils.rotateAroundMatrix(this, rotation, origin);
    },
    pp_rotateAroundQuat(rotation, origin) {
      return ObjectUtils.rotateAroundQuat(this, rotation, origin);
    },
    pp_rotateAroundWorld(rotation, origin) {
      return ObjectUtils.rotateAroundWorld(this, rotation, origin);
    },
    pp_rotateAroundWorldDegrees(rotation, origin) {
      return ObjectUtils.rotateAroundWorldDegrees(this, rotation, origin);
    },
    pp_rotateAroundWorldRadians(rotation, origin) {
      return ObjectUtils.rotateAroundWorldRadians(this, rotation, origin);
    },
    pp_rotateAroundWorldMatrix(rotation, origin) {
      return ObjectUtils.rotateAroundWorldMatrix(this, rotation, origin);
    },
    pp_rotateAroundWorldQuat(rotation, origin) {
      return ObjectUtils.rotateAroundWorldQuat(this, rotation, origin);
    },
    pp_rotateAroundLocal(rotation, origin) {
      return ObjectUtils.rotateAroundLocal(this, rotation, origin);
    },
    pp_rotateAroundLocalDegrees(rotation, origin) {
      return ObjectUtils.rotateAroundLocalDegrees(this, rotation, origin);
    },
    pp_rotateAroundLocalRadians(rotation, origin) {
      return ObjectUtils.rotateAroundLocalRadians(this, rotation, origin);
    },
    pp_rotateAroundLocalMatrix(rotation, origin) {
      return ObjectUtils.rotateAroundLocalMatrix(this, rotation, origin);
    },
    pp_rotateAroundLocalQuat(rotation, origin) {
      return ObjectUtils.rotateAroundLocalQuat(this, rotation, origin);
    },
    pp_rotateAroundObject(rotation, origin) {
      return ObjectUtils.rotateAroundObject(this, rotation, origin);
    },
    pp_rotateAroundObjectDegrees(rotation, origin) {
      return ObjectUtils.rotateAroundObjectDegrees(this, rotation, origin);
    },
    pp_rotateAroundObjectRadians(rotation, origin) {
      return ObjectUtils.rotateAroundObjectRadians(this, rotation, origin);
    },
    pp_rotateAroundObjectMatrix(rotation, origin) {
      return ObjectUtils.rotateAroundObjectMatrix(this, rotation, origin);
    },
    pp_rotateAroundObjectQuat(rotation, origin) {
      return ObjectUtils.rotateAroundObjectQuat(this, rotation, origin);
    },
    pp_rotateAroundAxis(angle2, axis, origin) {
      return ObjectUtils.rotateAroundAxis(this, angle2, axis, origin);
    },
    pp_rotateAroundAxisDegrees(angle2, axis, origin) {
      return ObjectUtils.rotateAroundAxisDegrees(this, angle2, axis, origin);
    },
    pp_rotateAroundAxisRadians(angle2, axis, origin) {
      return ObjectUtils.rotateAroundAxisRadians(this, angle2, axis, origin);
    },
    pp_rotateAroundAxisWorld(angle2, axis, origin) {
      return ObjectUtils.rotateAroundAxisWorld(this, angle2, axis, origin);
    },
    pp_rotateAroundAxisWorldDegrees(angle2, axis, origin) {
      return ObjectUtils.rotateAroundAxisWorldDegrees(this, angle2, axis, origin);
    },
    pp_rotateAroundAxisWorldRadians(angle2, axis, origin) {
      return ObjectUtils.rotateAroundAxisWorldRadians(this, angle2, axis, origin);
    },
    pp_rotateAroundAxisLocal(angle2, axis, origin) {
      return ObjectUtils.rotateAroundAxisLocal(this, angle2, axis, origin);
    },
    pp_rotateAroundAxisLocalDegrees(angle2, axis, origin) {
      return ObjectUtils.rotateAroundAxisLocalDegrees(this, angle2, axis, origin);
    },
    pp_rotateAroundAxisLocalRadians(angle2, axis, origin) {
      return ObjectUtils.rotateAroundAxisLocalRadians(this, angle2, axis, origin);
    },
    pp_rotateAroundAxisObject(angle2, axis, origin) {
      return ObjectUtils.rotateAroundAxisObject(this, angle2, axis, origin);
    },
    pp_rotateAroundAxisObjectDegrees(angle2, axis, origin) {
      return ObjectUtils.rotateAroundAxisObjectDegrees(this, angle2, axis, origin);
    },
    pp_rotateAroundAxisObjectRadians(angle2, axis, origin) {
      return ObjectUtils.rotateAroundAxisObjectRadians(this, angle2, axis, origin);
    },
    pp_scaleObject(scale4) {
      return ObjectUtils.scaleObject(this, scale4);
    },
    pp_lookAt(position, up) {
      return ObjectUtils.lookAt(this, position, up);
    },
    pp_lookAtWorld(position, up) {
      return ObjectUtils.lookAtWorld(this, position, up);
    },
    pp_lookAtLocal(position, up) {
      return ObjectUtils.lookAtLocal(this, position, up);
    },
    pp_lookTo(direction, up) {
      return ObjectUtils.lookTo(this, direction, up);
    },
    pp_lookToWorld(direction, up) {
      return ObjectUtils.lookToWorld(this, direction, up);
    },
    pp_lookToLocal(direction, up) {
      return ObjectUtils.lookToLocal(this, direction, up);
    },
    pp_convertPositionObjectToWorld(position, outPosition) {
      return ObjectUtils.convertPositionObjectToWorld(this, position, outPosition);
    },
    pp_convertDirectionObjectToWorld(direction, outDirection) {
      return ObjectUtils.convertDirectionObjectToWorld(this, direction, outDirection);
    },
    pp_convertPositionWorldToObject(position, outPosition) {
      return ObjectUtils.convertPositionWorldToObject(this, position, outPosition);
    },
    pp_convertDirectionWorldToObject(direction, outDirection) {
      return ObjectUtils.convertDirectionWorldToObject(this, direction, outDirection);
    },
    pp_convertPositionLocalToWorld(position, outPosition) {
      return ObjectUtils.convertPositionLocalToWorld(this, position, outPosition);
    },
    pp_convertDirectionLocalToWorld(direction, outDirection) {
      return ObjectUtils.convertDirectionLocalToWorld(this, direction, outDirection);
    },
    pp_convertPositionWorldToLocal(position, outPosition) {
      return ObjectUtils.convertPositionWorldToLocal(this, position, outPosition);
    },
    pp_convertDirectionWorldToLocal(direction, outDirection) {
      return ObjectUtils.convertDirectionWorldToLocal(this, direction, outDirection);
    },
    pp_convertPositionObjectToLocal(position, outPosition) {
      return ObjectUtils.convertPositionObjectToLocal(this, position, outPosition);
    },
    pp_convertDirectionObjectToLocal(direction, outDirection) {
      return ObjectUtils.convertDirectionObjectToLocal(this, direction, outDirection);
    },
    pp_convertPositionLocalToObject(position, outPosition) {
      return ObjectUtils.convertPositionLocalToObject(this, position, outPosition);
    },
    pp_convertDirectionLocalToObject(direction, outDirection) {
      return ObjectUtils.convertDirectionLocalToObject(this, direction, outDirection);
    },
    pp_convertTransformObjectToWorld(transform, outTransform) {
      return ObjectUtils.convertTransformObjectToWorld(this, transform, outTransform);
    },
    pp_convertTransformObjectToWorldMatrix(transform, outTransform) {
      return ObjectUtils.convertTransformObjectToWorldMatrix(this, transform, outTransform);
    },
    pp_convertTransformObjectToWorldQuat(transform, outTransform) {
      return ObjectUtils.convertTransformObjectToWorldQuat(this, transform, outTransform);
    },
    pp_convertTransformWorldToObject(transform, outTransform) {
      return ObjectUtils.convertTransformWorldToObject(this, transform, outTransform);
    },
    pp_convertTransformWorldToObjectMatrix(transform, outTransform) {
      return ObjectUtils.convertTransformWorldToObjectMatrix(this, transform, outTransform);
    },
    pp_convertTransformWorldToObjectQuat(transform, outTransform) {
      return ObjectUtils.convertTransformWorldToObjectQuat(this, transform, outTransform);
    },
    pp_convertTransformLocalToWorld(transform, outTransform) {
      return ObjectUtils.convertTransformLocalToWorld(this, transform, outTransform);
    },
    pp_convertTransformLocalToWorldMatrix(transform, outTransform) {
      return ObjectUtils.convertTransformLocalToWorldMatrix(this, transform, outTransform);
    },
    pp_convertTransformLocalToWorldQuat(transform, outTransform) {
      return ObjectUtils.convertTransformLocalToWorldQuat(this, transform, outTransform);
    },
    pp_convertTransformWorldToLocal(transform, outTransform) {
      return ObjectUtils.convertTransformWorldToLocal(this, transform, outTransform);
    },
    pp_convertTransformWorldToLocalMatrix(transform, outTransform) {
      return ObjectUtils.convertTransformWorldToLocalMatrix(this, transform, outTransform);
    },
    pp_convertTransformWorldToLocalQuat(transform, outTransform) {
      return ObjectUtils.convertTransformWorldToLocalQuat(this, transform, outTransform);
    },
    pp_convertTransformObjectToLocal(transform, outTransform) {
      return ObjectUtils.convertTransformObjectToLocal(this, transform, outTransform);
    },
    pp_convertTransformObjectToLocalMatrix(transform, outTransform) {
      return ObjectUtils.convertTransformObjectToLocalMatrix(this, transform, outTransform);
    },
    pp_convertTransformObjectToLocalQuat(transform, outTransform) {
      return ObjectUtils.convertTransformObjectToLocalQuat(this, transform, outTransform);
    },
    pp_convertTransformLocalToObject(transform, outTransform) {
      return ObjectUtils.convertTransformLocalToObject(this, transform, outTransform);
    },
    pp_convertTransformLocalToObjectMatrix(transform, outTransform) {
      return ObjectUtils.convertTransformLocalToObjectMatrix(this, transform, outTransform);
    },
    pp_convertTransformLocalToObjectQuat(transform, outTransform) {
      return ObjectUtils.convertTransformLocalToObjectQuat(this, transform, outTransform);
    },
    pp_setParent(newParent, keepTransformWorld) {
      return ObjectUtils.setParent(this, newParent, keepTransformWorld);
    },
    pp_getParent() {
      return ObjectUtils.getParent(this);
    },
    pp_addComponent(classOrType, paramsOrActive, active) {
      return ObjectUtils.addComponent(this, classOrType, paramsOrActive, active);
    },
    pp_getComponent(classOrType, index) {
      return ObjectUtils.getComponent(this, classOrType, index);
    },
    pp_getComponentSelf(classOrType, index) {
      return ObjectUtils.getComponentSelf(this, classOrType, index);
    },
    pp_getComponentHierarchy(classOrType, index) {
      return ObjectUtils.getComponentHierarchy(this, classOrType, index);
    },
    pp_getComponentHierarchyBreadth(classOrType, index) {
      return ObjectUtils.getComponentHierarchyBreadth(this, classOrType, index);
    },
    pp_getComponentHierarchyDepth(classOrType, index) {
      return ObjectUtils.getComponentHierarchyDepth(this, classOrType, index);
    },
    pp_getComponentDescendants(classOrType, index) {
      return ObjectUtils.getComponentDescendants(this, classOrType, index);
    },
    pp_getComponentDescendantsBreadth(classOrType, index) {
      return ObjectUtils.getComponentDescendantsBreadth(this, classOrType, index);
    },
    pp_getComponentDescendantsDepth(classOrType, index) {
      return ObjectUtils.getComponentDescendantsDepth(this, classOrType, index);
    },
    pp_getComponentChildren(classOrType, index) {
      return ObjectUtils.getComponentChildren(this, classOrType, index);
    },
    pp_getComponents(classOrType) {
      return ObjectUtils.getComponents(this, classOrType);
    },
    pp_getComponentsSelf(classOrType) {
      return ObjectUtils.getComponentsSelf(this, classOrType);
    },
    pp_getComponentsHierarchy(classOrType) {
      return ObjectUtils.getComponentsHierarchy(this, classOrType);
    },
    pp_getComponentsHierarchyBreadth(classOrType) {
      return ObjectUtils.getComponentsHierarchyBreadth(this, classOrType);
    },
    pp_getComponentsHierarchyDepth(classOrType) {
      return ObjectUtils.getComponentsHierarchyDepth(this, classOrType);
    },
    pp_getComponentsDescendants(classOrType) {
      return ObjectUtils.getComponentsDescendants(this, classOrType);
    },
    pp_getComponentsDescendantsBreadth(classOrType) {
      return ObjectUtils.getComponentsDescendantsBreadth(this, classOrType);
    },
    pp_getComponentsDescendantsDepth(classOrType) {
      return ObjectUtils.getComponentsDescendantsDepth(this, classOrType);
    },
    pp_getComponentsChildren(classOrType) {
      return ObjectUtils.getComponentsChildren(this, classOrType);
    },
    pp_setActive(active) {
      return ObjectUtils.setActive(this, active);
    },
    pp_setActiveSelf(active) {
      return ObjectUtils.setActiveSelf(this, active);
    },
    pp_setActiveHierarchy(active) {
      return ObjectUtils.setActiveHierarchy(this, active);
    },
    pp_setActiveHierarchyBreadth(active) {
      return ObjectUtils.setActiveHierarchyBreadth(this, active);
    },
    pp_setActiveHierarchyDepth(active) {
      return ObjectUtils.setActiveHierarchyDepth(this, active);
    },
    pp_setActiveDescendants(active) {
      return ObjectUtils.setActiveDescendants(this, active);
    },
    pp_setActiveDescendantsBreadth(active) {
      return ObjectUtils.setActiveDescendantsBreadth(this, active);
    },
    pp_setActiveDescendantsDepth(active) {
      return ObjectUtils.setActiveDescendantsDepth(this, active);
    },
    pp_setActiveChildren(active) {
      return ObjectUtils.setActiveChildren(this, active);
    },
    pp_hasUniformScale() {
      return ObjectUtils.hasUniformScale(this);
    },
    pp_hasUniformScaleWorld() {
      return ObjectUtils.hasUniformScaleWorld(this);
    },
    pp_hasUniformScaleLocal() {
      return ObjectUtils.hasUniformScaleLocal(this);
    },
    pp_clone(cloneParams) {
      return ObjectUtils.clone(this, cloneParams);
    },
    pp_isCloneable(cloneParams) {
      return ObjectUtils.isCloneable(this, cloneParams);
    },
    pp_toString() {
      return ObjectUtils.toString(this);
    },
    pp_toStringExtended() {
      return ObjectUtils.toStringExtended(this);
    },
    pp_toStringCompact() {
      return ObjectUtils.toStringCompact(this);
    },
    pp_log() {
      return ObjectUtils.log(this);
    },
    pp_logExtended() {
      return ObjectUtils.logExtended(this);
    },
    pp_logCompact() {
      return ObjectUtils.logCompact(this);
    },
    pp_warn() {
      return ObjectUtils.warn(this);
    },
    pp_warnExtended() {
      return ObjectUtils.warnExtended(this);
    },
    pp_warnCompact() {
      return ObjectUtils.warnCompact(this);
    },
    pp_error() {
      return ObjectUtils.error(this);
    },
    pp_errorExtended() {
      return ObjectUtils.errorExtended(this);
    },
    pp_errorCompact() {
      return ObjectUtils.errorCompact(this);
    },
    pp_getObjectByName(name, isRegex, index) {
      return ObjectUtils.getObjectByName(this, name, isRegex, index);
    },
    pp_getObjectByNameHierarchy(name, isRegex, index) {
      return ObjectUtils.getObjectByNameHierarchy(this, name, isRegex, index);
    },
    pp_getObjectByNameHierarchyBreadth(name, isRegex, index) {
      return ObjectUtils.getObjectByNameHierarchyBreadth(this, name, isRegex, index);
    },
    pp_getObjectByNameHierarchyDepth(name, isRegex, index) {
      return ObjectUtils.getObjectByNameHierarchyDepth(this, name, isRegex, index);
    },
    pp_getObjectByNameDescendants(name, isRegex, index) {
      return ObjectUtils.getObjectByNameDescendants(this, name, isRegex, index);
    },
    pp_getObjectByNameDescendantsBreadth(name, isRegex, index) {
      return ObjectUtils.getObjectByNameDescendantsBreadth(this, name, isRegex, index);
    },
    pp_getObjectByNameDescendantsDepth(name, isRegex, index) {
      return ObjectUtils.getObjectByNameDescendantsDepth(this, name, isRegex, index);
    },
    pp_getObjectByNameChildren(name, isRegex, index) {
      return ObjectUtils.getObjectByNameChildren(this, name, isRegex, index);
    },
    pp_getObjectsByName(name, isRegex) {
      return ObjectUtils.getObjectsByName(this, name, isRegex);
    },
    pp_getObjectsByNameHierarchy(name, isRegex) {
      return ObjectUtils.getObjectsByNameHierarchy(this, name, isRegex);
    },
    pp_getObjectsByNameHierarchyBreadth(name, isRegex) {
      return ObjectUtils.getObjectsByNameHierarchyBreadth(this, name, isRegex);
    },
    pp_getObjectsByNameHierarchyDepth(name, isRegex) {
      return ObjectUtils.getObjectsByNameHierarchyDepth(this, name, isRegex);
    },
    pp_getObjectsByNameDescendants(name, isRegex) {
      return ObjectUtils.getObjectsByNameDescendants(this, name, isRegex);
    },
    pp_getObjectsByNameDescendantsBreadth(name, isRegex) {
      return ObjectUtils.getObjectsByNameDescendantsBreadth(this, name, isRegex);
    },
    pp_getObjectsByNameDescendantsDepth(name, isRegex) {
      return ObjectUtils.getObjectsByNameDescendantsDepth(this, name, isRegex);
    },
    pp_getObjectsByNameChildren(name, isRegex) {
      return ObjectUtils.getObjectsByNameChildren(this, name, isRegex);
    },
    pp_getObjectByID(id) {
      return ObjectUtils.getObjectByID(this, id);
    },
    pp_getObjectByIDHierarchy(id) {
      return ObjectUtils.getObjectByIDHierarchy(this, id);
    },
    pp_getObjectByIDHierarchyBreadth(id) {
      return ObjectUtils.getObjectByIDHierarchyBreadth(this, id);
    },
    pp_getObjectByIDHierarchyDepth(id) {
      return ObjectUtils.getObjectByIDHierarchyDepth(this, id);
    },
    pp_getObjectByIDDescendants(id) {
      return ObjectUtils.getObjectByIDDescendants(this, id);
    },
    pp_getObjectByIDDescendantsBreadth(id) {
      return ObjectUtils.getObjectByIDDescendantsBreadth(this, id);
    },
    pp_getObjectByIDDescendantsDepth(id) {
      return ObjectUtils.getObjectByIDDescendantsDepth(this, id);
    },
    pp_getObjectByIDChildren(id) {
      return ObjectUtils.getObjectByIDChildren(this, id);
    },
    pp_getHierarchy() {
      return ObjectUtils.getHierarchy(this);
    },
    pp_getHierarchyBreadth() {
      return ObjectUtils.getHierarchyBreadth(this);
    },
    pp_getHierarchyDepth() {
      return ObjectUtils.getHierarchyDepth(this);
    },
    pp_getDescendants() {
      return ObjectUtils.getDescendants(this);
    },
    pp_getDescendantsBreadth() {
      return ObjectUtils.getDescendantsBreadth(this);
    },
    pp_getDescendantsDepth() {
      return ObjectUtils.getDescendantsDepth(this);
    },
    pp_getChildren() {
      return ObjectUtils.getChildren(this);
    },
    pp_getSelf() {
      return ObjectUtils.getSelf(this);
    },
    pp_addChild() {
      return ObjectUtils.addChild(this);
    },
    pp_getName() {
      return ObjectUtils.getName(this);
    },
    pp_setName(name) {
      return ObjectUtils.setName(this, name);
    },
    pp_getEngine() {
      return ObjectUtils.getEngine(this);
    },
    pp_getID() {
      return ObjectUtils.getID(this);
    },
    pp_markDirty() {
      return ObjectUtils.markDirty(this);
    },
    pp_isTransformChanged() {
      return ObjectUtils.isTransformChanged(this);
    },
    pp_destroy() {
      return ObjectUtils.destroy(this);
    },
    pp_reserveObjects(count) {
      return ObjectUtils.reserveObjects(this, count);
    },
    pp_reserveObjectsSelf(count) {
      return ObjectUtils.reserveObjectsSelf(this, count);
    },
    pp_reserveObjectsHierarchy(count) {
      return ObjectUtils.reserveObjectsHierarchy(this, count);
    },
    pp_reserveObjectsDescendants(count) {
      return ObjectUtils.reserveObjectsDescendants(this, count);
    },
    pp_reserveObjectsChildren(count) {
      return ObjectUtils.reserveObjectsChildren(this, count);
    },
    pp_getComponentsAmountMap(outComponentsAmountMap) {
      return ObjectUtils.getComponentsAmountMap(this, outComponentsAmountMap);
    },
    pp_getComponentsAmountMapSelf(outComponentsAmountMap) {
      return ObjectUtils.getComponentsAmountMapSelf(this, outComponentsAmountMap);
    },
    pp_getComponentsAmountMapHierarchy(outComponentsAmountMap) {
      return ObjectUtils.getComponentsAmountMapHierarchy(this, outComponentsAmountMap);
    },
    pp_getComponentsAmountMapDescendants(outComponentsAmountMap) {
      return ObjectUtils.getComponentsAmountMapDescendants(this, outComponentsAmountMap);
    },
    pp_getComponentsAmountMapChildren(outComponentsAmountMap) {
      return ObjectUtils.getComponentsAmountMapChildren(this, outComponentsAmountMap);
    }
  };
  PluginUtils.injectOwnProperties(objectExtension, Object3D2.prototype, false, true, true);
}

// dist/pp/plugin/wl/extensions/init_wl_extentions.js
function initWLExtensions() {
  initObjectExtension();
  initNumberArrayExtension();
}

// dist/pp/plugin/wl/mods/components/cauldron_mods.js
import { Emitter as Emitter7 } from "@wonderlandengine/api";
function initCauldronMods() {
  _initEmitterModPrototype();
}
function _initEmitterModPrototype() {
  const emitterMod = {
    add(listener, opts = {}) {
      const { once = false, id = void 0 } = opts;
      const data = { id, once, callback: listener };
      const _notifying = this._notifying;
      if (_notifying) {
        const _transactions = this._transactions;
        _transactions.push({ type: 1, data });
      } else {
        this._listeners.pp_removeAll((listener2) => {
          return data.id !== void 0 && listener2.id === data.id || data.id === void 0 && listener2.id === void 0 && listener2.callback === data.callback;
        });
        this._listeners.push(data);
      }
      return this;
    },
    _flushTransactions() {
      const listeners = this._listeners;
      const _transactions = this._transactions;
      for (let i = 0; i < _transactions.length; i++) {
        const transaction = _transactions[i];
        if (transaction.type == 1) {
          this._listeners.pp_removeAll((listener) => {
            return transaction.data.id !== void 0 && listener.id === transaction.data.id || transaction.data.id === void 0 && listener.id === void 0 && listener.callback === transaction.data.callback;
          });
          listeners.push(transaction.data);
        } else {
          this.remove(transaction.data);
        }
      }
      _transactions.length = 0;
    }
  };
  PluginUtils.injectOwnProperties(emitterMod, Emitter7.prototype, false, true, true);
}

// dist/pp/plugin/wl/mods/components/cursor_component_mod.js
import { InputComponent as InputComponent2, ViewComponent as ViewComponent3 } from "@wonderlandengine/api";
import { Cursor as Cursor3, CursorTarget as CursorTarget3, HitTestLocation as HitTestLocation3 } from "@wonderlandengine/components";
function initCursorComponentMod() {
  _initCursorComponentModPrototype();
}
function _initCursorComponentModPrototype() {
  let cursorComponentMod = {};
  cursorComponentMod.init = function init() {
    this.visible = false;
    this.globalTarget = this.object.pp_addComponent(CursorTarget3);
    this.hitTestTarget = this.object.pp_addComponent(CursorTarget3);
    this.hoveringObject = null;
    this.hoveringObjectTarget = null;
    this.handednessTyped = null;
    this.cursorPos = vec3_create();
    this._collisionMask = 1 << this.collisionGroup;
    this._doubleClickTimer = 0;
    this._tripleClickTimer = 0;
    this._multipleClickObject = null;
    this._multipleClickDelay = 0.3;
    this._onDeactivateCallbacks = [];
    this._prevHitLocationLocalToTarget = vec3_create();
    this._pointerID = null;
    this._updatePointerStyle = false;
    this._lastClientX = null;
    this._lastClientY = null;
    this._lastWidth = null;
    this._lastHeight = null;
    this._lastPointerID = null;
    this._lastOriginalMouseEvent = null;
    this._lastOriginalGamepadEvent = null;
    this._pointerLeaveToProcess = false;
    this._pointerLeaveMouseEvent = null;
    this._transformQuat = quat2_create();
    this._origin = vec3_create();
    this._direction = vec3_create();
    this._isHovering = false;
    this._isDown = false;
    this._lastIsDown = false;
    this._isRealDown = false;
    this._isDownForUpWithDown = false;
    this._isUpWithNoDown = false;
    this._tempVec = vec3_create();
    this._viewComponent = null;
    this._viewComponentBackup = null;
    this._cursorRayOrigin = vec3_create();
    this._cursorRayScale = vec3_create();
    this._projectionMatrix = mat4_create();
    this._hitTestLocation = null;
    this._hitTestObject = null;
    this._rayHitLocation = vec3_create();
    this._hitObjectData = [null, null, null];
    this._myViewEventListenersRegistered = false;
  };
  cursorComponentMod.start = function start() {
    this._screenSize = [0, 0];
    if (this.handedness == 0) {
      let inputComp = this.object.pp_getComponent(InputComponent2);
      if (!inputComp) {
        console.warn("cursor component on object " + this.object.pp_getName() + ' was configured with handedness "input component", but object has no input component.');
        this.handedness = null;
      } else {
        this.handedness = inputComp.handedness;
        this.input = inputComp;
      }
    } else {
      this.handedness = InputUtils.getHandednessByIndex(this.handedness - 1);
    }
    this.handednessTyped = this.handedness;
    this.pp_setViewComponent(this.object.pp_getComponent(ViewComponent3));
    this._viewComponentBackup = null;
    if (this.cursorRayObject) {
      this.cursorRayObject.pp_setActive(false);
      this._cursorRayScale.set(this.cursorRayObject.pp_getScaleLocal());
      this._setCursorRayTransform(null);
    }
    this._setCursorVisibility(false);
    if (this.useWebXRHitTest) {
      this._hitTestObject = this.object.pp_addChild();
      this._hitTestLocation = this.hitTestObject.pp_addComponent(HitTestLocation3, { scaleObject: false });
    }
    this.isHeadset = BrowserUtils.isDesktop() && XRUtils.isVRSupported(this.engine);
  };
  cursorComponentMod.update = function update(dt) {
    if (this._doubleClickTimer > 0) {
      this._doubleClickTimer -= dt;
    }
    if (this._tripleClickTimer > 0) {
      this._tripleClickTimer -= dt;
    }
    if (XRUtils.isSessionActive(this.engine) && this._viewComponent == null) {
      if (this.handedness == null || Globals.getHandPose(this.handedness, this.engine).getInputSourceType() != null) {
        if (this.arTouchDown && this._pp_isAR()) {
          let axes = XRUtils.getSession(this.engine).inputSources[0].gamepad.axes;
          this._direction.vec3_set(axes[0], -axes[1], -1);
          this.updateDirection();
        } else {
          this.object.pp_getPosition(this._origin);
          this.object.pp_getForward(this._direction);
        }
        let hitObjectData = this._pp_rayCast();
        this._pp_hoverBehaviour(hitObjectData[0], hitObjectData[1], hitObjectData[2], this._lastOriginalGamepadEvent);
      } else if (this.hoveringObject != null) {
        this._pp_hoverBehaviour(null, null, null, this._lastOriginalGamepadEvent, true);
      }
    } else if (!XRUtils.isSessionActive(this.engine) && this._viewComponent != null) {
      if (this._lastPointerID != null) {
        this._pp_updateMousePos(this._lastClientX, this._lastClientY, this._lastWidth, this._lastHeight);
        let hitObjectData = this._pp_rayCast();
        this._pp_hoverBehaviour(hitObjectData[0], hitObjectData[1], hitObjectData[2], this._lastOriginalMouseEvent);
        if (this.hoveringObject != null) {
          this._pointerID = this._lastPointerID;
        } else {
          this._pointerID = null;
        }
      } else if (this.hoveringObject != null) {
        this._pp_hoverBehaviour(null, null, null, this._lastOriginalMouseEvent, true);
      }
    } else if (this.hoveringObject != null) {
      this._pp_hoverBehaviour(null, null, null, null, true);
    }
    this._pp_processPointerLeave();
    if (this.hoveringObject != null && (this.cursorPos[0] != 0 || this.cursorPos[1] != 0 || this.cursorPos[2] != 0)) {
      if (this.cursorObject) {
        this._setCursorVisibility(true);
        this.cursorObject.pp_setPosition(this.cursorPos);
        this.cursorObject.pp_setTransformLocalQuat(this.cursorObject.pp_getTransformLocalQuat(this._transformQuat).quat2_normalize(this._transformQuat));
      }
      if (this.cursorRayObject) {
        this._setCursorRayTransform(this.cursorPos);
      }
    } else {
      if (this.cursorObject) {
        this._setCursorVisibility(false);
      }
      if (this.cursorRayObject) {
        this._setCursorRayTransform(null);
      }
    }
    if (this.cursorRayObject) {
      if (XRUtils.isSessionActive(this.engine) && this._viewComponent == null || !XRUtils.isSessionActive(this.engine) && this._viewComponent != null && this.handedness == null) {
        this.cursorRayObject.pp_setActive(true);
      } else {
        this.cursorRayObject.pp_setActive(false);
      }
    }
    if (this.hoveringObject == null) {
      this._pointerID = null;
    }
    this._updatePointerStyle = false;
    this._lastOriginalMouseEvent = null;
    this._lastOriginalGamepadEvent = null;
  };
  cursorComponentMod.onActivate = function onActivate() {
    this._isDown = false;
    this._lastIsDown = false;
    this._isDownForUpWithDown = false;
    this._isUpWithNoDown = false;
    if (this._viewComponent == null) {
      if (this._viewComponentBackup != null) {
        this.pp_setViewComponent(this._viewComponentBackup);
      } else {
        this.pp_setViewComponent(this.object.pp_getComponent(ViewComponent3));
        this._viewComponentBackup = null;
      }
    }
    XRUtils.registerSessionStartEventListener(this, this.setupVREvents.bind(this), true, false, this.engine);
    this._onDeactivateCallbacks.push(() => {
      XRUtils.unregisterSessionStartEventListener(this, this.engine);
    });
  };
  cursorComponentMod.onDeactivate = function onDeactivate() {
    if (this.hoveringObject != null) {
      this._pp_hoverBehaviour(null, null, null, null, true);
    }
    this.hoveringObject = null;
    this.hoveringObjectTarget = null;
    this._pp_updateCursorStyle();
    this._setCursorVisibility(false);
    if (this.cursorRayObject) {
      this.cursorRayObject.pp_setActive(false);
    }
    this._isDown = false;
    this._lastIsDown = false;
    this._isRealDown = false;
    this._isDownForUpWithDown = false;
    this._isUpWithNoDown = false;
    this._pointerID = null;
    this._lastPointerID = null;
    this._lastClientX = null;
    this._lastClientY = null;
    this._lastWidth = null;
    this._lastHeight = null;
    this._lastOriginalMouseEvent = null;
    this._lastOriginalGamepadEvent = null;
    this._pointerLeaveToProcess = false;
    this._pointerLeaveMouseEvent = null;
    for (let callback of this._onDeactivateCallbacks) {
      callback();
    }
    this._onDeactivateCallbacks = [];
    this._viewComponent = null;
  };
  cursorComponentMod.onDestroy = function onDestroy() {
    if (this._hitTestObject != null) {
      this._hitTestObject.pp_destroy();
    }
  };
  cursorComponentMod.updateDirection = function() {
    let transformWorld = quat2_create();
    return function updateDirection() {
      this.object.pp_getPosition(this._origin);
      this._direction.vec3_transformMat4(this._projectionMatrix, this._direction);
      this._direction.vec3_normalize(this._direction);
      this._direction.vec3_transformQuat(this.object.pp_getTransformQuat(transformWorld), this._direction);
    };
  }();
  cursorComponentMod.setupVREvents = function setupVREvents(session) {
    let onSelect = this.onSelect.bind(this);
    session.addEventListener("select", onSelect);
    let onSelectStart = this.onSelectStart.bind(this);
    session.addEventListener("selectstart", onSelectStart);
    let onSelectEnd = this.onSelectEnd.bind(this);
    session.addEventListener("selectend", onSelectEnd);
    this._onDeactivateCallbacks.push(() => {
      if (!XRUtils.isSessionActive(this.engine))
        return;
      let session2 = XRUtils.getSession(this.engine);
      session2.removeEventListener("select", onSelect);
      session2.removeEventListener("selectstart", onSelectStart);
      session2.removeEventListener("selectend", onSelectEnd);
    });
    this._onViewportResize();
  };
  cursorComponentMod.onSelect = function onSelect(e) {
  };
  cursorComponentMod.onSelectStart = function onSelectStart(e) {
    if (this.active) {
      if (this._pp_isAR()) {
        this.arTouchDown = true;
        this._lastOriginalGamepadEvent = e;
      } else if (e.inputSource.handedness == this.handedness) {
        this._isDown = true;
        this._isRealDown = true;
        if (!this._lastIsDown) {
          this._isDownForUpWithDown = true;
        }
        this._lastOriginalGamepadEvent = e;
      }
    }
  };
  cursorComponentMod.onSelectEnd = function onSelectEnd(e) {
    if (this.active) {
      if (this._pp_isAR()) {
        this.arTouchDown = false;
        this._lastOriginalGamepadEvent = e;
      } else if (e.inputSource.handedness == this.handedness) {
        if (!this._isDownForUpWithDown) {
          this._isUpWithNoDown = true;
        }
        this._isDown = false;
        this._isRealDown = false;
        this._isDownForUpWithDown = false;
        this._lastOriginalGamepadEvent = e;
      }
    }
  };
  cursorComponentMod.onPointerMove = function onPointerMove(e) {
    if (this.active && !this._pointerLeaveToProcess) {
      if (this._pointerID != null && this._pointerID != e.pointerId && !this.isHeadset)
        return;
      this._pp_updateMouseData(e, e.clientX, e.clientY, this._screenSize[0], this._screenSize[1], e.pointerId);
    }
  };
  cursorComponentMod.onClick = function onClick(e) {
  };
  cursorComponentMod.onPointerDown = function onPointerDown(e) {
    if (this.active && !this._pointerLeaveToProcess) {
      if (this._pointerID != null && this._pointerID != e.pointerId && !this.isHeadset || e.button != 0)
        return;
      this._pp_updateMouseData(e, e.clientX, e.clientY, this._screenSize[0], this._screenSize[1], e.pointerId);
      this._isDown = true;
      this._isRealDown = true;
      if (!this._lastIsDown) {
        this._isDownForUpWithDown = true;
      }
    }
  };
  cursorComponentMod.onPointerUp = function onPointerUp(e) {
    if (this.active && !this._pointerLeaveToProcess) {
      if (this._pointerID != null && this._pointerID != e.pointerId && !this.isHeadset || e.button != 0)
        return;
      this._pp_updateMouseData(e, e.clientX, e.clientY, this._screenSize[0], this._screenSize[1], e.pointerId);
      if (!this._isDownForUpWithDown) {
        this._isUpWithNoDown = true;
      }
      this._isDown = false;
      this._isRealDown = false;
      this._isDownForUpWithDown = false;
      this._updatePointerStyle = true;
    }
  };
  cursorComponentMod._onViewportResize = function _onViewportResize() {
    if (!this._viewComponent)
      return;
    this._viewComponent.projectionMatrix.mat4_invert(this._projectionMatrix);
  };
  cursorComponentMod._setCursorRayTransform = function _setCursorRayTransform(hitPosition) {
    if (!this.cursorRayObject)
      return;
    if (this.cursorRayScalingAxis != 4) {
      this.cursorRayObject.pp_resetScaleLocal();
      if (hitPosition != null) {
        this.cursorRayObject.pp_getPosition(this._cursorRayOrigin);
        let dist = this._cursorRayOrigin.vec3_distance(hitPosition);
        this._cursorRayScale[this.cursorRayScalingAxis] = dist;
        this.cursorRayObject.pp_scaleObject(this._cursorRayScale);
      }
    }
  };
  cursorComponentMod._setCursorVisibility = function _setCursorVisibility(visible) {
    this.visible = visible;
    if (!this.cursorObject)
      return;
    this.cursorObject.pp_setActive(visible);
  };
  cursorComponentMod._pp_hoverBehaviour = function _pp_hoverBehaviour(hitObject, hitLocation, hitTestResults, originalEvent = null, forceUnhover = false) {
    if (!forceUnhover && hitObject != null) {
      let hoveringObjectChanged = false;
      if (this.hoveringObject == null || this.hoveringObject != hitObject) {
        if (this.hoveringObject != null) {
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget && !this.hoveringObjectTarget.isDestroyed && this.hoveringObjectTarget.active)
              this.hoveringObjectTarget.onUnhover.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onUnhover.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onUnhover.notify(null, this, originalEvent);
          }
        }
        hoveringObjectChanged = true;
        this.hoveringObject = hitObject;
        this.hoveringObjectTarget = this.hoveringObject.pp_getComponentSelf(CursorTarget3);
        if (this.hoveringObjectTarget != null && !this.hoveringObjectTarget.active) {
          this.hoveringObjectTarget = null;
        }
        if (!this.hoveringReality) {
          if (this.hoveringObjectTarget)
            this.hoveringObjectTarget.onHover.notify(this.hoveringObject, this, originalEvent);
          this.globalTarget.onHover.notify(this.hoveringObject, this, originalEvent);
        } else {
          this.hitTestTarget.onHover.notify(hitTestResults, this, originalEvent);
        }
        this._pp_updateCursorStyle();
        if (!this._pp_isDownToProcess() && this._isRealDown) {
          this._isDown = true;
          this._lastIsDown = true;
          this._isDownForUpWithDown = false;
          this._isUpWithNoDown = false;
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onDownOnHover.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onDownOnHover.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onDownOnHover.notify(hitTestResults, this, originalEvent);
          }
        }
      }
      if (this._updatePointerStyle) {
        this._pp_updateCursorStyle();
      }
      if (!hoveringObjectChanged && this._pp_isMoving(hitLocation)) {
        if (!this.hoveringReality) {
          if (this.hoveringObjectTarget)
            this.hoveringObjectTarget.onMove.notify(this.hoveringObject, this, originalEvent);
          this.globalTarget.onMove.notify(this.hoveringObject, this, originalEvent);
        } else {
          this.hitTestTarget.onMove.notify(hitTestResults, this, originalEvent);
        }
      }
      if (this._pp_isDownToProcess()) {
        if (!this.hoveringReality) {
          if (this.hoveringObjectTarget)
            this.hoveringObjectTarget.onDown.notify(this.hoveringObject, this, originalEvent);
          this.globalTarget.onDown.notify(this.hoveringObject, this, originalEvent);
        } else {
          this.hitTestTarget.onDown.notify(hitTestResults, this, originalEvent);
        }
        if (!this.hoveringReality) {
          if (this.hoveringObjectTarget)
            this.hoveringObjectTarget.onClick.notify(this.hoveringObject, this, originalEvent);
          this.globalTarget.onClick.notify(this.hoveringObject, this, originalEvent);
        } else {
          this.hitTestTarget.onClick.notify(hitTestResults, this, originalEvent);
        }
        if (this._tripleClickTimer > 0 && this._multipleClickObject && this._multipleClickObject == this.hoveringObject) {
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onTripleClick.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onTripleClick.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onTripleClick.notify(hitTestResults, this, originalEvent);
          }
          this._tripleClickTimer = 0;
        } else if (this._doubleClickTimer > 0 && this._multipleClickObject && this._multipleClickObject == this.hoveringObject) {
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onDoubleClick.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onDoubleClick.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onDoubleClick.notify(hitTestResults, this, originalEvent);
          }
          this._tripleClickTimer = this._multipleClickDelay;
          this._doubleClickTimer = 0;
        } else {
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onSingleClick.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onSingleClick.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onSingleClick.notify(hitTestResults, this, originalEvent);
          }
          this._tripleClickTimer = 0;
          this._doubleClickTimer = this._multipleClickDelay;
          this._multipleClickObject = this.hoveringObject;
        }
      } else {
        if (!this._isUpWithNoDown && !hoveringObjectChanged && this._pp_isUpToProcess()) {
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onUp.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onUp.notify(this.hoveringObject, this, originalEvent);
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onUpWithDown.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onUpWithDown.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onUp.notify(hitTestResults, this, originalEvent);
            this.hitTestTarget.onUpWithDown.notify(hitTestResults, this, originalEvent);
          }
        } else if (this._isUpWithNoDown || hoveringObjectChanged && this._pp_isUpToProcess()) {
          if (!this.hoveringReality) {
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onUp.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onUp.notify(this.hoveringObject, this, originalEvent);
            if (this.hoveringObjectTarget)
              this.hoveringObjectTarget.onUpWithNoDown.notify(this.hoveringObject, this, originalEvent);
            this.globalTarget.onUpWithNoDown.notify(this.hoveringObject, this, originalEvent);
          } else {
            this.hitTestTarget.onUp.notify(hitTestResults, this, originalEvent);
            this.hitTestTarget.onUpWithNoDown.notify(hitTestResults, this, originalEvent);
          }
        }
      }
      this._prevHitLocationLocalToTarget = this.hoveringObject.pp_convertPositionWorldToLocal(hitLocation, this._prevHitLocationLocalToTarget);
    } else if (this.hoveringObject != null && (forceUnhover || hitObject == null)) {
      if (!this.hoveringReality) {
        if (this.hoveringObjectTarget && !this.hoveringObjectTarget.isDestroyed && this.hoveringObjectTarget.active)
          this.hoveringObjectTarget.onUnhover.notify(this.hoveringObject, this, originalEvent);
        this.globalTarget.onUnhover.notify(this.hoveringObject, this, originalEvent);
      } else {
        this.hitTestTarget.onUnhover.notify(null, this, originalEvent);
      }
      this.hoveringObject = null;
      this.hoveringObjectTarget = null;
      this._pp_updateCursorStyle();
    }
    if (this.hoveringObject != null) {
      this._lastIsDown = this._isDown;
    } else {
      this._isDown = false;
      this._lastIsDown = false;
      this._isDownForUpWithDown = false;
    }
    this._isUpWithNoDown = false;
  };
  cursorComponentMod._pp_rayCast = function _pp_rayCast() {
    let rayHit = this.rayCastMode == 0 ? Globals.getScene(this.engine).rayCast(this._origin, this._direction, this._collisionMask) : Globals.getPhysics(this.engine).rayCast(this._origin, this._direction, this._collisionMask, this.maxDistance);
    let rayHitCollisionDistanceValid = true;
    if (this.rayCastMode == 0 && rayHit.hitCount > 0 && rayHit.distances[0] > this.maxDistance) {
      rayHitCollisionDistanceValid = false;
    }
    this._hitObjectData[0] = null;
    this._hitObjectData[1] = null;
    this._hitObjectData[2] = null;
    let hitTestResultDistance = Infinity;
    if (this._hitTestLocation != null && this._hitTestLocation.visible) {
      this._hitTestObject.pp_getPositionWorld(this.cursorPos);
      this._rayHitLocation.vec3_copy(this.cursorPos);
      hitTestResultDistance = this.cursorPos.vec3_distance(this.object.pp_getPositionWorld(this._tempVec));
      this._hitObjectData[0] = this._hitTestObject;
      this._hitObjectData[1] = this._rayHitLocation;
    }
    this.hoveringReality = false;
    if (rayHit.hitCount > 0 && rayHitCollisionDistanceValid) {
      let rayHitDistance = rayHit.distances[0];
      if (rayHitDistance <= hitTestResultDistance) {
        this.cursorPos.vec3_copy(rayHit.locations[0]);
        this._rayHitLocation.vec3_copy(this.cursorPos);
        this._hitObjectData[0] = rayHit.objects[0];
        this._hitObjectData[1] = this._rayHitLocation;
      } else {
        this.hoveringReality = true;
      }
    } else if (hitTestResultDistance == Infinity) {
      this.cursorPos.vec3_zero();
      this._hitObjectData[0] = null;
      this._hitObjectData[1] = null;
    }
    let xrFrame = XRUtils.getFrame(this.engine);
    if (this.hoveringReality && xrFrame != null) {
      this._hitObjectData[2] = this._hitTestLocation.getHitTestResults(xrFrame)[0];
    }
    if (this._hitObjectData[0] != null) {
      const cursorTarget = this._hitObjectData[0].pp_getComponentSelf(CursorTarget3);
      if (cursorTarget == null || !cursorTarget.active) {
        this._hitObjectData[0] = null;
        this._hitObjectData[1] = null;
        this._hitObjectData[2] = null;
      }
    }
    return this._hitObjectData;
  };
  cursorComponentMod._pp_updateMouseData = function _pp_updateMouseData(e, clientX, clientY, w, h, pointerID) {
    this._lastClientX = clientX;
    this._lastClientY = clientY;
    this._lastWidth = w;
    this._lastHeight = h;
    this._lastPointerID = pointerID;
    this._lastOriginalMouseEvent = e;
  };
  cursorComponentMod._pp_updateMousePos = function _pp_updateMousePos(clientX, clientY, w, h) {
    let left = clientX / w;
    let top = clientY / h;
    this._direction.vec3_set(left * 2 - 1, -top * 2 + 1, -1);
    this.updateDirection();
  };
  cursorComponentMod.pp_setViewComponent = function pp_setViewComponent(viewComponent) {
    this._viewComponent = viewComponent;
    if (this._viewComponent != null) {
      this._viewComponent.projectionMatrix.mat4_invert(this._projectionMatrix);
      if (!this._myViewEventListenersRegistered) {
        this._myViewEventListenersRegistered = true;
        this._myWindowResizeEventListener = () => {
          let bounds = document.body.getBoundingClientRect();
          this._screenSize[0] = bounds.width;
          this._screenSize[1] = bounds.height;
        };
        this._myWindowResizeEventListener();
        window.addEventListener("resize", this._myWindowResizeEventListener);
        let onClick = this.onClick.bind(this);
        Globals.getCanvas(this.engine).addEventListener("click", onClick);
        let onPointerDown = this.onPointerDown.bind(this);
        Globals.getCanvas(this.engine).addEventListener("pointerdown", onPointerDown);
        let onPointerMove = this.onPointerMove.bind(this);
        Globals.getCanvas(this.engine).addEventListener("pointermove", onPointerMove);
        let onPointerUp = this.onPointerUp.bind(this);
        Globals.getCanvas(this.engine).addEventListener("pointerup", onPointerUp);
        let onPointerLeave = this._pp_onPointerLeave.bind(this);
        Globals.getCanvas(this.engine).addEventListener("pointerleave", onPointerLeave);
        let onViewportResize = this._onViewportResize.bind(this);
        this.engine.onResize.add(onViewportResize);
        this._onDeactivateCallbacks.push(() => {
          Globals.getCanvas(this.engine).removeEventListener("click", onClick);
          Globals.getCanvas(this.engine).removeEventListener("pointerdown", onPointerDown);
          Globals.getCanvas(this.engine).removeEventListener("pointermove", onPointerMove);
          Globals.getCanvas(this.engine).removeEventListener("pointerup", onPointerUp);
          Globals.getCanvas(this.engine).removeEventListener("pointerleave", onPointerLeave);
          this.engine.onResize.remove(onViewportResize);
          window.removeEventListener("resize", this._myWindowResizeEventListener);
          this._myViewEventListenersRegistered = false;
        });
      }
    }
    this._viewComponentBackup = this._viewComponent;
  };
  cursorComponentMod._pp_onPointerLeave = function _pp_onPointerLeave(e) {
    if (this._pointerID == null || this._pointerID == e.pointerId || this.isHeadset) {
      this._pointerLeaveToProcess = true;
      this._pointerLeaveMouseEvent = e;
    }
  };
  cursorComponentMod._pp_processPointerLeave = function _pp_processPointerLeave() {
    if (this._pointerLeaveToProcess) {
      this._pointerID = null;
      this._lastPointerID = null;
      this._lastClientX = null;
      this._lastClientY = null;
      this._lastWidth = null;
      this._lastHeight = null;
      this._lastOriginalMouseEvent = this._pointerLeaveMouseEvent;
      this._pointerLeaveToProcess = false;
      this._pointerLeaveMouseEvent = null;
      if (this.hoveringObject != null) {
        this._pp_hoverBehaviour(null, null, null, this._lastOriginalMouseEvent, true);
      }
      this._isDown = false;
      this._lastIsDown = false;
      this._isRealDown = false;
      this._isDownForUpWithDown = false;
      this._isUpWithNoDown = false;
    }
  };
  cursorComponentMod._pp_isDownToProcess = function _pp_isDownToProcess() {
    return this._isDown != this._lastIsDown && this._isDown;
  };
  cursorComponentMod._pp_isUpToProcess = function _pp_isUpToProcess() {
    return this._isDown != this._lastIsDown && !this._isDown;
  };
  cursorComponentMod._pp_isMoving = function() {
    let hitLocationLocalToTarget = vec3_create();
    return function _pp_isMoving(hitLocation) {
      let moving = false;
      hitLocationLocalToTarget = this.hoveringObject.pp_convertPositionWorldToLocal(hitLocation, hitLocationLocalToTarget);
      if (!hitLocationLocalToTarget.vec_equals(this._prevHitLocationLocalToTarget, 1e-4)) {
        moving = true;
      }
      return moving;
    };
  }();
  cursorComponentMod._pp_isAR = function _pp_isAR() {
    let firstInputSource = XRUtils.getSession(this.engine).inputSources[0];
    return this.input != null && firstInputSource.handedness == "none" && firstInputSource.gamepad != null;
  };
  cursorComponentMod._pp_updateCursorStyle = function _pp_updateCursorStyle() {
    if (this.styleCursor) {
      if (this.hoveringObjectTarget != null && !this.hoveringObjectTarget.isSurface) {
        document.body.style.cursor = "pointer";
      } else if (document.body.style.cursor == "pointer") {
        document.body.style.cursor = "default";
      }
    }
  };
  PluginUtils.injectOwnProperties(cursorComponentMod, Cursor3.prototype, false, true, true);
}

// dist/pp/plugin/wl/mods/components/cursor_target_component_mod.js
import { Emitter as Emitter8 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget4 } from "@wonderlandengine/components";
function initCursorTargetComponentMod() {
  _initCursorTargetComponentModPrototype();
}
function _initCursorTargetComponentModPrototype() {
  const cursorTargetComponentMod = {
    // New Functions 
    init() {
      this.onSingleClick = new Emitter8();
      this.onDoubleClick = new Emitter8();
      this.onTripleClick = new Emitter8();
      this.onDownOnHover = new Emitter8();
      this.onUpWithDown = new Emitter8();
      this.onUpWithNoDown = new Emitter8();
      this.isSurface = false;
    },
    start() {
    },
    update(dt) {
    },
    onActivate() {
    },
    onDeactivate() {
    },
    onDestroy() {
    }
  };
  PluginUtils.injectOwnProperties(cursorTargetComponentMod, CursorTarget4.prototype, false, true, true);
}

// dist/pp/plugin/wl/mods/components/mouse_look_component_mod.js
import { MouseLookComponent as MouseLookComponent3 } from "@wonderlandengine/components";
function initMouseLookComponentMod() {
  _initMouseLookComponentModPrototype();
}
function _initMouseLookComponentModPrototype() {
  let mouseLookComponentMod = {};
  mouseLookComponentMod.init = function init() {
    this.pointerId = null;
    this.prevMoveEvent = null;
    this.resetMovingDelay = 0.15;
    this.resetMovingTimer = new Timer(this.resetMovingDelay, false);
    this.isMoving = false;
    this.mouseDown = false;
    this.pointerMoveListener = this._onMove.bind(this);
    this.contextMenuListener = function(event) {
      if (this.active) {
        event.preventDefault();
      }
    }.bind(this);
    this.pointerDown = function(event) {
      if (this.active) {
        if (this.pointerId != null)
          return;
        if (!this.mouseDown) {
          if (event.button == this.mouseButtonIndex) {
            this.pointerId = event.pointerId;
            this.mouseDown = true;
            if (event.button == 1) {
              event.preventDefault();
              return false;
            }
          }
        }
      }
    }.bind(this);
    this.pointerUp = function(event) {
      if (this.active) {
        if (event.pointerId != this.pointerId)
          return;
        if (this.mouseDown) {
          if (event.button == this.mouseButtonIndex) {
            this.mouseDown = false;
          }
        }
      }
    }.bind(this);
    this.pointerLeave = function(event) {
      if (this.active) {
        if (event.pointerId != this.pointerId)
          return;
        this.pointerId = null;
        this.prevMoveEvent = null;
        if (this.mouseDown) {
          this.mouseDown = false;
        }
      }
    }.bind(this);
  };
  mouseLookComponentMod.start = function start() {
  };
  mouseLookComponentMod.onActivate = function onActivate() {
    document.body.addEventListener("pointermove", this.pointerMoveListener);
    if (this.requireMouseDown) {
      if (this.mouseButtonIndex == 2) {
        Globals.getCanvas(this.engine).addEventListener("contextmenu", this.contextMenuListener, false);
      }
      Globals.getCanvas(this.engine).addEventListener("pointerdown", this.pointerDown);
      document.body.addEventListener("pointerup", this.pointerUp);
    }
    document.body.addEventListener("pointerleave", this.pointerLeave);
  };
  mouseLookComponentMod.onDeactivate = function onDeactivate() {
    if (this.mouseDown) {
    }
    this.isMoving = false;
    this.mouseDown = false;
    this.pointerId = null;
    this.prevMoveEvent = null;
    document.body.removeEventListener("pointermove", this.pointerMoveListener);
    Globals.getCanvas(this.engine).removeEventListener("contextmenu", this.contextMenuListener);
    Globals.getCanvas(this.engine).removeEventListener("pointerdown", this.pointerDown);
    document.body.removeEventListener("pointerup", this.pointerUp);
    document.body.removeEventListener("pointerleave", this.pointerLeave);
  };
  mouseLookComponentMod.update = function update(dt) {
    if (this.resetMovingTimer.isRunning()) {
      this.resetMovingTimer.update(dt);
      if (this.resetMovingTimer.isDone()) {
        this.resetMovingTimer.reset();
        this.isMoving = false;
      }
    }
    if (!this.isMoving) {
      if (!this.requireMouseDown || !this.mouseDown) {
        this.pointerId = null;
      }
      this.prevMoveEvent = null;
    }
  };
  mouseLookComponentMod._onMove = function() {
    let viewForward = vec3_create();
    let viewUp = vec3_create();
    let referenceUp = vec3_create();
    let referenceUpNegate = vec3_create();
    let referenceRight = vec3_create();
    let newUp = vec3_create();
    return function _onMove(event) {
      if (this.active) {
        if (this.pointerId != null && event.pointerId != this.pointerId)
          return;
        if (this.mouseDown || !this.requireMouseDown) {
          viewForward = this.object.pp_getBackward(viewForward);
          viewUp = this.object.pp_getUp(viewUp);
          referenceUp.vec3_set(0, 1, 0);
          if (this.object.pp_getParent() != null) {
            referenceUp = this.object.pp_getParent().pp_getUp(referenceUp);
          }
          referenceRight = viewForward.vec3_cross(referenceUp, referenceRight);
          let minAngle = 1;
          if (viewForward.vec3_angle(referenceUp) < minAngle) {
            referenceRight = viewUp.vec3_negate(referenceRight).vec3_cross(referenceUp, referenceRight);
          } else if (viewForward.vec3_angle(referenceUp.vec3_negate(referenceUpNegate)) < minAngle) {
            referenceRight = viewUp.vec3_cross(referenceUp, referenceRight);
          } else if (!viewUp.vec3_isConcordant(referenceUp)) {
            referenceRight.vec3_negate(referenceRight);
          }
          referenceRight.vec3_normalize(referenceRight);
          let movementX = event.movementX;
          let movementY = event.movementY;
          if (movementX == null || movementY == null) {
            if (this.prevMoveEvent != null) {
              movementX = event.pageX - this.prevMoveEvent.pageX;
              movementY = event.pageY - this.prevMoveEvent.pageY;
            } else {
              movementX = 0;
              movementY = 0;
            }
          }
          this.rotationX = -this.sensitity * movementX;
          this.rotationY = -this.sensitity * movementY;
          this.object.pp_rotateAxis(this.rotationY, referenceRight);
          let maxVerticalAngle = 89 - 1e-3;
          newUp = this.object.pp_getUp(newUp);
          let angleWithUp = Math.pp_angleClamp(newUp.vec3_angleSigned(referenceUp, referenceRight));
          if (Math.abs(angleWithUp) > maxVerticalAngle) {
            let fixAngle = (Math.abs(angleWithUp) - maxVerticalAngle) * Math.pp_sign(angleWithUp);
            this.object.pp_rotateAxis(fixAngle, referenceRight);
          }
          this.object.pp_rotateAxis(this.rotationX, referenceUp);
          this.prevMoveEvent = event;
          this.pointerId = event.pointerId;
          this.resetMovingTimer.start(this.resetMovingDelay);
          this.isMoving = true;
        }
      }
    };
  }();
  PluginUtils.injectOwnProperties(mouseLookComponentMod, MouseLookComponent3.prototype, false, true, true);
}

// dist/pp/plugin/wl/mods/components/init_component_mods.js
function initComponentMods() {
  initCursorComponentMod();
  initCursorTargetComponentMod();
  initMouseLookComponentMod();
  initCauldronMods();
}

// dist/pp/plugin/wl/mods/init_wl_mods.js
function initWLMods() {
  initComponentMods();
}

// dist/pp/plugin/wl/init_wl_plugins.js
function initWLPlugins() {
  initWLExtensions();
  initWLMods();
}

// dist/pp/plugin/init_plugins.js
function initPlugins() {
  initJSPlugins();
  initWLPlugins();
}

// dist/pp/pp/pp_version.js
var PP_VERSION = "0.8.2";

// dist/pp/pp/init_pp.js
function initPP(engine) {
  console.log("PP version: " + PP_VERSION);
  Globals.setMainEngine(engine);
  ComponentUtils.setWLComponentDefaultCloneCallbacks(engine);
  registerWLComponents(engine);
  registerPPComponents(engine);
  initPlugins();
}

// dist/pp/pp/components/add_pp_to_window_component.js
import { Component as Component18, Property as Property12 } from "@wonderlandengine/api";
var AddPPToWindowComponent = class extends Component18 {
  static TypeName = "pp-add-pp-to-window";
  static Properties = {
    _myAdd: Property12.bool(true)
  };
  start() {
    this._myPP = null;
    if (this._myAdd) {
      this._myPP = {};
      this._addProperties(index_exports);
      window.PP = this._myPP;
    }
  }
  _addProperties(object) {
    let propertyNames = Object.getOwnPropertyNames(object);
    for (let propertyName of propertyNames) {
      if (object[propertyName] != void 0) {
        this._myPP[propertyName] = object[propertyName];
      }
    }
  }
  onActivate() {
    if (this._myPP != null) {
      window.PP = this._myPP;
    }
  }
  onDeactivate() {
    if (this._myPP != null) {
      delete window.PP;
    }
  }
};

// dist/pp/pp/components/pp_gateway_component.js
var _myRegisteredEngines = /* @__PURE__ */ new WeakMap();
var PPGatewayComponent = class extends Component19 {
  static TypeName = "pp-gateway";
  static Properties = {
    _myEnableDebug: Property13.bool(true),
    _myEnableTool: Property13.bool(true),
    _myAddPPToWindow: Property13.bool(true),
    _myAddWLToWindow: Property13.bool(true),
    _myClearConsoleOnInit: Property13.bool(false),
    ...InputManagerComponent.Properties,
    ...AudioManagerComponent.Properties,
    ...VisualManagerComponent.Properties,
    ...CharacterCollisionSystemComponent.Properties,
    ...ObjectPoolManagerComponent.Properties,
    ...SaveManagerComponent.Properties,
    ...AnalyticsManagerComponent.Properties,
    ...DebugManagerComponent.Properties,
    ...GetSceneObjectsComponent.Properties,
    ...GetDefaultResourcesComponent.Properties
  };
  _myEnableDebug;
  _myEnableTool;
  _myAddPPToWindow;
  _myAddWLToWindow;
  _myClearConsoleOnInit;
  _myGetDefaultResourcesComponent;
  _myGetSceneObjectsComponent;
  _myEnableDebugComponent;
  _myEnableToolComponent;
  _myAddPPToWindowComponent;
  _myAddWLToWindowComponent;
  _myInitConsoleVRComponent;
  _myInitEasyTuneVariablesComponent;
  _myObjectPoolManagerComponent;
  _myInputManagerComponent;
  _myAudioManagerComponent;
  _myVisualManagerComponent;
  _myCharacterCollisionSystemComponent;
  _mySaveManagerComponent;
  _myAnalyticsManagerComponent;
  _myDebugManagerComponent;
  _myClearConsoleComponent = null;
  static onRegister(engine) {
    if (!_myRegisteredEngines.has(engine)) {
      _myRegisteredEngines.set(engine, null);
      initPP(engine);
    }
  }
  init() {
    if (!this.markedActive)
      return;
    if (this._myClearConsoleOnInit) {
      this._myClearConsoleComponent = this.object.pp_addComponent(ClearConsoleComponent, false);
    }
    this._myGetDefaultResourcesComponent = this.object.pp_addComponent(GetDefaultResourcesComponent, this._getProperties(GetDefaultResourcesComponent.Properties), false);
    this._myGetSceneObjectsComponent = this.object.pp_addComponent(GetSceneObjectsComponent, this._getProperties(GetSceneObjectsComponent.Properties), false);
    if (this._myEnableDebug) {
      this._myEnableDebugComponent = this.object.pp_addComponent(EnableDebugComponent, false);
    }
    if (this._myEnableTool) {
      this._myEnableToolComponent = this.object.pp_addComponent(EnableToolComponent, false);
    }
    if (this._myAddPPToWindow) {
      this._myAddPPToWindowComponent = this.object.pp_addComponent(AddPPToWindowComponent, false);
    }
    if (this._myAddWLToWindow) {
      this._myAddWLToWindowComponent = this.object.pp_addComponent(AddWLToWindowComponent, false);
    }
    this._myInitConsoleVRComponent = this.object.pp_addComponent(InitConsoleVRComponent, false);
    this._myInitEasyTuneVariablesComponent = this.object.pp_addComponent(InitEasyTuneVariablesComponent, false);
    this._myObjectPoolManagerComponent = this.object.pp_addComponent(ObjectPoolManagerComponent, this._getProperties(ObjectPoolManagerComponent.Properties), false);
    this._myInputManagerComponent = this.object.pp_addComponent(InputManagerComponent, this._getProperties(InputManagerComponent.Properties), false);
    this._myAudioManagerComponent = this.object.pp_addComponent(AudioManagerComponent, this._getProperties(AudioManagerComponent.Properties), false);
    this._myVisualManagerComponent = this.object.pp_addComponent(VisualManagerComponent, this._getProperties(VisualManagerComponent.Properties), false);
    this._myCharacterCollisionSystemComponent = this.object.pp_addComponent(CharacterCollisionSystemComponent, this._getProperties(CharacterCollisionSystemComponent.Properties), false);
    this._mySaveManagerComponent = this.object.pp_addComponent(SaveManagerComponent, this._getProperties(SaveManagerComponent.Properties), false);
    this._myAnalyticsManagerComponent = this.object.pp_addComponent(AnalyticsManagerComponent, this._getProperties(AnalyticsManagerComponent.Properties), false);
    this._myDebugManagerComponent = this.object.pp_addComponent(DebugManagerComponent, this._getProperties(DebugManagerComponent.Properties), false);
  }
  start() {
    if (this._myClearConsoleComponent != null) {
      this._myClearConsoleComponent.active = true;
    }
    this._myGetDefaultResourcesComponent.active = true;
    this._myGetSceneObjectsComponent.active = true;
    if (this._myEnableDebugComponent != null) {
      this._myEnableDebugComponent.active = true;
    }
    if (this._myEnableToolComponent != null) {
      this._myEnableToolComponent.active = true;
    }
    if (this._myAddPPToWindowComponent != null) {
      this._myAddPPToWindowComponent.active = true;
    }
    if (this._myAddWLToWindowComponent != null) {
      this._myAddWLToWindowComponent.active = true;
    }
    this._myInitConsoleVRComponent.active = true;
    this._myInitEasyTuneVariablesComponent.active = true;
    this._myObjectPoolManagerComponent.active = true;
    this._myInputManagerComponent.active = true;
    this._myAudioManagerComponent.active = true;
    this._myVisualManagerComponent.active = true;
    this._myCharacterCollisionSystemComponent.active = true;
    this._mySaveManagerComponent.active = true;
    this._myAnalyticsManagerComponent.active = true;
    this._myDebugManagerComponent.active = true;
  }
  _getProperties(propertiesToGet) {
    const properties = {};
    if (propertiesToGet != null) {
      const propertyNames = Object.getOwnPropertyNames(propertiesToGet);
      for (const propertyName of propertyNames) {
        const _this = this;
        if (_this[propertyName] != void 0) {
          properties[propertyName] = _this[propertyName];
        }
      }
    }
    return properties;
  }
};

// dist/pp/audio/audio_utils.js
import { Howler as Howler3 } from "howler";
function isPlaybackBlocked() {
  let blocked = false;
  if (Howler3 != null && Howler3.state != "running") {
    blocked = true;
  }
  return blocked;
}
var AudioUtils = {
  isPlaybackBlocked
};

// dist/pp/audio/howler/howler_audio_player.js
var HowlerAudioPlayer = class extends AudioPlayer {
  constructor(howl, audioSetup = null) {
    super(audioSetup, howl);
    if (audioSetup == null) {
      this._myAudioSetup.myAudioFilePath = this._myAudio._src;
      this._myAudioSetup.myLoop = this._myAudio._loop;
      this._myAudioSetup.myAutoPlay = this._myAudio._autoplay;
      this._myAudioSetup.myVolume = this._myAudio._volume;
      this._myAudioSetup.myRate = this._myAudio._rate;
      this._myAudioSetup.myPool = this._myAudio._pool;
      this._myAudioSetup.myPreload = this._myAudio._preload;
      this._myAudioSetup.myPosition = this._myAudio._pos != null ? this._myAudio._pos.vec3_clone() : null;
      this._myAudioSetup.mySpatial = this._myAudio._pos != null;
      this._myAudioSetup.myReferenceDistance = this._myAudio._pannerAttr.refDistance;
    } else {
      this._myAudioSetup.myAudioFilePath = this._myAudio._src;
      this._myAudio.loop(this._myAudioSetup.myLoop);
      this._myAudio._autoplay = this._myAudioSetup.myAutoPlay;
      this._myAudio.volume(this._myAudioSetup.myVolume);
      this._myAudio.rate(this._myAudioSetup.myRate);
      this._myAudio._pool = this._myAudioSetup.myPool;
      this._myAudio._preload = this._myAudioSetup.myPreload;
      this.updatePosition(this._myAudioSetup.myPosition);
      this._myAudio._pannerAttr.refDistance = this._myAudioSetup.myReferenceDistance;
      if (this._myAudioSetup.myAutoPlay) {
        this._myAudio.play();
      }
    }
    this._addListeners();
  }
};

// dist/pp/audio/components/mute_everything_component.js
import { Component as Component20 } from "@wonderlandengine/api";
import { Howler as Howler4 } from "howler";
var MuteEverythingComponent = class extends Component20 {
  static TypeName = "pp-mute-everything";
  start() {
    Howler4.mute(true);
  }
};

// dist/pp/audio/components/spatial_audio_listener_component.js
import { Component as Component21 } from "@wonderlandengine/api";
import { Howler as Howler5 } from "howler";
var SpatialAudioListenerComponent = class extends Component21 {
  static TypeName = "pp-spatial-audio-listener";
  init() {
    this._myOrigin = vec3_create();
    this._myForward = vec3_create();
    this._myUp = vec3_create();
  }
  start() {
    this._updateAudioListener();
  }
  update(dt) {
    this._updateAudioListener();
  }
  _updateAudioListener() {
    this.object.pp_getPosition(this._myOrigin);
    this.object.pp_getForward(this._myForward);
    this.object.pp_getUp(this._myUp);
    Howler5.pos(this._myOrigin[0], this._myOrigin[1], this._myOrigin[2]);
    Howler5.orientation(this._myForward[0], this._myForward[1], this._myForward[2], this._myUp[0], this._myUp[1], this._myUp[2]);
  }
};

// dist/pp/cauldron/benchmarks/benchmark_max_physx_component.js
import { Component as Component22, PhysXComponent as PhysXComponent4, Property as Property14, Shape } from "@wonderlandengine/api";

// dist/pp/cauldron/physics/physics_collision_collector.js
import { CollisionEventType, Emitter as Emitter9, PhysXComponent as PhysXComponent3 } from "@wonderlandengine/api";
var PhysicsCollisionCollector = class _PhysicsCollisionCollector {
  _myPhysXComponent;
  _myActive = false;
  _myCollisionCallbackID = null;
  _myCollisionEmitter = new Emitter9();
  _myCollisionStartEmitter = new Emitter9();
  _myCollisionEndEmitter = new Emitter9();
  _myCollisions = [];
  _myCollisionsStarted = [];
  _myCollisionsEnded = [];
  _myCollisionsStartedToProcess = [];
  _myCollisionsEndedToProcess = [];
  // This separation is needed so it's possible to return the physx component list without having to build it every time
  // Beside, this is only needed due to trigger not detecting a collision end if the physX component they are colliding with goes inactive or is destroyed
  _myCollisionObjects = [];
  _myCollisionObjectsStarted = [];
  _myCollisionObjectsEnded = [];
  _myCollisionObjectsStartedToProcess = [];
  _myCollisionObjectsEndedToProcess = [];
  _myUpdateActive = false;
  _myCollisionStartEndProcessingActive = true;
  _myTriggerDesyncFixDelay = new Timer(0.1);
  _myLogEnabled = false;
  _myDestroyed = false;
  constructor(physXComponent) {
    this._myPhysXComponent = physXComponent;
    this.setActive(true);
  }
  getPhysXComponent() {
    return this._myPhysXComponent;
  }
  getCollisions() {
    return this._myCollisions;
  }
  getCollisionsStarted() {
    return this._myCollisionsStarted;
  }
  getCollisionsEnded() {
    return this._myCollisionsEnded;
  }
  isActive() {
    return this._myActive;
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      this._myCollisions.pp_clear();
      this._myCollisionObjects.pp_clear();
      this._myCollisionsStarted.pp_clear();
      this._myCollisionObjectsStarted.pp_clear();
      this._myCollisionsEnded.pp_clear();
      this._myCollisionObjectsEnded.pp_clear();
      this._myCollisionsStartedToProcess.pp_clear();
      this._myCollisionObjectsStartedToProcess.pp_clear();
      this._myCollisionsEndedToProcess.pp_clear();
      this._myCollisionObjectsEndedToProcess.pp_clear();
      if (this._myActive) {
        this._myCollisionCallbackID = this._myPhysXComponent.onCollision(this._onCollision.bind(this));
      } else if (this._myCollisionCallbackID != null && !this._myPhysXComponent.isDestroyed) {
        this._myPhysXComponent.removeCollisionCallback(this._myCollisionCallbackID);
        this._myCollisionCallbackID = null;
      }
    }
  }
  /** `update` is not mandatory, use it only if u want to access collisions start and end or if the phsyX is a trigger */
  update(dt) {
    if (!this._myActive) {
      return;
    }
    this._myUpdateActive = true;
    if (this._myCollisionStartEndProcessingActive) {
      const prevCollisionsStartToProcess = this._myCollisionsStartedToProcess;
      this._myCollisionsStartedToProcess = this._myCollisionsStarted;
      this._myCollisionsStartedToProcess.pp_clear();
      this._myCollisionsStarted = prevCollisionsStartToProcess;
      const prevCollisionObjectsStartToProcess = this._myCollisionObjectsStartedToProcess;
      this._myCollisionObjectsStartedToProcess = this._myCollisionObjectsStarted;
      this._myCollisionObjectsStartedToProcess.pp_clear();
      this._myCollisionObjectsStarted = prevCollisionObjectsStartToProcess;
      const prevCollisionsEndToProcess = this._myCollisionsEndedToProcess;
      this._myCollisionsEndedToProcess = this._myCollisionsEnded;
      this._myCollisionsEndedToProcess.pp_clear();
      this._myCollisionsEnded = prevCollisionsEndToProcess;
      const prevCollisionObjectsEndToProcess = this._myCollisionObjectsEndedToProcess;
      this._myCollisionObjectsEndedToProcess = this._myCollisionObjectsEnded;
      this._myCollisionObjectsEndedToProcess.pp_clear();
      this._myCollisionObjectsEnded = prevCollisionObjectsEndToProcess;
    }
    if (this._myPhysXComponent.trigger) {
      this._triggerDesyncFix(dt);
    }
  }
  /** Set to `true` only if u are going to actually update this object and don't want to
      lose any collision start or end events prior to updating the first time after activation,
      since on update this flag is automatically set to `true` */
  setUpdateActive(active) {
    this._myUpdateActive = active;
  }
  /** If this is set to `false` you won't be able to get the collision that just started or ended, but just the current colliding ones
      Keep in mind that you also need to update the collector for this to work */
  setCollisionStartEndProcessingActive(active) {
    this._myCollisionStartEndProcessingActive = active;
  }
  isLogEnabled() {
    return this._myLogEnabled;
  }
  setLogEnabled(enabled) {
    this._myLogEnabled = enabled;
  }
  registerCollisionEventListener(id, listener) {
    this._myCollisionEmitter.add(listener, { id });
  }
  unregisterCollisionEventListener(id) {
    this._myCollisionEmitter.remove(id);
  }
  registerCollisionStartEventListener(id, listener) {
    this._myCollisionStartEmitter.add(listener, { id });
  }
  unregisterCollisionStartEventListener(id) {
    this._myCollisionStartEmitter.remove(id);
  }
  registerCollisionEndEventListener(id, listener) {
    this._myCollisionEndEmitter.add(listener, { id });
  }
  unregisterCollisionEndEventListener(id) {
    this._myCollisionEndEmitter.remove(id);
  }
  _onCollision(type, physXComponent) {
    let collisionValid = this._areLayerFlagsMatching(physXComponent);
    if (collisionValid) {
      if (type == CollisionEventType.Touch || type == CollisionEventType.TriggerTouch) {
        collisionValid = this._onCollisionStart(type, physXComponent);
      } else if (type == CollisionEventType.TouchLost || type == CollisionEventType.TriggerTouchLost) {
        collisionValid = this._onCollisionEnd(type, physXComponent, physXComponent.object);
      }
      if (collisionValid) {
        this._myCollisionEmitter.notify(this._myPhysXComponent, physXComponent, type);
      }
    }
  }
  _onCollisionStart(type, physXComponent) {
    let componentFound = false;
    for (const physXComponentToCheck of this._myCollisions) {
      if (physXComponentToCheck == physXComponent) {
        componentFound = true;
        break;
      }
    }
    if (this._myLogEnabled && componentFound) {
      console.error("Collision Start on PhysX component already collected");
    }
    if (!componentFound) {
      this._myCollisions.push(physXComponent);
      this._myCollisionObjects.push(physXComponent.object);
      if (this._myUpdateActive && this._myCollisionStartEndProcessingActive) {
        this._myCollisionsStartedToProcess.push(physXComponent);
        this._myCollisionObjectsStartedToProcess.push(physXComponent.object);
        const indexesToRemove = this._myCollisionsEndedToProcess.pp_findAllIndexes(function(physXComponentToCheck) {
          return physXComponentToCheck == physXComponent;
        });
        for (let i = indexesToRemove.length - 1; i >= 0; i--) {
          this._myCollisionsEndedToProcess.pp_removeIndex(indexesToRemove[i]);
          this._myCollisionObjectsEndedToProcess.pp_removeIndex(indexesToRemove[i]);
        }
      }
      if (this._myLogEnabled) {
        console.log("Collision Start - Object ID: " + physXComponent.object.pp_getID());
      }
      this._myCollisionStartEmitter.notify(this._myPhysXComponent, physXComponent, type);
      return true;
    } else {
      return false;
    }
  }
  _onCollisionEnd(type, physXComponent, physXObject) {
    let componentFound = false;
    for (const physXComponentToCheck of this._myCollisions) {
      if (physXComponentToCheck == physXComponent) {
        componentFound = true;
        break;
      }
    }
    if (this._myLogEnabled && !componentFound) {
      console.error("Collision End on physX component not collected - Object ID: " + physXObject.pp_getID());
    }
    if (componentFound) {
      const indexesToRemove = this._myCollisions.pp_findAllIndexes(function(physXComponentToCheck) {
        return physXComponentToCheck == physXComponent;
      });
      for (let i = indexesToRemove.length - 1; i >= 0; i--) {
        this._myCollisions.pp_removeIndex(indexesToRemove[i]);
        this._myCollisionObjects.pp_removeIndex(indexesToRemove[i]);
      }
      if (this._myUpdateActive && this._myCollisionStartEndProcessingActive) {
        this._myCollisionsEndedToProcess.push(physXComponent);
        this._myCollisionObjectsEndedToProcess.push(physXObject);
        const indexesToRemove2 = this._myCollisionsStartedToProcess.pp_findAllIndexes(function(physXComponentToCheck) {
          return physXComponentToCheck == physXComponent;
        });
        for (let i = indexesToRemove2.length - 1; i >= 0; i--) {
          this._myCollisionsStartedToProcess.pp_removeIndex(indexesToRemove2[i]);
          this._myCollisionObjectsStartedToProcess.pp_removeIndex(indexesToRemove2[i]);
        }
      }
      if (this._myLogEnabled) {
        console.log("Collision End - Object ID: " + physXObject.pp_getID());
      }
      this._myCollisionEndEmitter.notify(this._myPhysXComponent, physXComponent, type);
      return true;
    } else {
      return false;
    }
  }
  _areLayerFlagsMatching(physXComponent) {
    if (!this._myPhysXComponent.trigger) {
      return true;
    }
    return (this._myPhysXComponent.groupsMask & physXComponent.groupsMask) > 0;
  }
  static _triggerDesyncFixSV = {
    findAllCallback(object) {
      const physXComponent = object.pp_getComponentSelf(PhysXComponent3);
      return physXComponent == null || !physXComponent.active;
    }
  };
  _triggerDesyncFix(dt) {
    this._myTriggerDesyncFixDelay.update(dt);
    if (this._myTriggerDesyncFixDelay.isDone()) {
      this._myTriggerDesyncFixDelay.start();
      if (this._myCollisionObjects.length > 0) {
        const findAllCallback = _PhysicsCollisionCollector._triggerDesyncFixSV.findAllCallback;
        let collisionsToEndIndexes = null;
        if (!this._myPhysXComponent.active) {
          collisionsToEndIndexes = [];
          for (let i = 0; i < this._myCollisionObjects.length; i++) {
            collisionsToEndIndexes.push(i);
          }
        } else {
          collisionsToEndIndexes = this._myCollisionObjects.pp_findAllIndexes(findAllCallback);
        }
        if (collisionsToEndIndexes.length > 0) {
          const physXComponentsToEnd = [];
          for (let i = 0; i < collisionsToEndIndexes.length; i++) {
            physXComponentsToEnd.push([this._myCollisionObjects[collisionsToEndIndexes[i]], this._myCollisions[collisionsToEndIndexes[i]]]);
          }
          for (const physXComponentToEnd of physXComponentsToEnd) {
            if (this._myLogEnabled) {
              console.log("Trigger Desync Fix - Object ID: " + physXComponentToEnd[0].pp_getID());
            }
            if (this._onCollisionEnd(CollisionEventType.TriggerTouchLost, physXComponentToEnd[1], physXComponentToEnd[0])) {
              this._myCollisionEmitter.notify(this._myPhysXComponent, physXComponentToEnd[1], CollisionEventType.TriggerTouchLost);
            }
          }
        }
      }
    }
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/cauldron/benchmarks/benchmark_max_physx_component.js
var BenchmarkMaxPhysXComponent = class extends Component22 {
  static TypeName = "pp-benchmark-max-physx";
  static Properties = {
    _myStaticDomeSize: Property14.float(40),
    _myStaticPhysXCount: Property14.int(1e3),
    _myDynamicDomeSize: Property14.float(80),
    _myDynamicPhysXCount: Property14.int(250),
    _myKinematicDomeSize: Property14.float(120),
    _myKinematicPhysXCount: Property14.int(250),
    _myRaycastCount: Property14.int(100),
    _myVisualizeRaycast: Property14.bool(false),
    _myVisualizeRaycastDelay: Property14.float(0.5),
    // You can use this to test with convex mesh, 
    // but u first need to add a physx with a convex mesh to the scene and read the shapeData index on the component to set it as _myShapeIndex
    _myUseConvexMesh: Property14.bool(false),
    _myShapeIndex: Property14.int(0),
    _myShapeScaleMultiplier: Property14.float(1),
    // Used to adjust the scale of the convex mesh if too big or small based on how u imported it
    _myLogEnabled: Property14.bool(true),
    _myClearConsoleBeforeLog: Property14.bool(true)
  };
  start() {
    this._myActive = false;
    if (Globals.isDebugEnabled(this.engine)) {
      this._myActive = true;
    }
    this._myStarted = false;
    this._myPreStartTimer = new Timer(1);
  }
  _start() {
    this._myParentObject = this.object.pp_addChild();
    this._myRaycastParams = new RaycastParams(Globals.getPhysics(this.engine));
    this._myRaycastResults = new RaycastResults();
    this._myStaticPhysXObjects = [];
    this._myStaticPhysXComponents = [];
    this._myStaticPhysXCollectors = [];
    this._myDynamicPhysXObjects = [];
    this._myDynamicPhysXComponents = [];
    this._myDynamicPhysXCollectors = [];
    this._myKinematicPhysXObjects = [];
    this._myKinematicPhysXComponents = [];
    this._myKinematicPhysXCollectors = [];
    this._spawnDome(true, false);
    this._spawnDome(false, false);
    this._spawnDome(false, true);
    this._myStartTimer = new Timer(1);
    this._myTimer = new Timer(0);
    this._myDebugTimer = new Timer(this._myVisualizeRaycastDelay);
    this._myLogEnabledTimer = new Timer(1);
    this._myFPSHistory = [];
    for (let i = 0; i < 7; i++) {
      this._myFPSHistory.push(0);
    }
    this._myAddVelocityDelay = 10;
    this._myTranslateVec3 = vec3_create();
    this._myRotateVec3 = vec3_create();
    this._myStarted = true;
  }
  update(dt) {
    if (!this._myActive || !Globals.isDebugEnabled(this.engine))
      return;
    if (!this._myStarted) {
      this._myPreStartTimer.update(dt);
      if (this._myPreStartTimer.isDone()) {
        this._start();
      }
    } else {
      this._myStartTimer.update(dt);
      if (this._myStartTimer.isDone()) {
        this._myTimer.update(dt);
        this._myDebugTimer.update(dt);
        this._myLogEnabledTimer.update(dt);
        if (this._myTimer.isDone()) {
          this._myTimer.start();
          let debugEnabled = false;
          if (this._myDebugTimer.isDone()) {
            this._myDebugTimer.start();
            debugEnabled = true;
          }
          debugEnabled = debugEnabled && this._myVisualizeRaycast;
          this._raycastTest(debugEnabled);
        }
        this._myFPSHistory.pop();
        this._myFPSHistory.unshift(Math.round(1 / dt));
        if (this._myLogEnabled) {
          if (this._myLogEnabledTimer.isDone()) {
            this._myLogEnabledTimer.start();
            if (this._myClearConsoleBeforeLog) {
              console.clear();
            }
            console.log("Static PhysX Dome Size:", this._myStaticPhysXObjects.length);
            console.log("Dynamic PhysX Dome Size:", this._myDynamicPhysXObjects.length);
            console.log("Kinematic PhysX Dome Size:", this._myKinematicPhysXObjects.length);
            let staticCollisions = 0;
            for (let collector of this._myStaticPhysXCollectors) {
              staticCollisions += collector.getCollisions().length;
            }
            let dynamicCollisions = 0;
            for (let collector of this._myDynamicPhysXCollectors) {
              dynamicCollisions += collector.getCollisions().length;
            }
            let kinematicCollisions = 0;
            for (let collector of this._myKinematicPhysXCollectors) {
              kinematicCollisions += collector.getCollisions().length;
            }
            let totalCollisions = (staticCollisions + dynamicCollisions + kinematicCollisions) / 2;
            console.log("Current Collisions Count:", totalCollisions);
            console.log("Raycast Count:", this._myRaycastCount);
            console.log("FPS History:");
            let fpsString = "";
            for (let fps of this._myFPSHistory) {
              fpsString = fpsString.concat(fps, "\n");
            }
            console.log(fpsString);
          }
        }
      }
      if (this._myAddVelocityDelay > 0) {
        this._myAddVelocityDelay--;
        if (this._myAddVelocityDelay == 0) {
          for (let physX of this._myDynamicPhysXComponents) {
            physX.kinematic = false;
            let strength = 50;
            physX.linearVelocity = [Math.pp_random(-strength, strength), Math.pp_random(-strength, strength), Math.pp_random(-strength, strength)];
            physX.angularVelocity = [Math.pp_random(-strength, strength), Math.pp_random(-strength, strength), Math.pp_random(-strength, strength)];
          }
        }
      }
      for (let physX of this._myKinematicPhysXObjects) {
        let strength = 5 * dt;
        this._myTranslateVec3.vec3_set(Math.pp_random(-strength, strength), Math.pp_random(-strength, strength), Math.pp_random(-strength, strength));
        physX.pp_translate(this._myTranslateVec3);
        let rotateStrength = 50 * dt;
        this._myRotateVec3.vec3_set(Math.pp_random(-rotateStrength, rotateStrength), Math.pp_random(-rotateStrength, rotateStrength), Math.pp_random(-rotateStrength, rotateStrength));
        physX.pp_rotate(this._myRotateVec3);
      }
    }
  }
  _raycastTest(debugEnabled) {
    let raycastCount = this._myRaycastCount;
    let distance2 = 1e4;
    for (let i = 0; i < raycastCount; i++) {
      let origin = [Math.pp_random(1, 2) * Math.pp_randomSign(), Math.pp_random(1, 2) * Math.pp_randomSign(), Math.pp_random(1, 2) * Math.pp_randomSign()];
      let direction = [Math.pp_random(-1, 1), Math.pp_random(-1, 1), Math.pp_random(-1, 1)];
      direction.vec3_normalize(direction);
      this._myRaycastParams.myOrigin.vec3_copy(origin);
      this._myRaycastParams.myDirection.vec3_copy(direction);
      this._myRaycastParams.myDistance = distance2;
      this._myRaycastParams.myBlockLayerFlags.setAllFlagsActive();
      let raycastResults = PhysicsUtils.raycast(this._myRaycastParams, this._myRaycastResults);
      if (debugEnabled && Globals.isDebugEnabled(this.engine)) {
        Globals.getDebugVisualManager(this.engine).drawRaycast(this._myDebugTimer.getDuration(), raycastResults, true, 5, 0.015);
      }
    }
  }
  _spawnDome(staticDome, dynamicDome) {
    let maxCount = this._myStaticPhysXCount;
    let physXList = this._myStaticPhysXObjects;
    let cloves = Math.ceil(Math.sqrt(this._myStaticPhysXCount));
    if (!staticDome) {
      if (dynamicDome) {
        cloves = Math.ceil(Math.sqrt(this._myDynamicPhysXCount));
        maxCount = this._myDynamicPhysXCount;
        physXList = this._myDynamicPhysXObjects;
      } else {
        cloves = Math.ceil(Math.sqrt(this._myKinematicPhysXCount));
        maxCount = this._myKinematicPhysXCount;
        physXList = this._myKinematicPhysXObjects;
      }
    }
    let angleForClove = Math.PI * 2 / cloves;
    let minDistance = Math.max(0, this._myStaticDomeSize - 20);
    let maxDistance = this._myStaticDomeSize + 20;
    if (!staticDome) {
      if (dynamicDome) {
        minDistance = Math.max(0, this._myDynamicDomeSize - 20);
        maxDistance = this._myDynamicDomeSize + 20;
      } else {
        minDistance = Math.max(0, this._myKinematicDomeSize - 20);
        maxDistance = this._myKinematicDomeSize + 20;
      }
    }
    let minExtraRotation = 0;
    let maxExtraRotation = Math.pp_toRadians(10);
    let upDirection = vec3_create(0, 1, 0);
    let horizontalDirection = vec3_create(0, 0, -1);
    for (let i = 0; i < cloves / 2; i++) {
      let verticalDirection = vec3_create(0, 1, 0);
      let rotationAxis = vec3_create();
      horizontalDirection.vec3_cross(verticalDirection, rotationAxis);
      rotationAxis.vec3_normalize(rotationAxis);
      for (let j = 0; j < cloves; j++) {
        if (physXList.length < maxCount) {
          let distance2 = Math.random() * (maxDistance - minDistance) + minDistance;
          let extraAxisRotation = (Math.random() * 2 - 1) * (maxExtraRotation - minExtraRotation) + minExtraRotation;
          let extraUpRotation = (Math.random() * 2 - 1) * (maxExtraRotation - minExtraRotation) + minExtraRotation;
          let physXDirection = verticalDirection.pp_clone();
          physXDirection.vec3_rotateAxisRadians(extraAxisRotation, rotationAxis, physXDirection);
          physXDirection.vec3_rotateAxisRadians(extraUpRotation, upDirection, physXDirection);
          physXDirection.vec3_scale(distance2, physXDirection);
          this._addPhysX(physXDirection, staticDome, dynamicDome);
        }
        verticalDirection.vec3_rotateAxisRadians(angleForClove / 2, rotationAxis, verticalDirection);
        if (physXList.length < maxCount) {
          let distance2 = Math.random() * (maxDistance - minDistance) + minDistance;
          let extraAxisRotation = (Math.random() * 2 - 1) * (maxExtraRotation - minExtraRotation) + minExtraRotation;
          let extraUpRotation = (Math.random() * 2 - 1) * (maxExtraRotation - minExtraRotation) + minExtraRotation;
          let physXDirection = verticalDirection.pp_clone();
          physXDirection.vec3_rotateAxisRadians(extraAxisRotation, rotationAxis, physXDirection);
          physXDirection.vec3_rotateAxisRadians(extraUpRotation, upDirection, physXDirection);
          physXDirection.vec3_scale(distance2, physXDirection);
          this._addPhysX(physXDirection, staticDome, dynamicDome);
        }
        verticalDirection.vec3_rotateAxisRadians(angleForClove / 2, rotationAxis, verticalDirection);
      }
      horizontalDirection.vec3_rotateAxisRadians(angleForClove, upDirection, horizontalDirection);
    }
  }
  _addPhysX(physXDirection, staticDome, dynamicDome) {
    let position = physXDirection;
    let scale4 = Math.pp_random(1, 10);
    let shape = Math.pp_randomPick(Shape.Sphere, Shape.Box);
    if (this._myUseConvexMesh) {
      shape = Shape.ConvexMesh;
      scale4 *= this._myShapeScaleMultiplier;
    }
    let physX = this._myParentObject.pp_addChild();
    physX.pp_setPosition(position);
    let physXComponent = physX.pp_addComponent(PhysXComponent4, {
      "shape": shape,
      "shapeData": { index: this._myShapeIndex },
      "extents": vec3_create(scale4, scale4, scale4),
      "static": staticDome,
      "kinematic": !dynamicDome,
      "mass": 1
    });
    if (staticDome) {
      this._myStaticPhysXObjects.push(physX);
      this._myStaticPhysXComponents.push(physXComponent);
      this._myStaticPhysXCollectors.push(new PhysicsCollisionCollector(physXComponent));
    } else if (dynamicDome) {
      this._myDynamicPhysXObjects.push(physX);
      this._myDynamicPhysXComponents.push(physXComponent);
      this._myDynamicPhysXCollectors.push(new PhysicsCollisionCollector(physXComponent));
    } else {
      this._myKinematicPhysXObjects.push(physX);
      this._myKinematicPhysXComponents.push(physXComponent);
      this._myKinematicPhysXCollectors.push(new PhysicsCollisionCollector(physXComponent));
    }
  }
  onActivate() {
    if (this._myStaticPhysXCollectors != null) {
      for (let collector of this._myStaticPhysXCollectors) {
        collector.setActive(true);
      }
    }
    if (this._myDynamicPhysXCollectors != null) {
      for (let collector of this._myDynamicPhysXCollectors) {
        collector.setActive(true);
      }
    }
    if (this._myKinematicPhysXCollectors != null) {
      for (let collector of this._myKinematicPhysXCollectors) {
        collector.setActive(true);
      }
    }
  }
  onDeactivate() {
    if (this._myStaticPhysXCollectors != null) {
      for (let collector of this._myStaticPhysXCollectors) {
        collector.setActive(false);
      }
    }
    if (this._myDynamicPhysXCollectors != null) {
      for (let collector of this._myDynamicPhysXCollectors) {
        collector.setActive(false);
      }
    }
    if (this._myKinematicPhysXCollectors != null) {
      for (let collector of this._myKinematicPhysXCollectors) {
        collector.setActive(false);
      }
    }
  }
  onDestroy() {
    if (this._myStaticPhysXCollectors != null) {
      for (let collector of this._myStaticPhysXCollectors) {
        collector.destroy();
      }
    }
    if (this._myDynamicPhysXCollectors != null) {
      for (let collector of this._myDynamicPhysXCollectors) {
        collector.destroy();
      }
    }
    if (this._myKinematicPhysXCollectors != null) {
      for (let collector of this._myKinematicPhysXCollectors) {
        collector.destroy();
      }
    }
  }
};

// dist/pp/cauldron/benchmarks/benchmark_max_visible_triangles_component.js
import { Alignment as Alignment3, Component as Component23, MeshComponent as MeshComponent7, Property as Property15, TextComponent as TextComponent4, VerticalAlignment as VerticalAlignment3 } from "@wonderlandengine/api";
var BenchmarkMaxVisibleTrianglesComponent = class extends Component23 {
  static TypeName = "pp-benchmark-max-visible-triangles";
  static Properties = {
    _myTargetFrameRate: Property15.int(-1),
    // -1 means it will auto detect it at start
    _myTargetFrameRateThreshold: Property15.int(3),
    _myStartPlaneCount: Property15.int(1),
    _myPlaneTriangles: Property15.int(100),
    _mySecondsBeforeDoubling: Property15.float(0.5),
    // Higher gives a better frame rate evaluation
    _myDTHistoryToIgnorePercentage: Property15.float(0.25),
    _myCloneMaterial: Property15.bool(false),
    _myCloneMesh: Property15.bool(false),
    _myLogEnabled: Property15.bool(true),
    _myStartOnXRStart: Property15.bool(false),
    _myDisplayInFrontOfPlayer: Property15.bool(true),
    _myDisplayInFrontOfPlayerDistance: Property15.float(10),
    _myPlaneMaterial: Property15.material(),
    _myBackgroundMaterial: Property15.material(),
    _myTextMaterial: Property15.material(null)
  };
  _start() {
    if (this._myPlaneMaterial == null) {
      this._myPlaneMaterial = Globals.getDefaultMaterials(this.engine).myPhongOpaque.clone();
      this._myPlaneMaterial.diffuseColor = vec4_create(0.95, 0.95, 0.95, 1);
      this._myPlaneMaterial.ambientColor = vec4_create(0, 0, 0, 1);
      this._myPlaneMaterial.ambientFactor = 0.5;
    }
    if (this._myBackgroundMaterial == null) {
      this._myBackgroundMaterial = Globals.getDefaultMaterials(this.engine).myPhongOpaque.clone();
      this._myBackgroundMaterial.diffuseColor = vec4_create(0.25, 0.25, 0.25, 1);
      this._myBackgroundMaterial.ambientColor = vec4_create(0, 0, 0, 1);
      this._myBackgroundMaterial.ambientFactor = 0.5;
    }
    if (this._myTextMaterial == null) {
      this._myTextMaterial = Globals.getDefaultMaterials(this.engine).myText.clone();
    }
    this._myLagColor = vec4_create(0.6, 0, 0, 1);
    this._myNormalColor = vec4_create(0.25, 0.25, 0.25, 1);
    this._myRealTrianglesAmount = 0;
    let parent = this.object;
    if (this._myDisplayInFrontOfPlayer) {
      parent = Globals.getPlayerObjects(this.engine).myHead.pp_addChild();
      parent.pp_rotateAxis(180, vec3_create(0, 1, 0));
      parent.pp_translateLocal(vec3_create(0, 0, this._myDisplayInFrontOfPlayerDistance));
    }
    this._myTrianglesObject = parent.pp_addChild();
    this._myBackgroundObject = this._myTrianglesObject.pp_addChild();
    {
      let meshComponent = this._myBackgroundObject.pp_addComponent(MeshComponent7);
      meshComponent.mesh = MeshUtils.createPlane(this.engine);
      meshComponent.material = this._myBackgroundMaterial.clone();
    }
    this._myPlaneObject = this._myTrianglesObject.pp_addChild();
    {
      let meshComponent = this._myPlaneObject.pp_addComponent(MeshComponent7);
      meshComponent.mesh = this._createPlaneMesh(this._myPlaneTriangles);
      this._myRealTrianglesAmount = meshComponent.mesh.indexData.length / 3;
      meshComponent.material = this._myPlaneMaterial.clone();
    }
    let poolParams = new ObjectPoolParams();
    if (!this._myCloneMesh) {
      poolParams.myInitialPoolSize = 3e4;
    } else {
      if (this._myRealTrianglesAmount <= 4) {
        poolParams.myInitialPoolSize = 15e3;
      } else if (this._myRealTrianglesAmount <= 8) {
        poolParams.myInitialPoolSize = 1e4;
      } else if (this._myRealTrianglesAmount <= 64) {
        poolParams.myInitialPoolSize = 7500;
      } else {
        poolParams.myInitialPoolSize = 5e3;
      }
    }
    poolParams.myPercentageToAddWhenEmpty = 0;
    poolParams.myAmountToAddWhenEmpty = 1e4;
    poolParams.myCloneParams = new ObjectCloneParams();
    poolParams.myCloneParams.myComponentDeepCloneParams.setDeepCloneComponentVariable(MeshComponent7.TypeName, "material", this._myCloneMaterial);
    poolParams.myCloneParams.myComponentDeepCloneParams.setDeepCloneComponentVariable(MeshComponent7.TypeName, "mesh", this._myCloneMesh);
    this._myPoolID = this.type + "_" + Math.pp_randomUUID();
    Globals.getObjectPoolManager(this.engine).addPool(this._myPoolID, new ObjectPool(this._myPlaneObject, poolParams));
    this._myBackgroundObject.pp_setActive(false);
    this._myPlaneObject.pp_setActive(false);
    this._myTextsObject = this._myTrianglesObject.pp_addChild();
    this._myTriangleTextObject = this._myTextsObject.pp_addChild();
    this._myTriangleTextComponent = this._myTriangleTextObject.pp_addComponent(TextComponent4);
    this._myTriangleTextComponent.alignment = Alignment3.Left;
    this._myTriangleTextComponent.verticalAlignment = VerticalAlignment3.Line;
    this._myTriangleTextComponent.material = this._myTextMaterial.clone();
    this._myTriangleTextComponent.material.color = this._myNormalColor;
    this._myTriangleTextComponent.text = " ";
    this._myPlaneTextObject = this._myTextsObject.pp_addChild();
    this._myPlaneTextComponent = this._myPlaneTextObject.pp_addComponent(TextComponent4);
    this._myPlaneTextComponent.alignment = Alignment3.Left;
    this._myPlaneTextComponent.verticalAlignment = VerticalAlignment3.Line;
    this._myPlaneTextComponent.material = this._myTextMaterial.clone();
    this._myPlaneTextComponent.material.color = this._myNormalColor;
    this._myPlaneTextComponent.text = " ";
    this._myFPSTextObject = this._myTextsObject.pp_addChild();
    this._myFPSTextComponent = this._myFPSTextObject.pp_addComponent(TextComponent4);
    this._myFPSTextComponent.alignment = Alignment3.Left;
    this._myFPSTextComponent.verticalAlignment = VerticalAlignment3.Line;
    this._myFPSTextComponent.material = this._myTextMaterial.clone();
    this._myFPSTextComponent.material.color = this._myNormalColor;
    this._myFPSTextComponent.text = " ";
    this._myDoneTextObject = this._myTrianglesObject.pp_addChild();
    this._myDoneTextComponent = this._myDoneTextObject.pp_addComponent(TextComponent4);
    this._myDoneTextComponent.alignment = Alignment3.Center;
    this._myDoneTextComponent.verticalAlignment = VerticalAlignment3.Line;
    this._myDoneTextComponent.material = this._myTextMaterial.clone();
    this._myDoneTextComponent.material.color = this._myNormalColor;
    this._myDoneTextComponent.text = " ";
    this._myTextsObject.pp_setPositionLocal(vec3_create(0, 4.3, 0));
    this._myTextsObject.pp_setScale(2.75);
    this._myTriangleTextObject.pp_setPositionLocal(vec3_create(-1.4, 0, 0));
    this._myPlaneTextObject.pp_setPositionLocal(vec3_create(0.55, 0, 0));
    this._myFPSTextObject.pp_setPositionLocal(vec3_create(-0.315, 0, 0));
    this._myDoneTextObject.pp_setPositionLocal(vec3_create(0, -4.6, 0));
    this._myDoneTextObject.pp_setScale(4);
    this._myBackgroundSize = 4;
    this._myBackgroundObject.pp_setActive(true);
    this._myBackgroundObject.pp_setScale(this._myBackgroundSize + 0.1);
    this._myBackgroundObject.pp_translateLocal(vec3_create(0, 0, -1e-3));
    this._myDoubleTimer = new Timer(this._mySecondsBeforeDoubling);
    this._myDone = false;
    this._myCurrentPlanes = this._myStartPlaneCount;
    this._myDTHistory = [];
    this._myUpperLimit = -1;
    this._myLowerLimit = 0;
    this._myPlanes = [];
    this._mySkipNextFrames = 0;
    this._myMaxWaitFrames = 0;
    this._myMaxPlanesReached = false;
    this._myFirstTime = true;
  }
  _update(dt) {
    {
      if (dt < 1e-5) {
        return;
      }
      if (dt > 0.5 && this._myMaxWaitFrames > 0) {
        this._myMaxWaitFrames--;
        return;
      }
      this._myMaxWaitFrames = 10;
      if (this._mySkipNextFrames > 0) {
        this._mySkipNextFrames--;
        return;
      }
    }
    if (!this._myDone) {
      this._myDoubleTimer.update(dt);
      this._myDTHistory.push(dt);
      if (this._myDoubleTimer.isDone()) {
        this._myDoubleTimer.start();
        let frameRate = this._computeAverageFrameRate(false);
        if (this._myFirstTime) {
          this._myFirstTime = false;
        } else {
          let lagging = false;
          if (frameRate < this._myStableFrameRate - this._myTargetFrameRateThreshold) {
            this._myUpperLimit = this._myCurrentPlanes;
            lagging = true;
            if (this._myUpperLimit == 1) {
              this._myLowerLimit = 1;
            }
          } else {
            this._myLowerLimit = this._myCurrentPlanes;
            if (this._myUpperLimit > 0) {
              this._myUpperLimit = Math.max(this._myUpperLimit, this._myLowerLimit);
            }
          }
          this._myTriangleTextComponent.text = "Triangles: " + this._myCurrentPlanes * this._myRealTrianglesAmount;
          this._myPlaneTextComponent.text = "Planes: " + this._myCurrentPlanes;
          this._myFPSTextComponent.text = "FPS: " + frameRate + " / " + this._myStableFrameRate;
          if (lagging) {
            this._myTriangleTextComponent.material.color = this._myLagColor;
            this._myPlaneTextComponent.material.color = this._myLagColor;
            this._myFPSTextComponent.material.color = this._myLagColor;
          } else {
            this._myTriangleTextComponent.material.color = this._myNormalColor;
            this._myPlaneTextComponent.material.color = this._myNormalColor;
            this._myFPSTextComponent.material.color = this._myNormalColor;
          }
          let reset12 = false;
          if (this._myUpperLimit > 0 && (!lagging && this._myUpperLimit - this._myLowerLimit <= Math.max(2, 1e3 / this._myRealTrianglesAmount)) || lagging && this._myUpperLimit - this._myLowerLimit <= 1 || !lagging && this._myMaxPlanesReached) {
            if (frameRate < this._myStableFrameRate - this._myTargetFrameRateThreshold) {
              this._myLowerLimit = Math.max(1, Math.floor(this._myUpperLimit / 2.5));
              this._myUpperLimit = 0;
              reset12 = true;
              if (this._myLogEnabled) {
                console.log("Rst - Triangles:", this._myCurrentPlanes * this._myRealTrianglesAmount, "- Planes:", this._myCurrentPlanes, "- Frame Rate:", frameRate);
              }
            } else {
              if (this._myMaxPlanesReached) {
                if (this._myLogEnabled) {
                  console.log("Aborted - Max Planes Reached");
                  this._myDoneTextComponent.text = "Aborted - Max Planes Reached";
                }
              } else {
                this._displayPlanes(this._myLowerLimit);
                if (this._myLogEnabled) {
                  console.log("\nEnd - Triangles:", this._myLowerLimit * this._myRealTrianglesAmount, "- Planes:", this._myLowerLimit, "- Frame Rate:", frameRate);
                  console.log("Plane Triangles (Adjusted):", this._myRealTrianglesAmount);
                  console.log("Target Frame Rate:", this._myStableFrameRate, "- Threshold: ", this._myStableFrameRate - this._myTargetFrameRateThreshold);
                }
                this._myTriangleTextComponent.text = "Triangles: " + this._myLowerLimit * this._myRealTrianglesAmount;
                this._myPlaneTextComponent.text = "Planes: " + this._myLowerLimit;
                this._myFPSTextComponent.text = "FPS: " + frameRate + " / " + this._myStableFrameRate;
                this._myDoneTextComponent.text = "End";
              }
              this._myDone = true;
            }
          }
          if (lagging && !reset12) {
            if (this._myLogEnabled) {
              console.log("Lag - Triangles:", this._myCurrentPlanes * this._myRealTrianglesAmount, "- Planes:", this._myCurrentPlanes, "- Frame Rate:", frameRate);
            }
          }
          if (!this._myDone) {
            if (this._myUpperLimit > 0) {
              this._myCurrentPlanes = Math.floor((this._myUpperLimit + this._myLowerLimit) / 2);
              this._myCurrentPlanes = Math.max(this._myCurrentPlanes, 1);
            } else if (!reset12) {
              this._myCurrentPlanes = this._myLowerLimit * 2;
            } else {
              this._myCurrentPlanes = this._myLowerLimit;
            }
            if (this._myCurrentPlanes > 5e4) {
              this._myCurrentPlanes = 5e4;
              this._myMaxPlanesReached = true;
            } else {
              this._myMaxPlanesReached = false;
            }
          }
        }
        if (!this._myDone) {
          this._displayPlanes(this._myCurrentPlanes);
          this._myElapsedTime = 0;
          this._myFrameCount = 0;
          this._mySkipNextFrames = 30;
        }
      }
    }
  }
  _displayPlanes(count) {
    while (this._myPlanes.length > count) {
      let plane = this._myPlanes.pop();
      Globals.getObjectPoolManager(this.engine).release(this._myPoolID, plane);
    }
    while (this._myPlanes.length < count) {
      let plane = Globals.getObjectPoolManager(this.engine).get(this._myPoolID);
      this._myPlanes.push(plane);
    }
    let gridSize = 1;
    while (gridSize * gridSize < count) {
      gridSize++;
    }
    let spaceBetween = 0.01;
    let totalSpaceBetween = spaceBetween * (gridSize - 1);
    let planeSize = (this._myBackgroundSize * 2 - totalSpaceBetween) / (gridSize * 2);
    let currentCount = count;
    for (let i = 0; i < gridSize && currentCount > 0; i++) {
      for (let j = 0; j < gridSize && currentCount > 0; j++) {
        let plane = this._myPlanes[currentCount - 1];
        plane.pp_setScale(planeSize);
        let position = [-this._myBackgroundSize + planeSize + j * planeSize * 2 + j * spaceBetween, this._myBackgroundSize - planeSize - i * planeSize * 2 - i * spaceBetween, 0];
        plane.pp_setPositionLocal(position);
        plane.pp_setActive(true);
        currentCount--;
      }
    }
  }
  start() {
    this._myActive = false;
    if (Globals.isDebugEnabled(this.engine)) {
      this._myActive = true;
    }
    this._myStartTimer = new Timer(2);
    this._mySessionStarted = false;
    this._myDTHistory = [];
    this._myFramesToSkip = 10;
  }
  update(dt) {
    if (!this._myActive || !Globals.isDebugEnabled(this.engine))
      return;
    if (this._myFramesToSkip == 0) {
      if (this._mySessionStarted || !this._myStartOnXRStart) {
        if (this._myStartTimer.isRunning()) {
          this._myStartTimer.update(dt);
          this._myDTHistory.push(dt);
          if (this._myStartTimer.isDone()) {
            this._myStableFrameRate = this._computeAverageFrameRate(true);
            if (this._myTargetFrameRate > 0) {
              this._myStableFrameRate = this._myTargetFrameRate;
            }
            if (this._myLogEnabled) {
              console.log("\nPlane Triangles (Adjusted):", this._myRealTrianglesAmount);
              console.log("Target Frame Rate:", this._myStableFrameRate, "- Threshold: ", this._myStableFrameRate - this._myTargetFrameRateThreshold);
              console.log("");
            }
            this._start();
          }
        } else {
          this._update(dt);
        }
      } else {
        this._mySessionStarted = XRUtils.getSession(this.engine) != null;
      }
    } else {
      this._myFramesToSkip--;
    }
  }
  _computeAverageFrameRate(firstCompute) {
    let frameRate = 0;
    this._myDTHistory.sort((a, b) => a - b);
    let elementsToRemove = Math.floor(this._myDTHistory.length * Math.min(0.9, this._myDTHistoryToIgnorePercentage * (firstCompute ? 2 : 1)));
    for (let i = 0; i < elementsToRemove && this._myDTHistory.length > 1; i++) {
      this._myDTHistory.pop();
    }
    let averageDT = 0;
    for (let dt of this._myDTHistory) {
      averageDT += dt;
    }
    averageDT /= this._myDTHistory.length;
    frameRate = Math.round(1 / averageDT);
    this._myDTHistory = [];
    return frameRate;
  }
  _createPlaneMesh(trianglesAmount) {
    let squaresAmount = Math.ceil(trianglesAmount / 2);
    let row = 1;
    let column = 1;
    let closestSqrt = 1;
    while (closestSqrt * closestSqrt < squaresAmount) {
      closestSqrt++;
    }
    row = closestSqrt;
    column = closestSqrt;
    while (row > 1 && column > 1 && row * column > squaresAmount && (row - 1) * column >= squaresAmount) {
      row--;
    }
    let meshCreationParams = new MeshCreationParams(this.engine);
    for (let i = 0; i < row + 1; i++) {
      for (let j = 0; j < column + 1; j++) {
        let x = 2 / column * j;
        let y = 2 / row * i;
        let vertexCreationParams = new MeshCreationVertexParams();
        vertexCreationParams.myPosition = vec3_create();
        vertexCreationParams.myPosition[0] = x - 1;
        vertexCreationParams.myPosition[1] = y - 1;
        vertexCreationParams.myPosition[2] = 0;
        vertexCreationParams.myTextureCoordinates = vec2_create();
        vertexCreationParams.myTextureCoordinates[0] = x / 2;
        vertexCreationParams.myTextureCoordinates[1] = y / 2;
        vertexCreationParams.myNormal = vec3_create();
        vertexCreationParams.myNormal[0] = 0;
        vertexCreationParams.myNormal[1] = 0;
        vertexCreationParams.myNormal[2] = 1;
        meshCreationParams.myVertexes.push(vertexCreationParams);
      }
    }
    for (let i = 0; i < row; i++) {
      for (let j = 0; j < column; j++) {
        let firstTriangle = new MeshCreationTriangleParams();
        firstTriangle.myIndexes[0] = i * (column + 1) + j;
        firstTriangle.myIndexes[1] = i * (column + 1) + j + 1;
        firstTriangle.myIndexes[2] = (i + 1) * (column + 1) + j;
        let secondTriangle = new MeshCreationTriangleParams();
        secondTriangle.myIndexes[0] = (i + 1) * (column + 1) + j;
        secondTriangle.myIndexes[1] = i * (column + 1) + j + 1;
        secondTriangle.myIndexes[2] = (i + 1) * (column + 1) + j + 1;
        meshCreationParams.myTriangles.push(firstTriangle);
        meshCreationParams.myTriangles.push(secondTriangle);
      }
    }
    let mesh = MeshUtils.create(meshCreationParams);
    return mesh;
  }
  onDeactivate() {
    Globals.getObjectPoolManager(this.engine)?.releaseAll(this._myPoolID);
  }
  onDestroy() {
    Globals.getObjectPoolManager(this.engine)?.destroyPool(this._myPoolID);
  }
};

// dist/pp/cauldron/cauldron/components/adjust_hierarchy_physx_scale_component.js
import { Component as Component24, PhysXComponent as PhysXComponent5, Property as Property16 } from "@wonderlandengine/api";
var AdjustHierarchyPhysXScaleComponent = class extends Component24 {
  static TypeName = "pp-adjust-hierarchy-physx-scale";
  static Properties = {
    _myWhen: Property16.enum(["Init", "Start", "First Update"], "Start")
  };
  init() {
    if (this.markedActive && this._myWhen == 0) {
      this._adjustScale();
    }
  }
  start() {
    if (this._myWhen == 1) {
      this._adjustScale();
    }
    this._myFirst = true;
  }
  update(dt) {
    if (this._myWhen == 2 && this._myFirst) {
      this._myFirst = false;
      this._adjustScale();
    }
  }
  _adjustScale() {
    let scale4 = this.object.pp_getScale();
    let physXComponents = this.object.pp_getComponents(PhysXComponent5);
    for (let physX of physXComponents) {
      physX.extents[0] = physX.extents[0] * scale4[0];
      physX.extents[1] = physX.extents[1] * scale4[1];
      physX.extents[2] = physX.extents[2] * scale4[2];
      if (physX.active) {
        physX.active = false;
        physX.active = true;
      }
    }
  }
};

// dist/pp/cauldron/cauldron/components/reset_local_transform_component.js
import { Component as Component25, property as property3 } from "@wonderlandengine/api";
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ResetLocalTransformComponent = class extends Component25 {
  static TypeName = "pp-reset-local-transform";
  _myResetLocalTransformOn;
  _myResetLocalTransformWhen;
  _myFirstUpdate = true;
  _myFirstXRStart = true;
  _myFirstXREnd = true;
  init() {
    if (this.markedActive && this._myResetLocalTransformWhen == 0) {
      this._resetLocalTransform();
    }
  }
  start() {
    if (this._myResetLocalTransformWhen == 1) {
      this._resetLocalTransform();
    }
  }
  update(dt) {
    if (this._myResetLocalTransformWhen == 2 && this._myFirstUpdate) {
      this._resetLocalTransform();
    }
    this._myFirstUpdate = false;
  }
  _onXRSessionStart() {
    if (this._myResetLocalTransformWhen == 3 || this._myResetLocalTransformWhen == 5 && this._myFirstXRStart) {
      this._resetLocalTransform();
    }
    this._myFirstXRStart = false;
  }
  _onXRSessionEnd() {
    if (this._myResetLocalTransformWhen == 4 || this._myResetLocalTransformWhen == 6 && this._myFirstXREnd) {
      this._resetLocalTransform();
    }
    this._myFirstXREnd = false;
  }
  _resetLocalTransform() {
    let objects = [];
    if (this._myResetLocalTransformOn == 0) {
      objects = [this.object.pp_getSelf()];
    } else if (this._myResetLocalTransformOn == 1) {
      objects = this.object.pp_getChildren();
    } else if (this._myResetLocalTransformOn == 2) {
      objects = this.object.pp_getDescendants();
    } else {
      objects = this.object.pp_getHierarchy();
    }
    for (const object of objects) {
      object.pp_resetTransformLocal();
    }
  }
  onActivate() {
    if (this._myResetLocalTransformWhen == 3 || this._myResetLocalTransformWhen == 5) {
      XRUtils.registerSessionStartEventListener(this, this._onXRSessionStart.bind(this), true, true, this.engine);
    }
    if (this._myResetLocalTransformWhen == 4 || this._myResetLocalTransformWhen == 6) {
      XRUtils.registerSessionEndEventListener(this, this._onXRSessionEnd.bind(this), this.engine);
    }
  }
  onDeactivate() {
    XRUtils.unregisterSessionStartEndEventListeners(this, this.engine);
  }
};
__decorate3([
  property3.enum(["Self", "Children", "Descendants", "Hierarchy"], "Self")
], ResetLocalTransformComponent.prototype, "_myResetLocalTransformOn", void 0);
__decorate3([
  property3.enum(["Init", "Start", "First Update", "Enter XR", "Exit XR", "First Enter XR", "First Exit XR"], "Init")
], ResetLocalTransformComponent.prototype, "_myResetLocalTransformWhen", void 0);

// dist/pp/cauldron/cauldron/components/set_active_component.js
import { Component as Component26, Property as Property17 } from "@wonderlandengine/api";
var SetActiveComponent = class extends Component26 {
  static TypeName = "pp-set-active";
  static Properties = {
    _myActive: Property17.bool(true),
    _mySetActiveOn: Property17.enum(["Self", "Children", "Descendants", "Hierarchy"], "Hierarchy"),
    _mySetActiveWhen: Property17.enum(["Init", "Start", "First Update", "Enter XR", "Exit XR", "First Enter XR", "First Exit XR"], "Init")
  };
  init() {
    if (this.markedActive && this._mySetActiveWhen == 0) {
      this._setActive();
    }
  }
  start() {
    if (this._mySetActiveWhen == 1) {
      this._setActive();
    }
    this._myFirstUpdate = true;
    this._myFirstXRStart = true;
    this._myFirstXREnd = true;
    this._myActivateOnNextUpdate = false;
  }
  update(dt) {
    if (this._myActivateOnNextUpdate) {
      this._onActivate();
      this._myActivateOnNextUpdate = false;
    }
    if (this._mySetActiveWhen == 2 && this._myFirstUpdate) {
      this._setActive();
    }
    this._myFirstUpdate = false;
  }
  _onXRSessionStart() {
    if (this._mySetActiveWhen == 3 || this._mySetActiveWhen == 5 && this._myFirstXRStart) {
      this._setActive();
    }
    this._myFirstXRStart = false;
  }
  _onXRSessionEnd() {
    if (this._mySetActiveWhen == 4 || this._mySetActiveWhen == 6 && this._myFirstXREnd) {
      this._setActive();
    }
    this._myFirstXREnd = false;
  }
  _setActive() {
    if (this._mySetActiveOn == 0) {
      this.object.pp_setActiveSelf(this._myActive);
    } else if (this._mySetActiveOn == 1) {
      this.object.pp_setActiveChildren(this._myActive);
    } else if (this._mySetActiveOn == 2) {
      this.object.pp_setActiveDescendants(this._myActive);
    } else {
      this.object.pp_setActive(this._myActive);
    }
  }
  onActivate() {
    this._myActivateOnNextUpdate = true;
  }
  _onActivate() {
    if (this._mySetActiveWhen == 3 || this._mySetActiveWhen == 5) {
      XRUtils.registerSessionStartEventListener(this, this._onXRSessionStart.bind(this), true, true, this.engine);
    } else if (this._mySetActiveWhen == 4 || this._mySetActiveWhen == 6) {
      XRUtils.registerSessionEndEventListener(this, this._onXRSessionEnd.bind(this), this.engine);
    }
  }
  onDeactivate() {
    XRUtils.unregisterSessionStartEndEventListeners(this, this.engine);
  }
};

// dist/pp/cauldron/cauldron/components/set_engine_log_level_component.js
import { Component as Component27, LogLevel, property as property4 } from "@wonderlandengine/api";
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SetEngineLogLevelComponent = class extends Component27 {
  static TypeName = "pp-set-engine-log-level";
  _myInfoEnabled;
  _myWarnEnabled;
  _myErrorEnabled;
  init() {
    if (!this.markedActive)
      return;
    const logLevelsToDisable = [];
    if (!this._myInfoEnabled) {
      logLevelsToDisable.push(LogLevel.Info);
    }
    if (!this._myWarnEnabled) {
      logLevelsToDisable.push(LogLevel.Warn);
    }
    if (!this._myErrorEnabled) {
      logLevelsToDisable.push(LogLevel.Error);
    }
    if (logLevelsToDisable.length > 0) {
      this.engine.log.levels.disable(...logLevelsToDisable);
    }
  }
};
__decorate4([
  property4.bool(true)
], SetEngineLogLevelComponent.prototype, "_myInfoEnabled", void 0);
__decorate4([
  property4.bool(true)
], SetEngineLogLevelComponent.prototype, "_myWarnEnabled", void 0);
__decorate4([
  property4.bool(true)
], SetEngineLogLevelComponent.prototype, "_myErrorEnabled", void 0);

// dist/pp/cauldron/cauldron/components/show_xr_buttons_component.js
import { Component as Component28, property as property5 } from "@wonderlandengine/api";
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var _ButtonBehaviorWhenNotAvailable;
(function(_ButtonBehaviorWhenNotAvailable2) {
  _ButtonBehaviorWhenNotAvailable2["NONE"] = "none";
  _ButtonBehaviorWhenNotAvailable2["DISABLE"] = "disable";
  _ButtonBehaviorWhenNotAvailable2["HIDE"] = "hide";
})(_ButtonBehaviorWhenNotAvailable || (_ButtonBehaviorWhenNotAvailable = {}));
var ShowXRButtonsComponent = class extends Component28 {
  static TypeName = "pp-show-xr-buttons";
  _myShowVRButton;
  _myVRButtonBehaviorWhenNotAvailable;
  _myShowARButton;
  _myARButtonBehaviorWhenNotAvailable;
  _myXRButtonsContainer = null;
  _myVRButton = null;
  _myARButton = null;
  _myFirstUpdate = false;
  _myVRButtonVisibilityUpdated = false;
  _myVRButtonUsabilityUpdated = false;
  _myVRButtonDisabledOpacityUpdated = false;
  _myARButtonVisibilityUpdated = false;
  _myARButtonUsabilityUpdated = false;
  _myARButtonDisabledOpacityUpdated = false;
  init() {
    this._myXRButtonsContainer = document.getElementById("xr-buttons-container");
    this._myVRButton = document.getElementById("vr-button");
    this._myARButton = document.getElementById("ar-button");
  }
  update(dt) {
    if (!this._myFirstUpdate) {
      this._myFirstUpdate = true;
      if (this._myXRButtonsContainer != null) {
        if (this._myShowVRButton || this._myShowARButton) {
          this._myXRButtonsContainer.style.setProperty("display", "flex");
        } else {
          this._myXRButtonsContainer.style.setProperty("display", "none");
        }
      }
      if (this._myVRButton != null) {
        if (this._myShowVRButton) {
          this._myVRButton.style.setProperty("display", "block");
        } else {
          this._myVRButton.style.setProperty("display", "none");
        }
      }
      if (this._myARButton != null) {
        if (this._myShowARButton) {
          this._myARButton.style.setProperty("display", "block");
        } else {
          this._myARButton.style.setProperty("display", "none");
        }
      }
    } else {
      this._updateXRButtons(dt);
    }
  }
  _updateXRButtons(dt) {
    if (this._myShowVRButton) {
      if (!this._myVRButtonUsabilityUpdated) {
        if (this._myVRButton != null) {
          if (!this._myVRButtonVisibilityUpdated) {
            this._myVRButton.style.setProperty("transform", "scale(1)");
            this._myVRButtonVisibilityUpdated = true;
          }
          if (!this._myVRButtonUsabilityUpdated) {
            if (XRUtils.isVRSupported(this.engine)) {
              this._myVRButton.style.setProperty("opacity", "1");
              this._myVRButton.style.setProperty("pointer-events", "all");
              this._myVRButtonUsabilityUpdated = true;
            } else if (!this._myVRButtonDisabledOpacityUpdated) {
              switch (this._myVRButtonBehaviorWhenNotAvailable) {
                case 0:
                  this._myVRButton.style.setProperty("opacity", "1");
                  this._myVRButton.style.setProperty("pointer-events", "all");
                  break;
                case 1:
                  this._myVRButton.style.setProperty("opacity", "0.5");
                  break;
                case 2:
                  this._myVRButton.style.setProperty("display", "none");
                  break;
              }
              this._myVRButtonDisabledOpacityUpdated = true;
            }
          }
        } else {
          this._myVRButtonUsabilityUpdated = true;
        }
      }
    }
    if (this._myShowARButton) {
      if (!this._myARButtonUsabilityUpdated) {
        if (this._myARButton != null) {
          if (!this._myARButtonVisibilityUpdated) {
            this._myARButton.style.setProperty("transform", "scale(1)");
            this._myARButtonVisibilityUpdated = true;
          }
          if (!this._myARButtonUsabilityUpdated) {
            if (XRUtils.isARSupported(this.engine)) {
              this._myARButton.style.setProperty("opacity", "1");
              this._myARButton.style.setProperty("pointer-events", "all");
              this._myARButtonUsabilityUpdated = true;
            } else if (!this._myARButtonDisabledOpacityUpdated) {
              switch (this._myARButtonBehaviorWhenNotAvailable) {
                case 0:
                  this._myARButton.style.setProperty("opacity", "1");
                  this._myARButton.style.setProperty("pointer-events", "all");
                  break;
                case 1:
                  this._myARButton.style.setProperty("opacity", "0.5");
                  break;
                case 2:
                  this._myARButton.style.setProperty("display", "none");
                  break;
              }
              this._myARButtonDisabledOpacityUpdated = true;
            }
          }
        } else {
          this._myARButtonUsabilityUpdated = true;
        }
      }
    }
  }
  onActivate() {
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this.engine);
  }
  onDeactivate() {
    XRUtils.unregisterSessionStartEndEventListeners(this, this.engine);
  }
  _onXRSessionStart() {
    if (this._myXRButtonsContainer != null) {
      this._myXRButtonsContainer.style.setProperty("display", "none");
    }
  }
  _onXRSessionEnd() {
    if (this._myXRButtonsContainer != null && (this._myShowVRButton || this._myShowARButton)) {
      this._myXRButtonsContainer.style.setProperty("display", "flex");
    }
  }
};
__decorate5([
  property5.bool(true)
], ShowXRButtonsComponent.prototype, "_myShowVRButton", void 0);
__decorate5([
  property5.enum(Object.values(_ButtonBehaviorWhenNotAvailable), _ButtonBehaviorWhenNotAvailable.DISABLE)
], ShowXRButtonsComponent.prototype, "_myVRButtonBehaviorWhenNotAvailable", void 0);
__decorate5([
  property5.bool(true)
], ShowXRButtonsComponent.prototype, "_myShowARButton", void 0);
__decorate5([
  property5.enum(Object.values(_ButtonBehaviorWhenNotAvailable), _ButtonBehaviorWhenNotAvailable.DISABLE)
], ShowXRButtonsComponent.prototype, "_myARButtonBehaviorWhenNotAvailable", void 0);

// dist/pp/cauldron/fsm/fsm.js
import { Emitter as Emitter10 } from "@wonderlandengine/api";
var StateData = class {
  myID;
  myState;
  constructor(stateID, state) {
    this.myID = stateID;
    this.myState = state;
  }
};
var TransitionData = class {
  myID;
  myFromStateData;
  myToStateData;
  myTransition;
  mySkipStateFunction;
  constructor(transitionID, fromStateData, toStateData, transition, skipStateFunction) {
    this.myID = transitionID;
    this.myFromStateData = fromStateData;
    this.myToStateData = toStateData;
    this.myTransition = transition;
    this.mySkipStateFunction = skipStateFunction;
  }
};
var PendingPerform = class {
  myID;
  myTransitionArgs;
  constructor(transitionID, ...args) {
    this.myID = transitionID;
    this.myTransitionArgs = args;
  }
};
var PerformMode;
(function(PerformMode2) {
  PerformMode2[PerformMode2["IMMEDIATE"] = 0] = "IMMEDIATE";
  PerformMode2[PerformMode2["DELAYED"] = 1] = "DELAYED";
})(PerformMode || (PerformMode = {}));
var PerformDelayedMode;
(function(PerformDelayedMode2) {
  PerformDelayedMode2[PerformDelayedMode2["QUEUE"] = 0] = "QUEUE";
  PerformDelayedMode2[PerformDelayedMode2["KEEP_FIRST"] = 1] = "KEEP_FIRST";
  PerformDelayedMode2[PerformDelayedMode2["KEEP_LAST"] = 2] = "KEEP_LAST";
})(PerformDelayedMode || (PerformDelayedMode = {}));
var SkipStateFunction;
(function(SkipStateFunction2) {
  SkipStateFunction2[SkipStateFunction2["NONE"] = 0] = "NONE";
  SkipStateFunction2[SkipStateFunction2["END"] = 1] = "END";
  SkipStateFunction2[SkipStateFunction2["START"] = 2] = "START";
  SkipStateFunction2[SkipStateFunction2["BOTH"] = 3] = "BOTH";
})(SkipStateFunction || (SkipStateFunction = {}));
var FSM = class _FSM {
  _myCurrentStateData = null;
  _myStatesData = /* @__PURE__ */ new Map();
  _myTransitionsData = /* @__PURE__ */ new Map();
  _myLogEnabled = false;
  _myLogShowDelayedInfo = false;
  _myLogFSMName = "FSM";
  _myPerformMode;
  _myPerformDelayedMode;
  _myPendingPerforms = [];
  _myCurrentlyPerformedTransitionData = null;
  _myInitEmitter = new Emitter10();
  _myInitIDEmitters = /* @__PURE__ */ new Map();
  _myTransitionEmitter = new Emitter10();
  _myTransitionIDEmitters = [];
  constructor(performMode = PerformMode.IMMEDIATE, performDelayedMode = PerformDelayedMode.QUEUE) {
    this._myPerformMode = performMode;
    this._myPerformDelayedMode = performDelayedMode;
  }
  addState(stateID, state, stateStartCallback, stateEndCallback, stateInitCallback) {
    let adjustedState = null;
    if (state == null || typeof state == "function") {
      adjustedState = {};
      if (state != null) {
        adjustedState.update = function update(dt, fsm, stateData2, ...args) {
          return state(dt, fsm, stateData2, ...args);
        };
      }
      if (stateStartCallback != null) {
        adjustedState.start = function start(fsm, transitionData, ...args) {
          return stateStartCallback(fsm, transitionData, ...args);
        };
      }
      if (stateEndCallback != null) {
        adjustedState.end = function end(fsm, transitionData, ...args) {
          return stateEndCallback(fsm, transitionData, ...args);
        };
      }
      if (stateInitCallback != null) {
        adjustedState.init = function init(fsm, stateData2, ...args) {
          return stateInitCallback(fsm, stateData2, ...args);
        };
      }
      adjustedState.clone = function clone13() {
        const clonedState = {};
        clonedState.update = this.update;
        clonedState.clone = this.clone;
        return clonedState;
      };
    } else {
      adjustedState = state;
    }
    const stateData = new StateData(stateID, adjustedState);
    this._myStatesData.set(stateID, stateData);
    this._myTransitionsData.set(stateID, /* @__PURE__ */ new Map());
  }
  addTransition(fromStateID, toStateID, transitionID, transition, skipStateFunction = SkipStateFunction.NONE) {
    let adjustedTransition = null;
    if (transition == null || typeof transition == "function") {
      adjustedTransition = {};
      if (transition != null) {
        adjustedTransition.perform = function perform(fsm, transitionData, ...args) {
          return transition(fsm, transitionData, ...args);
        };
      }
      adjustedTransition.clone = function clone13() {
        const clonedTransition = {};
        clonedTransition.perform = this.perform;
        clonedTransition.clone = this.clone;
        return clonedTransition;
      };
    } else {
      adjustedTransition = transition;
    }
    if (this.hasState(fromStateID) && this.hasState(toStateID)) {
      const transitionsDataFromState = this._getTransitionsDataFromState(fromStateID);
      const transitionData = new TransitionData(transitionID, this.getStateData(fromStateID), this.getStateData(toStateID), adjustedTransition, skipStateFunction);
      transitionsDataFromState.set(transitionID, transitionData);
    } else {
      if (!this.hasState(fromStateID) && !this.hasState(toStateID)) {
        console.error("Can't add transition:", transitionID, "- from state not found:", fromStateID, "- to state not found:", toStateID);
      } else if (!this.hasState(fromStateID)) {
        console.error("Can't add transition:", transitionID, "- from state not found:", fromStateID);
      } else if (!this.hasState(toStateID)) {
        console.error("Can't add transition:", transitionID, "- to state not found:", toStateID);
      }
    }
  }
  init(stateID, transition, ...args) {
    let adjustedInitTransition = null;
    if (transition == null || typeof transition == "function") {
      adjustedInitTransition = {};
      if (transition != null) {
        adjustedInitTransition.performInit = function performInit(fsm, stateData, ...args2) {
          return transition(fsm, stateData, ...args2);
        };
      }
    } else {
      adjustedInitTransition = transition;
    }
    if (this.hasState(stateID)) {
      const stateData = this._myStatesData.get(stateID);
      if (this._myLogEnabled) {
        console.log(this._myLogFSMName, "- Init:", stateID);
      }
      if (adjustedInitTransition != null && adjustedInitTransition.performInit != null) {
        adjustedInitTransition.performInit(this, stateData, ...args);
      } else if (stateData.myState != null && stateData.myState.init != null) {
        stateData.myState.init(this, stateData, ...args);
      }
      this._myCurrentStateData = stateData;
      this._myInitEmitter.notify(this, stateData, ...args);
      if (this._myInitIDEmitters.size > 0) {
        const emitter = this._myInitIDEmitters.get(stateID);
        if (emitter != null) {
          emitter.notify(this, stateData, ...args);
        }
      }
    } else if (this._myLogEnabled) {
      console.warn(this._myLogFSMName, "- Init state not found:", stateID);
    }
  }
  update(dt, ...args) {
    if (this._myPendingPerforms.length > 0) {
      for (let i = 0; i < this._myPendingPerforms.length; i++) {
        this._perform(this._myPendingPerforms[i].myID, PerformMode.DELAYED, ...this._myPendingPerforms[i].myTransitionArgs);
      }
      this._myPendingPerforms.pp_clear();
    }
    if (this._myCurrentStateData != null && this._myCurrentStateData.myState != null && this._myCurrentStateData.myState.update != null) {
      this._myCurrentStateData.myState.update(dt, this, this._myCurrentStateData, ...args);
    }
  }
  perform(transitionID, ...args) {
    if (this._myPerformMode == PerformMode.DELAYED) {
      this.performDelayed(transitionID, ...args);
    } else {
      this.performImmediate(transitionID, ...args);
    }
  }
  performDelayed(transitionID, ...args) {
    let performDelayed = false;
    switch (this._myPerformDelayedMode) {
      case PerformDelayedMode.QUEUE:
        this._myPendingPerforms.push(new PendingPerform(transitionID, ...args));
        performDelayed = true;
        break;
      case PerformDelayedMode.KEEP_FIRST:
        if (!this.hasPendingPerforms()) {
          this._myPendingPerforms.push(new PendingPerform(transitionID, ...args));
          performDelayed = true;
        }
        break;
      case PerformDelayedMode.KEEP_LAST:
        this.resetPendingPerforms();
        this._myPendingPerforms.push(new PendingPerform(transitionID, ...args));
        performDelayed = true;
        break;
    }
    return performDelayed;
  }
  performImmediate(transitionID, ...args) {
    return this._perform(transitionID, PerformMode.IMMEDIATE, ...args);
  }
  canPerform(transitionID) {
    if (this._myCurrentStateData == null) {
      return false;
    }
    return this.hasTransitionFromState(this._myCurrentStateData.myID, transitionID);
  }
  canGoTo(stateID, transitionID) {
    if (this._myCurrentStateData == null) {
      return false;
    }
    return this.hasTransitionFromStateToState(this._myCurrentStateData.myID, stateID, transitionID);
  }
  isInState(stateID) {
    return this._myCurrentStateData != null && this._myCurrentStateData.myID == stateID;
  }
  isPerformingTransition() {
    return this._myCurrentlyPerformedTransitionData != null;
  }
  getCurrentlyPerformingTransitionData() {
    return this._myCurrentlyPerformedTransitionData;
  }
  hasBeenInit() {
    return this._myCurrentStateData != null;
  }
  reset() {
    this.resetCurrentState();
    this.resetPendingPerforms();
  }
  resetCurrentState() {
    this._myCurrentStateData = null;
  }
  resetPendingPerforms() {
    this._myPendingPerforms.pp_clear();
  }
  getCurrentStateData() {
    return this._myCurrentStateData;
  }
  getCurrentTransitionsData() {
    if (this._myCurrentStateData == null) {
      return [];
    }
    return this.getTransitionsDataFromState(this._myCurrentStateData.myID);
  }
  getCurrentTransitionsDataToState(stateID) {
    if (this._myCurrentStateData == null) {
      return [];
    }
    return this.getTransitionsDataFromStateToState(this._myCurrentStateData.myID, stateID);
  }
  getStateData(stateID) {
    const stateData = this._myStatesData.get(stateID);
    return stateData != null ? stateData : null;
  }
  getStatesData() {
    return Array.from(this._myStatesData.values());
  }
  getTransitionsData() {
    const transitionsData = [];
    for (const transitionsDataFromState of this._myTransitionsData.values()) {
      for (const transitionData of transitionsDataFromState.values()) {
        transitionsData.push(transitionData);
      }
    }
    return transitionsData;
  }
  getTransitionsDataFromState(fromStateID) {
    const transitionsDataFromState = this._getTransitionsDataFromState(fromStateID);
    if (transitionsDataFromState == null) {
      return [];
    }
    return Array.from(transitionsDataFromState.values());
  }
  getTransitionsDataFromStateToState(fromStateID, toStateID) {
    const transitionsDataFromState = this._getTransitionsDataFromState(fromStateID);
    if (transitionsDataFromState == null) {
      return [];
    }
    const transitionsDataToState = [];
    for (const transitionData of transitionsDataFromState.values()) {
      if (transitionData.myToStateData.myID == toStateID) {
        transitionsDataToState.push(transitionData);
      }
    }
    return transitionsDataToState;
  }
  removeState(stateID) {
    if (this.hasState(stateID)) {
      this._myStatesData.delete(stateID);
      this._myTransitionsData.delete(stateID);
      for (const transitionsDataFromState of this._myTransitionsData.values()) {
        const toDelete = [];
        for (const [transitionID, transitionData] of transitionsDataFromState.entries()) {
          if (transitionData.myToStateData.myID == stateID) {
            toDelete.push(transitionID);
          }
        }
        for (const transitionID of toDelete) {
          transitionsDataFromState.delete(transitionID);
        }
      }
      return true;
    }
    return false;
  }
  removeTransitionFromState(fromStateID, transitionID) {
    const transitionsDataFromState = this._getTransitionsDataFromState(fromStateID);
    if (transitionsDataFromState != null) {
      return transitionsDataFromState.delete(transitionID);
    }
    return false;
  }
  hasState(stateID) {
    return this._myStatesData.has(stateID);
  }
  hasTransitionFromState(fromStateID, transitionID) {
    const transitionsData = this.getTransitionsDataFromState(fromStateID);
    const transitionIndex = transitionsData.findIndex(function(transition) {
      return transition.myID == transitionID;
    });
    return transitionIndex >= 0;
  }
  hasTransitionFromStateToState(fromStateID, toStateID, transitionID) {
    const transitionsData = this.getTransitionsDataFromStateToState(fromStateID, toStateID);
    let hasTransition = false;
    if (transitionID != null) {
      const transitionIndex = transitionsData.findIndex(function(transition) {
        return transition.myID == transitionID;
      });
      hasTransition = transitionIndex >= 0;
    } else {
      hasTransition = transitionsData.length > 0;
    }
    return hasTransition;
  }
  setPerformMode(performMode) {
    this._myPerformMode = performMode;
  }
  getPerformMode() {
    return this._myPerformMode;
  }
  setPerformDelayedMode(performDelayedMode) {
    this._myPerformDelayedMode = performDelayedMode;
  }
  getPerformDelayedMode() {
    return this._myPerformDelayedMode;
  }
  hasPendingPerforms() {
    return this._myPendingPerforms.length > 0;
  }
  getPendingPerforms() {
    return this._myPendingPerforms;
  }
  clone(deepClone = false) {
    if (!this.isCloneable(deepClone)) {
      return null;
    }
    const cloneFSM = new _FSM();
    cloneFSM._myLogEnabled = this._myLogEnabled;
    cloneFSM._myLogShowDelayedInfo = this._myLogShowDelayedInfo;
    cloneFSM._myLogFSMName = this._myLogFSMName;
    cloneFSM._myPerformMode = this._myPerformMode;
    cloneFSM._myPerformDelayedMode = this._myPerformDelayedMode;
    cloneFSM._myPendingPerforms = this._myPendingPerforms.pp_clone();
    for (const stateData of this._myStatesData.values()) {
      let clonedStateData = null;
      if (deepClone) {
        clonedStateData = new StateData(stateData.myID, stateData.myState.clone());
      } else {
        clonedStateData = new StateData(stateData.myID, stateData.myState);
      }
      cloneFSM._myStatesData.set(clonedStateData.myID, clonedStateData);
    }
    for (const [stateID, transitionsDataFromState] of this._myTransitionsData.entries()) {
      const clonedTransitionsDataFromState = /* @__PURE__ */ new Map();
      cloneFSM._myTransitionsData.set(stateID, clonedTransitionsDataFromState);
      for (const transitonData of transitionsDataFromState.values()) {
        let clonedTransitionData = null;
        const fromState = cloneFSM.getStateData(transitonData.myFromStateData.myID);
        const toState = cloneFSM.getStateData(transitonData.myToStateData.myID);
        if (deepClone) {
          clonedTransitionData = new TransitionData(transitonData.myID, fromState, toState, transitonData.myTransition.clone(), transitonData.mySkipStateFunction);
        } else {
          clonedTransitionData = new TransitionData(transitonData.myID, fromState, toState, transitonData.myTransition, transitonData.mySkipStateFunction);
        }
        clonedTransitionsDataFromState.set(clonedTransitionData.myID, clonedTransitionData);
      }
    }
    if (this._myCurrentStateData != null) {
      cloneFSM._myCurrentStateData = cloneFSM.getStateData(this._myCurrentStateData.myID);
    }
    return cloneFSM;
  }
  isCloneable(deepClone = false) {
    if (!deepClone) {
      return true;
    }
    let deepCloneable = true;
    for (const stateData of this._myStatesData.values()) {
      deepCloneable = deepCloneable && stateData.myState.clone != null;
    }
    for (const transitionsData of this._myTransitionsData.values()) {
      for (const transitionsDataFromState of transitionsData.values()) {
        deepCloneable = deepCloneable && transitionsDataFromState.myTransition.clone != null;
      }
    }
    return deepCloneable;
  }
  setLogEnabled(active, fsmName, showDelayedInfo = false) {
    this._myLogEnabled = active;
    this._myLogShowDelayedInfo = showDelayedInfo;
    if (fsmName != null) {
      this._myLogFSMName = "FSM: ".concat(fsmName);
    }
  }
  registerInitEventListener(listenerID, listener) {
    this._myInitEmitter.add(listener, { id: listenerID });
  }
  unregisterInitEventListener(listenerID) {
    this._myInitEmitter.remove(listenerID);
  }
  registerInitIDEventListener(stateID, listenerID, listener) {
    let stateIDEmitter = this._myInitIDEmitters.get(stateID);
    if (stateIDEmitter == null) {
      this._myInitIDEmitters.set(stateID, new Emitter10());
      stateIDEmitter = this._myInitIDEmitters.get(stateID);
    }
    stateIDEmitter.add(listener, { id: listenerID });
  }
  unregisterInitIDEventListener(stateID, listenerID) {
    const stateIDEmitter = this._myInitIDEmitters.get(stateID);
    if (stateIDEmitter != null) {
      stateIDEmitter.remove(listenerID);
      if (stateIDEmitter.isEmpty) {
        this._myInitIDEmitters.delete(stateID);
      }
    }
  }
  registerTransitionEventListener(listenerID, listener) {
    this._myTransitionEmitter.add(listener, { id: listenerID });
  }
  unregisterTransitionEventListener(listenerID) {
    this._myTransitionEmitter.remove(listenerID);
  }
  /** The fsm IDs can be `null`, that means that the listener is called whenever only the valid IDs match
      This let you register to all the transitions with a specific ID and from of a specific state but to every state (`toStateID == null`) */
  registerTransitionIDEventListener(fromStateID, toStateID, transitionID, listenerID, listener) {
    let internalTransitionIDEmitter = null;
    for (const value of this._myTransitionIDEmitters) {
      if (value[0] == fromStateID && value[1] == toStateID && value[2] == transitionID) {
        internalTransitionIDEmitter = value[3];
        break;
      }
    }
    if (internalTransitionIDEmitter == null) {
      const transitionIDEmitter = [
        fromStateID,
        toStateID,
        transitionID,
        new Emitter10()
      ];
      internalTransitionIDEmitter = transitionIDEmitter[3];
      this._myTransitionIDEmitters.push(transitionIDEmitter);
    }
    internalTransitionIDEmitter.add(listener, { id: listenerID });
  }
  unregisterTransitionIDEventListener(fromStateID, toStateID, transitionID, listenerID) {
    let internalTransitionIDEmitter = null;
    for (const value of this._myTransitionIDEmitters) {
      if (value[0] == fromStateID && value[1] == toStateID && value[2] == transitionID) {
        internalTransitionIDEmitter = value[3];
        break;
      }
    }
    if (internalTransitionIDEmitter != null) {
      internalTransitionIDEmitter.remove(listenerID);
      if (internalTransitionIDEmitter.isEmpty) {
        this._myTransitionIDEmitters.pp_remove((element) => element[0] == fromStateID && element[1] == toStateID && element[2] == transitionID);
      }
    }
  }
  _perform(transitionID, performMode, ...args) {
    if (this.isPerformingTransition()) {
      const currentlyPerformingTransitionData = this.getCurrentlyPerformingTransitionData();
      const consoleArguments = [this._myLogFSMName, "- Trying to perform:", transitionID];
      if (this._myLogShowDelayedInfo) {
        consoleArguments.push(performMode == PerformMode.DELAYED ? "- Delayed" : "- Immediate");
      }
      consoleArguments.push("- But another transition is currently being performed -", currentlyPerformingTransitionData.myID);
      console.warn(...consoleArguments);
      return false;
    }
    if (this._myCurrentStateData != null) {
      if (this.canPerform(transitionID)) {
        const transitionsData = this._myTransitionsData.get(this._myCurrentStateData.myID);
        const transitionDataToPerform = transitionsData.get(transitionID);
        this._myCurrentlyPerformedTransitionData = transitionDataToPerform;
        const fromStateData = this._myCurrentStateData;
        const toStateData = this._myStatesData.get(transitionDataToPerform.myToStateData.myID);
        if (this._myLogEnabled) {
          const consoleArguments = [this._myLogFSMName, "- From:", fromStateData.myID, "- To:", toStateData.myID, "- With:", transitionID];
          if (this._myLogShowDelayedInfo) {
            consoleArguments.push(performMode == PerformMode.DELAYED ? "- Delayed" : "- Immediate");
          }
          console.log(...consoleArguments);
        }
        if (transitionDataToPerform.mySkipStateFunction != SkipStateFunction.END && transitionDataToPerform.mySkipStateFunction != SkipStateFunction.BOTH && fromStateData.myState != null && fromStateData.myState.end != null) {
          fromStateData.myState.end(this, transitionDataToPerform, ...args);
        }
        if (transitionDataToPerform.myTransition != null && transitionDataToPerform.myTransition.perform != null) {
          transitionDataToPerform.myTransition.perform(this, transitionDataToPerform, ...args);
        }
        if (transitionDataToPerform.mySkipStateFunction != SkipStateFunction.START && transitionDataToPerform.mySkipStateFunction != SkipStateFunction.BOTH && toStateData.myState != null && toStateData.myState.start != null) {
          toStateData.myState.start(this, transitionDataToPerform, ...args);
        }
        this._myCurrentStateData = transitionDataToPerform.myToStateData;
        this._myTransitionEmitter.notify(this, transitionDataToPerform, performMode, ...args);
        if (this._myTransitionIDEmitters.length > 0) {
          const internalTransitionIDEmitters = [];
          for (const value of this._myTransitionIDEmitters) {
            if ((value[0] == null || value[0] == fromStateData.myID) && (value[1] == null || value[1] == toStateData.myID) && (value[2] == null || value[2] == transitionDataToPerform.myID)) {
              internalTransitionIDEmitters.push(value[3]);
            }
          }
          for (const emitter of internalTransitionIDEmitters) {
            emitter.notify(this, transitionDataToPerform, performMode, ...args);
          }
        }
        this._myCurrentlyPerformedTransitionData = null;
        return true;
      } else if (this._myLogEnabled) {
        const consoleArguments = [this._myLogFSMName, "- No Transition:", transitionID, "- From:", this._myCurrentStateData.myID];
        if (this._myLogShowDelayedInfo) {
          consoleArguments.push(performMode == PerformMode.DELAYED ? "- Delayed" : "- Immediate");
        }
        console.warn(...consoleArguments);
      }
    } else if (this._myLogEnabled) {
      const consoleArguments = [this._myLogFSMName, "- FSM not initialized yet"];
      if (this._myLogShowDelayedInfo) {
        consoleArguments.push(performMode == PerformMode.DELAYED ? "- Delayed" : "- Immediate");
      }
      console.warn(...consoleArguments);
    }
    return false;
  }
  _getTransitionsDataFromState(fromStateID) {
    const transitionsData = this._myTransitionsData.get(fromStateID);
    return transitionsData != null ? transitionsData : null;
  }
};

// dist/pp/cauldron/fsm/states/condition_states/base_condition_state.js
var BaseConditionState = class {
  _myConditionCallback;
  _myTransitionToPerformOnEnd;
  _myTransitionArgs;
  constructor(conditionCallback, transitionToPerformOnEnd, ...transitionArgs) {
    this._myConditionCallback = conditionCallback;
    this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
    this._myTransitionArgs = transitionArgs;
  }
  setTransitionToPerformOnEnd(transitionToPerformOnEnd, ...transitionArgs) {
    this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
    this._myTransitionArgs = transitionArgs;
  }
  _setConditionCallback(conditionCallback) {
    this._myConditionCallback = conditionCallback;
  }
  _update(dt, fsm) {
    if (this._myConditionCallback()) {
      if (this._myTransitionToPerformOnEnd != null) {
        fsm.perform(this._myTransitionToPerformOnEnd, ...this._myTransitionArgs);
      }
    }
  }
  _start(fsm, transitionData, conditionCallback, transitionToPerformOnEnd, ...transitionArgs) {
    if (conditionCallback != null) {
      this._myConditionCallback = conditionCallback;
    }
    if (transitionToPerformOnEnd != null) {
      this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
      this._myTransitionArgs = transitionArgs;
    }
  }
  _init(fsm, stateData, conditionCallback, transitionToPerformOnEnd, ...transitionArgs) {
    if (conditionCallback != null) {
      this._myConditionCallback = conditionCallback;
    }
    if (transitionToPerformOnEnd != null) {
      this._myTransitionToPerformOnEnd = transitionToPerformOnEnd;
      this._myTransitionArgs = transitionArgs;
    }
  }
};

// dist/pp/cauldron/fsm/states/condition_states/condition_state.js
var ConditionState = class extends BaseConditionState {
  constructor(conditionCallback, transitionToPerformOnEnd, ...transitionArgs) {
    super(conditionCallback, transitionToPerformOnEnd, ...transitionArgs);
  }
  setConditionCallback(conditionCallback) {
    super._setConditionCallback(conditionCallback);
  }
  update(dt, fsm) {
    this._update(dt, fsm);
  }
  start(fsm, transitionData, conditionCallback, transitionToPerformOnEnd, ...transitionArgs) {
    this._start(fsm, transitionData, conditionCallback, transitionToPerformOnEnd, ...transitionArgs);
  }
  init(fsm, stateData, conditionCallback, transitionToPerformOnEnd, ...transitionArgs) {
    this._init(fsm, stateData, conditionCallback, transitionToPerformOnEnd, ...transitionArgs);
  }
};

// dist/pp/cauldron/fsm/states/condition_states/timer_state.js
var TimerState = class extends BaseConditionState {
  _myTimer;
  constructor(duration = 0, transitionToPerformOnEnd, ...transitionArgs) {
    super(() => this._myTimer.isDone(), transitionToPerformOnEnd, ...transitionArgs);
    this._myTimer = new Timer(duration, false);
  }
  setDuration(duration) {
    this._myTimer.setDuration(duration);
  }
  onEnd(listener, id) {
    this._myTimer.onEnd(listener, id);
  }
  unregisterOnEnd(id) {
    this._myTimer.unregisterOnEnd(id);
  }
  update(dt, fsm) {
    this._myTimer.update(dt);
    super._update(dt, fsm);
  }
  start(fsm, transitionData, duration, transitionToPerformOnEnd, ...transitionArgs) {
    this._myTimer.start(duration);
    super._start(fsm, transitionData, void 0, transitionToPerformOnEnd, ...transitionArgs);
  }
  init(fsm, stateData, duration, transitionToPerformOnEnd, ...transitionArgs) {
    this._myTimer.start(duration);
    super._init(fsm, stateData, void 0, transitionToPerformOnEnd, ...transitionArgs);
  }
};

// dist/pp/cauldron/fsm/states/condition_states/frames_countdown_state.js
var FramesCountdownState = class extends BaseConditionState {
  _myFramesCountdown;
  _myCurrentFramesCountdown;
  constructor(framesCountdown = 0, transitionToPerformOnEnd, ...transitionArgs) {
    super(() => this._myCurrentFramesCountdown <= 0, transitionToPerformOnEnd, ...transitionArgs);
    this._myFramesCountdown = framesCountdown;
    this._myCurrentFramesCountdown = this._myFramesCountdown;
  }
  setFramesCountdown(framesCountdown) {
    this._myFramesCountdown = framesCountdown;
    this._myCurrentFramesCountdown = this._myFramesCountdown;
  }
  update(dt, fsm) {
    if (this._myCurrentFramesCountdown > 0) {
      this._myCurrentFramesCountdown--;
    }
    super._update(dt, fsm);
  }
  start(fsm, transitionData, duration, transitionToPerformOnEnd, ...transitionArgs) {
    this._myCurrentFramesCountdown = this._myFramesCountdown;
    super._start(fsm, transitionData, void 0, transitionToPerformOnEnd, ...transitionArgs);
  }
  init(fsm, stateData, duration, transitionToPerformOnEnd, ...transitionArgs) {
    this._myCurrentFramesCountdown = this._myFramesCountdown;
    super._init(fsm, stateData, void 0, transitionToPerformOnEnd, ...transitionArgs);
  }
};

// dist/pp/cauldron/fsm/states/condition_states/delay_state.js
var DelayState = class extends BaseConditionState {
  _myTimer;
  _myFramesCountdown;
  _myCurrentFramesCountdown;
  _myUpdateTimerAfterFramesCountdown;
  constructor(duration = 0, framesCountdown = 0, updateTimerAfterFramesCountdown = true, transitionToPerformOnEnd, ...transitionArgs) {
    super(() => this._myCurrentFramesCountdown <= 0 && this._myTimer.isDone(), transitionToPerformOnEnd, ...transitionArgs);
    this._myTimer = new Timer(duration, false);
    this._myFramesCountdown = framesCountdown;
    this._myCurrentFramesCountdown = this._myFramesCountdown;
    this._myUpdateTimerAfterFramesCountdown = updateTimerAfterFramesCountdown;
  }
  setUpdateTimerAfterFramesCountdown(updateTimerAfterFramesCountdown) {
    this._myUpdateTimerAfterFramesCountdown = updateTimerAfterFramesCountdown;
  }
  setDuration(duration) {
    this._myTimer.setDuration(duration);
  }
  setFramesCountdown(framesCountdown) {
    this._myFramesCountdown = framesCountdown;
    this._myCurrentFramesCountdown = this._myFramesCountdown;
  }
  update(dt, fsm) {
    if (this._myCurrentFramesCountdown > 0) {
      this._myCurrentFramesCountdown--;
    }
    if (!this._myUpdateTimerAfterFramesCountdown || this._myCurrentFramesCountdown <= 0) {
      this._myTimer.update(dt);
    }
    super._update(dt, fsm);
  }
  start(fsm, transitionData, duration, transitionToPerformOnEnd, ...transitionArgs) {
    this._myTimer.start(duration);
    this._myCurrentFramesCountdown = this._myFramesCountdown;
    super._start(fsm, transitionData, void 0, transitionToPerformOnEnd, ...transitionArgs);
  }
  init(fsm, stateData, duration, transitionToPerformOnEnd, ...transitionArgs) {
    this._myTimer.start(duration);
    this._myCurrentFramesCountdown = this._myFramesCountdown;
    super._init(fsm, stateData, void 0, transitionToPerformOnEnd, ...transitionArgs);
  }
};

// dist/pp/cauldron/fsm/states/cauldron/branch_state.js
var BranchState = class {
  _myBranchCallback;
  constructor(branchCallback) {
    this._myBranchCallback = branchCallback;
  }
  setBranchCallback(branchCallback) {
    this._myBranchCallback = branchCallback;
  }
  update(dt, fsm) {
    const branchResult = this._myBranchCallback();
    if (branchResult != null) {
      if (Array.isArray(branchResult) && branchResult.length == 2) {
        fsm.perform(branchResult[0], ...branchResult[1]);
      } else {
        fsm.perform(branchResult);
      }
    }
  }
  start(fsm, transitionData, branchCallback) {
    if (branchCallback != null) {
      this._myBranchCallback = branchCallback;
    }
  }
  init(fsm, stateData, branchCallback) {
    if (branchCallback != null) {
      this._myBranchCallback = branchCallback;
    }
  }
};

// dist/pp/cauldron/utils/color_utils.js
var ColorModel;
(function(ColorModel2) {
  ColorModel2[ColorModel2["RGB"] = 0] = "RGB";
  ColorModel2[ColorModel2["HSV"] = 1] = "HSV";
})(ColorModel || (ColorModel = {}));
function rgbToHSV(rgb, out = Vec4Utils.clone(rgb)) {
  const r = rgb[0];
  const g = rgb[1];
  const b = rgb[2];
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const d = max - min;
  let h = 0;
  const s = max == 0 ? 0 : d / max;
  const v = max;
  switch (max) {
    case min:
      h = 0;
      break;
    case r:
      h = g - b + d * (g < b ? 6 : 0);
      h /= 6 * d;
      break;
    case g:
      h = b - r + d * 2;
      h /= 6 * d;
      break;
    case b:
      h = r - g + d * 4;
      h /= 6 * d;
      break;
  }
  out[0] = h;
  out[1] = s;
  out[2] = v;
  out[3] = rgb[3];
  return out;
}
function hsvToRGB(hsv, out = Vec4Utils.clone(hsv)) {
  const h = hsv[0];
  const s = hsv[1];
  const v = hsv[2];
  const i = Math.floor(h * 6);
  const f = h * 6 - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  let r = 0;
  let g = 0;
  let b = 0;
  switch (i % 6) {
    case 0:
      r = v;
      g = t;
      b = p;
      break;
    case 1:
      r = q;
      g = v;
      b = p;
      break;
    case 2:
      r = p;
      g = v;
      b = t;
      break;
    case 3:
      r = p;
      g = q;
      b = v;
      break;
    case 4:
      r = t;
      g = p;
      b = v;
      break;
    case 5:
      r = v;
      g = p;
      b = q;
      break;
  }
  out[0] = r;
  out[1] = g;
  out[2] = b;
  out[3] = hsv[3];
  return out;
}
function colorNormalizedToInt(color, out = Vec4Utils.clone(color)) {
  for (let i = 0; i < out.length; i++) {
    out[i] = Math.round(color[i] * 255);
    out[i] = Math.pp_clamp(out[i], 0, 255);
  }
  return out;
}
function colorIntToNormalized(color, out = Vec4Utils.clone(color)) {
  for (let i = 0; i < out.length; i++) {
    out[i] = color[i] / 255;
    out[i] = Math.pp_clamp(out[i], 0, 1);
  }
  return out;
}
var ColorUtils = {
  rgbToHSV,
  hsvToRGB,
  colorNormalizedToInt,
  colorIntToNormalized
};

// dist/pp/cauldron/utils/analytics_utils.js
var _myAnalyticsEnabled = false;
var _mySendDataCallback = null;
var _myEventsSentOnce = [];
var _myDataLogEnabled = false;
var _myEventsLogEnabled = false;
var _myErrorsLogEnabled = false;
function setAnalyticsEnabled(enabled) {
  _myAnalyticsEnabled = enabled;
}
function isAnalyticsEnabled() {
  return _myAnalyticsEnabled;
}
function setSendDataCallback(callback) {
  _mySendDataCallback = callback;
}
function sendData(...args) {
  let dataSent = false;
  try {
    if (_myAnalyticsEnabled) {
      if (_myDataLogEnabled) {
        console.log("Analytics Data: " + args);
      }
      if (_mySendDataCallback != null) {
        _mySendDataCallback(...args);
        dataSent = true;
      } else if (_myErrorsLogEnabled) {
        console.error("You need to set the send data callback");
      }
    }
  } catch (error4) {
    if (_myErrorsLogEnabled) {
      console.error(error4);
    }
    dataSent = false;
  }
  return dataSent;
}
function sendEvent(eventName, params) {
  let eventSent = false;
  try {
    if (_myAnalyticsEnabled) {
      if (_myEventsLogEnabled) {
        if (params != null) {
          console.log("Analytics Event: " + eventName + " - Params:", params);
        } else {
          console.log("Analytics Event: " + eventName);
        }
      }
      if (_mySendDataCallback != null) {
        if (params != null) {
          _mySendDataCallback("event", eventName, params);
        } else {
          _mySendDataCallback("event", eventName);
        }
        eventSent = true;
      } else if (_myErrorsLogEnabled) {
        console.error("Analytics Error: You need to set the send data callback");
      } else {
        console.warn("Analytics Error: You need to set the send data callback");
      }
    }
  } catch (error4) {
    if (_myErrorsLogEnabled) {
      console.error(error4);
    }
    eventSent = false;
  }
  return eventSent;
}
function sendEventOnce(eventName, params) {
  let eventSent = false;
  if (_myAnalyticsEnabled) {
    if (!AnalyticsUtils.hasEventAlreadyBeenSent(eventName)) {
      eventSent = AnalyticsUtils.sendEvent(eventName, params);
      if (eventSent) {
        _myEventsSentOnce.pp_pushUnique(eventName);
      }
    }
  }
  return eventSent;
}
function sendEventWithValue(eventName, value) {
  return AnalyticsUtils.sendEvent(eventName, { "value": value });
}
function sendEventOnceWithValue(eventName, value) {
  return AnalyticsUtils.sendEventOnce(eventName, { "value": value });
}
function clearEventSentOnceState(eventName) {
  _myEventsSentOnce.pp_removeEqual(eventName);
}
function clearAllEventsSentOnceState() {
  _myEventsSentOnce.pp_clear();
}
function hasEventAlreadyBeenSent(eventName) {
  return _myEventsSentOnce.pp_hasEqual(eventName);
}
function getEventsAlreadyBeenSent() {
  return _myEventsSentOnce;
}
function setDataLogEnabled(enabled) {
  _myDataLogEnabled = enabled;
}
function isDataLogEnabled() {
  return _myDataLogEnabled;
}
function setEventsLogEnabled(enabled) {
  _myEventsLogEnabled = enabled;
}
function isEventsLogEnabled() {
  return _myEventsLogEnabled;
}
function setErrorsLogEnabled(enabled) {
  _myErrorsLogEnabled = enabled;
}
function isErrorsLogEnabled() {
  return _myErrorsLogEnabled;
}
var AnalyticsUtils = {
  setAnalyticsEnabled,
  isAnalyticsEnabled,
  setSendDataCallback,
  sendData,
  sendEvent,
  sendEventOnce,
  sendEventWithValue,
  sendEventOnceWithValue,
  clearEventSentOnceState,
  clearAllEventsSentOnceState,
  hasEventAlreadyBeenSent,
  getEventsAlreadyBeenSent,
  setDataLogEnabled,
  isDataLogEnabled,
  setEventsLogEnabled,
  isEventsLogEnabled,
  setErrorsLogEnabled,
  isErrorsLogEnabled
};

// dist/pp/cauldron/wl/components/wl_cursor_target_wrapper_component.js
import { Component as Component29, property as property6 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget5 } from "@wonderlandengine/components";
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var WLCursorTargetWrapperComponent = class extends Component29 {
  static TypeName = "pp-wl-cursor-target-wrapper";
  _myIsSurface;
  cursorTargetComponent = null;
  init() {
    if (this.markedActive) {
      this.cursorTargetComponent = this.object.pp_addComponent(CursorTarget5);
      this.cursorTargetComponent.isSurface = this._myIsSurface;
    }
  }
};
__decorate6([
  property6.bool(false)
], WLCursorTargetWrapperComponent.prototype, "_myIsSurface", void 0);

// dist/pp/cauldron/wl/utils/material_utils.js
import { MeshComponent as MeshComponent8, TextComponent as TextComponent5 } from "@wonderlandengine/api";
var setAlpha = function() {
  const color = vec4_create();
  return function setAlpha2(material, alpha) {
    const flatMaterial = material;
    if (flatMaterial.color != null) {
      color.vec4_copy(flatMaterial.color);
      color[3] = alpha;
      flatMaterial.color = color;
    }
    const phongMaterial = material;
    if (phongMaterial.diffuseColor != null) {
      color.vec4_copy(phongMaterial.diffuseColor);
      color[3] = alpha;
      phongMaterial.diffuseColor = color;
    }
    if (phongMaterial.ambientColor != null) {
      color.vec4_copy(phongMaterial.ambientColor);
      color[3] = alpha;
      phongMaterial.ambientColor = color;
    }
  };
}();
function setObjectAlpha(object, alpha) {
  const meshComponents = object.pp_getComponents(MeshComponent8);
  for (const meshComponent of meshComponents) {
    if (meshComponent.material != null) {
      MaterialUtils.setAlpha(meshComponent.material, alpha);
    }
  }
  const textComponents = object.pp_getComponents(TextComponent5);
  for (const textComponent of textComponents) {
    if (textComponent.material != null) {
      MaterialUtils.setAlpha(textComponent.material, alpha);
    }
  }
}
function setObjectMaterial(object, material, cloneMaterial = false) {
  const meshComponents = object.pp_getComponents(MeshComponent8);
  for (const meshComponent of meshComponents) {
    if (cloneMaterial) {
      meshComponent.material = material.clone();
    } else {
      meshComponent.material = material;
    }
  }
  const textComponents = object.pp_getComponents(TextComponent5);
  for (const textComponent of textComponents) {
    if (cloneMaterial) {
      textComponent.material = material.clone();
    } else {
      textComponent.material = material;
    }
  }
}
function setObjectClonedMaterials(object) {
  const meshComponents = object.pp_getComponents(MeshComponent8);
  for (const meshComponent of meshComponents) {
    if (meshComponent.material != null) {
      meshComponent.material = meshComponent.material.clone();
    }
  }
  const textComponents = object.pp_getComponents(TextComponent5);
  for (const textComponent of textComponents) {
    if (textComponent.material != null) {
      textComponent.material = textComponent.material.clone();
    }
  }
}
function setObjectSpecularColor(object, color) {
  const meshComponents = object.pp_getComponents(MeshComponent8);
  for (const meshComponent of meshComponents) {
    if (meshComponent.material != null) {
      const phongMaterial = meshComponent.material;
      if (phongMaterial.specularColor != null) {
        phongMaterial.specularColor = color;
      }
    }
  }
  const textComponents = object.pp_getComponents(TextComponent5);
  for (const textComponent of textComponents) {
    if (textComponent.material != null) {
      const phongMaterial = textComponent.material;
      if (phongMaterial.specularColor != null) {
        phongMaterial.specularColor = color;
      }
    }
  }
}
function setObjectFogColor(object, color) {
  const meshComponents = object.pp_getComponents(MeshComponent8);
  for (const meshComponent of meshComponents) {
    if (meshComponent.material != null) {
      const phongMaterial = meshComponent.material;
      if (phongMaterial.fogColor != null) {
        phongMaterial.fogColor = color;
      }
    }
  }
  const textComponents = object.pp_getComponents(TextComponent5);
  for (const textComponent of textComponents) {
    if (textComponent.material != null) {
      const phongMaterial = textComponent.material;
      if (phongMaterial.fogColor != null) {
        phongMaterial.fogColor = color;
      }
    }
  }
}
var MaterialUtils = {
  setAlpha,
  setObjectAlpha,
  setObjectMaterial,
  setObjectClonedMaterials,
  setObjectSpecularColor,
  setObjectFogColor
};

// dist/pp/cauldron/wl/utils/text_utils.js
import { TextComponent as TextComponent6 } from "@wonderlandengine/api";
function setClonedMaterials(object) {
  let textComponents = object.pp_getComponents(TextComponent6);
  for (let textComponent of textComponents) {
    if (textComponent.material != null) {
      textComponent.material = textComponent.material.clone();
    }
  }
}
var TextUtils = {
  setClonedMaterials
};

// dist/pp/debug/components/debug_transform_component.js
import { Component as Component30, Property as Property18 } from "@wonderlandengine/api";
var DebugTransformComponent = class extends Component30 {
  static TypeName = "pp-debug-transform";
  static Properties = {
    _myLength: Property18.float(0.1),
    _myThickness: Property18.float(5e-3)
  };
  start() {
    this._myStarted = false;
  }
  update(dt) {
    if (Globals.isDebugEnabled(this.engine)) {
      if (!this._myStarted) {
        this._myDebugVisualTransform = null;
        this._myDebugTransformParams = new VisualTransformParams(this.engine);
        this._myDebugTransformParams.myLength = this._myLength;
        this._myDebugTransformParams.myThickness = this._myThickness;
        this._myDebugVisualTransform = new VisualTransform(this._myDebugTransformParams);
        this._myDebugVisualTransform.setVisible(Globals.isDebugEnabled(this.engine));
        this._myStarted = true;
      } else {
        this.object.pp_getTransform(this._myDebugTransformParams.myTransform);
        this._myDebugVisualTransform.paramsUpdated();
        this._myDebugVisualTransform.setVisible(true);
      }
    }
  }
  onDeactivate() {
    if (this._myStarted) {
      this._myDebugVisualTransform.setVisible(false);
    }
  }
  onDestroy() {
    if (this._myStarted) {
      this._myDebugVisualTransform.destroy();
    }
  }
};

// dist/pp/debug/components/show_fps_component.js
import { Alignment as Alignment4, Component as Component31, Property as Property19, VerticalAlignment as VerticalAlignment4 } from "@wonderlandengine/api";
var ShowFPSComponent = class extends Component31 {
  static TypeName = "pp-show-fps";
  static Properties = {
    _myRefreshSeconds: Property19.float(0.25),
    _myScreenPositionX: Property19.float(1),
    _myScreenPositionY: Property19.float(-1),
    _myScreenPositionZ: Property19.float(1),
    _myScale: Property19.float(1.5),
    _myTextMaterial: Property19.material()
  };
  start() {
    this._myColor = vec4_create(1, 1, 1, 1);
    if (this._myTextMaterial != null) {
      this._myColor.vec4_copy(this._myTextMaterial.color);
    }
    this._myScreenPosition = vec3_create(this._myScreenPositionX, this._myScreenPositionY, this._myScreenPositionZ);
    this._myCurrentFPS = 0;
    this._myTimer = new Timer(this._myRefreshSeconds);
    this._myTotalDT = 0;
    this._myFrames = 0;
  }
  update(dt) {
    if (Globals.isDebugEnabled(this.engine) && Globals.getDebugVisualManager(this.engine) != null) {
      this._myTotalDT += dt;
      this._myFrames++;
      this._myTimer.update(dt);
      if (this._myTimer.isDone()) {
        this._myTimer.start();
        this._myCurrentFPS = Math.round(this._myFrames / this._myTotalDT);
        this._myTotalDT = 0;
        this._myFrames = 0;
      }
      Globals.getDebugVisualManager(this.engine).drawUIText(0, this._myCurrentFPS.toFixed(0), this._myScreenPosition, this._myScale, this._myColor, Alignment4.Right, VerticalAlignment4.Bottom);
    }
  }
};

// dist/pp/debug/components/toggle_active_on_button_press_component.js
import { Component as Component32, property as property7 } from "@wonderlandengine/api";
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ToggleActiveOnButtonPressComponent = class extends Component32 {
  static TypeName = "toggle-active-on-button-press";
  _myHandedness;
  _myButton;
  _myMultiplePressCount;
  _myHandednessType;
  _myButtonID;
  _myActive = false;
  start() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    switch (this._myButton) {
      case 0:
        this._myButtonID = GamepadButtonID.SELECT;
        break;
      case 1:
        this._myButtonID = GamepadButtonID.SQUEEZE;
        break;
      case 2:
        this._myButtonID = GamepadButtonID.THUMBSTICK;
        break;
      case 3:
        this._myButtonID = GamepadButtonID.TOP_BUTTON;
        break;
      case 4:
        this._myButtonID = GamepadButtonID.BOTTOM_BUTTON;
        break;
    }
    const components = this.object.pp_getComponents();
    for (const component of components) {
      if (component.active) {
        this._myActive = true;
        break;
      }
    }
  }
  update(dt) {
    if (Globals.isDebugEnabled() && Globals.getGamepad(this._myHandednessType).getButtonInfo(this._myButtonID).isPressEnd(this._myMultiplePressCount > 0 ? this._myMultiplePressCount : null)) {
      this.object.pp_setActive(!this._myActive);
      this.active = true;
      this._myActive = !this._myActive;
    }
  }
};
__decorate7([
  property7.enum(["Left", "Right"], "Left")
], ToggleActiveOnButtonPressComponent.prototype, "_myHandedness", void 0);
__decorate7([
  property7.enum(["Select", "Squeeze", "Thumstick", "Top Button", "Bottom Button"], "Bottom Button")
], ToggleActiveOnButtonPressComponent.prototype, "_myButton", void 0);
__decorate7([
  property7.int(2)
], ToggleActiveOnButtonPressComponent.prototype, "_myMultiplePressCount", void 0);

// dist/pp/debug/debug_functions_overwriter/debug_functions_overwriter.js
var DebugFunctionsOverwriterParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myObjectsByReference = [];
    this.myObjectsByPath = [];
    this.myClassesByReference = [];
    this.myClassesByPath = [];
    this.myFunctionsByPath = [];
    this.myExcludeConstructors = false;
    this.myExcludeJSObjectFunctions = false;
    this.myFunctionNamesToInclude = [];
    this.myFunctionNamesToExclude = [];
    this.myFunctionPathsToInclude = [];
    this.myFunctionPathsToExclude = [];
    this.myObjectAddObjectDescendantsDepthLevel = 0;
    this.myObjectAddClassDescendantsDepthLevel = 0;
    this.myObjectNamesToInclude = [];
    this.myObjectNamesToExclude = [];
    this.myClassNamesToInclude = [];
    this.myClassNamesToExclude = [];
    this.myObjectPathsToInclude = [];
    this.myObjectPathsToExclude = [];
    this.myClassPathsToInclude = [];
    this.myClassPathsToExclude = [];
    this.myLogEnabled = false;
    this.myEngine = engine;
  }
};
var DebugFunctionsOverwriter = class {
  constructor(params = new DebugFunctionsOverwriterParams()) {
    this._myParams = params;
    this._myPropertiesAlreadyOverwritten = /* @__PURE__ */ new Map();
  }
  overwriteFunctions() {
    let classesAndParents = this._getReferencesAndParents(this._myParams.myClassesByReference, this._myParams.myClassesByPath, true);
    let objectsAndParents = this._getReferencesAndParents(this._myParams.myObjectsByReference, this._myParams.myObjectsByPath, false);
    let functionsAndParents = this._getReferencesAndParents([], this._myParams.myFunctionsByPath, false);
    this._objectAddDescendants(objectsAndParents, classesAndParents);
    for (let referenceAndParent of classesAndParents) {
      let reference = referenceAndParent[0];
      let referenceParent = referenceAndParent[1];
      let referenceName = referenceAndParent[2];
      let referencePath = referenceAndParent[3];
      let referenceNameForFilter = referenceAndParent[4];
      this._overwriteReferenceFunctions(reference, referenceParent, referenceName, referencePath, referenceNameForFilter, true);
    }
    for (let referenceAndParent of objectsAndParents) {
      let reference = referenceAndParent[0];
      let referenceParent = referenceAndParent[1];
      let referenceName = referenceAndParent[2];
      let referencePath = referenceAndParent[3];
      let referenceNameForFilter = referenceAndParent[4];
      this._overwriteReferenceFunctions(reference, referenceParent, referenceName, referencePath, referenceNameForFilter, false);
    }
    for (let referenceAndParent of functionsAndParents) {
      let referenceParent = referenceAndParent[1];
      let referenceName = referenceAndParent[2];
      let referencePath = referenceAndParent[3];
      this._overwriteFunction(referenceParent, referenceName, null, null, referencePath, false, true);
    }
  }
  // Hooks
  _getOverwrittenFunction(reference, propertyName, referencePath, isClass2, isFunction2) {
    return JSUtils.getObjectProperty(reference, propertyName);
  }
  _getOverwrittenConstructor(reference, propertyName, referencePath, isClass2, isFunction2) {
    return JSUtils.getObjectProperty(reference, propertyName);
  }
  _onOverwriteSuccess(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2, isConstructor) {
  }
  _onOverwriteFailure(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2, isConstructor) {
  }
  // Hooks end
  _overwriteReferenceFunctions(reference, referenceParent, referenceName, referencePath, referenceNameForFilter, isClass2) {
    let includePathList = this._myParams.myObjectPathsToInclude;
    let excludePathList = this._myParams.myObjectPathsToExclude;
    let includeNameList = this._myParams.myObjectNamesToInclude;
    let excludeNameList = this._myParams.myObjectNamesToExclude;
    if (isClass2) {
      includePathList = this._myParams.myClassPathsToInclude;
      excludePathList = this._myParams.myClassPathsToExclude;
      includeNameList = this._myParams.myClassNamesToInclude;
      excludeNameList = this._myParams.myClassNamesToExclude;
    }
    let validReferencePath = this._filterName(referencePath, includePathList, excludePathList);
    let validReferenceName = this._filterName(referenceNameForFilter, includeNameList, excludeNameList);
    if (validReferencePath && validReferenceName) {
      let propertyNames = JSUtils.getObjectPropertyNames(reference);
      if (propertyNames.pp_hasEqual("constructor")) {
        propertyNames.unshift("constructor");
      }
      for (let propertyName of propertyNames) {
        let overwriteTargetReference = null;
        let referenceParentForConstructor = null;
        let referenceNameForConstructor = null;
        if (isClass2) {
          let fixedReference = reference;
          if (referenceParent != null) {
            let ownReferenceDescriptor = Object.getOwnPropertyDescriptor(referenceParent, referenceName);
            if (ownReferenceDescriptor != null && ownReferenceDescriptor.value != null) {
              fixedReference = ownReferenceDescriptor.value;
            }
          }
          overwriteTargetReference = fixedReference.prototype;
          if (overwriteTargetReference == null) {
            overwriteTargetReference = fixedReference;
          } else {
            try {
              let referenceProperty = JSUtils.getObjectProperty(overwriteTargetReference, propertyName);
              if (referenceProperty == null) {
                overwriteTargetReference = fixedReference;
              }
            } catch (error4) {
              overwriteTargetReference = fixedReference;
            }
          }
          referenceParentForConstructor = referenceParent;
          referenceNameForConstructor = referenceName;
        } else {
          overwriteTargetReference = reference;
        }
        this._overwriteFunction(overwriteTargetReference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, false);
      }
    }
  }
  _overwriteFunction(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2) {
    try {
      let propertyCountedAlready = this._myPropertiesAlreadyOverwritten.get(propertyName) != null && this._myPropertiesAlreadyOverwritten.get(propertyName).pp_hasEqual(reference);
      if (!propertyCountedAlready) {
        if (JSUtils.isFunctionByName(reference, propertyName) || propertyName == "constructor" && JSUtils.isClassByName(reference, propertyName)) {
          if (!this._myParams.myExcludeJSObjectFunctions || !this._isJSObjectFunction(propertyName)) {
            let validFunctionName = this._filterName(propertyName, this._myParams.myFunctionNamesToInclude, this._myParams.myFunctionNamesToExclude);
            let validFunctionPath = this._filterName((referencePath != null ? referencePath + "." : "") + propertyName, this._myParams.myFunctionPathsToInclude, this._myParams.myFunctionPathsToExclude);
            if (validFunctionName && validFunctionPath) {
              if (!this._myPropertiesAlreadyOverwritten.has(propertyName)) {
                this._myPropertiesAlreadyOverwritten.set(propertyName, []);
              }
              let overwriteSuccess = false;
              let isConstructor = false;
              if (propertyName != "constructor") {
                try {
                  let newFunction = this._getOverwrittenFunction(reference, propertyName, referencePath, isClass2, isFunction2);
                  if (newFunction != JSUtils.getObjectProperty(reference, propertyName)) {
                    overwriteSuccess = JSUtils.overwriteObjectProperty(newFunction, reference, propertyName, false, true, this._myParams.myLogEnabled);
                  } else {
                    overwriteSuccess = true;
                  }
                } catch (error4) {
                  overwriteSuccess = false;
                  if (this._myParams.myLogEnabled) {
                    console.error(error4);
                  }
                }
              } else if (!this._myParams.myExcludeConstructors && isClass2 && referenceParentForConstructor != null) {
                let referenceForConstructor = JSUtils.getObjectProperty(referenceParentForConstructor, referenceNameForConstructor);
                if (referenceForConstructor != null && referenceForConstructor.prototype != null) {
                  isConstructor = true;
                  try {
                    let newConstructor = this._getOverwrittenConstructor(referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2);
                    if (newConstructor != referenceForConstructor) {
                      overwriteSuccess = JSUtils.overwriteObjectProperty(newConstructor, referenceParentForConstructor, referenceNameForConstructor, false, true, this._myParams.myLogEnabled);
                      if (overwriteSuccess) {
                        overwriteSuccess = JSUtils.overwriteObjectProperty(newConstructor, referenceForConstructor.prototype, propertyName, false, true, this._myParams.myLogEnabled);
                      }
                    } else {
                      overwriteSuccess = true;
                    }
                  } catch (error4) {
                    overwriteSuccess = false;
                    if (this._myParams.myLogEnabled) {
                      console.error(error4);
                    }
                  }
                }
              }
              if (overwriteSuccess) {
                this._myPropertiesAlreadyOverwritten.get(propertyName).push(reference);
                this._onOverwriteSuccess(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2, isConstructor);
              } else {
                this._onOverwriteFailure(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2, isConstructor);
              }
            }
          }
        }
      }
    } catch (error4) {
      if (this._myParams.myLogEnabled) {
        console.error(error4);
      }
    }
  }
  _getReferencesAndParents(byReferenceList, byPathList, isClass2) {
    let referenceAndParents = [];
    let equalCallback = (first2, second) => first2[0] == second[0];
    for (let pathPair of byPathList) {
      let path = pathPair;
      let referenceName = "";
      let referencePath = pathPair;
      let referenceNameForFilter = "";
      if (pathPair != null && Array.isArray(pathPair) && pathPair.length != null && pathPair.length == 2 && typeof pathPair[1] == "string") {
        path = pathPair[0];
        referencePath = pathPair[1];
      }
      referenceName = JSUtils.getObjectNameFromPath(path);
      referenceNameForFilter = JSUtils.getObjectNameFromPath(referencePath);
      let reference = JSUtils.getObjectFromPath(path, window);
      let referenceParent = JSUtils.getObjectParentFromPath(path, window);
      if (reference != null) {
        referenceAndParents.pp_pushUnique([reference, referenceParent, referenceName, referencePath, referenceNameForFilter], equalCallback);
      }
    }
    for (let referencePair of byReferenceList) {
      let reference = referencePair;
      let referenceName = "";
      let referencePath = "";
      let referenceNameForFilter = "";
      if (referencePair != null && referencePair.length != null && referencePair.length == 2 && typeof referencePair[1] == "string") {
        reference = referencePair[0];
        referencePath = referencePair[1];
        referenceNameForFilter = JSUtils.getObjectNameFromPath(referencePath);
      } else {
        referencePath = isClass2 ? reference.name : null;
        referenceNameForFilter = isClass2 ? reference.name : null;
      }
      if (isClass2) {
        referenceName = reference.name;
      } else {
        referenceName = JSUtils.getObjectNameFromPath(referencePath);
      }
      if (reference != null) {
        referenceAndParents.pp_pushUnique([reference, null, referenceName, referencePath, referenceNameForFilter], equalCallback);
      }
    }
    return referenceAndParents;
  }
  _objectAddDescendants(objectsAndParents, classesAndParents) {
    let equalCallback = (first2, second) => first2[0] == second[0];
    let objectsToVisit = [];
    for (let objectAndParent of objectsAndParents) {
      objectsToVisit.pp_pushUnique([objectAndParent[0], 0, objectAndParent[3]], equalCallback);
    }
    while (objectsToVisit.length > 0) {
      let objectToVisit = objectsToVisit.shift();
      let object = objectToVisit[0];
      let objectLevel = objectToVisit[1];
      let objectPath = objectToVisit[2];
      if (objectLevel + 1 <= this._myParams.myObjectAddObjectDescendantsDepthLevel || this._myParams.myObjectAddObjectDescendantsDepthLevel == -1 || objectLevel + 1 <= this._myParams.myObjectAddClassDescendantsDepthLevel || this._myParams.myObjectAddClassDescendantsDepthLevel == -1) {
        let propertyNames = null;
        try {
          propertyNames = JSUtils.getObjectPropertyNames(object);
        } catch (error4) {
          continue;
        }
        for (let propertyName of propertyNames) {
          let objectProperty = null;
          try {
            objectProperty = JSUtils.getObjectProperty(object, propertyName);
            if (objectProperty == null) {
              continue;
            }
          } catch (error4) {
            continue;
          }
          let currentPath = "";
          let currentName = "";
          if (objectPath != null) {
            currentName = propertyName;
            currentPath = objectPath + "." + currentName;
          } else {
            currentName = propertyName;
            currentPath = currentName;
          }
          let isClass2 = JSUtils.isClassByName(object, propertyName);
          let isObject2 = JSUtils.isObjectByName(object, propertyName);
          let includePathList = this._myParams.myObjectPathsToInclude;
          let excludePathList = this._myParams.myObjectPathsToExclude;
          let includeNameList = this._myParams.myObjectNamesToInclude;
          let excludeNameList = this._myParams.myObjectNamesToExclude;
          if (isClass2) {
            includePathList = this._myParams.myClassPathsToInclude;
            excludePathList = this._myParams.myClassPathsToExclude;
            includeNameList = this._myParams.myClassNamesToInclude;
            excludeNameList = this._myParams.myClassNamesToExclude;
          }
          let validReferencePath = this._filterName(currentPath, includePathList, excludePathList);
          let validReferenceName = this._filterName(propertyName, includeNameList, excludeNameList);
          if (validReferencePath && validReferenceName) {
            if (isObject2 && (objectLevel + 1 <= this._myParams.myObjectAddObjectDescendantsDepthLevel || this._myParams.myObjectAddObjectDescendantsDepthLevel == -1)) {
              objectsAndParents.pp_pushUnique([objectProperty, object, propertyName, currentPath, currentName], equalCallback);
            }
            if (isClass2 && propertyName != "constructor" && (objectLevel + 1 <= this._myParams.myObjectAddClassDescendantsDepthLevel || this._myParams.myObjectAddClassDescendantsDepthLevel == -1)) {
              classesAndParents.pp_pushUnique([objectProperty, object, propertyName, currentPath, currentName], equalCallback);
            }
            if (isObject2) {
              objectsToVisit.pp_pushUnique([objectProperty, objectLevel + 1, currentPath], equalCallback);
            }
          }
        }
      }
    }
  }
  _filterName(name, includeList, excludeList) {
    let validName = includeList.length == 0;
    for (let includeName of includeList) {
      if (name.match(includeName) != null) {
        validName = true;
        break;
      }
    }
    if (validName) {
      for (let excludeName of excludeList) {
        if (name.match(excludeName) != null) {
          validName = false;
          break;
        }
      }
    }
    return validName;
  }
  _isJSObjectFunction(propertyName) {
  }
};
DebugFunctionsOverwriter.prototype._isJSObjectFunction = /* @__PURE__ */ function() {
  let jsObjectFunctions = [
    "__defineGetter__",
    "__defineSetter__",
    "hasOwnProperty",
    "__lookupGetter__",
    "__lookupSetter__",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toString",
    "valueOf",
    "__proto__",
    "toLocaleString",
    "arguments",
    "caller",
    "apply",
    "bind",
    "call",
    "callee"
  ];
  return function _isJSObjectFunction(propertyName) {
    return jsObjectFunctions.pp_hasEqual(propertyName);
  };
}();

// dist/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/debug_functions_performance_analyzer.js
var DebugFunctionsPerformanceAnalyzerParams = class extends DebugFunctionsOverwriterParams {
  constructor() {
    super();
    this.myExecutionTimeAnalysisEnabled = true;
    this.myAddPathPrefixToFunctionID = true;
    this.myFilterDebugFunctionsPerformanceAnalyzerClasses = true;
  }
};
var DebugFunctionPerformanceAnalysisResults = class {
  constructor() {
    this.myReference = null;
    this.myName = "";
    this.myPath = "";
    this.myID = "";
    this.myCallsCount = 0;
    this.myTotalExecutionTime = 0;
    this.myTotalExecutionTimePercentage = 0;
    this.myAverageExecutionTime = 0;
    this.myTimeElapsedSinceLastReset = 0;
    this._myTotalExecutionTimeInternal = 0;
  }
  reset() {
    this.myCallsCount = 0;
    this.myTotalExecutionTime = 0;
    this.myTotalExecutionTimePercentage = 0;
    this.myAverageExecutionTime = 0;
    this.myTimeElapsedSinceLastReset = 0;
    this._myTotalExecutionTimeInternal = 0;
  }
  max(other) {
    this.myCallsCount = Math.max(this.myCallsCount, other.myCallsCount);
    this.myTotalExecutionTime = Math.max(this.myTotalExecutionTime, other.myTotalExecutionTime);
    this.myTotalExecutionTimePercentage = Math.max(this.myTotalExecutionTimePercentage, other.myTotalExecutionTimePercentage);
    this.myAverageExecutionTime = Math.max(this.myAverageExecutionTime, other.myAverageExecutionTime);
  }
  copy(other) {
    this.myReference = other.myReference;
    this.myName = other.myName;
    this.myPath = other.myPath;
    this.myID = other.myID;
    this.myCallsCount = other.myCallsCount;
    this.myTotalExecutionTime = other.myTotalExecutionTime;
    this.myTotalExecutionTimePercentage = other.myTotalExecutionTimePercentage;
    this.myAverageExecutionTime = other.myAverageExecutionTime;
    this.myTimeElapsedSinceLastReset = other.myTimeElapsedSinceLastReset;
    this._myTotalExecutionTimeInternal = other._myTotalExecutionTimeInternal;
  }
};
var DebugFunctionsPerformanceAnalyzerSortOrder = {
  NONE: 0,
  CALLS_COUNT: 1,
  TOTAL_EXECUTION_TIME: 2,
  AVERAGE_EXECUTION_TIME: 3
};
var DebugFunctionsPerformanceAnalyzer = class _DebugFunctionsPerformanceAnalyzer extends DebugFunctionsOverwriter {
  constructor(params = new DebugFunctionsPerformanceAnalyzerParams()) {
    super(params);
    this._myFunctionPerformanceAnalysisResults = /* @__PURE__ */ new Map();
    this._myFunctionPerformanceAnalysisMaxResults = /* @__PURE__ */ new Map();
    this._myResultsAlreadyAdded = false;
    this._myExecutionTimes = {
      myOverheadExecutionTimeSinceLastReset: 0,
      myLastFunctionExecutionTime: 0,
      myOriginalFunctionOverheadExecutionTimes: []
    };
    this._myTimeOfLastReset = window.performance.now();
    this._myMaxTimeElapsedSinceLastReset = 0;
    let originalPush = Array.prototype["push"];
    let originalPop = Array.prototype["pop"];
    this._myExecutionTimes.myOriginalFunctionOverheadExecutionTimes.push = function() {
      return originalPush.bind(this)(...arguments);
    };
    this._myExecutionTimes.myOriginalFunctionOverheadExecutionTimes.pop = function() {
      return originalPop.bind(this)(...arguments);
    };
  }
  overwriteFunctions() {
    super.overwriteFunctions();
    this.resetResults();
    this.resetMaxResults();
  }
  getTimeElapsedSinceLastReset() {
    return window.performance.now() - this._myTimeOfLastReset - this._myExecutionTimes.myOverheadExecutionTimeSinceLastReset;
  }
  getMaxTimeElapsedSinceLastReset() {
    this._myMaxTimeElapsedSinceLastReset = Math.max(this._myMaxTimeElapsedSinceLastReset, this.getTimeElapsedSinceLastReset());
    return this._myMaxTimeElapsedSinceLastReset;
  }
  resetResults() {
    this._updateDerivatesResults();
    this._updateMaxResults();
    for (let property19 of this._myFunctionPerformanceAnalysisResults.keys()) {
      this._myFunctionPerformanceAnalysisResults.get(property19).reset();
    }
    this._myExecutionTimes.myOverheadExecutionTimeSinceLastReset = 0;
    this._myTimeOfLastReset = window.performance.now();
  }
  resetMaxResults() {
    this._myMaxTimeElapsedSinceLastReset = 0;
    for (let property19 of this._myFunctionPerformanceAnalysisMaxResults.keys()) {
      this._myFunctionPerformanceAnalysisMaxResults.get(property19).reset();
    }
  }
  getResults(sortOrder = DebugFunctionsPerformanceAnalyzerSortOrder.NONE) {
    this._updateDerivatesResults();
    this._updateMaxResults();
    let results = this._myFunctionPerformanceAnalysisResults;
    results = this._sortResults(results, sortOrder);
    return results;
  }
  getMaxResults(sortOrder = DebugFunctionsPerformanceAnalyzerSortOrder.NONE) {
    this._updateDerivatesResults();
    this._updateMaxResults();
    let results = this._myFunctionPerformanceAnalysisMaxResults;
    results = this._sortResults(results, sortOrder);
    return results;
  }
  _getOverwrittenFunction(reference, propertyName, referencePath, isClass2, isFunction2) {
    return this._getOverwrittenFunctionInternal(reference, propertyName, referencePath, isClass2, isFunction2, false);
  }
  _getOverwrittenConstructor(reference, propertyName, referencePath, isClass2, isFunction2) {
    return this._getOverwrittenFunctionInternal(reference, propertyName, referencePath, isClass2, isFunction2, true);
  }
  _onOverwriteSuccess(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2, isConstructor) {
    this._myResultsAlreadyAdded = false;
  }
  _onOverwriteFailure(reference, propertyName, referenceParentForConstructor, referenceNameForConstructor, referencePath, isClass2, isFunction2, isConstructor) {
    if (this._myResultsAlreadyAdded) {
      let propertyID = this._getPropertyID(propertyName, referencePath, isFunction2, isConstructor);
      this._myFunctionPerformanceAnalysisResults.delete(propertyID);
    }
  }
  _sortResults(results, sortOrder) {
    let sortedResults = results;
    if (sortOrder != DebugFunctionsPerformanceAnalyzerSortOrder.NONE) {
      sortedResults = new Map([...results.entries()].sort(function(first2, second) {
        let sortResult = 0;
        if (sortOrder == DebugFunctionsPerformanceAnalyzerSortOrder.CALLS_COUNT) {
          sortResult = -(first2[1].myCallsCount - second[1].myCallsCount);
          if (sortResult == 0) {
            sortResult = -(first2[1].myTotalExecutionTime - second[1].myTotalExecutionTime);
            if (sortResult == 0) {
              sortResult = -(first2[1].myAverageExecutionTime - second[1].myAverageExecutionTime);
            }
          }
        } else if (sortOrder == DebugFunctionsPerformanceAnalyzerSortOrder.TOTAL_EXECUTION_TIME) {
          sortResult = -(first2[1].myTotalExecutionTime - second[1].myTotalExecutionTime);
          if (sortResult == 0) {
            sortResult = -(first2[1].myAverageExecutionTime - second[1].myAverageExecutionTime);
            if (sortResult == 0) {
              sortResult = -(first2[1].myCallsCount - second[1].myCallsCount);
            }
          }
        } else {
          sortResult = -(first2[1].myAverageExecutionTime - second[1].myAverageExecutionTime);
          if (sortResult == 0) {
            sortResult = -(first2[1].myTotalExecutionTime - second[1].myTotalExecutionTime);
            if (sortResult == 0) {
              sortResult = -(first2[1].myCallsCount - second[1].myCallsCount);
            }
          }
        }
        return sortResult;
      }));
    }
    return sortedResults;
  }
  _getPropertyID(propertyName, referencePath, isFunction2, isConstructor) {
    let id = isConstructor ? "constructor" : propertyName;
    if (referencePath != null && this._myParams.myAddPathPrefixToFunctionID) {
      if (!isFunction2) {
        id = referencePath + "." + id;
      } else {
        id = referencePath;
      }
    }
    return id;
  }
  _updateDerivatesResults() {
    let timeElapsedSinceLastReset = this.getTimeElapsedSinceLastReset();
    let beforeTime = window.performance.now();
    for (let property19 of this._myFunctionPerformanceAnalysisResults.keys()) {
      let results = this._myFunctionPerformanceAnalysisResults.get(property19);
      if (timeElapsedSinceLastReset != 0) {
        results.myTotalExecutionTimePercentage = results.myTotalExecutionTime / timeElapsedSinceLastReset;
      } else {
        if (results.myCallsCount != 0) {
          results.myTotalExecutionTimePercentage = 1;
        } else {
          results.myTotalExecutionTimePercentage = 0;
        }
      }
      if (results.myCallsCount != 0) {
        results.myAverageExecutionTime = results.myTotalExecutionTime / results.myCallsCount;
      } else {
        results.myAverageExecutionTime = 0;
      }
      results.myTimeElapsedSinceLastReset = timeElapsedSinceLastReset;
    }
    this._myExecutionTimes.myOverheadExecutionTimeSinceLastReset += window.performance.now() - beforeTime;
  }
  _updateMaxResults() {
    let beforeTime = window.performance.now();
    this._myMaxTimeElapsedSinceLastReset = Math.max(this._myMaxTimeElapsedSinceLastReset, this.getTimeElapsedSinceLastReset());
    for (let property19 of this._myFunctionPerformanceAnalysisResults.keys()) {
      if (this._myFunctionPerformanceAnalysisMaxResults.has(property19)) {
        this._myFunctionPerformanceAnalysisMaxResults.get(property19).max(this._myFunctionPerformanceAnalysisResults.get(property19));
      } else {
        let maxResults = new DebugFunctionPerformanceAnalysisResults();
        maxResults.copy(this._myFunctionPerformanceAnalysisResults.get(property19));
        this._myFunctionPerformanceAnalysisMaxResults.set(property19, maxResults);
      }
    }
    this._myExecutionTimes.myOverheadExecutionTimeSinceLastReset += window.performance.now() - beforeTime;
  }
  _getOverwrittenFunctionInternal(reference, propertyName, referencePath, isClass2, isFunction2, isConstructor) {
    let newFunction = JSUtils.getObjectProperty(reference, propertyName);
    if (!this._myParams.myFilterDebugFunctionsPerformanceAnalyzerClasses || !this._isPerformanceAnalyzer(reference, propertyName, isClass2)) {
      if (propertyName != "_myPerformanceAnalyzerOriginalFunction") {
        let propertyID = this._getPropertyID(propertyName, referencePath, isFunction2, isConstructor);
        this._myResultsAlreadyAdded = this._myFunctionPerformanceAnalysisResults.has(propertyID);
        let analysisResults = new DebugFunctionPerformanceAnalysisResults();
        analysisResults.myReference = reference;
        analysisResults.myName = propertyName;
        analysisResults.myPath = referencePath;
        analysisResults.myID = referencePath;
        this._myFunctionPerformanceAnalysisResults.set(propertyID, analysisResults);
        try {
          let functionPerformanceAnalysisResults = this._myFunctionPerformanceAnalysisResults.get(propertyID);
          let executionTimes = this._myExecutionTimes;
          let originalFunction = reference[propertyName];
          let functionCallOverhead = 175e-6;
          let overheadError = 35e-5;
          let executionTimeAnalysisEnabled = this._myParams.myExecutionTimeAnalysisEnabled;
          if (!isConstructor) {
            newFunction = function() {
              let startTime = window.performance.now();
              let errorToThrow = null;
              let returnValue = void 0;
              let boundOriginalFunction = null;
              let startOriginalFunctionTime = 0;
              let endOriginalFunctionTime = 0;
              let originalFunctionOverheadExecutionTime = 0;
              let executionTimeToAdjust = 0;
              let executionTime = 0;
              let beforeOverhead = 0;
              let inBetweenOverhead = 0;
              if (executionTimeAnalysisEnabled) {
                executionTimes.myOriginalFunctionOverheadExecutionTimes.push(0);
                startOriginalFunctionTime = window.performance.now();
                endOriginalFunctionTime = window.performance.now();
                try {
                  boundOriginalFunction = originalFunction.bind(this);
                  startOriginalFunctionTime = window.performance.now();
                  returnValue = boundOriginalFunction(...arguments);
                  endOriginalFunctionTime = window.performance.now();
                } catch (error4) {
                  endOriginalFunctionTime = window.performance.now();
                  errorToThrow = error4;
                }
              } else {
                try {
                  boundOriginalFunction = originalFunction.bind(this);
                  returnValue = boundOriginalFunction(...arguments);
                } catch (error4) {
                  errorToThrow = error4;
                }
              }
              functionPerformanceAnalysisResults.myCallsCount += 1;
              if (executionTimeAnalysisEnabled) {
                originalFunctionOverheadExecutionTime = executionTimes.myOriginalFunctionOverheadExecutionTimes.pop();
                executionTimeToAdjust = endOriginalFunctionTime - startOriginalFunctionTime - originalFunctionOverheadExecutionTime;
                executionTime = executionTimeToAdjust - functionCallOverhead;
                if (originalFunction._myPerformanceAnalyzerHasBeenOverwritten) {
                  executionTime = executionTimes.myLastFunctionExecutionTime;
                }
                functionPerformanceAnalysisResults._myTotalExecutionTimeInternal += executionTime;
                functionPerformanceAnalysisResults.myTotalExecutionTime = Math.max(0, functionPerformanceAnalysisResults._myTotalExecutionTimeInternal);
                executionTimes.myLastFunctionExecutionTime = executionTime;
                beforeOverhead = startOriginalFunctionTime - startTime;
                inBetweenOverhead = beforeOverhead - endOriginalFunctionTime - overheadError;
                if (executionTimes.myOriginalFunctionOverheadExecutionTimes.length > 0) {
                  executionTimes.myOriginalFunctionOverheadExecutionTimes[executionTimes.myOriginalFunctionOverheadExecutionTimes.length - 1] += inBetweenOverhead + originalFunctionOverheadExecutionTime + overheadError * 2.75;
                  executionTimes.myOriginalFunctionOverheadExecutionTimes[executionTimes.myOriginalFunctionOverheadExecutionTimes.length - 1] += window.performance.now();
                }
                executionTimes.myOverheadExecutionTimeSinceLastReset += inBetweenOverhead;
                executionTimes.myOverheadExecutionTimeSinceLastReset += window.performance.now();
              }
              if (errorToThrow != null) {
                throw errorToThrow;
              }
              return returnValue;
            };
          } else {
            newFunction = function() {
              let startTime = window.performance.now();
              let errorToThrow = null;
              let returnValue = void 0;
              let startOriginalFunctionTime = 0;
              let endOriginalFunctionTime = 0;
              let originalFunctionOverheadExecutionTime = 0;
              let executionTimeToAdjust = 0;
              let executionTime = 0;
              let beforeOverhead = 0;
              let inBetweenOverhead = 0;
              if (executionTimeAnalysisEnabled) {
                executionTimes.myOriginalFunctionOverheadExecutionTimes.push(0);
                startOriginalFunctionTime = window.performance.now();
                endOriginalFunctionTime = window.performance.now();
                try {
                  startOriginalFunctionTime = window.performance.now();
                  returnValue = new originalFunction(...arguments);
                  endOriginalFunctionTime = window.performance.now();
                } catch (error4) {
                  endOriginalFunctionTime = window.performance.now();
                  errorToThrow = error4;
                }
              } else {
                try {
                  returnValue = new originalFunction(...arguments);
                } catch (error4) {
                  errorToThrow = error4;
                }
              }
              functionPerformanceAnalysisResults.myCallsCount += 1;
              if (executionTimeAnalysisEnabled) {
                originalFunctionOverheadExecutionTime = executionTimes.myOriginalFunctionOverheadExecutionTimes.pop();
                executionTimeToAdjust = endOriginalFunctionTime - startOriginalFunctionTime - originalFunctionOverheadExecutionTime;
                executionTime = executionTimeToAdjust - functionCallOverhead;
                if (originalFunction._myPerformanceAnalyzerHasBeenOverwritten) {
                  executionTime = executionTimes.myLastFunctionExecutionTime;
                }
                functionPerformanceAnalysisResults._myTotalExecutionTimeInternal += executionTime;
                functionPerformanceAnalysisResults.myTotalExecutionTime = Math.max(0, functionPerformanceAnalysisResults._myTotalExecutionTimeInternal);
                executionTimes.myLastFunctionExecutionTime = executionTime;
                beforeOverhead = startOriginalFunctionTime - startTime;
                inBetweenOverhead = beforeOverhead - endOriginalFunctionTime - overheadError;
                if (executionTimes.myOriginalFunctionOverheadExecutionTimes.length > 0) {
                  executionTimes.myOriginalFunctionOverheadExecutionTimes[executionTimes.myOriginalFunctionOverheadExecutionTimes.length - 1] += inBetweenOverhead + originalFunctionOverheadExecutionTime + overheadError * 2.75;
                  executionTimes.myOriginalFunctionOverheadExecutionTimes[executionTimes.myOriginalFunctionOverheadExecutionTimes.length - 1] += window.performance.now();
                }
                executionTimes.myOverheadExecutionTimeSinceLastReset += inBetweenOverhead;
                executionTimes.myOverheadExecutionTimeSinceLastReset += window.performance.now();
              }
              if (errorToThrow != null) {
                throw errorToThrow;
              }
              return returnValue;
            };
          }
          if (newFunction != null) {
            Object.defineProperty(newFunction, "_myPerformanceAnalyzerHasBeenOverwritten", {
              value: true,
              enumerable: false,
              configurable: false,
              writable: false
            });
            Object.defineProperty(newFunction, "_myPerformanceAnalyzerOriginalFunction", {
              value: originalFunction,
              enumerable: false,
              configurable: false,
              writable: false
            });
          }
        } catch (error4) {
          if (this._myParams.myLogEnabled) {
            console.error("Function:", propertyName, "of:", reference, "can't be overwritten.\nError:", error4);
          }
        }
      }
    }
    return newFunction;
  }
  _isPerformanceAnalyzer(reference, propertyName, isClass2) {
    let isPerformanceAnalyzer = false;
    if (isClass2) {
      if (reference == _DebugFunctionsPerformanceAnalyzer.prototype || reference == DebugFunctionPerformanceAnalysisResults.prototype) {
        isPerformanceAnalyzer = true;
      }
    }
    return isPerformanceAnalyzer;
  }
};

// dist/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/debug_functions_performance_analysis_results_logger.js
var DebugFunctionsPerformanceAnalysisResultsLoggerParams = class {
  constructor() {
    this.myPerformanceAnalyzer = null;
    this.myLogTitle = "Functions Performance Analysis Results";
    this.mySecondsBetweenLogs = 1;
    this.myLogFunction = "log";
    this.myFormatLog = true;
    this.myFormatLogIndentationCharacter = "-";
    this.myLogMaxResults = false;
    this.myLogSortOrder = DebugFunctionsPerformanceAnalyzerSortOrder.NONE;
    this.myLogMaxAmountOfFunctions = null;
    this.myLogFunctionsWithCallsCountAbove = null;
    this.myLogFunctionsWithTotalExecutionTimePercentageAbove = null;
    this.myLogCallsCountResults = false;
    this.myLogTotalExecutionTimeResults = false;
    this.myLogTotalExecutionTimePercentageResults = false;
    this.myLogAverageExecutionTimeResults = false;
    this.myClearConsoleBeforeLog = false;
  }
};
var DebugFunctionsPerformanceAnalysisResultsLogger = class {
  constructor(params) {
    this._myParams = params;
    this._myLogTimer = new Timer(this._myParams.mySecondsBetweenLogs);
    this._myMaxNameLength = 0;
    this._myMaxCallsCountLength = 0;
    this._myMaxTotalExecutionTimeLength = 0;
    this._myMaxTotalExecutionTimePercentageLength = 0;
    this._myMaxAverageExecutionTimeLength = 0;
  }
  update(dt) {
    if (this._myParams.myPerformanceAnalyzer == null) {
      return;
    }
    this._myLogTimer.update(dt);
    if (this._myLogTimer.isDone()) {
      this._myLogTimer.start();
      let timeSinceLastReset = this._myParams.myPerformanceAnalyzer.getTimeElapsedSinceLastReset();
      if (this._myParams.myLogMaxResults) {
        timeSinceLastReset = this._myParams.myPerformanceAnalyzer.getMaxTimeElapsedSinceLastReset();
      }
      let analysisResults = null;
      if (!this._myParams.myLogMaxResults) {
        analysisResults = this._myParams.myPerformanceAnalyzer.getResults(this._myParams.myLogSortOrder);
      } else {
        analysisResults = this._myParams.myPerformanceAnalyzer.getMaxResults(this._myParams.myLogSortOrder);
      }
      if (this._myParams.myLogFunctionsWithCallsCountAbove != null) {
        let analysisResultsClone = new Map(analysisResults);
        analysisResults = /* @__PURE__ */ new Map();
        let keys = [...analysisResultsClone.keys()];
        for (let i = 0; i < keys.length; i++) {
          let results = analysisResultsClone.get(keys[i]);
          if (results.myCallsCount > this._myParams.myLogFunctionsWithCallsCountAbove) {
            analysisResults.set(keys[i], results);
          }
        }
      }
      if (this._myParams.myLogFunctionsWithTotalExecutionTimePercentageAbove != null) {
        let analysisResultsClone = new Map(analysisResults);
        analysisResults = /* @__PURE__ */ new Map();
        let keys = [...analysisResultsClone.keys()];
        for (let i = 0; i < keys.length; i++) {
          let results = analysisResultsClone.get(keys[i]);
          if (results.myTotalExecutionTimePercentage * 100 > this._myParams.myLogFunctionsWithTotalExecutionTimePercentageAbove) {
            analysisResults.set(keys[i], results);
          }
        }
      }
      if (this._myParams.myLogMaxAmountOfFunctions != null) {
        let analysisResultsClone = new Map(analysisResults);
        analysisResults = /* @__PURE__ */ new Map();
        let keys = [...analysisResultsClone.keys()];
        for (let i = 0; i < this._myParams.myLogMaxAmountOfFunctions && i < keys.length; i++) {
          let counter = analysisResultsClone.get(keys[i]);
          analysisResults.set(keys[i], counter);
        }
      }
      if (this._myParams.myClearConsoleBeforeLog) {
        console.clear();
      }
      let analysisResultsToLog = /* @__PURE__ */ new Map();
      for (let key of analysisResults.keys()) {
        let currentResults = analysisResults.get(key);
        let resultsToLog = {};
        if (this._myParams.myLogCallsCountResults) {
          resultsToLog.myCallsCount = currentResults.myCallsCount;
        }
        if (this._myParams.myLogTotalExecutionTimeResults) {
          resultsToLog.myTotalExecutionTime = currentResults.myTotalExecutionTime;
        }
        if (this._myParams.myLogTotalExecutionTimePercentageResults) {
          resultsToLog.myTotalExecutionTimePercentage = currentResults.myTotalExecutionTimePercentage;
        }
        if (this._myParams.myLogAverageExecutionTimeResults) {
          resultsToLog.myAverageExecutionTime = currentResults.myAverageExecutionTime;
        }
        analysisResultsToLog.set(key, resultsToLog);
      }
      let resultsText = "";
      for (let entry of analysisResults.entries()) {
        let name = entry[0];
        let results = entry[1];
        this._myMaxNameLength = Math.max(this._myMaxNameLength, name.length);
        this._myMaxCallsCountLength = Math.max(this._myMaxCallsCountLength, results.myCallsCount.toFixed(0).length);
        this._myMaxTotalExecutionTimeLength = Math.max(this._myMaxTotalExecutionTimeLength, results.myTotalExecutionTime.toFixed(5).length);
        this._myMaxTotalExecutionTimePercentageLength = Math.max(this._myMaxTotalExecutionTimePercentageLength, (results.myTotalExecutionTimePercentage * 100).toFixed(2).length);
        this._myMaxAverageExecutionTimeLength = Math.max(this._myMaxAverageExecutionTimeLength, results.myAverageExecutionTime.toFixed(5).length);
      }
      for (let entry of analysisResults.entries()) {
        let name = entry[0];
        let results = entry[1];
        let parametersToLog = 0;
        if (this._myParams.myLogCallsCountResults) {
          parametersToLog++;
        }
        if (this._myParams.myLogTotalExecutionTimeResults) {
          parametersToLog++;
        }
        if (this._myParams.myLogTotalExecutionTimePercentageResults) {
          parametersToLog++;
        }
        if (this._myParams.myLogAverageExecutionTimeResults) {
          parametersToLog++;
        }
        let textOrdered = [];
        let callsCountText = parametersToLog > 1 ? "Calls Count: " : "";
        if (this._myParams.myFormatLog) {
          for (let i = 0; i < this._myMaxCallsCountLength - results.myCallsCount.toFixed(0).length; i++) {
            callsCountText += " ";
          }
        }
        callsCountText += results.myCallsCount.toFixed(0);
        let totalExecutionTimeText = parametersToLog > 1 ? "Total Time: " : "";
        if (this._myParams.myFormatLog) {
          for (let i = 0; i < this._myMaxTotalExecutionTimeLength - results.myTotalExecutionTime.toFixed(5).length; i++) {
            totalExecutionTimeText += " ";
          }
        }
        totalExecutionTimeText += results.myTotalExecutionTime.toFixed(5) + "ms";
        let totalExecutionTimePercentageText = parametersToLog > 1 ? "Total Time: " : "";
        if (this._myParams.myFormatLog) {
          for (let i = 0; i < this._myMaxTotalExecutionTimePercentageLength - (results.myTotalExecutionTimePercentage * 100).toFixed(2).length; i++) {
            totalExecutionTimePercentageText += " ";
          }
        }
        totalExecutionTimePercentageText += (results.myTotalExecutionTimePercentage * 100).toFixed(2) + "%";
        let averageExecutionTimeText = parametersToLog > 1 ? "Average Time: " : "";
        if (this._myParams.myFormatLog) {
          for (let i = 0; i < this._myMaxAverageExecutionTimeLength - results.myAverageExecutionTime.toFixed(5).length; i++) {
            averageExecutionTimeText += " ";
          }
        }
        averageExecutionTimeText += results.myAverageExecutionTime.toFixed(5) + "ms";
        if (!this._myParams.myLogCallsCountResults) {
          callsCountText = null;
        }
        if (!this._myParams.myLogTotalExecutionTimeResults) {
          totalExecutionTimeText = null;
        }
        if (!this._myParams.myLogTotalExecutionTimePercentageResults) {
          totalExecutionTimePercentageText = null;
        }
        if (!this._myParams.myLogAverageExecutionTimeResults) {
          averageExecutionTimeText = null;
        }
        switch (this._myParams.myLogSortOrder) {
          case DebugFunctionsPerformanceAnalyzerSortOrder.CALLS_COUNT:
            textOrdered.push(callsCountText);
            textOrdered.push(totalExecutionTimeText);
            textOrdered.push(totalExecutionTimePercentageText);
            textOrdered.push(averageExecutionTimeText);
            break;
          case DebugFunctionsPerformanceAnalyzerSortOrder.TOTAL_EXECUTION_TIME:
            textOrdered.push(totalExecutionTimeText);
            textOrdered.push(totalExecutionTimePercentageText);
            textOrdered.push(averageExecutionTimeText);
            textOrdered.push(callsCountText);
            break;
          case DebugFunctionsPerformanceAnalyzerSortOrder.AVERAGE_EXECUTION_TIME:
            textOrdered.push(averageExecutionTimeText);
            textOrdered.push(totalExecutionTimeText);
            textOrdered.push(totalExecutionTimePercentageText);
            textOrdered.push(callsCountText);
            break;
          default:
            textOrdered.push(callsCountText);
            textOrdered.push(totalExecutionTimeText);
            textOrdered.push(totalExecutionTimePercentageText);
            textOrdered.push(averageExecutionTimeText);
        }
        resultsText += "\n";
        if (this._myParams.myFormatLog) {
          let nameIndented = name + " ";
          while (nameIndented.length < this._myMaxNameLength + 1) {
            nameIndented += this._myParams.myFormatLogIndentationCharacter;
          }
          nameIndented += this._myParams.myFormatLogIndentationCharacter + " ";
          resultsText += nameIndented;
        } else {
          resultsText += name + " - ";
        }
        let avoidFirst = true;
        for (let text of textOrdered) {
          if (text != null) {
            if (avoidFirst) {
              avoidFirst = false;
            } else {
              resultsText += " - ";
            }
            resultsText += text;
          }
        }
      }
      if (this._myParams.myLogTotalExecutionTimeResults || this._myParams.myLogTotalExecutionTimePercentageResults || this._myParams.myLogAverageExecutionTimeResults) {
        console[this._myParams.myLogFunction]("\n" + this._myParams.myLogTitle, "\n\nTotal Time:", timeSinceLastReset.toFixed(5), "ms\n", resultsText);
      } else {
        console[this._myParams.myLogFunction]("\n" + this._myParams.myLogTitle, "\n", resultsText);
      }
    }
  }
};

// dist/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_functions_performance_analyzer_component.js
import { Component as Component33, Property as Property20 } from "@wonderlandengine/api";
var DebugFunctionsPerformanceAnalyzerComponent = class extends Component33 {
  static TypeName = "pp-debug-functions-performance-analyzer";
  static Properties = {
    _myObjectsByPath: Property20.string(""),
    _myClassesByPath: Property20.string(""),
    _myFunctionsByPath: Property20.string(""),
    _myDelayStart: Property20.float(0),
    _myLogTitle: Property20.string("Functions Performance Analysis Results"),
    _myLogFunction: Property20.enum(["Log", "Error", "Warn", "Debug"], "Error"),
    _mySecondsBetweenLogs: Property20.float(1),
    _myLogMaxResults: Property20.bool(false),
    _myLogSortOrder: Property20.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "Calls Count"),
    _myLogCallsCountResults: Property20.bool(true),
    _myLogTotalExecutionTimeResults: Property20.bool(false),
    _myLogTotalExecutionTimePercentageResults: Property20.bool(false),
    _myLogAverageExecutionTimeResults: Property20.bool(false),
    _myLogMaxAmountOfFunctions: Property20.int(-1),
    _myLogFunctionsWithCallsCountAbove: Property20.int(0),
    _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property20.float(-1),
    _myFunctionPathsToInclude: Property20.string(""),
    _myFunctionPathsToExclude: Property20.string(""),
    _myExcludeConstructors: Property20.bool(false),
    _myExcludeJSObjectFunctions: Property20.bool(true),
    _myAddPathPrefixToFunctionID: Property20.bool(true),
    _myObjectAddObjectDescendantsDepthLevel: Property20.int(0),
    _myObjectAddClassDescendantsDepthLevel: Property20.int(0),
    _myClearConsoleBeforeLog: Property20.bool(false),
    _myResetMaxResultsShortcutEnabled: Property20.bool(false),
    _myClassesByReference: Property20.enum(["Code Driven"], "Code Driven"),
    _myObjectsByReference: Property20.enum(["Code Driven"], "Code Driven")
  };
  init() {
    if (!this.markedActive)
      return;
    this._myActive = false;
    if (Globals.isDebugEnabled(this.engine)) {
      this._init();
    }
  }
  _init() {
    this._myActive = true;
    this._myFunctionsPerformanceAnalyzer = null;
    this._myFunctionsPerformanceAnalysisResultsLogger = null;
    this._mySkipFirstUpdate = true;
    this._myStartTimer = new Timer(this._myDelayStart);
    if (this._myDelayStart == 0) {
      this._myStartTimer.end();
      this._mySkipFirstUpdate = false;
      this._start();
    }
  }
  start() {
    if (!this._myActive && Globals.isDebugEnabled(this.engine)) {
      this._init();
    }
  }
  update(dt) {
    if (!Globals.isDebugEnabled(this.engine))
      return;
    if (this._myActive) {
      if (this._mySkipFirstUpdate) {
        this._mySkipFirstUpdate = false;
        return;
      }
      if (this._myStartTimer.isRunning()) {
        this._myStartTimer.update(dt);
        if (this._myStartTimer.isDone()) {
          this._start();
        }
      } else {
        this._myFunctionsPerformanceAnalysisResultsLogger.update(dt);
        this._myFunctionsPerformanceAnalyzer.resetResults();
      }
      if (this._myResetMaxResultsShortcutEnabled) {
        if (Globals.getLeftGamepad(this.engine).getButtonInfo(GamepadButtonID.SELECT).isPressEnd(3)) {
          this._myFunctionsPerformanceAnalyzer.resetMaxResults();
        }
      }
    }
  }
  _start() {
    let functionsPerformanceAnalyzerParams = new DebugFunctionsPerformanceAnalyzerParams(this.engine);
    if (this._myObjectsByPath.length > 0) {
      let toIncludeList = [...this._myObjectsByPath.split(",")];
      for (let i = 0; i < toIncludeList.length; i++) {
        toIncludeList[i] = toIncludeList[i].trim();
      }
      functionsPerformanceAnalyzerParams.myObjectsByPath.push(...toIncludeList);
    }
    if (this._myClassesByPath.length > 0) {
      let toIncludeList = [...this._myClassesByPath.split(",")];
      for (let i = 0; i < toIncludeList.length; i++) {
        toIncludeList[i] = toIncludeList[i].trim();
      }
      functionsPerformanceAnalyzerParams.myClassesByPath.push(...toIncludeList);
    }
    if (this._myFunctionsByPath.length > 0) {
      let toIncludeList = [...this._myFunctionsByPath.split(",")];
      for (let i = 0; i < toIncludeList.length; i++) {
        toIncludeList[i] = toIncludeList[i].trim();
      }
      functionsPerformanceAnalyzerParams.myFunctionsByPath.push(...toIncludeList);
    }
    functionsPerformanceAnalyzerParams.myExcludeConstructors = this._myExcludeConstructors;
    functionsPerformanceAnalyzerParams.myExcludeJSObjectFunctions = this._myExcludeJSObjectFunctions;
    functionsPerformanceAnalyzerParams.myAddPathPrefixToFunctionID = this._myAddPathPrefixToFunctionID;
    if (this._myFunctionPathsToInclude.length > 0) {
      let toIncludeList = [...this._myFunctionPathsToInclude.split(",")];
      for (let i = 0; i < toIncludeList.length; i++) {
        toIncludeList[i] = toIncludeList[i].trim();
      }
      functionsPerformanceAnalyzerParams.myFunctionPathsToInclude.push(...toIncludeList);
    }
    if (this._myFunctionPathsToExclude.length > 0) {
      let toExcludeList = [...this._myFunctionPathsToExclude.split(",")];
      for (let i = 0; i < toExcludeList.length; i++) {
        toExcludeList[i] = toExcludeList[i].trim();
      }
      functionsPerformanceAnalyzerParams.myFunctionPathsToExclude.push(...toExcludeList);
    }
    functionsPerformanceAnalyzerParams.myObjectAddObjectDescendantsDepthLevel = this._myObjectAddObjectDescendantsDepthLevel;
    functionsPerformanceAnalyzerParams.myObjectAddClassDescendantsDepthLevel = this._myObjectAddClassDescendantsDepthLevel;
    functionsPerformanceAnalyzerParams.myExecutionTimeAnalysisEnabled = this._myLogTotalExecutionTimeResults || this._myLogTotalExecutionTimePercentageResults || this._myLogAverageExecutionTimeResults;
    functionsPerformanceAnalyzerParams.myClassesByReference = this._myClassesByReference != 0 ? this._myClassesByReference : [];
    functionsPerformanceAnalyzerParams.myObjectsByReference = this._myObjectsByReference != 0 ? this._myObjectsByReference : [];
    this._myFunctionsPerformanceAnalyzer = new DebugFunctionsPerformanceAnalyzer(functionsPerformanceAnalyzerParams);
    this._myFunctionsPerformanceAnalyzer.overwriteFunctions();
    let functionsPerformanceAnalysisResultsLoggerParams = new DebugFunctionsPerformanceAnalysisResultsLoggerParams();
    functionsPerformanceAnalysisResultsLoggerParams.myPerformanceAnalyzer = this._myFunctionsPerformanceAnalyzer;
    functionsPerformanceAnalysisResultsLoggerParams.myLogTitle = this._myLogTitle;
    functionsPerformanceAnalysisResultsLoggerParams.mySecondsBetweenLogs = this._mySecondsBetweenLogs;
    functionsPerformanceAnalysisResultsLoggerParams.myLogFunction = ["log", "error", "warn", "debug"][this._myLogFunction];
    functionsPerformanceAnalysisResultsLoggerParams.myLogMaxAmountOfFunctions = this._myLogMaxAmountOfFunctions >= 0 ? this._myLogMaxAmountOfFunctions : null;
    functionsPerformanceAnalysisResultsLoggerParams.myLogFunctionsWithCallsCountAbove = this._myLogFunctionsWithCallsCountAbove >= 0 ? this._myLogFunctionsWithCallsCountAbove : null;
    functionsPerformanceAnalysisResultsLoggerParams.myLogFunctionsWithTotalExecutionTimePercentageAbove = this._myLogFunctionsWithTotalExecutionTimePercentageAbove >= 0 ? this._myLogFunctionsWithTotalExecutionTimePercentageAbove : null;
    functionsPerformanceAnalysisResultsLoggerParams.myLogMaxResults = this._myLogMaxResults;
    functionsPerformanceAnalysisResultsLoggerParams.myClearConsoleBeforeLog = this._myClearConsoleBeforeLog;
    functionsPerformanceAnalysisResultsLoggerParams.myLogSortOrder = this._myLogSortOrder;
    functionsPerformanceAnalysisResultsLoggerParams.myLogCallsCountResults = this._myLogCallsCountResults;
    functionsPerformanceAnalysisResultsLoggerParams.myLogTotalExecutionTimeResults = this._myLogTotalExecutionTimeResults;
    functionsPerformanceAnalysisResultsLoggerParams.myLogTotalExecutionTimePercentageResults = this._myLogTotalExecutionTimePercentageResults;
    functionsPerformanceAnalysisResultsLoggerParams.myLogAverageExecutionTimeResults = this._myLogAverageExecutionTimeResults;
    this._myFunctionsPerformanceAnalysisResultsLogger = new DebugFunctionsPerformanceAnalysisResultsLogger(functionsPerformanceAnalysisResultsLoggerParams);
  }
};

// dist/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_pp_functions_performance_analyzer_component.js
import { Component as Component34, Property as Property21 } from "@wonderlandengine/api";
var DebugPPFunctionsPerformanceAnalyzerComponent = class extends Component34 {
  static TypeName = "pp-debug-pp-functions-performance-analyzer";
  static Properties = {
    _myDelayStart: Property21.float(0),
    _myLogFunction: Property21.enum(["Log", "Error", "Warn", "Debug"], "Error"),
    _mySecondsBetweenLogs: Property21.float(1),
    _myLogMaxResults: Property21.bool(false),
    _myLogSortOrder: Property21.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "Calls Count"),
    _myLogCallsCountResults: Property21.bool(true),
    _myLogTotalExecutionTimeResults: Property21.bool(false),
    _myLogTotalExecutionTimePercentageResults: Property21.bool(false),
    _myLogAverageExecutionTimeResults: Property21.bool(false),
    _myLogMaxAmountOfFunctions: Property21.int(-1),
    _myLogFunctionsWithCallsCountAbove: Property21.int(0),
    _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property21.float(-1),
    _myFunctionPathsToInclude: Property21.string(""),
    _myFunctionPathsToExclude: Property21.string(""),
    _myExcludeConstructors: Property21.bool(false),
    _myClearConsoleBeforeLog: Property21.bool(false),
    _myResetMaxResultsShortcutEnabled: Property21.bool(false)
  };
  init() {
    if (!this.markedActive)
      return;
    this.object.pp_addComponent(DebugFunctionsPerformanceAnalyzerComponent, {
      _myObjectsByPath: "PP",
      _myDelayStart: this._myDelayStart,
      _myLogTitle: "PP Functions Performance Analysis Results",
      _myLogFunction: this._myLogFunction,
      _mySecondsBetweenLogs: this._mySecondsBetweenLogs,
      _myLogMaxResults: this._myLogMaxResults,
      _myLogSortOrder: this._myLogSortOrder,
      _myLogMaxAmountOfFunctions: this._myLogMaxAmountOfFunctions,
      _myLogFunctionsWithCallsCountAbove: this._myLogFunctionsWithCallsCountAbove,
      _myLogFunctionsWithTotalExecutionTimePercentageAbove: this._myLogFunctionsWithTotalExecutionTimePercentageAbove,
      _myLogCallsCountResults: this._myLogCallsCountResults,
      _myLogTotalExecutionTimeResults: this._myLogTotalExecutionTimeResults,
      _myLogTotalExecutionTimePercentageResults: this._myLogTotalExecutionTimePercentageResults,
      _myLogAverageExecutionTimeResults: this._myLogAverageExecutionTimeResults,
      _myFunctionPathsToInclude: this._myFunctionPathsToInclude,
      _myFunctionPathsToExclude: this._myFunctionPathsToExclude,
      _myExcludeConstructors: this._myExcludeConstructors,
      _myExcludeJSObjectFunctions: true,
      _myAddPathPrefixToFunctionID: true,
      _myObjectAddObjectDescendantsDepthLevel: 1,
      _myObjectAddClassDescendantsDepthLevel: 1,
      _myClearConsoleBeforeLog: this._myClearConsoleBeforeLog,
      _myResetMaxResultsShortcutEnabled: this._myResetMaxResultsShortcutEnabled
    });
  }
};

// dist/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_array_functions_performance_analyzer_component.js
import { Component as Component35, Property as Property22 } from "@wonderlandengine/api";
var DebugArrayFunctionsPerformanceAnalyzerComponent = class extends Component35 {
  static TypeName = "pp-debug-array-functions-performance-analyzer";
  static Properties = {
    _myIncludeOnlyMainArrayTypes: Property22.bool(true),
    _myIncludeOnlyArrayExtensionFunctions: Property22.bool(false),
    _myDelayStart: Property22.float(0),
    _myLogFunction: Property22.enum(["Log", "Error", "Warn", "Debug"], "Error"),
    _mySecondsBetweenLogs: Property22.float(1),
    _myLogMaxResults: Property22.bool(false),
    _myLogSortOrder: Property22.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "Calls Count"),
    _myLogCallsCountResults: Property22.bool(true),
    _myLogTotalExecutionTimeResults: Property22.bool(false),
    _myLogTotalExecutionTimePercentageResults: Property22.bool(false),
    _myLogAverageExecutionTimeResults: Property22.bool(false),
    _myLogMaxAmountOfFunctions: Property22.int(-1),
    _myLogFunctionsWithCallsCountAbove: Property22.int(0),
    _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property22.float(-1),
    _myFunctionPathsToInclude: Property22.string(""),
    _myFunctionPathsToExclude: Property22.string(""),
    _myExcludeConstructors: Property22.bool(false),
    _myClearConsoleBeforeLog: Property22.bool(false),
    _myResetMaxResultsShortcutEnabled: Property22.bool(false)
  };
  init() {
    if (!this.markedActive)
      return;
    let classesByPath = "Array, Uint8ClampedArray, Uint8Array, Uint16Array, Uint32Array, Int8Array, Int16Array, Int32Array, Float32Array, Float64Array";
    if (this._myIncludeOnlyMainArrayTypes) {
      classesByPath = "Array, Uint8Array, Uint16Array, Float32Array";
    }
    this.object.pp_addComponent(DebugFunctionsPerformanceAnalyzerComponent, {
      _myClassesByPath: classesByPath,
      _myDelayStart: this._myDelayStart,
      _myLogTitle: "Array Functions Performance Analysis Results",
      _myLogFunction: this._myLogFunction,
      _mySecondsBetweenLogs: this._mySecondsBetweenLogs,
      _myLogMaxResults: this._myLogMaxResults,
      _myLogSortOrder: this._myLogSortOrder,
      _myLogMaxAmountOfFunctions: this._myLogMaxAmountOfFunctions,
      _myLogFunctionsWithCallsCountAbove: this._myLogFunctionsWithCallsCountAbove,
      _myLogFunctionsWithTotalExecutionTimePercentageAbove: this._myLogFunctionsWithTotalExecutionTimePercentageAbove,
      _myLogCallsCountResults: this._myLogCallsCountResults,
      _myLogTotalExecutionTimeResults: this._myLogTotalExecutionTimeResults,
      _myLogTotalExecutionTimePercentageResults: this._myLogTotalExecutionTimePercentageResults,
      _myLogAverageExecutionTimeResults: this._myLogAverageExecutionTimeResults,
      _myFunctionPathsToInclude: this._myFunctionPathsToInclude + (this._myFunctionPathsToInclude.length > 0 && this._myIncludeOnlyArrayExtensionFunctions ? ", " : "") + (this._myIncludeOnlyArrayExtensionFunctions ? "pp_, vec_, vec2_, vec3_, vec4_, quat_, quat2_, mat3_, mat4_, _pp_, _vec_, _quat_" : ""),
      _myFunctionPathsToExclude: this._myFunctionPathsToExclude,
      _myExcludeConstructors: this._myExcludeConstructors,
      _myExcludeJSObjectFunctions: true,
      _myAddPathPrefixToFunctionID: true,
      _myClearConsoleBeforeLog: this._myClearConsoleBeforeLog,
      _myResetMaxResultsShortcutEnabled: this._myResetMaxResultsShortcutEnabled
    });
  }
};

// dist/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_pp_array_creation_performance_analyzer_component.js
import { Component as Component36, Property as Property23 } from "@wonderlandengine/api";
var DebugPPArrayCreationPerformanceAnalyzerComponent = class extends Component36 {
  static TypeName = "pp-debug-pp-array-creation-performance-analyzer";
  static Properties = {
    _myDelayStart: Property23.float(0),
    _myLogFunction: Property23.enum(["Log", "Error", "Warn", "Debug"], "Error"),
    _mySecondsBetweenLogs: Property23.float(1),
    _myLogMaxResults: Property23.bool(false),
    _myLogSortOrder: Property23.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "Calls Count"),
    _myLogCallsCountResults: Property23.bool(true),
    _myLogTotalExecutionTimeResults: Property23.bool(false),
    _myLogTotalExecutionTimePercentageResults: Property23.bool(false),
    _myLogAverageExecutionTimeResults: Property23.bool(false),
    _myLogMaxAmountOfFunctions: Property23.int(-1),
    _myLogFunctionsWithCallsCountAbove: Property23.int(0),
    _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property23.float(-1),
    _myClearConsoleBeforeLog: Property23.bool(false),
    _myResetMaxResultsShortcutEnabled: Property23.bool(false)
  };
  init() {
    if (!this.markedActive)
      return;
    this.object.pp_addComponent(DebugFunctionsPerformanceAnalyzerComponent, {
      _myObjectsByReference: [
        [Vec2Utils, "Vec2Utils"],
        [Vec3Utils, "Vec3Utils"],
        [Vec4Utils, "Vec4Utils"],
        [QuatUtils, "QuatUtils"],
        [Quat2Utils, "Quat2Utils"],
        [Mat3Utils, "Mat3Utils"],
        [Mat4Utils, "Mat4Utils"]
      ],
      _myDelayStart: this._myDelayStart,
      _myLogTitle: "PP Array Creation Performance Analysis Results",
      _myLogFunction: this._myLogFunction,
      _mySecondsBetweenLogs: this._mySecondsBetweenLogs,
      _myLogMaxResults: this._myLogMaxResults,
      _myLogSortOrder: this._myLogSortOrder,
      _myLogMaxAmountOfFunctions: this._myLogMaxAmountOfFunctions,
      _myLogFunctionsWithCallsCountAbove: this._myLogFunctionsWithCallsCountAbove,
      _myLogFunctionsWithTotalExecutionTimePercentageAbove: this._myLogFunctionsWithTotalExecutionTimePercentageAbove,
      _myLogCallsCountResults: this._myLogCallsCountResults,
      _myLogTotalExecutionTimeResults: this._myLogTotalExecutionTimeResults,
      _myLogTotalExecutionTimePercentageResults: this._myLogTotalExecutionTimePercentageResults,
      _myLogAverageExecutionTimeResults: this._myLogAverageExecutionTimeResults,
      _myFunctionPathsToInclude: "create",
      _myExcludeConstructors: true,
      _myExcludeJSObjectFunctions: true,
      _myAddPathPrefixToFunctionID: true,
      _myClearConsoleBeforeLog: this._myClearConsoleBeforeLog,
      _myResetMaxResultsShortcutEnabled: this._myResetMaxResultsShortcutEnabled
    });
  }
};

// dist/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_wl_function_performance_analyzer_component.js
import { Component as Component37, Property as Property24 } from "@wonderlandengine/api";
var DebugWLFunctionsPerformanceAnalyzerComponent = class extends Component37 {
  static TypeName = "pp-debug-wl-functions-performance-analyzer";
  static Properties = {
    _myDelayStart: Property24.float(0),
    _myLogFunction: Property24.enum(["Log", "Error", "Warn", "Debug"], "Error"),
    _mySecondsBetweenLogs: Property24.float(1),
    _myLogMaxResults: Property24.bool(false),
    _myLogSortOrder: Property24.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "Calls Count"),
    _myLogCallsCountResults: Property24.bool(true),
    _myLogTotalExecutionTimeResults: Property24.bool(false),
    _myLogTotalExecutionTimePercentageResults: Property24.bool(false),
    _myLogAverageExecutionTimeResults: Property24.bool(false),
    _myLogMaxAmountOfFunctions: Property24.int(-1),
    _myLogFunctionsWithCallsCountAbove: Property24.int(0),
    _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property24.float(-1),
    _myFunctionPathsToInclude: Property24.string(""),
    _myFunctionPathsToExclude: Property24.string(""),
    _myExcludeConstructors: Property24.bool(false),
    _myClearConsoleBeforeLog: Property24.bool(false),
    _myResetMaxResultsShortcutEnabled: Property24.bool(false)
  };
  init() {
    if (!this.markedActive)
      return;
    this.object.pp_addComponent(DebugFunctionsPerformanceAnalyzerComponent, {
      _myObjectsByPath: "WL",
      _myDelayStart: this._myDelayStart,
      _myLogTitle: "WL Functions Performance Analysis Results",
      _myLogFunction: this._myLogFunction,
      _mySecondsBetweenLogs: this._mySecondsBetweenLogs,
      _myLogMaxResults: this._myLogMaxResults,
      _myLogSortOrder: this._myLogSortOrder,
      _myLogMaxAmountOfFunctions: this._myLogMaxAmountOfFunctions,
      _myLogFunctionsWithCallsCountAbove: this._myLogFunctionsWithCallsCountAbove,
      _myLogFunctionsWithTotalExecutionTimePercentageAbove: this._myLogFunctionsWithTotalExecutionTimePercentageAbove,
      _myLogCallsCountResults: this._myLogCallsCountResults,
      _myLogTotalExecutionTimeResults: this._myLogTotalExecutionTimeResults,
      _myLogTotalExecutionTimePercentageResults: this._myLogTotalExecutionTimePercentageResults,
      _myLogAverageExecutionTimeResults: this._myLogAverageExecutionTimeResults,
      _myFunctionPathsToInclude: this._myFunctionPathsToInclude,
      _myFunctionPathsToExclude: this._myFunctionPathsToExclude,
      _myExcludeConstructors: this._myExcludeConstructors,
      _myExcludeJSObjectFunctions: true,
      _myAddPathPrefixToFunctionID: true,
      _myObjectAddObjectDescendantsDepthLevel: 1,
      _myObjectAddClassDescendantsDepthLevel: 1,
      _myClearConsoleBeforeLog: this._myClearConsoleBeforeLog,
      _myResetMaxResultsShortcutEnabled: this._myResetMaxResultsShortcutEnabled
    });
  }
};

// dist/pp/debug/debug_functions_overwriter/debug_functions_performance_analyzer/components/debug_wl_components_function_performance_analyzer_component.js
import { AnimationComponent as AnimationComponent2, CollisionComponent as CollisionComponent2, Component as Component38, InputComponent as InputComponent3, LightComponent as LightComponent2, MeshComponent as MeshComponent9, PhysXComponent as PhysXComponent6, Property as Property25, TextComponent as TextComponent7, ViewComponent as ViewComponent4 } from "@wonderlandengine/api";
var DebugWLComponentsFunctionsPerformanceAnalyzerComponent = class extends Component38 {
  static TypeName = "pp-debug-wl-components-functions-performance-analyzer";
  static Properties = {
    _myAnalyzeComponentTypes: Property25.bool(true),
    _myAnalyzeComponentInstances: Property25.bool(false),
    _myComponentInstanceID: Property25.enum(["Object ID", "Object Name", "Object ID - Object Name"], "Object ID - Object Name"),
    _myDelayStart: Property25.float(0),
    _myLogFunction: Property25.enum(["Log", "Error", "Warn", "Debug"], "Error"),
    _mySecondsBetweenLogs: Property25.float(1),
    _myLogMaxResults: Property25.bool(false),
    _myLogSortOrder: Property25.enum(["None", "Calls Count", "Total Execution Time", "Average Execution Time"], "Calls Count"),
    _myLogCallsCountResults: Property25.bool(true),
    _myLogTotalExecutionTimeResults: Property25.bool(false),
    _myLogTotalExecutionTimePercentageResults: Property25.bool(false),
    _myLogAverageExecutionTimeResults: Property25.bool(false),
    _myLogMaxAmountOfFunctions: Property25.int(-1),
    _myLogFunctionsWithCallsCountAbove: Property25.int(0),
    _myLogFunctionsWithTotalExecutionTimePercentageAbove: Property25.float(-1),
    _myFunctionPathsToInclude: Property25.string(""),
    _myFunctionPathsToExclude: Property25.string(""),
    _myExcludeConstructors: Property25.bool(false),
    _myClearConsoleBeforeLog: Property25.bool(false),
    _myResetMaxResultsShortcutEnabled: Property25.bool(false)
  };
  init() {
    if (!this.markedActive)
      return;
    this._myStartTimer = new Timer(this._myDelayStart);
    if (this._myDelayStart == 0) {
      this._myStartTimer.end();
      this._start();
    }
  }
  update(dt) {
    if (this._myStartTimer.isRunning()) {
      this._myStartTimer.update(dt);
      if (this._myStartTimer.isDone()) {
        this._start();
      }
    }
  }
  _start() {
    let objectsByReference = [];
    let classesByReference = [];
    if (this._myAnalyzeComponentInstances) {
      this._addComponentInstanceReferences(objectsByReference);
    }
    if (this._myAnalyzeComponentTypes) {
      this._addComponentTypeReferences(classesByReference);
    }
    this._myAnalyzerComponent = this.object.pp_addComponent(DebugFunctionsPerformanceAnalyzerComponent, {
      _myObjectsByReference: objectsByReference,
      _myClassesByReference: classesByReference,
      _myDelayStart: 0,
      _myLogTitle: "WL Components Performance Analysis Results",
      _myLogFunction: this._myLogFunction,
      _mySecondsBetweenLogs: this._mySecondsBetweenLogs,
      _myLogMaxResults: this._myLogMaxResults,
      _myLogSortOrder: this._myLogSortOrder,
      _myLogMaxAmountOfFunctions: this._myLogMaxAmountOfFunctions,
      _myLogFunctionsWithCallsCountAbove: this._myLogFunctionsWithCallsCountAbove,
      _myLogFunctionsWithTotalExecutionTimePercentageAbove: this._myLogFunctionsWithTotalExecutionTimePercentageAbove,
      _myLogCallsCountResults: this._myLogCallsCountResults,
      _myLogTotalExecutionTimeResults: this._myLogTotalExecutionTimeResults,
      _myLogTotalExecutionTimePercentageResults: this._myLogTotalExecutionTimePercentageResults,
      _myLogAverageExecutionTimeResults: this._myLogAverageExecutionTimeResults,
      _myFunctionPathsToInclude: this._myFunctionPathsToInclude,
      _myFunctionPathsToExclude: this._myFunctionPathsToExclude,
      _myExcludeConstructors: this._myExcludeConstructors,
      _myExcludeJSObjectFunctions: true,
      _myAddPathPrefixToFunctionID: true,
      _myObjectAddClassDescendantsDepthLevel: 0,
      _myClearConsoleBeforeLog: this._myClearConsoleBeforeLog,
      _myResetMaxResultsShortcutEnabled: this._myResetMaxResultsShortcutEnabled
    });
  }
  _addComponentTypeReferences(classesByReference) {
    let nativeComponentClasses = [
      AnimationComponent2,
      CollisionComponent2,
      InputComponent3,
      LightComponent2,
      MeshComponent9,
      PhysXComponent6,
      TextComponent7,
      ViewComponent4
    ];
    for (let nativeComponentClass of nativeComponentClasses) {
      classesByReference.push([nativeComponentClass.prototype, '{"' + nativeComponentClass.TypeName + '"}']);
    }
    for (let componentClass of ComponentUtils.getJavascriptComponentClassesByIndex(this.engine)) {
      classesByReference.push([componentClass.prototype, '{"' + componentClass.TypeName + '"}']);
    }
  }
  _addComponentInstanceReferences(objectsByReference) {
    for (let componentInstance of ComponentUtils.getJavascriptComponentInstances(false, this.engine)) {
      let id = "";
      switch (this._myComponentInstanceID) {
        case 0:
          id = componentInstance.object.pp_getID();
          break;
        case 1:
          id = componentInstance.object.pp_getName();
          break;
        case 2:
          id = componentInstance.object.pp_getID();
          if (componentInstance.object.pp_getName().length > 0) {
            id = id + " - " + componentInstance.object.pp_getName();
          }
          break;
      }
      objectsByReference.push([
        componentInstance,
        '{"' + componentInstance.type + '"}[' + id + "]"
      ]);
    }
  }
};

// dist/pp/gameplay/cauldron/cauldron/direction_2D_to_3D_converter.js
var Direction2DTo3DConverterParams = class {
  constructor() {
    this.myStartFlyingForward = false;
    this.myStartFlyingRight = false;
    this.myAutoUpdateFlyForward = false;
    this.myAutoUpdateFlyRight = false;
    this.myResetFlyForwardWhenZero = false;
    this.myResetFlyRightWhenZero = false;
    this.myMinAngleToFlyForwardUp = 90;
    this.myMinAngleToFlyForwardDown = 90;
    this.myMinAngleToFlyRightUp = 90;
    this.myMinAngleToFlyRightDown = 90;
    this.myAdjustForwardWhenCloseToUp = true;
    this.myAdjustRightWhenCloseToUp = true;
    this.myAdjustForwardWhenCloseToUpAngleThreshold = 10;
    this.myAdjustRightWhenCloseToUpAngleThreshold = 10;
    this.myInvertForwardWhenUpsideDown = false;
    this.myInvertRightWhenUpsideDown = false;
    this.myAdjustLastValidFlatForwardOverConversionReferenceRotation = true;
    this.myAdjustLastValidFlatRightOverConversionReferenceRotation = true;
  }
};
var Direction2DTo3DConverter = class {
  constructor(params = new Direction2DTo3DConverterParams()) {
    this._myParams = params;
    this._myFlyingForward = this._myParams.myStartFlyingForward;
    this._myFlyingRight = this._myParams.myStartFlyingRight;
    this._myLastConvertRotationQuat = quat_create();
    this._myLastConvertRotationQuatValid = false;
    this._myLastValidFlatForward = vec3_create();
    this._myLastValidFlatRight = vec3_create();
  }
  // @direction3DUp can be used to flat the direction if the @conversionTransform is not aligned with it
  // It's also needed to specify the fly axis, if different from the @conversionTransform up
  // If @direction3DUp is null, @conversionTransform up is used
  convert(direction2D, conversionTransform, direction3DUp = null, outDirection3D = vec3_create()) {
    return this.convertTransform(direction2D, conversionTransform, direction3DUp, outDirection3D);
  }
  isFlying() {
    return this._myFlyingForward || this._myFlyingRight;
  }
  isFlyingForward() {
    return this._myFlyingForward;
  }
  isFlyingRight() {
    return this._myFlyingRight;
  }
  startFlying() {
    this._myFlyingForward = true;
    this._myFlyingRight = true;
  }
  startFlyingForward() {
    this._myFlyingForward = true;
  }
  startFlyingRight() {
    this._myFlyingRight = true;
  }
  stopFlying() {
    this._myFlyingForward = false;
    this._myFlyingRight = false;
  }
  stopFlyingForward() {
    this._myFlyingForward = false;
  }
  stopFlyingRight() {
    this._myFlyingRight = false;
  }
  resetFly() {
    this.resetFlyForward();
    this.resetFlyRight();
  }
  resetFlyForward() {
    if (this._myParams.myStartFlyingForward) {
      this.startFlyingForward();
    } else {
      this.stopFlyingForward();
    }
  }
  resetFlyRight() {
    if (this._myParams.myStartFlyingRight) {
      this.startFlyingRight();
    } else {
      this.stopFlyingRight();
    }
  }
  resetLastValidFlatDirections() {
    this._myLastValidFlatForward.vec3_zero();
    this._myLastValidFlatRight.vec3_zero();
  }
  resetLastValidFlatForward() {
    this._myLastValidFlatForward.vec3_zero();
  }
  resetLastValidFlatRight() {
    this._myLastValidFlatRight.vec3_zero();
  }
  resetLastConvertTransform() {
    this._myLastConvertRotationQuatValid = false;
    this._myLastConvertRotationQuat.quat_identity();
  }
  // Convert Alternatives
  // If @direction3DUp is null, vec3_create(0, 1, 0) is used
  // Does not work properly if @conversionForward is aligned with @direction3DUp
  convertForward(direction2D, conversionForward, direction3DUp = null, outDirection3D = vec3_create()) {
  }
  // @direction3DUp can be used to flat the direction if the @conversionTransform is not aligned with it
  // It's also needed to specify the fly axis, if different from the @conversionTransform up
  // If @direction3DUp is null, conversionTransform up is used
  convertTransform(direction2D, conversionTransform, direction3DUp = null, outDirection3D = vec3_create()) {
    return this.convertTransformMatrix(direction2D, conversionTransform, direction3DUp, outDirection3D);
  }
  convertTransformMatrix(direction2D, conversionTransformMatrix, direction3DUp = null, outDirection3D = vec3_create()) {
  }
  convertTransformQuat(direction2D, conversionTransformQuat, direction3DUp = null, outDirection3D = vec3_create()) {
  }
  convertRotationQuat(direction2D, conversionRotationQuat, direction3DUp = null, outDirection3D = vec3_create()) {
  }
};
Direction2DTo3DConverter.prototype.convertForward = function() {
  let rotationQuat = quat_create();
  return function convertForward(direction2D, conversionForward, direction3DUp = null, outDirection3D = vec3_create()) {
    rotationQuat.quat_identity();
    rotationQuat.quat_setForward(conversionForward, direction3DUp);
    return this.convertRotationQuat(direction2D, rotationQuat, direction3DUp, outDirection3D);
  };
}();
Direction2DTo3DConverter.prototype.convertTransformMatrix = function() {
  let rotationQuat = quat_create();
  return function convertTransformMatrix(direction2D, conversionTransformMatrix, direction3DUp = null, outDirection3D = vec3_create()) {
    rotationQuat = conversionTransformMatrix.mat4_getRotationQuat(rotationQuat);
    return this.convertRotationQuat(direction2D, rotationQuat, direction3DUp, outDirection3D);
  };
}();
Direction2DTo3DConverter.prototype.convertTransformQuat = function() {
  let rotationQuat = quat_create();
  return function convertTransformQuat(direction2D, conversionTransformQuat, direction3DUp = null, outDirection3D = vec3_create()) {
    rotationQuat = conversionTransformQuat.quat2_getRotationQuat(rotationQuat);
    return this.convertRotationQuat(direction2D, rotationQuat, direction3DUp, outDirection3D);
  };
}();
Direction2DTo3DConverter.prototype.convertRotationQuat = function() {
  let forward = vec3_create();
  let right = vec3_create();
  let up = vec3_create();
  let direction3DUpNegate = vec3_create();
  let forwardScaled = vec3_create();
  let rightScaled = vec3_create();
  let rotationToNewConvertPivoted = quat_create();
  return function convertRotationQuat(direction2D, conversionRotationQuat, direction3DUp = null, outDirection3D = vec3_create()) {
    outDirection3D.vec3_zero();
    if (this._myParams.myAdjustLastValidFlatForwardOverConversionReferenceRotation || this._myParams.myAdjustLastValidFlatRightOverConversionReferenceRotation) {
      if (direction3DUp != null) {
        if (this._myLastConvertRotationQuatValid) {
          rotationToNewConvertPivoted = this._myLastConvertRotationQuat.quat_rotationToQuat(conversionRotationQuat, rotationToNewConvertPivoted).quat_rotationAroundAxisQuat(direction3DUp, rotationToNewConvertPivoted);
          if (Math.pp_angleClamp(rotationToNewConvertPivoted.quat_getAngle(), true) > Math.PP_EPSILON_DEGREES) {
            if (this._myParams.myAdjustLastValidFlatForwardOverConversionReferenceRotation) {
              this._myLastValidFlatForward.vec3_rotateQuat(rotationToNewConvertPivoted, this._myLastValidFlatForward);
            }
            if (this._myParams.myAdjustLastValidFlatRightOverConversionReferenceRotation) {
              this._myLastValidFlatRight.vec3_rotateQuat(rotationToNewConvertPivoted, this._myLastValidFlatRight);
            }
          }
        }
      }
    }
    if (direction2D.vec2_isZero()) {
      let resetFlyForward = this._myParams.myAutoUpdateFlyForward && this._myParams.myResetFlyForwardWhenZero;
      if (resetFlyForward) {
        this.resetFlyForward();
      }
      let resetFlyRight = this._myParams.myAutoUpdateFlyRight && this._myParams.myResetFlyRightWhenZero;
      if (resetFlyRight) {
        this.resetFlyRight();
      }
    } else {
      forward = conversionRotationQuat.quat_getForward(forward);
      right = conversionRotationQuat.quat_getRight(right);
      up = conversionRotationQuat.quat_getUp(up);
      if (direction3DUp != null) {
        let upsideDown = !direction3DUp.vec3_isConcordant(up);
        direction3DUpNegate = direction3DUp.vec3_negate(direction3DUpNegate);
        if (this._myParams.myAutoUpdateFlyForward) {
          let angleForwardWithDirectionUp = forward.vec3_angle(direction3DUp);
          this._myFlyingForward = this._myFlyingForward || (angleForwardWithDirectionUp < 90 - this._myParams.myMinAngleToFlyForwardUp || angleForwardWithDirectionUp > 90 + this._myParams.myMinAngleToFlyForwardDown);
        }
        if (this._myParams.myAutoUpdateFlyRight) {
          let angleRightWithDirectionUp = right.vec3_angle(direction3DUp);
          this._myFlyingRight = this._myFlyingRight || (angleRightWithDirectionUp < 90 - this._myParams.myMinAngleToFlyRightUp || angleRightWithDirectionUp > 90 + this._myParams.myMinAngleToFlyRightDown);
        }
        if (!this._myFlyingForward) {
          if (this._myParams.myAdjustForwardWhenCloseToUp && !this._myLastValidFlatForward.vec3_isZero(Math.PP_EPSILON) && (forward.vec3_angle(direction3DUp) < this._myParams.myAdjustForwardWhenCloseToUpAngleThreshold || forward.vec3_angle(direction3DUpNegate) < this._myParams.myAdjustForwardWhenCloseToUpAngleThreshold)) {
            forward.pp_copy(this._myLastValidFlatForward);
          } else if (upsideDown && this._myParams.myInvertForwardWhenUpsideDown) {
            forward.vec3_negate(forward);
          }
          forward = forward.vec3_removeComponentAlongAxis(direction3DUp, forward);
          forward.vec3_normalize(forward);
          if (forward.vec3_isZero(Math.PP_EPSILON)) {
            if (!this._myLastValidFlatForward.vec3_isZero(Math.PP_EPSILON)) {
              forward.pp_copy(this._myLastValidFlatForward);
            } else {
              forward.vec3_set(0, 0, 1);
            }
          }
        }
        if (!this._myFlyingRight) {
          if (this._myParams.myAdjustRightWhenCloseToUp && !this._myLastValidFlatRight.vec3_isZero(Math.PP_EPSILON) && (right.vec3_angle(direction3DUp) < this._myParams.myAdjustRightWhenCloseToUpAngleThreshold || right.vec3_angle(direction3DUpNegate) < this._myParams.myAdjustRightWhenCloseToUpAngleThreshold)) {
            right.pp_copy(this._myLastValidFlatRight);
          } else if (upsideDown && this._myParams.myInvertRightWhenUpsideDown) {
            right.vec3_negate(right);
          }
          right = right.vec3_removeComponentAlongAxis(direction3DUp, right);
          right.vec3_normalize(right);
          if (right.vec3_isZero(Math.PP_EPSILON)) {
            if (!this._myLastValidFlatRight.vec3_isZero(Math.PP_EPSILON)) {
              right.pp_copy(this._myLastValidFlatRight);
            } else {
              right.vec3_set(-1, 0, 0);
            }
          }
        }
        if (forward.vec3_angle(direction3DUp) >= this._myParams.myAdjustForwardWhenCloseToUpAngleThreshold && forward.vec3_angle(direction3DUpNegate) >= this._myParams.myAdjustForwardWhenCloseToUpAngleThreshold || direction2D[1] != 0 && this._myLastValidFlatForward.vec3_isZero(Math.PP_EPSILON)) {
          this._myLastValidFlatForward = forward.vec3_removeComponentAlongAxis(direction3DUp, this._myLastValidFlatForward);
          this._myLastValidFlatForward.vec3_normalize(this._myLastValidFlatForward);
        }
        if (right.vec3_angle(direction3DUp) >= this._myParams.myAdjustRightWhenCloseToUpAngleThreshold && right.vec3_angle(direction3DUpNegate) >= this._myParams.myAdjustRightWhenCloseToUpAngleThreshold || direction2D[0] != 0 && this._myLastValidFlatRight.vec3_isZero(Math.PP_EPSILON)) {
          this._myLastValidFlatRight = right.vec3_removeComponentAlongAxis(direction3DUp, this._myLastValidFlatRight);
          this._myLastValidFlatRight.vec3_normalize(this._myLastValidFlatRight);
        }
      }
      outDirection3D = right.vec3_scale(direction2D[0], rightScaled).vec3_add(forward.vec3_scale(direction2D[1], forwardScaled), outDirection3D);
      if (direction3DUp != null && !this._myFlyingForward && !this._myFlyingRight) {
        outDirection3D = outDirection3D.vec3_removeComponentAlongAxis(direction3DUp, outDirection3D);
      }
      outDirection3D.vec3_normalize(outDirection3D);
    }
    this._myLastConvertRotationQuat.quat_copy(conversionRotationQuat);
    this._myLastConvertRotationQuatValid = true;
    return outDirection3D;
  };
}();

// dist/pp/gameplay/cauldron/cauldron/number_over_factor.js
var NumberOverFactor = class {
  _myFromValue;
  _myToValue;
  _myFromFactor;
  _myToFactor;
  _myEasingFunction;
  /** `Math.round` / `Math.floor` / `Math.ceil` can be used */
  _myRoundingFunction;
  constructor(fromValue, toValue = fromValue, fromFactor = 0, toFactor = 0, easingFunction = EasingFunction.linear, roundingFunction = null) {
    this._myFromValue = fromValue;
    this._myToValue = toValue;
    this._myFromFactor = fromFactor;
    this._myToFactor = toFactor;
    this._myEasingFunction = easingFunction;
    this._myRoundingFunction = roundingFunction;
  }
  get(factor) {
    const interpolationFactor = this._myEasingFunction(Math.pp_mapToRange(factor, this._myFromFactor, this._myToFactor, 0, 1));
    let currentValue = Math.pp_lerp(this._myFromValue, this._myToValue, interpolationFactor);
    if (this._myRoundingFunction != null) {
      currentValue = this._myRoundingFunction(currentValue, this._myFromValue, this._myToValue);
    }
    return currentValue;
  }
  getAverage(factor) {
    return this.get(factor);
  }
  getRange(factor) {
    const currentValue = this.get(factor);
    return [currentValue, currentValue];
  }
  getMax(factor) {
    return this.get(factor);
  }
  getMin(factor) {
    return this.get(factor);
  }
  isInside(value, factor) {
    const currentValue = this.get(factor);
    return currentValue == value;
  }
  isInsideAngleRange(value, factor) {
    return this.isInsideAngleRangeDegrees(value, factor);
  }
  isInsideAngleRangeDegrees(value, factor) {
    const currentValue = this.get(factor);
    const clampedValue = Math.pp_angleClampDegrees(value);
    const clampedCurrentValue = Math.pp_angleClampDegrees(currentValue);
    return clampedValue == clampedCurrentValue;
  }
  isInsideAngleRangeRadians(value, factor) {
    const currentValue = this.get(factor);
    const clampedValue = Math.pp_angleClampRadians(value);
    const clampedCurrentValue = Math.pp_angleClampRadians(currentValue);
    return clampedValue == clampedCurrentValue;
  }
};
var IntOverFactor = class extends NumberOverFactor {
  constructor(fromValue, toValue = fromValue, fromFactor = 0, toFactor = 0, easingFunction = EasingFunction.linear, roundingFunction = null) {
    if (roundingFunction == null) {
      roundingFunction = function(valueToRound, fromValue2, toValue2) {
        let roundedValue = null;
        const useFloor = fromValue2 <= toValue2;
        if (useFloor) {
          roundedValue = Math.floor(valueToRound);
        } else {
          roundedValue = Math.ceil(valueToRound);
        }
        return roundedValue;
      };
    }
    super(fromValue, toValue, fromFactor, toFactor, easingFunction, roundingFunction);
  }
};
var NumberRangeOverFactor = class {
  _myRangeStartOverFactor;
  _myRangeEndOverFactor;
  _myRoundingFunction;
  // Math.round/floor/ceil can be used
  constructor(fromRange, toRange = fromRange, fromFactor = 0, toFactor = 0, easingFunction = EasingFunction.linear, roundingFunction = null) {
    this._myRangeStartOverFactor = new NumberOverFactor(fromRange[0], toRange[0], fromFactor, toFactor, easingFunction, roundingFunction);
    this._myRangeEndOverFactor = new NumberOverFactor(fromRange[1], toRange[1], fromFactor, toFactor, easingFunction, roundingFunction);
    this._myRoundingFunction = roundingFunction;
  }
  get(factor) {
    const rangeStart = this._myRangeStartOverFactor.get(factor);
    const rangeEnd = this._myRangeEndOverFactor.get(factor);
    let randomValue = null;
    if (this._myRoundingFunction) {
      randomValue = Math.pp_randomInt(rangeStart, rangeEnd);
    } else {
      randomValue = Math.pp_random(rangeStart, rangeEnd);
    }
    return randomValue;
  }
  getAverage(factor) {
    const rangeStart = this._myRangeStartOverFactor.get(factor);
    const rangeEnd = this._myRangeEndOverFactor.get(factor);
    let averageValue = (rangeStart + rangeEnd) / 2;
    if (this._myRoundingFunction) {
      averageValue = this._myRoundingFunction(averageValue, rangeStart, rangeEnd);
    }
    return averageValue;
  }
  getRange(factor) {
    const rangeStart = this._myRangeStartOverFactor.get(factor);
    const rangeEnd = this._myRangeEndOverFactor.get(factor);
    return [rangeStart, rangeEnd];
  }
  getMax(factor) {
    const rangeStart = this._myRangeStartOverFactor.get(factor);
    const rangeEnd = this._myRangeEndOverFactor.get(factor);
    return Math.max(rangeStart, rangeEnd);
  }
  getMin(factor) {
    const rangeStart = this._myRangeStartOverFactor.get(factor);
    const rangeEnd = this._myRangeEndOverFactor.get(factor);
    return Math.min(rangeStart, rangeEnd);
  }
  isInside(value, factor) {
    const rangeStart = this._myRangeStartOverFactor.get(factor);
    const rangeEnd = this._myRangeEndOverFactor.get(factor);
    const min = Math.min(rangeStart, rangeEnd);
    const max = Math.max(rangeStart, rangeEnd);
    return value >= min && value <= max;
  }
  isInsideAngleRange(value, factor) {
    return this.isInsideAngleRangeDegrees(value, factor);
  }
  isInsideAngleRangeDegrees(value, factor) {
    const rangeStart = this._myRangeStartOverFactor.get(factor);
    const rangeEnd = this._myRangeEndOverFactor.get(factor);
    return Math.pp_isInsideAngleRangeDegrees(value, rangeStart, rangeEnd);
  }
  isInsideAngleRangeRadians(value, factor) {
    const rangeStart = this._myRangeStartOverFactor.get(factor);
    const rangeEnd = this._myRangeEndOverFactor.get(factor);
    return Math.pp_isInsideAngleRangeRadians(value, rangeStart, rangeEnd);
  }
};
var IntRangeOverFactor = class extends NumberRangeOverFactor {
  constructor(fromRange, toRange = fromRange, fromFactor = 0, toFactor = 0, easingFunction = EasingFunction.linear, roundingFunction = null) {
    if (roundingFunction == null) {
      roundingFunction = function(valueToRound, fromValue, toValue) {
        let roundedValue = null;
        const useFloor = fromValue <= toValue;
        if (useFloor) {
          roundedValue = Math.floor(valueToRound);
        } else {
          roundedValue = Math.ceil(valueToRound);
        }
        return roundedValue;
      };
    }
    super(fromRange, toRange, fromFactor, toFactor, easingFunction, roundingFunction);
  }
};

// dist/pp/gameplay/cauldron/cauldron/animated_number.js
var AnimatedNumberParams = class {
  myInitialValue = 0;
  myAnimationSeconds = 0;
  myAnimationEasingFunction = EasingFunction.easeInOut;
  /**
   * If this value is not `null` it will be used as reference for the `myAnimationSeconds` time, which
   * will then be considered as the time to reach `myReferenceTargetValue` from `myInitialValue`
   *
   * This means that when a new target value is specified, the time to reach it will automatically be computed
   * based on this value, while if this value is `null` it will always take the same time (specified with `myAnimationSeconds`)
   * no matter how far or close the target value is from the current value
  */
  myReferenceTargetValue = null;
  /**
   * When setting a new target value, if the animated number still has to reach the old target, do not restart
   * the animation towards the new target from the start of the easing curve, but continue from the current point,
   * but take the new computed time as the time to reach the end of the easing curve.
   * This make it so the "velocity" of the number is kept even when the target changes.
   *
   * This settings is applid only if {@link myReferenceTargetValue} is specified
   */
  myKeepAnimationEasingProgressOnTargetUpdate = true;
  /** `Math.round` / `Math.floor` / `Math.ceil` can be used */
  myRoundingFunction = null;
};
var AnimatedNumber = class {
  _myParams;
  _myCurrentValue = 0;
  _myStartValue = 0;
  _myTargetValue = 0;
  _myAnimationTimer = new Timer(0, false);
  _myEasingFunction = this._easingFunction.bind(this);
  _myEasingStartValueToUse = 0;
  _myEasingNextStartValueToUse = 0;
  constructor(params) {
    this._myParams = params;
    this._myCurrentValue = this._myParams.myInitialValue;
    this._myStartValue = this._myParams.myInitialValue;
    this._myTargetValue = this._myParams.myInitialValue;
    this._myAnimationTimer.reset(this._myParams.myAnimationSeconds);
  }
  update(dt) {
    if (this._myAnimationTimer.isRunning()) {
      this._myAnimationTimer.update(dt);
      const animationPercentage = this._myAnimationTimer.getPercentage();
      this._myCurrentValue = MathUtils.interpolate(this._myStartValue, this._myTargetValue, animationPercentage, this._myEasingFunction);
    }
  }
  getParams() {
    return this._myParams;
  }
  getCurrentValue() {
    return this._myCurrentValue;
  }
  getStartValue() {
    return this._myStartValue;
  }
  getTargetValue() {
    return this._myTargetValue;
  }
  setTargetValue(targetValue, forceSet = false) {
    if (this._myTargetValue == targetValue && !forceSet)
      return;
    this._myTargetValue = targetValue;
    if (this._myParams.myReferenceTargetValue == null) {
      this._myStartValue = this._myCurrentValue;
      this._myAnimationTimer.start(this._myParams.myAnimationSeconds);
    } else {
      const distanceFromInitialToReference = Math.abs(this._myParams.myReferenceTargetValue - this._myParams.myInitialValue);
      const distanceFromCurrentToTarget = Math.abs(this._myTargetValue - this._myCurrentValue);
      const secondsToReachTarget = distanceFromCurrentToTarget / distanceFromInitialToReference * this._myParams.myAnimationSeconds;
      this._myStartValue = this._myCurrentValue;
      if (this._myAnimationTimer.isRunning() && this._myParams.myKeepAnimationEasingProgressOnTargetUpdate) {
        this._myEasingStartValueToUse = this._myEasingNextStartValueToUse;
        const maxValue = 1 - MathUtils.EPSILON;
        if (this._myEasingStartValueToUse >= maxValue || this._myParams.myAnimationEasingFunction(this._myEasingStartValueToUse) >= maxValue) {
          this._myEasingStartValueToUse = 0;
        }
      } else {
        this._myEasingStartValueToUse = 0;
      }
      this._myAnimationTimer.start(secondsToReachTarget);
    }
  }
  end() {
    this._myAnimationTimer.end();
    this._myCurrentValue = MathUtils.interpolate(this._myStartValue, this._myTargetValue, 1, this._myEasingFunction);
  }
  isDone() {
    return this._myAnimationTimer.isDone();
  }
  _easingFunction(valueToEase) {
    const adjustedValueToEase = MathUtils.mapToRange(valueToEase, 0, 1, this._myEasingStartValueToUse, 1);
    this._myEasingNextStartValueToUse = adjustedValueToEase;
    const easedValue = this._myParams.myAnimationEasingFunction(adjustedValueToEase);
    return MathUtils.mapToRange(easedValue, this._myParams.myAnimationEasingFunction(this._myEasingStartValueToUse), 1, 0, 1);
  }
};

// dist/pp/gameplay/cauldron/cauldron/components/cursor_button_component.js
import { Component as Component39, MeshComponent as MeshComponent10, property as property8, TextComponent as TextComponent8 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget6, FingerCursor as FingerCursor3 } from "@wonderlandengine/components";
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CursorButtonState;
(function(CursorButtonState2) {
  CursorButtonState2[CursorButtonState2["UNHOVER"] = 0] = "UNHOVER";
  CursorButtonState2[CursorButtonState2["HOVER"] = 1] = "HOVER";
  CursorButtonState2[CursorButtonState2["DOWN"] = 2] = "DOWN";
  CursorButtonState2[CursorButtonState2["UP"] = 3] = "UP";
})(CursorButtonState || (CursorButtonState = {}));
var CursorButtonComponent = class _CursorButtonComponent extends Component39 {
  static TypeName = "pp-cursor-button";
  /** This can be either a name of a component that is found on the same object of the cursor button,
      or the name of an handler added through `CursorButtonComponent.addButtonActionHandler` */
  _myButtonActionsHandlerNames;
  _myScaleOffsetOnHover;
  _myScaleOffsetOnDown;
  _myScaleOffsetOnUp;
  _myPulseIntensityOnHover;
  _myPulseIntensityOnDown;
  _myPulseIntensityOnUp;
  _myPulseIntensityOnUnhover;
  _myColorBrigthnessOffsetOnHover;
  _myColorBrigthnessOffsetOnDown;
  _myColorBrigthnessOffsetOnUp;
  _myUseSpatialAudio;
  _mySpatialAudioReferenceDistance;
  _mySFXOnHover;
  _mySFXOnDown;
  _mySFXOnUp;
  _mySFXOnUnhover;
  /** Even if you barely interact with the button, it will keep staying in this state for the specified amount */
  _myMinHoverSecond;
  /** Even if you barely interact with the button, it will keep staying in this state for the specified amount */
  _myMinDownSecond;
  /** Even if you barely interact with the button, it will keep staying in this state for the specified amount */
  _myMinUpSecond;
  /** Even if you barely interact with the button, it will keep staying in this state for the specified amount */
  _myMinUnhoverSecond;
  _myPerformDefaultSecondaryCursorFeedbackOnHover;
  _myPerformDefaultSecondaryCursorFeedbackOnDown;
  _myPerformDefaultSecondaryCursorFeedbackOnUp;
  _myPerformDefaultSecondaryCursorFeedbackOnUnhover;
  _myUpCursorIsMainOnlyIfLastDown;
  _myUpWithSecondaryCursorIsMain;
  _myCursorButtonComponentID = "cursor_button_component" + MathUtils.randomUUID();
  _myCursorTarget = null;
  _myButtonActionsHandlers = /* @__PURE__ */ new Map();
  _myFSM = new FSM();
  _myKeepCurrentStateTimer = new Timer(0);
  _myTransitionQueue = [];
  _myApplyQueuedTransitions = false;
  _myHoverCursors = [];
  _myMainDownCursor = null;
  _myDownCursors = [];
  _myOriginalScaleLocal = vec3_create();
  _myAnimatedScale;
  _myAnimatedColorBrightnessOffset;
  _myFlatMaterialOriginalColors = [];
  _myPhongMaterialOriginalColors = [];
  _myOnHoverAudioPlayer = null;
  _myOnDownAudioPlayer = null;
  _myOnUpAudioPlayer = null;
  _myOnUnhoverAudioPlayer = null;
  _myFirstUpdate = true;
  static _myCursorButtonActionHandlers = /* @__PURE__ */ new Map();
  /** Used to add handlers for every cursor buttons that can be indexes with a string */
  static addButtonActionHandler(id, buttonActionHandler, engine = Globals.getMainEngine()) {
    if (!_CursorButtonComponent._myCursorButtonActionHandlers.has(engine)) {
      _CursorButtonComponent._myCursorButtonActionHandlers.set(engine, /* @__PURE__ */ new Map());
    }
    _CursorButtonComponent._myCursorButtonActionHandlers.get(engine).set(id, buttonActionHandler);
  }
  static removeButtonActionHandler(id, engine = Globals.getMainEngine()) {
    if (_CursorButtonComponent._myCursorButtonActionHandlers.has(engine)) {
      _CursorButtonComponent._myCursorButtonActionHandlers.get(engine).delete(id);
    }
  }
  static getButtonActionHandler(id, engine = Globals.getMainEngine()) {
    const buttonActionHandler = _CursorButtonComponent._myCursorButtonActionHandlers.get(engine)?.get(id);
    return buttonActionHandler != null ? buttonActionHandler : null;
  }
  /** Used to add handlers for this specific instance of cursor button */
  addButtonActionHandler(id, buttonActionHandler) {
    this._myButtonActionsHandlers.set(id, buttonActionHandler);
  }
  removeButtonActionHandler(id) {
    this._myButtonActionsHandlers.delete(id);
  }
  getButtonActionHandler(id) {
    const buttonActionHandler = this._myButtonActionsHandlers.get(id);
    return buttonActionHandler != null ? buttonActionHandler : null;
  }
  getCurrentState() {
    let currentState = CursorButtonState.UNHOVER;
    const currentFSMState = this._myFSM.getCurrentStateData().myID;
    switch (currentFSMState) {
      case "unhover":
        currentState = CursorButtonState.UNHOVER;
        break;
      case "hover":
        currentState = CursorButtonState.HOVER;
        break;
      case "down":
        currentState = CursorButtonState.DOWN;
        break;
      case "up_with_down":
        currentState = CursorButtonState.UP;
        break;
    }
    return currentState;
  }
  start() {
    const buttonActionsHandlerNames = [...this._myButtonActionsHandlerNames.split(",")];
    for (let i = 0; i < buttonActionsHandlerNames.length; i++) {
      buttonActionsHandlerNames[i] = buttonActionsHandlerNames[i].trim();
    }
    for (const buttonActionsHandlerName of buttonActionsHandlerNames) {
      const buttonActionHandlerComponent = this.object.pp_getComponent(buttonActionsHandlerName);
      if (buttonActionHandlerComponent != null) {
        this._myButtonActionsHandlers.set(buttonActionsHandlerName, buttonActionHandlerComponent);
      } else {
        const buttonActionHandlerStatic = _CursorButtonComponent.getButtonActionHandler(buttonActionsHandlerName, this.engine);
        if (buttonActionHandlerStatic != null) {
          this._myButtonActionsHandlers.set(buttonActionsHandlerName, buttonActionHandlerStatic);
        }
      }
    }
    this._myKeepCurrentStateTimer.end();
    this._myFSM.setLogEnabled(false, "Cursor Button");
    this._myFSM.addState("unhover", { start: this._onUnhoverStart.bind(this) });
    this._myFSM.addState("hover", { start: this._onHoverStart.bind(this) });
    this._myFSM.addState("down", { start: this._onDownStart.bind(this) });
    this._myFSM.addState("up_with_down", { start: this._onUpWithDownStart.bind(this) });
    this._myFSM.addTransition("unhover", "hover", "hover");
    this._myFSM.addTransition("hover", "down", "down");
    this._myFSM.addTransition("down", "up_with_down", "up_with_down");
    this._myFSM.addTransition("down", "hover", "hover");
    this._myFSM.addTransition("up_with_down", "unhover", "unhover");
    this._myFSM.addTransition("up_with_down", "down", "down");
    this._myFSM.addTransition("hover", "unhover", "unhover");
    this._myFSM.addTransition("down", "unhover", "unhover");
    this._myFSM.addTransition("hover", "unhover", "instant_unhover", this._onInstantUnhover.bind(this), SkipStateFunction.BOTH);
    this._myFSM.addTransition("up_with_down", "unhover", "instant_unhover", this._onInstantUnhover.bind(this), SkipStateFunction.BOTH);
    this._myFSM.addTransition("down", "unhover", "instant_unhover", this._onInstantUnhover.bind(this), SkipStateFunction.BOTH);
    this._myFSM.addTransition("unhover", "unhover", "instant_unhover", this._onInstantUnhover.bind(this), SkipStateFunction.BOTH);
    this._myFSM.init("unhover");
  }
  _start() {
    this._setupVisualsAndSFXs();
    this._myCursorTarget = this.object.pp_getComponent(CursorTarget6);
    this.onActivate();
  }
  static _updateSV = {
    buttonScale: vec3_create(),
    hsvColor: vec4_create(),
    rgbColor: vec4_create()
  };
  update(dt) {
    if (this._myFirstUpdate) {
      this._start();
      this._myFirstUpdate = false;
    }
    this._myFSM.update(dt);
    if (this._myKeepCurrentStateTimer.isRunning()) {
      this._myKeepCurrentStateTimer.update(dt);
      if (this._myKeepCurrentStateTimer.isDone()) {
        this._myApplyQueuedTransitions = true;
      }
    }
    if (this._myApplyQueuedTransitions) {
      this._myApplyQueuedTransitions = false;
      while (this._myTransitionQueue.length > 0) {
        const transitionToApply = this._myTransitionQueue.shift();
        if (this._myFSM.canPerform(transitionToApply[0])) {
          if (transitionToApply[3] != null) {
            this._myFSM.perform(transitionToApply[0], transitionToApply[1], transitionToApply[2], transitionToApply[3]);
          } else {
            this._myFSM.perform(transitionToApply[0], transitionToApply[1], transitionToApply[2]);
          }
        } else {
          transitionToApply[4]();
        }
        if (this._myKeepCurrentStateTimer.isRunning()) {
          break;
        }
      }
    }
    let skipDefault = false;
    for (const buttonActionsHandler of this._myButtonActionsHandlers.values()) {
      if (buttonActionsHandler.onUpdate != null) {
        skipDefault ||= buttonActionsHandler.onUpdate(dt, this, this.getCurrentState());
      }
    }
    if (!skipDefault) {
      if (!this._myAnimatedScale.isDone()) {
        this._myAnimatedScale.update(dt);
        const buttonScale = _CursorButtonComponent._updateSV.buttonScale;
        this.object.pp_setScaleLocal(this._myOriginalScaleLocal.vec3_scale(this._myAnimatedScale.getCurrentValue(), buttonScale));
      }
      if (!this._myAnimatedColorBrightnessOffset.isDone()) {
        this._myAnimatedColorBrightnessOffset.update(dt);
        const colorBrightnessOffsetCurrentValue = this._myAnimatedColorBrightnessOffset.getCurrentValue();
        const hsvColor = _CursorButtonComponent._updateSV.hsvColor;
        const rgbColor = _CursorButtonComponent._updateSV.rgbColor;
        for (const [material, originalColor] of this._myPhongMaterialOriginalColors) {
          ColorUtils.rgbToHSV(originalColor, hsvColor);
          hsvColor[2] = MathUtils.clamp(hsvColor[2] + colorBrightnessOffsetCurrentValue, 0, 1);
          material.diffuseColor = ColorUtils.hsvToRGB(hsvColor, rgbColor);
        }
        for (const [material, originalColor] of this._myFlatMaterialOriginalColors) {
          ColorUtils.rgbToHSV(originalColor, hsvColor);
          hsvColor[2] = MathUtils.clamp(hsvColor[2] + colorBrightnessOffsetCurrentValue, 0, 1);
          material.color = ColorUtils.hsvToRGB(hsvColor, rgbColor);
        }
      }
    }
  }
  _onUnhover(targetObject, cursorComponent) {
    if (cursorComponent instanceof FingerCursor3)
      return;
    this._myHoverCursors.pp_removeEqual(cursorComponent);
    const cursorWasDown = this._myDownCursors.pp_removeEqual(cursorComponent);
    const isMainCursorDown = this._myDownCursors.length == 0 && cursorWasDown || this._myMainDownCursor == cursorComponent && !this._myUpCursorIsMainOnlyIfLastDown && !this._myUpWithSecondaryCursorIsMain;
    if (isMainCursorDown) {
      this._myMainDownCursor = null;
      if (this._myHoverCursors.length > 0) {
        this._addToTransitionQueue("hover", cursorComponent, false, true, this._onHoverStart.bind(this, null, null, cursorComponent, true, true));
      } else {
        this._addToTransitionQueue("unhover", cursorComponent, false, null, this._onUnhoverStart.bind(this, null, null, cursorComponent, true));
      }
    } else {
      if (this._myMainDownCursor == cursorComponent) {
        this._myMainDownCursor = this._myDownCursors[0];
      }
      const isSecondaryCursor = this._myHoverCursors.length > 0;
      this._addToTransitionQueue("unhover", cursorComponent, isSecondaryCursor, null, this._onUnhoverStart.bind(this, null, null, cursorComponent, true));
    }
  }
  _onHover(targetObject, cursorComponent) {
    if (cursorComponent instanceof FingerCursor3)
      return;
    const isSecondaryCursor = this._myHoverCursors.length > 0;
    this._myHoverCursors.pp_pushUnique(cursorComponent);
    this._addToTransitionQueue("hover", cursorComponent, isSecondaryCursor, false, this._onHoverStart.bind(this, null, null, cursorComponent, true, false));
  }
  _onDown(targetObject, cursorComponent) {
    if (cursorComponent instanceof FingerCursor3)
      return;
    const isSecondaryCursor = this._myMainDownCursor != null && this._myMainDownCursor != cursorComponent;
    if (this._myMainDownCursor == null) {
      this._myMainDownCursor = cursorComponent;
    }
    this._myDownCursors.pp_pushUnique(cursorComponent);
    this._addToTransitionQueue("down", cursorComponent, isSecondaryCursor, null, this._onDownStart.bind(this, null, null, cursorComponent, true));
  }
  onUpWithDown(targetObject, cursorComponent) {
    this._myDownCursors.pp_removeEqual(cursorComponent);
    const isSecondaryCursor = !this._myUpWithSecondaryCursorIsMain && (!this._myUpCursorIsMainOnlyIfLastDown && this._myMainDownCursor != cursorComponent || this._myUpCursorIsMainOnlyIfLastDown && this._myDownCursors.length > 0);
    if (!isSecondaryCursor) {
      this._myMainDownCursor = null;
    } else if (this._myMainDownCursor == cursorComponent) {
      this._myMainDownCursor = this._myDownCursors[0];
    }
    this._addToTransitionQueue("up_with_down", cursorComponent, isSecondaryCursor, null, this._onUpWithDownStart.bind(this, null, null, cursorComponent, true));
  }
  _addToTransitionQueue(transitionToPerform, cursorComponent, isSecondaryCursor, isHoverFromDown, startCallback) {
    if (!isSecondaryCursor) {
      if (!this._myKeepCurrentStateTimer.isDone()) {
        const index = this._myTransitionQueue.pp_findIndex((elementToCheck) => {
          return elementToCheck[0] == transitionToPerform && elementToCheck[1] == cursorComponent && elementToCheck[2] == isSecondaryCursor && elementToCheck[3] == isHoverFromDown;
        });
        if (index == -1) {
          this._myTransitionQueue.push([transitionToPerform, cursorComponent, isSecondaryCursor, isHoverFromDown, startCallback]);
        } else {
          this._myTransitionQueue.splice(index + 1);
        }
      } else if (this._myFSM.canPerform(transitionToPerform)) {
        this._myFSM.perform(transitionToPerform, cursorComponent, isSecondaryCursor, isHoverFromDown);
      } else {
        startCallback();
      }
    } else {
      startCallback();
    }
  }
  _onInstantUnhover(fsm, transitionData) {
    let skipDefault = false;
    for (const buttonActionsHandler of this._myButtonActionsHandlers.values()) {
      if (buttonActionsHandler.onInstantUnhover != null) {
        skipDefault ||= buttonActionsHandler.onInstantUnhover(this);
      }
    }
    if (skipDefault) {
      return;
    }
    {
      this._myAnimatedScale.setTargetValue(1);
      this._myAnimatedScale.end();
      this.object.pp_setScaleLocal(this._myOriginalScaleLocal.vec3_scale(this._myAnimatedScale.getCurrentValue()));
    }
    {
      this._myAnimatedColorBrightnessOffset.setTargetValue(0);
      this._myAnimatedColorBrightnessOffset.end();
      const colorBrightnessOffsetCurrentValue = this._myAnimatedColorBrightnessOffset.getCurrentValue();
      for (const [material, originalColor] of this._myPhongMaterialOriginalColors) {
        const hsvColor = ColorUtils.rgbToHSV(originalColor);
        hsvColor[2] = MathUtils.clamp(hsvColor[2] + colorBrightnessOffsetCurrentValue, 0, 1);
        material.diffuseColor = ColorUtils.hsvToRGB(hsvColor);
      }
      for (const [material, originalColor] of this._myFlatMaterialOriginalColors) {
        const hsvColor = ColorUtils.rgbToHSV(originalColor);
        hsvColor[2] = MathUtils.clamp(hsvColor[2] + colorBrightnessOffsetCurrentValue, 0, 1);
        material.color = ColorUtils.hsvToRGB(hsvColor);
      }
    }
  }
  _onUnhoverStart(fsm, transitionData, cursorComponent, isSecondaryCursor) {
    if (!isSecondaryCursor) {
      this._myKeepCurrentStateTimer.start(this._myMinUnhoverSecond);
      this._myKeepCurrentStateTimer.update(0);
    }
    let skipDefault = false;
    for (const buttonActionsHandler of this._myButtonActionsHandlers.values()) {
      if (buttonActionsHandler.onUnhover != null) {
        skipDefault ||= buttonActionsHandler.onUnhover(this, cursorComponent, isSecondaryCursor);
      }
    }
    if (skipDefault) {
      return;
    }
    if (!isSecondaryCursor) {
      if (this._myScaleOffsetOnHover != 0 || this._myScaleOffsetOnDown != 0 || this._myScaleOffsetOnUp != 0) {
        this._myAnimatedScale.setTargetValue(1);
      }
    }
    if (!isSecondaryCursor || this._myPerformDefaultSecondaryCursorFeedbackOnUnhover) {
      if (this._myPulseIntensityOnUnhover != 0) {
        const handedness = InputUtils.getHandednessByString(cursorComponent.handedness);
        if (handedness != null) {
          Globals.getGamepads()[handedness].pulse(this._myPulseIntensityOnUnhover, 0.085);
        }
      }
    }
    if (!isSecondaryCursor) {
      if (this._myColorBrigthnessOffsetOnHover != 0 || this._myColorBrigthnessOffsetOnDown != 0 || this._myColorBrigthnessOffsetOnUp != 0) {
        this._myAnimatedColorBrightnessOffset.setTargetValue(0);
      }
    }
    if (!isSecondaryCursor || this._myPerformDefaultSecondaryCursorFeedbackOnUnhover) {
      if (this._myOnUnhoverAudioPlayer != null) {
        this._myOnUnhoverAudioPlayer.setPosition(this.object.pp_getPosition());
        this._myOnUnhoverAudioPlayer.play();
      }
    }
  }
  _onHoverStart(fsm, transitionData, cursorComponent, isSecondaryCursor, isHoverFromDown) {
    if (!isSecondaryCursor) {
      this._myKeepCurrentStateTimer.start(this._myMinHoverSecond);
      this._myKeepCurrentStateTimer.update(0);
    }
    let skipDefault = false;
    for (const buttonActionsHandler of this._myButtonActionsHandlers.values()) {
      if (buttonActionsHandler.onHover != null) {
        skipDefault ||= buttonActionsHandler.onHover(this, cursorComponent, isSecondaryCursor, isHoverFromDown);
      }
    }
    if (skipDefault) {
      return;
    }
    if (!isSecondaryCursor) {
      if (this._myScaleOffsetOnHover != 0 || this._myScaleOffsetOnDown != 0 || this._myScaleOffsetOnUp != 0) {
        this._myAnimatedScale.setTargetValue(1 + this._myScaleOffsetOnHover);
      }
    }
    if (!isSecondaryCursor || this._myPerformDefaultSecondaryCursorFeedbackOnHover) {
      if (this._myPulseIntensityOnHover != 0) {
        const handedness = InputUtils.getHandednessByString(cursorComponent.handedness);
        if (handedness != null) {
          Globals.getGamepads()[handedness].pulse(this._myPulseIntensityOnHover, 0.085);
        }
      }
    }
    if (!isSecondaryCursor) {
      if (this._myColorBrigthnessOffsetOnHover != 0 || this._myColorBrigthnessOffsetOnDown != 0 || this._myColorBrigthnessOffsetOnUp != 0) {
        this._myAnimatedColorBrightnessOffset.setTargetValue(this._myColorBrigthnessOffsetOnHover);
      }
    }
    if (!isSecondaryCursor || this._myPerformDefaultSecondaryCursorFeedbackOnHover) {
      if (this._myOnHoverAudioPlayer != null) {
        this._myOnHoverAudioPlayer.setPosition(this.object.pp_getPosition());
        this._myOnHoverAudioPlayer.play();
      }
    }
  }
  _onDownStart(fsm, transitionData, cursorComponent, isSecondaryCursor) {
    if (!isSecondaryCursor) {
      this._myKeepCurrentStateTimer.start(this._myMinDownSecond);
      this._myKeepCurrentStateTimer.update(0);
    }
    let skipDefault = false;
    for (const buttonActionsHandler of this._myButtonActionsHandlers.values()) {
      if (buttonActionsHandler.onDown != null) {
        skipDefault ||= buttonActionsHandler.onDown(this, cursorComponent, isSecondaryCursor);
      }
    }
    if (skipDefault) {
      return;
    }
    if (!isSecondaryCursor) {
      if (this._myScaleOffsetOnHover != 0 || this._myScaleOffsetOnDown != 0 || this._myScaleOffsetOnUp != 0) {
        this._myAnimatedScale.setTargetValue(1 + this._myScaleOffsetOnDown);
      }
    }
    if (!isSecondaryCursor || this._myPerformDefaultSecondaryCursorFeedbackOnDown) {
      if (this._myPulseIntensityOnDown != 0) {
        const handedness = InputUtils.getHandednessByString(cursorComponent.handedness);
        if (handedness != null) {
          Globals.getGamepads()[handedness].pulse(this._myPulseIntensityOnDown, 0.085);
        }
      }
    }
    if (!isSecondaryCursor) {
      if (this._myColorBrigthnessOffsetOnHover != 0 || this._myColorBrigthnessOffsetOnDown != 0 || this._myColorBrigthnessOffsetOnUp != 0) {
        this._myAnimatedColorBrightnessOffset.setTargetValue(this._myColorBrigthnessOffsetOnDown);
      }
    }
    if (!isSecondaryCursor || this._myPerformDefaultSecondaryCursorFeedbackOnDown) {
      if (this._myOnDownAudioPlayer != null) {
        this._myOnDownAudioPlayer.setPosition(this.object.pp_getPosition());
        this._myOnDownAudioPlayer.play();
      }
    }
  }
  _onUpWithDownStart(fsm, transitionData, cursorComponent, isSecondaryCursor) {
    if (!isSecondaryCursor) {
      this._myKeepCurrentStateTimer.start(this._myMinUpSecond);
      this._myKeepCurrentStateTimer.update(0);
    }
    let skipDefault = false;
    for (const buttonActionsHandler of this._myButtonActionsHandlers.values()) {
      if (buttonActionsHandler.onUp != null) {
        skipDefault ||= buttonActionsHandler.onUp(this, cursorComponent, isSecondaryCursor);
      }
    }
    if (skipDefault) {
      return;
    }
    if (!isSecondaryCursor) {
      if (this._myScaleOffsetOnHover != 0 || this._myScaleOffsetOnDown != 0 || this._myScaleOffsetOnUp != 0) {
        this._myAnimatedScale.setTargetValue(1 + this._myScaleOffsetOnUp);
      }
    }
    if (!isSecondaryCursor || this._myPerformDefaultSecondaryCursorFeedbackOnUp) {
      if (this._myPulseIntensityOnUp != 0) {
        const handedness = InputUtils.getHandednessByString(cursorComponent.handedness);
        if (handedness != null) {
          Globals.getGamepads()[handedness].pulse(this._myPulseIntensityOnUp, 0.085);
        }
      }
    }
    if (!isSecondaryCursor) {
      if (this._myColorBrigthnessOffsetOnHover != 0 || this._myColorBrigthnessOffsetOnDown != 0 || this._myColorBrigthnessOffsetOnUp != 0) {
        this._myAnimatedColorBrightnessOffset.setTargetValue(this._myColorBrigthnessOffsetOnUp);
      }
    }
    if (!isSecondaryCursor || this._myPerformDefaultSecondaryCursorFeedbackOnUp) {
      if (this._myOnUpAudioPlayer != null) {
        this._myOnUpAudioPlayer.setPosition(this.object.pp_getPosition());
        this._myOnUpAudioPlayer.play();
      }
    }
  }
  _setupVisualsAndSFXs() {
    this.object.pp_getScaleLocal(this._myOriginalScaleLocal);
    const animatedScaleParams = new AnimatedNumberParams();
    animatedScaleParams.myInitialValue = this._myOriginalScaleLocal[0];
    animatedScaleParams.myAnimationSeconds = 0.25;
    this._myAnimatedScale = new AnimatedNumber(animatedScaleParams);
    const animatedColorBrightnessOffsetParams = new AnimatedNumberParams();
    animatedColorBrightnessOffsetParams.myInitialValue = 0;
    animatedColorBrightnessOffsetParams.myAnimationSeconds = 0.25;
    this._myAnimatedColorBrightnessOffset = new AnimatedNumber(animatedColorBrightnessOffsetParams);
    const meshComponents = this.object.pp_getComponents(MeshComponent10);
    for (const meshComponent of meshComponents) {
      meshComponent.material = meshComponent.material?.clone();
      const phongMaterial = meshComponent.material;
      if (phongMaterial.diffuseColor != null) {
        this._myPhongMaterialOriginalColors.push([phongMaterial, phongMaterial.diffuseColor.vec4_clone()]);
      } else {
        const flatMaterial = meshComponent.material;
        if (flatMaterial.color != null) {
          this._myFlatMaterialOriginalColors.push([flatMaterial, flatMaterial.color.vec4_clone()]);
        }
      }
    }
    const textComponents = this.object.pp_getComponents(TextComponent8);
    for (const textComponent of textComponents) {
      textComponent.material = textComponent.material?.clone();
      const flatMaterial = textComponent.material;
      if (flatMaterial.color != null) {
        this._myFlatMaterialOriginalColors.push([flatMaterial, flatMaterial.color.vec4_clone()]);
      }
    }
    const audioManager = Globals.getAudioManager(this.engine);
    if (this._mySFXOnHover.length > 0) {
      const audioSetup = new AudioSetup(this._mySFXOnHover);
      audioSetup.mySpatial = this._myUseSpatialAudio;
      audioSetup.myReferenceDistance = this._mySpatialAudioReferenceDistance;
      const audioID = this._myCursorButtonComponentID + "_on_hover";
      audioManager.addAudioSetup(audioID, audioSetup);
      this._myOnHoverAudioPlayer = audioManager.createAudioPlayer(audioID);
    }
    if (this._mySFXOnDown.length > 0) {
      const audioSetup = new AudioSetup(this._mySFXOnDown);
      audioSetup.mySpatial = this._myUseSpatialAudio;
      audioSetup.myReferenceDistance = this._mySpatialAudioReferenceDistance;
      const audioID = this._myCursorButtonComponentID + "_on_down";
      audioManager.addAudioSetup(audioID, audioSetup);
      this._myOnDownAudioPlayer = audioManager.createAudioPlayer(audioID);
    }
    if (this._mySFXOnUp.length > 0) {
      const audioSetup = new AudioSetup(this._mySFXOnUp);
      audioSetup.mySpatial = this._myUseSpatialAudio;
      audioSetup.myReferenceDistance = this._mySpatialAudioReferenceDistance;
      const audioID = this._myCursorButtonComponentID + "_on_up";
      audioManager.addAudioSetup(audioID, audioSetup);
      this._myOnUpAudioPlayer = audioManager.createAudioPlayer(audioID);
    }
    if (this._mySFXOnUnhover.length > 0) {
      const audioSetup = new AudioSetup(this._mySFXOnUnhover);
      audioSetup.mySpatial = this._myUseSpatialAudio;
      audioSetup.myReferenceDistance = this._mySpatialAudioReferenceDistance;
      const audioID = this._myCursorButtonComponentID + "_on_unhover";
      audioManager.addAudioSetup(audioID, audioSetup);
      this._myOnUnhoverAudioPlayer = audioManager.createAudioPlayer(audioID);
    }
  }
  onActivate() {
    if (this._myCursorTarget != null) {
      this._myCursorTarget.onUnhover.add(this._onUnhover.bind(this), { id: this });
      this._myCursorTarget.onHover.add(this._onHover.bind(this), { id: this });
      this._myCursorTarget.onDown.add(this._onDown.bind(this), { id: this });
      this._myCursorTarget.onUpWithDown.add(this.onUpWithDown.bind(this), { id: this });
    }
  }
  onDeactivate() {
    if (this._myCursorTarget != null) {
      this._myCursorTarget.onUnhover.remove(this);
      this._myCursorTarget.onHover.remove(this);
      this._myCursorTarget.onDown.remove(this);
      this._myCursorTarget.onUpWithDown.remove(this);
      this._myKeepCurrentStateTimer.end();
      this._myTransitionQueue.pp_clear();
      this._myApplyQueuedTransitions = false;
      this._myHoverCursors.pp_clear();
      this._myMainDownCursor = null;
      this._myDownCursors.pp_clear();
      this._myFSM.perform("instant_unhover");
    }
  }
};
__decorate8([
  property8.string("")
], CursorButtonComponent.prototype, "_myButtonActionsHandlerNames", void 0);
__decorate8([
  property8.float(0.075)
], CursorButtonComponent.prototype, "_myScaleOffsetOnHover", void 0);
__decorate8([
  property8.float(-0.075)
], CursorButtonComponent.prototype, "_myScaleOffsetOnDown", void 0);
__decorate8([
  property8.float(0.075)
], CursorButtonComponent.prototype, "_myScaleOffsetOnUp", void 0);
__decorate8([
  property8.float(0.1)
], CursorButtonComponent.prototype, "_myPulseIntensityOnHover", void 0);
__decorate8([
  property8.float(0)
], CursorButtonComponent.prototype, "_myPulseIntensityOnDown", void 0);
__decorate8([
  property8.float(0.1)
], CursorButtonComponent.prototype, "_myPulseIntensityOnUp", void 0);
__decorate8([
  property8.float(0)
], CursorButtonComponent.prototype, "_myPulseIntensityOnUnhover", void 0);
__decorate8([
  property8.float(-0.1)
], CursorButtonComponent.prototype, "_myColorBrigthnessOffsetOnHover", void 0);
__decorate8([
  property8.float(0)
], CursorButtonComponent.prototype, "_myColorBrigthnessOffsetOnDown", void 0);
__decorate8([
  property8.float(-0.1)
], CursorButtonComponent.prototype, "_myColorBrigthnessOffsetOnUp", void 0);
__decorate8([
  property8.bool(true)
], CursorButtonComponent.prototype, "_myUseSpatialAudio", void 0);
__decorate8([
  property8.float(1.5)
], CursorButtonComponent.prototype, "_mySpatialAudioReferenceDistance", void 0);
__decorate8([
  property8.string("")
], CursorButtonComponent.prototype, "_mySFXOnHover", void 0);
__decorate8([
  property8.string("")
], CursorButtonComponent.prototype, "_mySFXOnDown", void 0);
__decorate8([
  property8.string("")
], CursorButtonComponent.prototype, "_mySFXOnUp", void 0);
__decorate8([
  property8.string("")
], CursorButtonComponent.prototype, "_mySFXOnUnhover", void 0);
__decorate8([
  property8.float(0)
], CursorButtonComponent.prototype, "_myMinHoverSecond", void 0);
__decorate8([
  property8.float(0.15)
], CursorButtonComponent.prototype, "_myMinDownSecond", void 0);
__decorate8([
  property8.float(0)
], CursorButtonComponent.prototype, "_myMinUpSecond", void 0);
__decorate8([
  property8.float(0)
], CursorButtonComponent.prototype, "_myMinUnhoverSecond", void 0);
__decorate8([
  property8.bool(true)
], CursorButtonComponent.prototype, "_myPerformDefaultSecondaryCursorFeedbackOnHover", void 0);
__decorate8([
  property8.bool(true)
], CursorButtonComponent.prototype, "_myPerformDefaultSecondaryCursorFeedbackOnDown", void 0);
__decorate8([
  property8.bool(true)
], CursorButtonComponent.prototype, "_myPerformDefaultSecondaryCursorFeedbackOnUp", void 0);
__decorate8([
  property8.bool(true)
], CursorButtonComponent.prototype, "_myPerformDefaultSecondaryCursorFeedbackOnUnhover", void 0);
__decorate8([
  property8.bool(false)
], CursorButtonComponent.prototype, "_myUpCursorIsMainOnlyIfLastDown", void 0);
__decorate8([
  property8.bool(false)
], CursorButtonComponent.prototype, "_myUpWithSecondaryCursorIsMain", void 0);

// dist/pp/gameplay/cauldron/rough/components/scale_on_spawn_component.js
import { Component as Component40, Property as Property26 } from "@wonderlandengine/api";
var ScaleOnSpawnComponent = class extends Component40 {
  static TypeName = "pp-scale-on-spawn";
  static Properties = {
    _myStartDelay: Property26.float(0),
    _myScaleDuration: Property26.float(0)
  };
  init() {
    this._myTargetScale = vec3_create(1, 1, 1);
  }
  start() {
    this.object.pp_setScale(MathUtils.EPSILON);
    this._myDelayTimer = new Timer(this._myStartDelay);
    this._myScaleDurationTimer = new Timer(this._myScaleDuration);
  }
  update(dt) {
    if (this._myDelayTimer.isRunning()) {
      this._myDelayTimer.update(dt);
    } else if (this._myScaleDurationTimer.isRunning()) {
      this._myScaleDurationTimer.update(dt);
      this.object.pp_setScale(this._myTargetScale.vec3_scale(EasingFunction.easeOut(this._myScaleDurationTimer.getPercentage())));
    }
  }
  onActivate() {
    this.start();
  }
  pp_clone(targetObject) {
    let clonedComponent = ComponentUtils.cloneDefault(this, targetObject);
    return clonedComponent;
  }
};

// dist/pp/gameplay/grab_throw/grabbable_component.js
import { Component as Component41, Emitter as Emitter11, PhysXComponent as PhysXComponent7, Property as Property27 } from "@wonderlandengine/api";
var GrabbableComponent = class extends Component41 {
  static TypeName = "pp-grabbable";
  static Properties = {
    _myThrowLinearVelocityMultiplier: Property27.float(1),
    _myThrowAngularVelocityMultiplier: Property27.float(1),
    _myKinematicValueOnRelease: Property27.enum(["True", "False", "Own"], "False"),
    _myParentOnRelease: Property27.enum(["Scene", "Own"], "Own")
  };
  init() {
    this._myGrabbed = false;
    this._myGrabber = null;
    this._myOldParent = null;
    this._myPhysX = null;
    this._myOldKinematicValue = null;
    this._myGrabEmitter = new Emitter11();
    this._myThrowEmitter = new Emitter11();
    this._myReleaseEmitter = new Emitter11();
    this._mySceneParent = null;
  }
  start() {
    this._myOldParent = this.object.pp_getParent();
    this._myPhysX = this.object.pp_getComponent(PhysXComponent7);
  }
  update(dt) {
    this._mySceneParent = Globals.getSceneObjects(this.engine)?.myDynamics ?? null;
  }
  onActivate() {
    this._mySceneParent = Globals.getSceneObjects(this.engine)?.myDynamics ?? null;
  }
  onDeactivate() {
    this.release();
  }
  grab(grabber) {
    if (!this.isGrabbed()) {
      this._myOldKinematicValue = this._myPhysX.kinematic;
    }
    this.release();
    this._myPhysX.kinematic = true;
    this._myOldParent = this.object.pp_getParent();
    this.object.pp_setParent(grabber);
    this._myGrabbed = true;
    this._myGrabEmitter.notify(grabber, this);
  }
  throw(linearVelocity, angularVelocity) {
    if (this._myGrabbed) {
      let grabber = this._myGrabber;
      this._release();
      this._myPhysX.linearVelocity = linearVelocity.vec3_scale(this._myThrowLinearVelocityMultiplier);
      this._myPhysX.angularVelocity = angularVelocity.vec3_scale(this._myThrowAngularVelocityMultiplier);
      this._myThrowEmitter.notify(grabber, this);
      this._myReleaseEmitter.notify(grabber, this, true);
    }
  }
  release() {
    if (this._myGrabbed) {
      let grabber = this._myGrabber;
      this._release();
      this._myReleaseEmitter.notify(grabber, this, false);
    }
  }
  getLinearVelocity() {
    return this._myPhysX.linearVelocity.vec3_clone();
  }
  getAngularVelocity() {
    return this.getAngularVelocityDegrees();
  }
  getAngularVelocityDegrees() {
    let angularVelocityDegrees = vec3_create();
    this._myPhysX.angularVelocity.vec3_toDegrees(angularVelocityDegrees);
    return angularVelocityDegrees;
  }
  getAngularVelocityRadians() {
    return this._myPhysX.angularVelocity.vec3_clone();
  }
  isGrabbed() {
    return this._myGrabbed;
  }
  getGrabber() {
    return this._myGrabber;
  }
  registerGrabEventListener(id, listener) {
    this._myGrabEmitter.add(listener, { id });
  }
  unregisterGrabEventListener(id) {
    this._myGrabEmitter.remove(id);
  }
  registerThrowEventListener(id, listener) {
    this._myThrowEmitter.add(listener, { id });
  }
  unregisterThrowEventListener(id) {
    this._myThrowEmitter.remove(id);
  }
  registerReleaseEventListener(id, listener) {
    this._myReleaseEmitter.add(listener, { id });
  }
  unregisterReleaseEventListener(id) {
    this._myReleaseEmitter.remove(id);
  }
  _release() {
    if (this._myParentOnRelease == 0) {
      this.object.pp_setParent(this._mySceneParent);
    } else {
      this.object.pp_setParent(this._myOldParent);
    }
    this._myGrabbed = false;
    this._myGrabber = null;
    if (this._myKinematicValueOnRelease == 0) {
      this._myPhysX.kinematic = true;
    } else if (this._myKinematicValueOnRelease == 1) {
      this._myPhysX.kinematic = false;
    } else if (this._myOldKinematicValue != null) {
      this._myPhysX.kinematic = this._myOldKinematicValue;
    }
    if (this._myPhysX.kinematic) {
      this._myPhysX.linearVelocity = vec3_create();
      this._myPhysX.angularVelocity = vec3_create();
    }
  }
  pp_clone(targetObject) {
    let clonedComponent = ComponentUtils.cloneDefault(this, targetObject);
    return clonedComponent;
  }
  pp_clonePostProcess(clonedComponent) {
    clonedComponent.start();
  }
};

// dist/pp/gameplay/grab_throw/grabber_hand_component.js
import { Component as Component42, Emitter as Emitter12, PhysXComponent as PhysXComponent8, Property as Property28 } from "@wonderlandengine/api";
var GrabberHandComponent = class extends Component42 {
  static TypeName = "pp-grabber-hand";
  static Properties = {
    _myHandedness: Property28.enum(["Left", "Right"], "Left"),
    _myGrabButton: Property28.enum(["Select", "Squeeze", "Both", "Both Exclusive"], "Squeeze"),
    // @"Both Exclusive" means u can use both buttons but you have to use the same button you grabbed with to throw
    _mySnapGrabbableToOrigin: Property28.bool(false),
    _myMaxNumberOfObjects: Property28.int(1),
    // How many objects you can grab at the same time
    // ADVANCED SETTINGS
    _myThrowVelocitySource: Property28.enum(["Hand", "Grabbable"], "Hand"),
    _myThrowLinearVelocityMultiplier: Property28.float(1),
    // Multiply the overall throw speed, so slow throws will be multiplied too
    _myThrowMaxLinearSpeed: Property28.float(15),
    _myThrowAngularVelocityMultiplier: Property28.float(0.5),
    _myThrowMaxAngularSpeed: Property28.float(1080),
    // @Degrees
    _myThrowLinearVelocityBoost: Property28.float(1.75),
    // This boost is applied from 0% to 100% based on how fast you throw, so slow throws are not affected
    _myThrowLinearVelocityBoostMinSpeedThreshold: Property28.float(0.6),
    // 0% boost is applied if plain throw speed is under this value
    _myThrowLinearVelocityBoostMaxSpeedThreshold: Property28.float(2.5)
    // 100% boost is applied if plain throw speed is over this value
  };
  init() {
    this._myGrabbables = [];
    this._myGamepad = null;
    this._myActiveGrabButton = null;
    this._myPrevInputSourceType = null;
    this._myLinearVelocityHistorySize = 5;
    this._myLinearVelocityHistorySpeedAverageSamplesFromStart = 1;
    this._myLinearVelocityHistoryDirectionAverageSamplesFromStart = 3;
    this._myLinearVelocityHistoryDirectionAverageSkipFromStart = 0;
    this._myHandLinearVelocityHistory = new Array(this._myLinearVelocityHistorySize);
    this._myHandLinearVelocityHistory.fill(vec3_create());
    this._myAngularVelocityHistorySize = 1;
    this._myHandAngularVelocityHistory = new Array(this._myAngularVelocityHistorySize);
    this._myHandAngularVelocityHistory.fill(vec3_create());
    this._myThrowMaxAngularSpeedRadians = Math.pp_toRadians(this._myThrowMaxAngularSpeed);
    this._myGrabEmitter = new Emitter12();
    this._myThrowEmitter = new Emitter12();
    this._myDebugEnabled = false;
  }
  start() {
    if (this._myHandedness == HandednessIndex.LEFT) {
      this._myGamepad = Globals.getLeftGamepad(this.engine);
    } else {
      this._myGamepad = Globals.getRightGamepad(this.engine);
    }
    this._myPhysX = this.object.pp_getComponent(PhysXComponent8);
    this._myCollisionsCollector = new PhysicsCollisionCollector(this._myPhysX);
  }
  update(dt) {
    this._myCollisionsCollector.update(dt);
    let currentInputSourceType = null;
    if (this._myGamepad.getHandPose() != null) {
      currentInputSourceType = this._myGamepad.getHandPose().getInputSourceType();
    }
    if (this._myPrevInputSourceType != currentInputSourceType) {
      this.throw();
    }
    this._myPrevInputSourceType = currentInputSourceType;
    if (this._myGrabButton != 1 || currentInputSourceType == InputSourceType.TRACKED_HAND) {
      if (this._myGamepad.getButtonInfo(GamepadButtonID.SELECT).isPressStart()) {
        this._grab(GamepadButtonID.SELECT);
      } else if (this._myGamepad.getButtonInfo(GamepadButtonID.SELECT).isPressEnd()) {
        this._throw(GamepadButtonID.SELECT);
      }
    }
    if (this._myGrabButton != 0) {
      if (this._myGamepad.getButtonInfo(GamepadButtonID.SQUEEZE).isPressStart()) {
        this._grab(GamepadButtonID.SQUEEZE);
      } else if (this._myGamepad.getButtonInfo(GamepadButtonID.SQUEEZE).isPressEnd()) {
        this._throw(GamepadButtonID.SQUEEZE);
      }
    }
    this._updateLinearVelocityHistory();
    this._updateAngularVelocityHistory();
  }
  grab(grabButton = null) {
    this._grab(grabButton);
  }
  throw(throwButton = null) {
    this._throw(throwButton);
  }
  getGamepad() {
    return this._myGamepad;
  }
  getHandedness() {
    return InputUtils.getHandednessByIndex(this._myHandedness);
  }
  registerGrabEventListener(id, listener) {
    this._myGrabEmitter.add(listener, { id });
  }
  unregisterGrabEventListener(id) {
    this._myGrabEmitter.remove(id);
  }
  registerThrowEventListener(id, listener) {
    this._myThrowEmitter.add(listener, { id });
  }
  unregisterThrowEventListener(id) {
    this._myThrowEmitter.remove(id);
  }
  onActivate() {
    this._myCollisionsCollector.setActive(true);
  }
  onDeactivate() {
    this.throw();
    this._myHandLinearVelocityHistory = new Array(this._myLinearVelocityHistorySize);
    this._myHandLinearVelocityHistory.fill(vec3_create());
    this._myHandAngularVelocityHistory = new Array(this._myAngularVelocityHistorySize);
    this._myHandAngularVelocityHistory.fill(vec3_create());
    this._myCollisionsCollector.setActive(false);
  }
  _grab(grabButton) {
    if (this._myGrabbables.length >= this._myMaxNumberOfObjects) {
      return;
    }
    if (this._myGrabButton == 2 || this._myActiveGrabButton == null || this._myActiveGrabButton == grabButton || grabButton == null) {
      let grabbablesToGrab = [];
      let collisions = this._myCollisionsCollector.getCollisions();
      for (let i = 0; i < collisions.length; i++) {
        let grabbable = collisions[i].object.pp_getComponent(GrabbableComponent);
        if (grabbable && grabbable.active) {
          grabbablesToGrab.push(grabbable);
        }
      }
      let grabberPosition = this.object.pp_getPosition();
      grabbablesToGrab.sort(function(first2, second) {
        let firstPosition = first2.object.pp_getPosition();
        let secondPosition = second.object.pp_getPosition();
        let firstDistance = firstPosition.vec3_distance(grabberPosition);
        let secondDistance = secondPosition.vec3_distance(grabberPosition);
        return Math.pp_sign(firstDistance - secondDistance, 0);
      });
      for (let grabbableToGrab of grabbablesToGrab) {
        if (!this._isAlreadyGrabbed(grabbableToGrab)) {
          let grabbableData = new _GrabberHandComponentGrabbableData(grabbableToGrab, this._myThrowVelocitySource == 1, this._myLinearVelocityHistorySize, this._myAngularVelocityHistorySize);
          this._myGrabbables.push(grabbableData);
          grabbableToGrab.grab(this.object);
          grabbableToGrab.registerReleaseEventListener(this, this._onRelease.bind(this));
          if (this._mySnapGrabbableToOrigin) {
            grabbableToGrab.object.pp_resetPositionLocal();
          }
          this._myGrabEmitter.notify(this, grabbableToGrab);
        }
        if (this._myGrabbables.length >= this._myMaxNumberOfObjects) {
          break;
        }
      }
      if (this._myGrabbables.length > 0) {
        if (this._myActiveGrabButton == null) {
          this._myActiveGrabButton = grabButton;
        }
      }
    }
  }
  _throw(throwButton) {
    if (this._myGrabButton == 2 || this._myActiveGrabButton == null || this._myActiveGrabButton == throwButton || throwButton == null) {
      if (this._myGrabbables.length > 0) {
        let linearVelocity = null;
        let angularVelocity = null;
        if (this._myThrowVelocitySource == 0) {
          linearVelocity = this._computeReleaseLinearVelocity(this._myHandLinearVelocityHistory);
          angularVelocity = this._computeReleaseAngularVelocity(this._myHandAngularVelocityHistory);
        }
        for (let grabbableData of this._myGrabbables) {
          let grabbable = grabbableData.getGrabbable();
          grabbable.unregisterReleaseEventListener(this);
          if (this._myThrowVelocitySource == 1) {
            linearVelocity = this._computeReleaseLinearVelocity(grabbableData.getLinearVelocityHistory());
            angularVelocity = this._computeReleaseAngularVelocity(grabbableData.getAngularVelocityHistory());
          }
          grabbable.throw(linearVelocity, angularVelocity);
          this._myThrowEmitter.notify(this, grabbable);
        }
        this._myGrabbables = [];
      }
      this._myActiveGrabButton = null;
    }
  }
  _onRelease(grabber, grabbable) {
    grabbable.unregisterReleaseEventListener(this);
    this._myGrabbables.pp_remove((element) => element.getGrabbable() == grabbable);
    if (this._myGrabbables.length <= 0) {
      this._myActiveGrabButton = null;
    }
  }
  _updateLinearVelocityHistory() {
    const velocityToReuse = this._myHandLinearVelocityHistory.pop();
    let handPose = this._myGamepad.getHandPose();
    if (handPose != null) {
      this._myHandLinearVelocityHistory.unshift(handPose.getLinearVelocity(velocityToReuse));
    } else {
      velocityToReuse.vec3_zero();
      this._myHandLinearVelocityHistory.unshift(velocityToReuse);
    }
    for (let grabbable of this._myGrabbables) {
      grabbable.updateLinearVelocityHistory();
    }
  }
  _updateAngularVelocityHistory() {
    const velocityToReuse = this._myHandAngularVelocityHistory.pop();
    let handPose = this._myGamepad.getHandPose();
    if (handPose != null) {
      this._myHandAngularVelocityHistory.unshift(handPose.getAngularVelocityRadians(velocityToReuse));
    } else {
      velocityToReuse.vec3_zero();
      this._myHandAngularVelocityHistory.unshift(velocityToReuse);
    }
    for (let grabbable of this._myGrabbables) {
      grabbable.updateAngularVelocityHistory();
    }
  }
  _computeReleaseLinearVelocity(linearVelocityHistory) {
    let speed = linearVelocityHistory[0].vec3_length();
    for (let i = 1; i < this._myLinearVelocityHistorySpeedAverageSamplesFromStart; i++) {
      speed += linearVelocityHistory[i].vec3_length();
    }
    speed /= this._myLinearVelocityHistorySpeedAverageSamplesFromStart;
    let speedEaseMultiplier = Math.pp_mapToRange(speed, this._myThrowLinearVelocityBoostMinSpeedThreshold, this._myThrowLinearVelocityBoostMaxSpeedThreshold, 0, 1);
    speedEaseMultiplier = EasingFunction.easeIn(speedEaseMultiplier);
    let extraSpeed = speed * (speedEaseMultiplier * this._myThrowLinearVelocityBoost);
    speed += extraSpeed;
    speed *= this._myThrowLinearVelocityMultiplier;
    speed = Math.pp_clamp(speed, 0, this._myThrowMaxLinearSpeed);
    if (this._myDebugEnabled && Globals.isDebugEnabled(this.engine)) {
      this._debugDirectionLines(linearVelocityHistory);
    }
    let directionCurrentWeight = this._myLinearVelocityHistoryDirectionAverageSamplesFromStart;
    let lastDirectionIndex = this._myLinearVelocityHistoryDirectionAverageSkipFromStart + this._myLinearVelocityHistoryDirectionAverageSamplesFromStart;
    let direction = vec3_create();
    for (let i = this._myLinearVelocityHistoryDirectionAverageSkipFromStart; i < lastDirectionIndex; i++) {
      let currentDirection = linearVelocityHistory[i];
      currentDirection.vec3_scale(directionCurrentWeight, currentDirection);
      direction.vec3_add(currentDirection, direction);
      directionCurrentWeight--;
    }
    direction.vec3_normalize(direction);
    direction.vec3_scale(speed, direction);
    return direction;
  }
  _computeReleaseAngularVelocity(angularVelocityHistory) {
    let angularVelocity = angularVelocityHistory[0];
    let speed = angularVelocity.vec3_length();
    speed = Math.pp_clamp(speed * this._myThrowAngularVelocityMultiplier, 0, this._myThrowMaxAngularSpeedRadians);
    let direction = angularVelocity.vec3_clone();
    direction.vec3_normalize(direction);
    direction.vec3_scale(speed, direction);
    return direction;
  }
  _debugDirectionLines(linearVelocityHistory) {
    for (let j = this._myLinearVelocityHistoryDirectionAverageSkipFromStart + this._myLinearVelocityHistoryDirectionAverageSamplesFromStart; j > this._myLinearVelocityHistoryDirectionAverageSkipFromStart; j--) {
      let directionCurrentWeight = j - this._myLinearVelocityHistoryDirectionAverageSkipFromStart;
      let lastDirectionIndex = j - this._myLinearVelocityHistoryDirectionAverageSkipFromStart;
      let direction = vec3_create();
      for (let i = this._myLinearVelocityHistoryDirectionAverageSkipFromStart; i < lastDirectionIndex; i++) {
        let currentDirection = linearVelocityHistory[i].pp_clone();
        currentDirection.vec3_scale(directionCurrentWeight, currentDirection);
        direction.vec3_add(currentDirection, direction);
        directionCurrentWeight--;
      }
      direction.vec3_normalize(direction);
      let color = 1 / j;
      Globals.getDebugVisualManager(this.engine).drawLine(5, this.object.pp_getPosition(), direction, 0.2, vec4_create(color, color, color, 1));
    }
  }
  _isAlreadyGrabbed(grabbable) {
    let found = this._myGrabbables.pp_find((element) => element.getGrabbable() == grabbable);
    return found != null;
  }
  onDestroy() {
    this._myCollisionsCollector.destroy();
  }
};
var _GrabberHandComponentGrabbableData = class {
  constructor(grabbable, useGrabbableAsVelocitySource, linearVelocityHistorySize, angularVelocityHistorySize) {
    this._myGrabbable = grabbable;
    this._myUseGrabbableAsVelocitySource = useGrabbableAsVelocitySource;
    if (this._myUseGrabbableAsVelocitySource) {
      this._myLinearVelocityHistory = new Array(linearVelocityHistorySize);
      this._myLinearVelocityHistory.fill(vec3_create());
      this._myAngularVelocityHistory = new Array(angularVelocityHistorySize);
      this._myAngularVelocityHistory.fill(vec3_create());
    }
  }
  getGrabbable() {
    return this._myGrabbable;
  }
  getLinearVelocityHistory() {
    return this._myLinearVelocityHistory;
  }
  getAngularVelocityHistory() {
    return this._myAngularVelocityHistory;
  }
  updateLinearVelocityHistory() {
    if (this._myUseGrabbableAsVelocitySource) {
      this._myLinearVelocityHistory.unshift(this._myGrabbable.getLinearVelocity());
      this._myLinearVelocityHistory.pop();
    }
  }
  updateAngularVelocityHistory() {
    if (this._myUseGrabbableAsVelocitySource) {
      this._myAngularVelocityHistory.unshift(this._myGrabbable.getAngularVelocityRadians());
      this._myAngularVelocityHistory.pop();
    }
  }
};

// dist/pp/gameplay/integrations/construct_arcade/ca_utils.js
var _myDummyServer = null;
var _myUseDummyServerOnSDKMissing = false;
var _myUseDummyServerOnError = false;
var CAError = {
  NONE: 0,
  CA_SDK_MISSING: 1,
  DUMMY_NOT_INITIALIZED: 2,
  GET_LEADERBOARD_FAILED: 3,
  SUBMIT_SCORE_FAILED: 4,
  GET_USER_FAILED: 5,
  USER_NOT_LOGGED_IN: 6,
  USER_HAS_NO_SCORE: 7
};
function setUseDummyServerOnSDKMissing(useDummyServer) {
  _myUseDummyServerOnSDKMissing = useDummyServer;
}
function setUseDummyServerOnError(useDummyServer) {
  _myUseDummyServerOnError = useDummyServer;
}
function setDummyServer(dummyServer) {
  _myDummyServer = dummyServer;
}
function isUseDummyServerOnSDKMissing() {
  return _myUseDummyServerOnSDKMissing;
}
function isUseDummyServerOnError() {
  return _myUseDummyServerOnError;
}
function getDummyServer() {
  return _myDummyServer;
}
function isSDKAvailable() {
  return window.heyVR != null;
}
function getSDK() {
  return window.heyVR;
}
function getLeaderboard(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback = null, onErrorCallback = null, useDummyServerOverride = null) {
  if (CAUtils.isSDKAvailable()) {
    try {
      _getLeaderboard(leaderboardID, ascending, aroundPlayer, scoresAmount).then(function(result) {
        if (result.leaderboard != null) {
          if (!aroundPlayer) {
            if (onDoneCallback != null) {
              onDoneCallback(result.leaderboard);
            }
          } else {
            let userLeaderboard = result.leaderboard;
            CAUtils.getUser(function(user) {
              let userName = user.displayName;
              let userValid = false;
              for (let userLeaderboardEntry of userLeaderboard) {
                if (userLeaderboardEntry.displayName == userName) {
                  userValid = true;
                  break;
                }
              }
              if (userValid) {
                if (onDoneCallback != null) {
                  onDoneCallback(userLeaderboard);
                }
              } else {
                if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                  CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, CAError.USER_HAS_NO_SCORE);
                } else if (onErrorCallback != null) {
                  let error4 = {};
                  error4.reason = "Searching for around player but the user has not submitted a score yet";
                  error4.type = CAError.USER_HAS_NO_SCORE;
                  onErrorCallback(error4, null);
                }
              }
            }, function(error4, result2) {
              if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
                CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, error4.type);
              } else if (onErrorCallback != null) {
                onErrorCallback(error4, result2);
              }
            }, false);
          }
        } else {
          if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
            CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, CAError.GET_LEADERBOARD_FAILED);
          } else if (onErrorCallback != null) {
            let error4 = {};
            error4.reason = "Get leaderboard failed";
            error4.type = CAError.GET_LEADERBOARD_FAILED;
            onErrorCallback(error4, result);
          }
        }
      }).catch(function(result) {
        if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
          CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, CAError.GET_LEADERBOARD_FAILED);
        } else if (onErrorCallback != null) {
          let error4 = {};
          error4.reason = "Get leaderboard failed";
          error4.type = CAError.GET_LEADERBOARD_FAILED;
          onErrorCallback(error4, result);
        }
      });
    } catch (error4) {
      if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
        CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, CAError.GET_LEADERBOARD_FAILED);
      } else if (onErrorCallback != null) {
        let error5 = {};
        error5.reason = "Get leaderboard failed";
        error5.type = CAError.GET_LEADERBOARD_FAILED;
        onErrorCallback(error5, null);
      }
    }
  } else {
    if (_myDummyServer != null && _myDummyServer.getLeaderboard != null && (_myUseDummyServerOnSDKMissing && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
      CAUtils.getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, CAError.CA_SDK_MISSING);
    } else if (onErrorCallback != null) {
      let error4 = {};
      error4.reason = "Construct Arcade SDK missing";
      error4.type = CAError.CA_SDK_MISSING;
      onErrorCallback(error4, null);
    }
  }
}
function getLeaderboardDummy(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback = null, onErrorCallback = null, caError = CAError.NONE) {
  if (_myDummyServer) {
    _myDummyServer.getLeaderboard(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback, onErrorCallback, caError);
  } else {
    if (onErrorCallback != null) {
      let error4 = {};
      error4.reason = "Dummy server not initialized";
      error4.type = CAError.DUMMY_NOT_INITIALIZED;
      onErrorCallback(error4, null);
    }
  }
}
function submitScore(leaderboardID, scoreToSubmit, onDoneCallback = null, onErrorCallback = null, useDummyServerOverride = null) {
  if (CAUtils.isSDKAvailable()) {
    try {
      _submitScore(leaderboardID, scoreToSubmit).then(function(result) {
        if (result.scoreSubmitted) {
          if (onDoneCallback != null) {
            onDoneCallback();
          }
        } else if (result.scoreSubmitted != null) {
          if (_myDummyServer != null && _myDummyServer.submitScore != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
            CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback, CAError.USER_NOT_LOGGED_IN);
          } else if (onErrorCallback != null) {
            let error4 = {};
            error4.reason = "The score can't be submitted because the user is not logged in";
            error4.type = CAError.USER_NOT_LOGGED_IN;
            onErrorCallback(error4, result);
          }
        } else {
          if (_myDummyServer != null && _myDummyServer.submitScore != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
            CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback, CAError.SUBMIT_SCORE_FAILED);
          } else if (onErrorCallback != null) {
            let error4 = {};
            error4.reason = "Submit score failed";
            error4.type = CAError.SUBMIT_SCORE_FAILED;
            onErrorCallback(error4, result);
          }
        }
      }).catch(function(result) {
        if (_myDummyServer != null && _myDummyServer.submitScore != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
          CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback, CAError.SUBMIT_SCORE_FAILED);
        } else if (onErrorCallback != null) {
          let error4 = {};
          error4.reason = "Submit score failed";
          error4.type = CAError.SUBMIT_SCORE_FAILED;
          onErrorCallback(error4, result);
        }
      });
    } catch (error4) {
      if (_myDummyServer != null && _myDummyServer.submitScore != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
        CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback, CAError.SUBMIT_SCORE_FAILED);
      } else if (onErrorCallback != null) {
        let error5 = {};
        error5.reason = "Submit score failed";
        error5.type = CAError.SUBMIT_SCORE_FAILED;
        onErrorCallback(error5, null);
      }
    }
  } else {
    if (_myDummyServer != null && _myDummyServer.submitScore != null && (_myUseDummyServerOnSDKMissing && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
      CAUtils.submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback, CAError.CA_SDK_MISSING);
    } else if (onErrorCallback != null) {
      let error4 = {};
      error4.reason = "Construct Arcade SDK missing";
      error4.type = CAError.CA_SDK_MISSING;
      onErrorCallback(error4, null);
    }
  }
}
function submitScoreDummy(leaderboardID, scoreToSubmit, onDoneCallback = null, onErrorCallback = null, caError = CAError.NONE) {
  if (_myDummyServer) {
    _myDummyServer.submitScore(leaderboardID, scoreToSubmit, onDoneCallback, onErrorCallback, caError);
  } else {
    if (onErrorCallback != null) {
      let error4 = {};
      error4.reason = "Dummy server not initialized";
      error4.type = CAError.DUMMY_NOT_INITIALIZED;
      onErrorCallback(error4, null);
    }
  }
}
function getUser(onDoneCallback = null, onErrorCallback = null, useDummyServerOverride = null) {
  if (CAUtils.isSDKAvailable()) {
    try {
      _getUser().then(function(result) {
        if (result.user != null && result.user.displayName != null) {
          if (onDoneCallback != null) {
            onDoneCallback(result.user);
          }
        } else if (result.user != null) {
          if (_myDummyServer != null && _myDummyServer.getUser != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
            CAUtils.getUserDummy(onDoneCallback, onErrorCallback, CAError.USER_NOT_LOGGED_IN);
          } else if (onErrorCallback != null) {
            let error4 = {};
            error4.reason = "User not logged in";
            error4.type = CAError.USER_NOT_LOGGED_IN;
            onErrorCallback(error4, result);
          }
        } else {
          if (_myDummyServer != null && _myDummyServer.getUser != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
            CAUtils.getUserDummy(onDoneCallback, onErrorCallback, CAError.GET_USER_FAILED);
          } else if (onErrorCallback != null) {
            let error4 = {};
            error4.reason = "Get user failed";
            error4.type = CAError.GET_USER_FAILED;
            onErrorCallback(error4, result);
          }
        }
      }).catch(function(result) {
        if (_myDummyServer != null && _myDummyServer.getUser != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
          CAUtils.getUserDummy(onDoneCallback, onErrorCallback, CAError.GET_USER_FAILED);
        } else if (onErrorCallback != null) {
          let error4 = {};
          error4.reason = "Get user failed";
          error4.type = CAError.GET_USER_FAILED;
          onErrorCallback(error4, result);
        }
      });
    } catch (error4) {
      if (_myDummyServer != null && _myDummyServer.getUser != null && (_myUseDummyServerOnError && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
        CAUtils.getUserDummy(onDoneCallback, onErrorCallback, CAError.GET_USER_FAILED);
      } else if (onErrorCallback != null) {
        let error5 = {};
        error5.reason = "Get user failed";
        error5.type = CAError.GET_USER_FAILED;
        onErrorCallback(error5, null);
      }
    }
  } else {
    if (_myDummyServer != null && _myDummyServer.getUser != null && (_myUseDummyServerOnSDKMissing && useDummyServerOverride == null) || useDummyServerOverride != null && useDummyServerOverride) {
      CAUtils.getUserDummy(onDoneCallback, onErrorCallback, CAError.CA_SDK_MISSING);
    } else if (onErrorCallback != null) {
      let error4 = {};
      error4.reason = "Construct Arcade SDK missing";
      error4.type = CAError.CA_SDK_MISSING;
      onErrorCallback(error4, null);
    }
  }
}
function getUserDummy(onDoneCallback = null, onErrorCallback = null, caError = CAError.NONE) {
  if (_myDummyServer) {
    _myDummyServer.getUser(onDoneCallback, onErrorCallback, caError);
  } else {
    if (onErrorCallback != null) {
      let error4 = {};
      error4.reason = "Dummy server not initialized";
      error4.type = CAError.DUMMY_NOT_INITIALIZED;
      onErrorCallback(error4, null);
    }
  }
}
var CAUtils = {
  setUseDummyServerOnSDKMissing,
  setUseDummyServerOnError,
  setDummyServer,
  isUseDummyServerOnSDKMissing,
  isUseDummyServerOnError,
  getDummyServer,
  isSDKAvailable,
  getSDK,
  getLeaderboard,
  getLeaderboardDummy,
  submitScore,
  submitScoreDummy,
  getUser,
  getUserDummy
};
function _getLeaderboard(leaderboardID, ascending, aroundPlayer, scoresAmount) {
  let heyVR = CAUtils.getSDK();
  if (aroundPlayer) {
    return heyVR.leaderboard.getMy(leaderboardID, scoresAmount).then(function(result) {
      let adjustedLeaderboard = [];
      for (let leaderboardEntry of result) {
        adjustedLeaderboard.push({ rank: leaderboardEntry.rank - 1, displayName: leaderboardEntry.user, score: leaderboardEntry.score });
      }
      return { leaderboard: adjustedLeaderboard };
    }).catch(function(error4) {
      if (error4 != null && error4.status != null && error4.status.debug == "err_unauthenticated") {
        return { leaderboard: [] };
      } else {
        return { leaderboard: null };
      }
    });
  } else {
    return heyVR.leaderboard.get(leaderboardID, scoresAmount).then(function(result) {
      let adjustedLeaderboard = [];
      for (let leaderboardEntry of result) {
        adjustedLeaderboard.push({ rank: leaderboardEntry.rank - 1, displayName: leaderboardEntry.user, score: leaderboardEntry.score });
      }
      return { leaderboard: adjustedLeaderboard };
    }).catch(function() {
      return { leaderboard: null };
    });
  }
}
function _submitScore(leaderboardID, scoreToSubmit) {
  let heyVR = CAUtils.getSDK();
  return heyVR.leaderboard.postScore(leaderboardID, scoreToSubmit).then(function() {
    return { scoreSubmitted: true };
  }).catch(function(error4) {
    if (error4 != null && error4.status != null && error4.status.debug == "err_unauthenticated") {
      return { scoreSubmitted: false };
    } else {
      return { scoreSubmitted: null };
    }
  });
}
function _getUser() {
  let heyVR = CAUtils.getSDK();
  return heyVR.user.getName().then((result) => {
    return { user: { displayName: result } };
  }).catch(function(error4) {
    if (error4 != null && error4.status != null && error4.status.debug == "err_unauthenticated") {
      return { user: { displayName: null } };
    } else {
      return { user: null };
    }
  });
}

// dist/pp/gameplay/integrations/construct_arcade/ca_dummy_server.js
var CADummyServer = class {
  constructor() {
  }
  getLeaderboard(leaderboardID, ascending, aroundPlayer, scoresAmount, onDoneCallback = null, onErrorCallback = null, caError = CAError.NONE) {
    let leaderboard = null;
    if (caError != CAError.CA_SDK_MISSING) {
      if (aroundPlayer && (caError == CAError.USER_NOT_LOGGED_IN || caError == CAError.USER_HAS_NO_SCORE)) {
        leaderboard = [
          { rank: 0, displayName: "Sign In", score: 0 },
          { rank: 1, displayName: "And", score: 0 },
          { rank: 2, displayName: "Play", score: 0 },
          { rank: 3, displayName: "On", score: 0 },
          { rank: 4, displayName: "HeyVR", score: 0 },
          { rank: 5, displayName: "To", score: 0 },
          { rank: 6, displayName: "Submit", score: 0 },
          { rank: 7, displayName: "Your", score: 0 },
          { rank: 8, displayName: "Own", score: 0 },
          { rank: 9, displayName: "Score", score: 0 }
        ];
      } else {
        leaderboard = [
          { rank: 0, displayName: "An", score: 0 },
          { rank: 1, displayName: "Error", score: 0 },
          { rank: 2, displayName: "Has", score: 0 },
          { rank: 3, displayName: "Occurred", score: 0 },
          { rank: 4, displayName: "While", score: 0 },
          { rank: 5, displayName: "Trying", score: 0 },
          { rank: 6, displayName: "To", score: 0 },
          { rank: 7, displayName: "Retrieve", score: 0 },
          { rank: 8, displayName: "The", score: 0 },
          { rank: 9, displayName: "Leaderboard", score: 0 }
        ];
      }
    } else {
      if (aroundPlayer) {
        leaderboard = [
          { rank: 0, displayName: "Sign In", score: 0 },
          { rank: 1, displayName: "And", score: 0 },
          { rank: 2, displayName: "Play", score: 0 },
          { rank: 3, displayName: "On", score: 0 },
          { rank: 4, displayName: "HeyVR", score: 0 },
          { rank: 5, displayName: "To", score: 0 },
          { rank: 6, displayName: "Submit", score: 0 },
          { rank: 7, displayName: "Your", score: 0 },
          { rank: 8, displayName: "Own", score: 0 },
          { rank: 9, displayName: "Score", score: 0 }
        ];
      } else {
        leaderboard = [
          { rank: 0, displayName: "The", score: 0 },
          { rank: 1, displayName: "Top 10", score: 0 },
          { rank: 2, displayName: "Leaderboard", score: 0 },
          { rank: 3, displayName: "Is", score: 0 },
          { rank: 4, displayName: "Available", score: 0 },
          { rank: 5, displayName: "Only", score: 0 },
          { rank: 5, displayName: "When", score: 0 },
          { rank: 7, displayName: "Playing", score: 0 },
          { rank: 8, displayName: "On", score: 0 },
          { rank: 9, displayName: "HeyVR", score: 0 }
        ];
      }
    }
    while (leaderboard.length > scoresAmount) {
      leaderboard.pop();
    }
    if (onDoneCallback != null) {
      onDoneCallback(leaderboard);
    }
  }
  submitScore(leaderboardID, scoreToSubmit, onDoneCallback = null, onErrorCallback = null, caError = CAError.NONE) {
    if (onDoneCallback != null) {
      onDoneCallback();
    }
  }
  getUser(onDoneCallback = null, onErrorCallback = null, caError = CAError.NONE) {
    let user = {};
    user.displayName = "Florian";
    if (onDoneCallback != null) {
      onDoneCallback(user);
    }
  }
};

// dist/pp/gameplay/integrations/construct_arcade/ca_display_leaderboard_component.js
import { Component as Component43, Property as Property29, TextComponent as TextComponent9 } from "@wonderlandengine/api";
var CADisplayLeaderboardComponent = class extends Component43 {
  static TypeName = "pp-ca-display-leaderboard";
  static Properties = {
    _myUsernamesTextObject: Property29.object(),
    _myScoresTextObject: Property29.object(),
    _myLeaderboardID: Property29.string(""),
    _myLocal: Property29.bool(false),
    _myAscending: Property29.bool(false),
    _myScoresAmount: Property29.int(10),
    _myScoreFormat: Property29.enum(["Value", "Hours:Minutes:Seconds", "Minutes:Seconds", "Seconds", "Hours:Minutes", "Minutes"], "Value"),
    _myPositionAndUsernameSeparator: Property29.string(" - "),
    _myNumberOfLinesBetweenScores: Property29.int(1),
    _myAddDefaultCADummyServer: Property29.bool(false)
  };
  init() {
    this._myUsernamesTextComponent = null;
    this._myScoresTextComponent = null;
    this._myStarted = false;
  }
  start() {
    if (this._myAddDefaultCADummyServer) {
      CAUtils.setDummyServer(new CADummyServer());
      CAUtils.setUseDummyServerOnSDKMissing(true);
      CAUtils.setUseDummyServerOnError(true);
    }
  }
  update(dt) {
    if (!this._myStarted) {
      this._myStarted = true;
      if (this._myUsernamesTextObject != null) {
        this._myUsernamesTextComponent = this._myUsernamesTextObject.pp_getComponent(TextComponent9);
      }
      if (this._myScoresTextObject != null) {
        this._myScoresTextComponent = this._myScoresTextObject.pp_getComponent(TextComponent9);
      }
      this.updateLeaderboard();
    }
  }
  updateLeaderboard() {
    CAUtils.getLeaderboard(this._myLeaderboardID, this._myAscending, this._myLocal, this._myScoresAmount, this._onLeaderboardRetrieved.bind(this));
  }
  _onLeaderboardRetrieved(leaderboard) {
    if (this._myDestroyed)
      return;
    let namesText = "";
    let scoresText = "";
    let maxRankDigit = 0;
    for (let value of leaderboard) {
      let rank = value.rank + 1;
      if (rank.toFixed(0).length > maxRankDigit) {
        maxRankDigit = rank.toFixed(0).length;
      }
    }
    for (let value of leaderboard) {
      let rank = value.rank + 1;
      let fixedRank = rank.toFixed(0);
      while (fixedRank.length < maxRankDigit) {
        fixedRank = "0".concat(fixedRank);
      }
      let newlines = "\n";
      for (let i = 0; i < this._myNumberOfLinesBetweenScores; i++) {
        newlines = newlines + "\n";
      }
      namesText = namesText.concat(fixedRank, this._myPositionAndUsernameSeparator, value.displayName, newlines);
      let convertedScore = this._formatScore(value.score);
      scoresText = scoresText.concat(convertedScore, newlines);
    }
    if (this._myUsernamesTextComponent != null) {
      this._myUsernamesTextComponent.text = namesText;
    }
    if (this._myScoresTextComponent != null) {
      this._myScoresTextComponent.text = scoresText;
    }
  }
  _formatScore(score) {
    let convertedScore = score.toString();
    if (this._myScoreFormat == 1) {
      convertedScore = this._formatTime(score, true, true, true);
    } else if (this._myScoreFormat == 2) {
      convertedScore = this._formatTime(score, false, true, true);
    } else if (this._myScoreFormat == 3) {
      convertedScore = this._formatTime(score, false, false, true);
    } else if (this._myScoreFormat == 4) {
      convertedScore = this._formatTime(score, true, true, false);
    } else if (this._myScoreFormat == 5) {
      convertedScore = this._formatTime(score, false, true, false);
    }
    return convertedScore;
  }
  _formatTime(score, displayHours, displayMinutes, displaySeconds) {
    let time = Math.floor(score / 1e3);
    let hours = 0;
    if (displayHours) {
      hours = Math.floor(time / 3600);
      time -= hours * 3600;
    }
    let minutes = 0;
    if (displayMinutes) {
      minutes = Math.floor(time / 60);
      time -= minutes * 60;
    }
    let seconds = 0;
    if (displaySeconds) {
      seconds = Math.floor(time);
    }
    let convertedTime = "";
    if (displaySeconds) {
      convertedTime = seconds.toFixed(0).length < 2 && (displayMinutes || displayHours) ? "0".concat(seconds.toFixed(0)) : seconds.toFixed(0);
    }
    if (displayMinutes) {
      convertedTime = (minutes.toFixed(0).length < 2 && (displaySeconds || displayHours) ? "0".concat(minutes.toFixed(0)) : minutes.toFixed(0)) + (displaySeconds ? ":" + convertedTime : "");
    }
    if (displayHours) {
      convertedTime = (hours.toFixed(0).length < 2 && (displaySeconds || displayMinutes) ? "0".concat(hours.toFixed(0)) : hours.toFixed(0)) + (displayMinutes ? ":" + convertedTime : "");
    }
    return convertedTime;
  }
  pp_clone(targetObject) {
    let clonedComponent = ComponentUtils.cloneDefault(this, targetObject);
    return clonedComponent;
  }
};

// dist/pp/gameplay/experimental/character_controller/collision/legacy/collision_check/collision_check_utils.js
function generate360TeleportParamsFromMovementParams(movementParams, outTeleportParams = new CollisionCheckParams()) {
  outTeleportParams.copy(movementParams);
  outTeleportParams.myHalfConeAngle = 180;
  outTeleportParams.myHalfConeSliceAmount = Math.round(outTeleportParams.myHalfConeAngle / movementParams.myHalfConeAngle * movementParams.myHalfConeSliceAmount);
  outTeleportParams.myCheckHorizontalFixedForwardEnabled = true;
  outTeleportParams.myCheckHorizontalFixedForward = vec3_create(0, 0, 1);
  return outTeleportParams;
}
var CollisionCheckUtils = {
  generate360TeleportParamsFromMovementParams
};

// dist/pp/gameplay/experimental/character_controller/collision/character_collider_setup.js
var CharacterColliderSetup = class {
  constructor() {
    this.myHeight = 0;
    this.myHorizontalCheckParams = new CharacterColliderHorizontalCheckParams();
    this.myVerticalCheckParams = new CharacterColliderVerticalCheckParams();
    this.myWallSlideParams = new CharacterColliderWallSlideParams();
    this.myGroundParams = new CharacterColliderSurfaceParams();
    this.myCeilingParams = new CharacterColliderSurfaceParams();
    this.mySplitMovementParams = new CharacterColliderSplitMovementParams();
    this.myAdditionalParams = new CharacterColliderAdditionalParams();
    this.myDebugParams = new CharacterColliderDebugParams();
  }
  copy(other) {
  }
};
var CharacterColliderHorizontalPositionVerticalCheckDirection = {
  UPWARD: 0,
  // Gives less issues with a ground based movement, but may also collide a bit more, resulting in less sliding
  DOWNWARD: 1,
  // Gives less issues with a ceiling based movement (unusual), but may also collide a bit more, resulting in less sliding and more stuck in front of a wall
  BOTH: 2
  // Check both directions, more expensive (2x checks) and better prevent collisions, sliding more, but is more expensive and gives more issues           
  //                                                                                                                                                  _
  // The issues means that a small step at the end of a slope, maybe due to 2 rectangles, one for the floor and the other for the slope like this -> /   
  // can create a small step if the floor rectangle is a bit above the end of the slope, this will make the character get stuck thinking it's a wall
  // BOTH do a more "aggressive" vertical check that makes the character get less stuck in other situations, but can get stuck in this one
  // The better solution is to properly create the level, and if possible combine the 2 rectangles by having the floor a little below the end of the slope (like this -> /-)
  // The step that is created "on the other side" in fact can easily be ignored thanks to the myHorizontalCheckFeetDistanceToIgnore param
  // If the level is properly created the best solution should be UPWARD
  // and also myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision = false
};
var CharacterColliderHorizontalCheckParams = class {
  constructor() {
    this.myHorizontalCheckConeRadius = 0;
    this.myHorizontalCheckConeHalfAngle = 0;
    this.myHorizontalHeightCheckEnabled = false;
    this.myHorizontalCheckFeetDistanceToIgnore = 0;
    this.myHorizontalCheckHeadDistanceToIgnore = 0;
    this.myHorizontalCheckFixedForwardEnabled = false;
    this.myHorizontalCheckFixedForward = vec3_create();
    this.myHorizontalMovementCheckEnabled = false;
    this.myHorizontalMovementCheckRadialSteps = 0;
    this.myHorizontalMovementCheckSplitMovementEnabled = false;
    this.myHorizontalMovementCheckSplitMovementMaxSteps = null;
    this.myHorizontalMovementCheckSplitMovementMaxStepLength = null;
    this.myHorizontalMovementCheckSplitMovementMinStepLength = null;
    this.myHorizontalMovementCheckGetBetterReferenceHit = false;
    this.myHorizontalMovementHorizontalRadialCheckEnabled = false;
    this.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled = false;
    this.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled = false;
    this.myHorizontalMovementHorizontalStraightCheckEnabled = false;
    this.myHorizontalMovementHorizontalStraightCentralCheckEnabled = false;
    this.myHorizontalMovementHeightCheckSteps = 0;
    this.myHorizontalMovementHeightHorizontalCheckEnabled = false;
    this.myHorizontalMovementHeightVerticalCheckEnabled = false;
    this.myHorizontalMovementVerticalRadialDiagonalOutwardCheckEnabled = false;
    this.myHorizontalMovementVerticalRadialDiagonalInwardCheckEnabled = false;
    this.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled = false;
    this.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled = false;
    this.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled = false;
    this.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightCentralCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled = false;
    this.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = false;
    this.myHorizontalPositionCheckEnabled = false;
    this.myHorizontalPositionCheckConeHalfSlices = 0;
    this.myHorizontalPositionHorizontalBorderCheckEnabled = false;
    this.myHorizontalPositionHorizontalRadialCheckEnabled = false;
    this.myHorizontalPositionHeightCheckSteps = 0;
    this.myHorizontalPositionHeightHorizontalCheckEnabled = false;
    this.myHorizontalPositionHeightVerticalCheckEnabled = false;
    this.myHorizontalPositionVerticalStraightCheckEnabled = false;
    this.myHorizontalPositionVerticalStraightCentralCheckEnabled = false;
    this.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled = false;
    this.myHorizontalPositionVerticalRadialDiagonalInwardCheckEnabled = false;
    this.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled = false;
    this.myHorizontalPositionVerticalBorderDiagonalInwardCheckEnabled = false;
    this.myHorizontalPositionVerticalRadialBorderDiagonalOutwardCheckEnabled = false;
    this.myHorizontalPositionVerticalRadialBorderDiagonalInwardCheckEnabled = false;
    this.myHorizontalPositionVerticalCheckGetFarthestHit = false;
    this.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit = false;
    this.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit = false;
    this.myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision = false;
    this.myHorizontalPositionVerticalCheckDirection = CharacterColliderHorizontalPositionVerticalCheckDirection.UPWARD;
    this.myHorizontalCheckBlockLayerFlags = new PhysicsLayerFlags();
    this.myHorizontalCheckObjectsToIgnore = [];
    this.myHorizontalBlockColliderType = RaycastBlockColliderType.BOTH;
  }
  copy(other) {
  }
};
var CharacterColliderVerticalCheckParams = class {
  constructor() {
    this.myVerticalCheckCircumferenceRadius = 0;
    this.myVerticalCheckCircumferenceSlices = 0;
    this.myVerticalCheckCircumferenceCentralCheckEnabled = false;
    this.myVerticalCheckCircumferenceRadialSteps = 0;
    this.myVerticalCheckCircumferenceRotationPerRadialStep = 0;
    this.myVerticalCheckFixedForwardEnabled = false;
    this.myVerticalCheckFixedForward = vec3_create();
    this.myVerticalMovementCheckEnabled = false;
    this.myVerticalMovementCheckReductionEnabled = false;
    this.myVerticalMovementCheckPerformCheckOnBothSides = false;
    this.myVerticalPositionCheckEnabled = false;
    this.myVerticalPositionCheckPerformCheckOnBothSides = false;
    this.myVerticalCheckAllowHitsInsideCollisionIfOneValid = false;
    this.myVerticalCheckBlockLayerFlags = new PhysicsLayerFlags();
    this.myVerticalCheckObjectsToIgnore = [];
    this.myVerticalBlockColliderType = RaycastBlockColliderType.BOTH;
  }
  copy(other) {
  }
};
var CharacterColliderSlideFlickerPreventionMode = {
  NONE: 0,
  USE_PREVIOUS_RESULTS: 1,
  // Allow some flicker before stabilizing but avoid stopping for a 1 frame flicker only (false positive), is also less expensive
  COLLISION_ANGLE_ABOVE_90_DEGREES: 2,
  // Prevents most flicker apart those on almost flat surface, can have some false positive, always check when sliding into opposite direction
  COLLISION_ANGLE_ABOVE_90_DEGREES_OR_MOVEMENT_ANGLE_ABOVE_85_DEGREES: 3,
  // Less flicker than COLLISION_ANGLE_ABOVE_90_DEGREES but more false positive, always check when sliding into opposite direction
  ALWAYS: 4
  // Less flicker than COLLISION_ANGLE_ABOVE_90_DEGREES_OR_MOVEMENT_ANGLE_ABOVE_85_DEGREES but more false positive
};
var CharacterColliderWallSlideParams = class {
  constructor() {
    this.myWallSlideEnabled = false;
    this.myWallSlideMaxAttempts = 0;
    this.myCheckBothWallSlideDirections = false;
    this.myWallSlideFlickerPreventionMode = CharacterColliderSlideFlickerPreventionMode.NONE;
    this.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = false;
    this.myWallSlideFlickerPreventionForceCheckCounter = 0;
    this.my90DegreesWallSlideAdjustDirectionSign = false;
  }
  copy(other) {
  }
};
var CharacterColliderSurfaceParams = class {
  constructor() {
    this.mySurfaceSnapMaxDistance = 0;
    this.mySurfacePopOutMaxDistance = 0;
    this.mySurfaceAngleToIgnore = 0;
    this.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle = null;
    this.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance = null;
    this.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance = null;
    this.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft = null;
    this.myCollectSurfaceInfo = false;
    this.myOnSurfaceMaxOutsideDistance = 0;
    this.myOnSurfaceMaxInsideDistance = 0;
    this.myBaseInsideCollisionCheckEnabled = false;
    this.myOnSurfaceIfBaseInsideCollision = false;
    this.myCollectSurfaceNormalMaxOutsideDistance = 0;
    this.myCollectSurfaceNormalMaxInsideDistance = 0;
    this.myCollectSurfaceDistanceOutsideDistance = 0;
    this.myCollectSurfaceDistanceInsideDistance = 0;
    this.myCollectSurfaceCollisionHitOutsideDistance = 0;
    this.myCollectSurfaceCollisionHitInsideDistance = 0;
    this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill = false;
    this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill = false;
    this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfaceAngle = null;
    this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfaceAngle = null;
    this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle = null;
    this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle = null;
    this.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhill = false;
    this.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhillMinSurfaceAngle = null;
    this.myMovementMustStayOnSurface = false;
    this.myMovementMustStayOnSurfaceHitMaxAngle = null;
    this.myMovementMustStayOnIgnorableSurfaceAngleDownhill = false;
    this.myMovementMustStayOnSurfaceAngleDownhill = null;
    this.myTeleportMustBeOnSurface = false;
    this.myTeleportMustBeOnIgnorableSurfaceAngle = false;
    this.myTeleportMustBeOnSurfaceAngle = null;
    this.myCheckTransformMustBeOnSurface = false;
    this.myCheckTransformMustBeOnIgnorableSurfaceAngle = false;
    this.myCheckTransformMustBeOnSurfaceAngle = null;
    this.myRecollectSurfaceInfoOnSurfaceCheckFailed = false;
    this.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle = false;
  }
  copy(other) {
  }
};
var CharacterColliderSplitMovementParams = class {
  constructor() {
    this.mySplitMovementEnabled = false;
    this.mySplitMovementMaxSteps = null;
    this.mySplitMovementMaxStepLength = null;
    this.mySplitMovementMinStepLength = null;
    this.mySplitMovementLastStepCanBeLongerThanMaxStepLength = false;
    this.mySplitMovementStopOnHorizontalMovementFailed = false;
    this.mySplitMovementStopOnVerticalMovementFailed = false;
    this.mySplitMovementStopOnVerticalMovementReduced = false;
    this.mySplitMovementStopAndFailIfMovementWouldBeReduced = false;
    this.mySplitMovementStopReturnPreviousResults = false;
  }
  copy(other) {
  }
};
var CharacterColliderAdditionalParams = class {
  constructor() {
    this.myPositionOffsetLocal = vec3_create();
    this.myRotationOffsetLocalQuat = quat_create();
  }
  copy(other) {
  }
};
var CharacterColliderDebugParams = class {
  constructor() {
    this.myVisualDebugEnabled = false;
    this.myVisualDebugMovementEnabled = false;
    this.myVisualDebugHorizontalMovementCheckEnabled = false;
    this.myVisualDebugHorizontalPositionCheckEnabled = false;
    this.myVisualDebugVerticalMovementCheckEnabled = false;
    this.myVisualDebugVerticalPositionCheckEnabled = false;
    this.myVisualDebugSlideEnabled = false;
    this.myVisualDebugGroundInfoEnabled = false;
    this.myVisualDebugCeilingInfoEnabled = false;
    this.myVisualDebugResultsEnabled = false;
  }
  copy(other) {
  }
};
CharacterColliderSetup.prototype.copy = function copy21(other) {
  this.myHeight = other.myHeight;
  this.myHorizontalCheckParams.copy(other.myHorizontalCheckParams);
  this.myVerticalCheckParams.copy(other.myVerticalCheckParams);
  this.myWallSlideParams.copy(other.myWallSlideParams);
  this.myGroundParams.copy(other.myGroundParams);
  this.myCeilingParams.copy(other.myCeilingParams);
  this.mySplitMovementParams.copy(other.mySplitMovementParams);
  this.myAdditionalParams.copy(other.myAdditionalParams);
  this.myDebugParams.copy(other.myDebugParams);
};
CharacterColliderHorizontalCheckParams.prototype.copy = function copy22(other) {
  this.myHorizontalCheckConeRadius = other.myHorizontalCheckConeRadius;
  this.myHorizontalCheckConeHalfAngle = other.myHorizontalCheckConeHalfAngle;
  this.myHorizontalHeightCheckEnabled = other.myHorizontalHeightCheckEnabled;
  this.myHorizontalCheckFeetDistanceToIgnore = other.myHorizontalCheckFeetDistanceToIgnore;
  this.myHorizontalCheckHeadDistanceToIgnore = other.myHorizontalCheckHeadDistanceToIgnore;
  this.myHorizontalCheckFixedForwardEnabled = other.myHorizontalCheckFixedForwardEnabled;
  this.myHorizontalCheckFixedForward.vec3_copy(other.myHorizontalCheckFixedForward);
  this.myHorizontalMovementCheckEnabled = other.myHorizontalMovementCheckEnabled;
  this.myHorizontalMovementCheckRadialSteps = other.myHorizontalMovementCheckRadialSteps;
  this.myHorizontalMovementCheckSplitMovementEnabled = other.myHorizontalMovementCheckSplitMovementEnabled;
  this.myHorizontalMovementCheckSplitMovementMaxSteps = other.myHorizontalMovementCheckSplitMovementMaxSteps;
  this.myHorizontalMovementCheckSplitMovementMaxStepLength = other.myHorizontalMovementCheckSplitMovementMaxStepLength;
  this.myHorizontalMovementCheckSplitMovementMinStepLength = other.myHorizontalMovementCheckSplitMovementMinStepLength;
  this.myHorizontalMovementCheckGetBetterReferenceHit = other.myHorizontalMovementCheckGetBetterReferenceHit;
  this.myHorizontalMovementHorizontalRadialCheckEnabled = other.myHorizontalMovementHorizontalRadialCheckEnabled;
  this.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled = other.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled;
  this.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled = other.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled;
  this.myHorizontalMovementHorizontalStraightCheckEnabled = other.myHorizontalMovementHorizontalStraightCheckEnabled;
  this.myHorizontalMovementHorizontalStraightCentralCheckEnabled = other.myHorizontalMovementHorizontalStraightCentralCheckEnabled;
  this.myHorizontalMovementHeightCheckSteps = other.myHorizontalMovementHeightCheckSteps;
  this.myHorizontalMovementHeightVerticalCheckEnabled = other.myHorizontalMovementHeightVerticalCheckEnabled;
  this.myHorizontalMovementHeightHorizontalCheckEnabled = other.myHorizontalMovementHeightHorizontalCheckEnabled;
  this.myHorizontalMovementVerticalRadialDiagonalOutwardCheckEnabled = other.myHorizontalMovementVerticalRadialDiagonalOutwardCheckEnabled;
  this.myHorizontalMovementVerticalRadialDiagonalInwardCheckEnabled = other.myHorizontalMovementVerticalRadialDiagonalInwardCheckEnabled;
  this.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled = other.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled;
  this.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled = other.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled;
  this.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled = other.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled;
  this.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled = other.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled;
  this.myHorizontalMovementVerticalStraightCheckEnabled = other.myHorizontalMovementVerticalStraightCheckEnabled;
  this.myHorizontalMovementVerticalStraightCentralCheckEnabled = other.myHorizontalMovementVerticalStraightCentralCheckEnabled;
  this.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled;
  this.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled;
  this.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled;
  this.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = other.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled;
  this.myHorizontalPositionCheckEnabled = other.myHorizontalPositionCheckEnabled;
  this.myHorizontalPositionCheckConeHalfSlices = other.myHorizontalPositionCheckConeHalfSlices;
  this.myHorizontalPositionHorizontalBorderCheckEnabled = other.myHorizontalPositionHorizontalBorderCheckEnabled;
  this.myHorizontalPositionHorizontalRadialCheckEnabled = other.myHorizontalPositionHorizontalRadialCheckEnabled;
  this.myHorizontalPositionHeightCheckSteps = other.myHorizontalPositionHeightCheckSteps;
  this.myHorizontalPositionHeightHorizontalCheckEnabled = other.myHorizontalPositionHeightHorizontalCheckEnabled;
  this.myHorizontalPositionHeightVerticalCheckEnabled = other.myHorizontalPositionHeightVerticalCheckEnabled;
  this.myHorizontalPositionVerticalStraightCheckEnabled = other.myHorizontalPositionVerticalStraightCheckEnabled;
  this.myHorizontalPositionVerticalStraightCentralCheckEnabled = other.myHorizontalPositionVerticalStraightCentralCheckEnabled;
  this.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled = other.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled;
  this.myHorizontalPositionVerticalRadialDiagonalInwardCheckEnabled = other.myHorizontalPositionVerticalRadialDiagonalInwardCheckEnabled;
  this.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled = other.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled;
  this.myHorizontalPositionVerticalBorderDiagonalInwardCheckEnabled = other.myHorizontalPositionVerticalBorderDiagonalInwardCheckEnabled;
  this.myHorizontalPositionVerticalRadialBorderDiagonalOutwardCheckEnabled = other.myHorizontalPositionVerticalRadialBorderDiagonalOutwardCheckEnabled;
  this.myHorizontalPositionVerticalRadialBorderDiagonalInwardCheckEnabled = other.myHorizontalPositionVerticalRadialBorderDiagonalInwardCheckEnabled;
  this.myHorizontalPositionVerticalCheckGetFarthestHit = other.myHorizontalPositionVerticalCheckGetFarthestHit;
  this.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit = other.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit;
  this.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit = other.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit;
  this.myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision = other.myHorizontalPositionVerticalCheckIgnoreHitsInsideCollision;
  this.myHorizontalPositionVerticalCheckDirection = other.myHorizontalPositionVerticalCheckDirection;
  this.myHorizontalCheckBlockLayerFlags.setMask(other.myHorizontalCheckBlockLayerFlags.getMask());
  this.myHorizontalCheckObjectsToIgnore.pp_copy(other.myHorizontalCheckObjectsToIgnore);
  this.myHorizontalBlockColliderType = other.myHorizontalBlockColliderType;
};
CharacterColliderVerticalCheckParams.prototype.copy = function copy23(other) {
  this.myVerticalCheckCircumferenceRadius = other.myVerticalCheckCircumferenceRadius;
  this.myVerticalCheckCircumferenceSlices = other.myVerticalCheckCircumferenceSlices;
  this.myVerticalCheckCircumferenceCentralCheckEnabled = other.myVerticalCheckCircumferenceCentralCheckEnabled;
  this.myVerticalCheckCircumferenceRadialSteps = other.myVerticalCheckCircumferenceRadialSteps;
  this.myVerticalCheckCircumferenceRotationPerRadialStep = other.myVerticalCheckCircumferenceRotationPerRadialStep;
  this.myVerticalCheckFixedForwardEnabled = other.myVerticalCheckFixedForwardEnabled;
  this.myVerticalCheckFixedForward.vec3_copy(other.myVerticalCheckFixedForward);
  this.myVerticalMovementCheckEnabled = other.myVerticalMovementCheckEnabled;
  this.myVerticalMovementCheckReductionEnabled = other.myVerticalMovementCheckReductionEnabled;
  this.myVerticalMovementCheckPerformCheckOnBothSides = other.myVerticalMovementCheckPerformCheckOnBothSides;
  this.myVerticalPositionCheckEnabled = other.myVerticalPositionCheckEnabled;
  this.myVerticalPositionCheckPerformCheckOnBothSides = other.myVerticalPositionCheckPerformCheckOnBothSides;
  this.myVerticalCheckAllowHitsInsideCollisionIfOneValid = other.myVerticalCheckAllowHitsInsideCollisionIfOneValid;
  this.myVerticalCheckBlockLayerFlags.setMask(other.myVerticalCheckBlockLayerFlags.getMask());
  this.myVerticalCheckObjectsToIgnore.pp_copy(other.myVerticalCheckObjectsToIgnore);
  this.myVerticalBlockColliderType = other.myVerticalBlockColliderType;
};
CharacterColliderWallSlideParams.prototype.copy = function copy24(other) {
  this.myWallSlideEnabled = other.myWallSlideEnabled;
  this.myWallSlideMaxAttempts = other.myWallSlideMaxAttempts;
  this.myCheckBothWallSlideDirections = other.myCheckBothWallSlideDirections;
  this.myWallSlideFlickerPreventionMode = other.myWallSlideFlickerPreventionMode;
  this.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = other.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding;
  this.myWallSlideFlickerPreventionForceCheckCounter = other.myWallSlideFlickerPreventionForceCheckCounter;
  this.my90DegreesWallSlideAdjustDirectionSign = other.my90DegreesWallSlideAdjustDirectionSign;
};
CharacterColliderSurfaceParams.prototype.copy = function copy25(other) {
  this.mySurfaceSnapMaxDistance = other.mySurfaceSnapMaxDistance;
  this.mySurfacePopOutMaxDistance = other.mySurfacePopOutMaxDistance;
  this.mySurfaceAngleToIgnore = other.mySurfaceAngleToIgnore;
  this.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle = other.mySurfaceAngleToIgnoreWithSurfacePerceivedAngle;
  this.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance = other.myHorizontalMovementSurfaceAngleToIgnoreMaxVerticalDistance;
  this.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance = other.myHorizontalPositionSurfaceAngleToIgnoreMaxVerticalDistance;
  this.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft = other.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft;
  this.myCollectSurfaceInfo = other.myCollectSurfaceInfo;
  this.myOnSurfaceMaxOutsideDistance = other.myOnSurfaceMaxOutsideDistance;
  this.myOnSurfaceMaxInsideDistance = other.myOnSurfaceMaxInsideDistance;
  this.myBaseInsideCollisionCheckEnabled = other.myBaseInsideCollisionCheckEnabled;
  this.myOnSurfaceIfBaseInsideCollision = other.myOnSurfaceIfBaseInsideCollision;
  this.myCollectSurfaceNormalMaxOutsideDistance = other.myCollectSurfaceNormalMaxOutsideDistance;
  this.myCollectSurfaceNormalMaxInsideDistance = other.myCollectSurfaceNormalMaxInsideDistance;
  this.myCollectSurfaceDistanceOutsideDistance = other.myCollectSurfaceDistanceOutsideDistance;
  this.myCollectSurfaceDistanceInsideDistance = other.myCollectSurfaceDistanceInsideDistance;
  this.myCollectSurfaceCollisionHitOutsideDistance = other.myCollectSurfaceCollisionHitOutsideDistance;
  this.myCollectSurfaceCollisionHitInsideDistance = other.myCollectSurfaceCollisionHitInsideDistance;
  this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill = other.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill;
  this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill = other.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill;
  this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfaceAngle = other.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfaceAngle;
  this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfaceAngle = other.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfaceAngle;
  this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle = other.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhillMaxSurfacePerceivedAngle;
  this.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle = other.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphillMaxSurfacePerceivedAngle;
  this.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhill = other.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhill;
  this.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhillMinSurfaceAngle = other.myVerticalMovementAdjustHorizontalMovementOverSurfaceAngleDownhillMinSurfaceAngle;
  this.myMovementMustStayOnSurface = other.myMovementMustStayOnSurface;
  this.myMovementMustStayOnSurfaceHitMaxAngle = other.myMovementMustStayOnSurfaceHitMaxAngle;
  this.myMovementMustStayOnIgnorableSurfaceAngleDownhill = other.myMovementMustStayOnIgnorableSurfaceAngleDownhill;
  this.myMovementMustStayOnSurfaceAngleDownhill = other.myMovementMustStayOnSurfaceAngleDownhill;
  this.myTeleportMustBeOnSurface = other.myTeleportMustBeOnSurface;
  this.myTeleportMustBeOnIgnorableSurfaceAngle = other.myTeleportMustBeOnIgnorableSurfaceAngle;
  this.myTeleportMustBeOnSurfaceAngle = other.myTeleportMustBeOnSurfaceAngle;
  this.myCheckTransformMustBeOnSurface = other.myCheckTransformMustBeOnSurface;
  this.myCheckTransformMustBeOnIgnorableSurfaceAngle = other.myCheckTransformMustBeOnIgnorableSurfaceAngle;
  this.myCheckTransformMustBeOnSurfaceAngle = other.myCheckTransformMustBeOnSurfaceAngle;
  this.myRecollectSurfaceInfoOnSurfaceCheckFailed = other.myRecollectSurfaceInfoOnSurfaceCheckFailed;
  this.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle = other.myHorizontalMovementAllowExitAttemptWhenOnNotIgnorableSurfacePerceivedAngle;
};
CharacterColliderSplitMovementParams.prototype.copy = function copy26(other) {
  this.mySplitMovementEnabled = other.mySplitMovementEnabled;
  this.mySplitMovementMaxSteps = other.mySplitMovementMaxSteps;
  this.mySplitMovementMaxStepLength = other.mySplitMovementMaxStepLength;
  this.mySplitMovementMinStepLength = other.mySplitMovementMinStepLength;
  this.mySplitMovementLastStepCanBeLongerThanMaxStepLength = other.mySplitMovementLastStepCanBeLongerThanMaxStepLength;
  this.mySplitMovementStopOnHorizontalMovementFailed = other.mySplitMovementStopOnHorizontalMovementFailed;
  this.mySplitMovementStopOnVerticalMovementFailed = other.mySplitMovementStopOnVerticalMovementFailed;
  this.mySplitMovementStopOnVerticalMovementReduced = other.mySplitMovementStopOnVerticalMovementReduced;
  this.mySplitMovementStopAndFailIfMovementWouldBeReduced = other.mySplitMovementStopAndFailIfMovementWouldBeReduced;
  this.mySplitMovementStopReturnPreviousResults = other.mySplitMovementStopReturnPreviousResults;
};
CharacterColliderAdditionalParams.prototype.copy = function copy27(other) {
  this.myPositionOffsetLocal.vec3_copy(other.myPositionOffsetLocal);
  this.myRotationOffsetLocalQuat.quat_copy(other.myRotationOffsetLocalQuat);
};
CharacterColliderDebugParams.prototype.copy = function copy28(other) {
  this.myVisualDebugEnabled = other.myVisualDebugEnabled;
  this.myVisualDebugMovementEnabled = other.myVisualDebugMovementEnabled;
  this.myVisualDebugHorizontalMovementCheckEnabled = other.myVisualDebugHorizontalMovementCheckEnabled;
  this.myVisualDebugHorizontalPositionCheckEnabled = other.myVisualDebugHorizontalPositionCheckEnabled;
  this.myVisualDebugVerticalMovementCheckEnabled = other.myVisualDebugVerticalMovementCheckEnabled;
  this.myVisualDebugVerticalPositionCheckEnabled = other.myVisualDebugVerticalPositionCheckEnabled;
  this.myVisualDebugSlideEnabled = other.myVisualDebugSlideEnabled;
  this.myVisualDebugGroundInfoEnabled = other.myVisualDebugGroundInfoEnabled;
  this.myVisualDebugCeilingInfoEnabled = other.myVisualDebugCeilingInfoEnabled;
  this.myVisualDebugResultsEnabled = other.myVisualDebugResultsEnabled;
};

// dist/pp/gameplay/experimental/character_controller/character_controller_utils.js
function computeGroundPerceivedAngle(surfaceNormal, direction, up) {
  return this.computeSurfacePerceivedAngle(surfaceNormal, direction, up, true);
}
function computeCeilingPerceivedAngle(surfaceNormal, direction, up) {
  return this.computeSurfacePerceivedAngle(surfaceNormal, direction, up, false);
}
var computeSurfacePerceivedAngle = function() {
  let directionOnSurface = vec3_create();
  let verticalDirection = vec3_create();
  return function computeSurfacePerceivedAngle2(surfaceNormal, direction, up, ground) {
    let surfacePerceivedAngle = 0;
    verticalDirection.vec3_copy(up);
    if (!ground) {
      verticalDirection.vec3_negate(verticalDirection);
    }
    let surfaceAngle = surfaceNormal.vec3_angle(verticalDirection);
    if (surfaceAngle <= Math.PP_EPSILON_DEGREES) {
      surfaceAngle = 0;
    } else if (surfaceAngle >= 180 - Math.PP_EPSILON_DEGREES) {
      surfaceAngle = 180;
    }
    directionOnSurface = direction.vec3_projectOnPlaneAlongAxis(surfaceNormal, up, directionOnSurface);
    surfacePerceivedAngle = directionOnSurface.vec3_angle(direction);
    let fartherOnUp = directionOnSurface.vec3_isFartherAlongAxis(direction, up);
    if (!fartherOnUp && ground || fartherOnUp && !ground) {
      surfacePerceivedAngle *= -1;
    }
    if (Math.abs(surfacePerceivedAngle) >= surfaceAngle) {
      if (surfaceAngle != 0 && surfaceAngle != 180) {
        surfacePerceivedAngle = surfaceAngle * Math.pp_sign(surfacePerceivedAngle);
      } else {
        surfacePerceivedAngle = surfaceAngle;
      }
    }
    return surfacePerceivedAngle;
  };
}();
var CharacterControllerUtils = {
  computeGroundPerceivedAngle,
  computeCeilingPerceivedAngle,
  computeSurfacePerceivedAngle
};

// dist/pp/gameplay/experimental/character_controller/collision/character_collider_setup_utils.js
var CharacterColliderSetupSimplifiedCreationAccuracyLevel;
(function(CharacterColliderSetupSimplifiedCreationAccuracyLevel2) {
  CharacterColliderSetupSimplifiedCreationAccuracyLevel2[CharacterColliderSetupSimplifiedCreationAccuracyLevel2["VERY_LOW"] = 0] = "VERY_LOW";
  CharacterColliderSetupSimplifiedCreationAccuracyLevel2[CharacterColliderSetupSimplifiedCreationAccuracyLevel2["LOW"] = 1] = "LOW";
  CharacterColliderSetupSimplifiedCreationAccuracyLevel2[CharacterColliderSetupSimplifiedCreationAccuracyLevel2["MEDIUM"] = 2] = "MEDIUM";
  CharacterColliderSetupSimplifiedCreationAccuracyLevel2[CharacterColliderSetupSimplifiedCreationAccuracyLevel2["HIGH"] = 3] = "HIGH";
  CharacterColliderSetupSimplifiedCreationAccuracyLevel2[CharacterColliderSetupSimplifiedCreationAccuracyLevel2["VERY_HIGH"] = 4] = "VERY_HIGH";
})(CharacterColliderSetupSimplifiedCreationAccuracyLevel || (CharacterColliderSetupSimplifiedCreationAccuracyLevel = {}));
var CharacterColliderSetupSimplifiedCreationParams = class {
  myHeight = 0;
  myRadius = 0;
  myFeetRadius = null;
  myAccuracyLevel = CharacterColliderSetupSimplifiedCreationAccuracyLevel.VERY_LOW;
  myIsPlayer = false;
  /**
   * If you enable this, you might also want to disable {@link myCheckCeilings},
   * since it doesn't make much sense to check for ceilings when not checking the height
   */
  myCheckOnlyFeet = false;
  /**
   * If you enable this, you might also want to disable {@link myCheckOnlyFeet},
   * since it doesn't make much sense to check for ceilings without also checking the height
   */
  myCheckCeilings = false;
  myMaxMovementSteps = null;
  myShouldSlideAlongWall = false;
  myCollectGroundInfo = false;
  myMaxDistanceToSnapOnGround = 0;
  myMaxDistanceToPopOutGround = 0;
  myMaxWalkableGroundAngle = 0;
  myMaxWalkableGroundStepHeight = 0;
  /**
   * Normally, the ground params are used for the ceiling too, but this needs to be a different setting,
   * since allowing walkable steps on ceiling might create issues with view occlusion for the player (especially with a high value)
   * since you can go more under some low ceiling making the occlusion head collide with it
   *
   * Settings it to zero is safer, but means that the ceilings physx must be more flat, because it's easier that a small ceiling bump now blocks you
   */
  myMaxWalkableCeilingStepHeight = 0;
  myShouldNotFallFromEdges = false;
  myHorizontalCheckBlockLayerFlags = new PhysicsLayerFlags();
  myHorizontalCheckObjectsToIgnore = [];
  myVerticalCheckBlockLayerFlags = new PhysicsLayerFlags();
  myVerticalCheckObjectsToIgnore = [];
  myHorizontalCheckDebugEnabled = false;
  myVerticalCheckDebugEnabled = false;
};
function createSimplified(simplifiedCreationParams, outCharacterColliderSetup = new CharacterColliderSetup()) {
  outCharacterColliderSetup.myHeight = simplifiedCreationParams.myHeight;
  outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeRadius = simplifiedCreationParams.myRadius;
  outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadius = simplifiedCreationParams.myFeetRadius ?? simplifiedCreationParams.myRadius / 2;
  outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckFixedForwardEnabled = true;
  outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckFixedForward.vec3_set(0, 0, 1);
  if (!simplifiedCreationParams.myCheckOnlyFeet) {
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalHeightCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalPositionCheckEnabled = true;
  }
  outCharacterColliderSetup.myWallSlideParams.myWallSlideEnabled = simplifiedCreationParams.myShouldSlideAlongWall;
  outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckFeetDistanceToIgnore = simplifiedCreationParams.myMaxWalkableGroundStepHeight;
  outCharacterColliderSetup.myGroundParams.mySurfaceSnapMaxDistance = simplifiedCreationParams.myMaxDistanceToSnapOnGround;
  outCharacterColliderSetup.myGroundParams.mySurfacePopOutMaxDistance = Math.max(simplifiedCreationParams.myMaxDistanceToPopOutGround, outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckFeetDistanceToIgnore);
  outCharacterColliderSetup.myGroundParams.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft = simplifiedCreationParams.myRadius * 0.75;
  outCharacterColliderSetup.myGroundParams.myCollectSurfaceInfo = simplifiedCreationParams.myCollectGroundInfo || simplifiedCreationParams.myMaxWalkableGroundAngle > 0;
  outCharacterColliderSetup.myGroundParams.mySurfaceAngleToIgnore = simplifiedCreationParams.myMaxWalkableGroundAngle;
  outCharacterColliderSetup.myGroundParams.myOnSurfaceMaxOutsideDistance = 1e-3;
  outCharacterColliderSetup.myGroundParams.myOnSurfaceMaxInsideDistance = 1e-3;
  outCharacterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxOutsideDistance = simplifiedCreationParams.myRadius > 0.1 ? 0.1 : 0.01;
  outCharacterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxInsideDistance = outCharacterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxOutsideDistance;
  outCharacterColliderSetup.myGroundParams.myCollectSurfaceDistanceOutsideDistance = outCharacterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxOutsideDistance;
  outCharacterColliderSetup.myGroundParams.myCollectSurfaceDistanceInsideDistance = outCharacterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxInsideDistance;
  outCharacterColliderSetup.myGroundParams.myCollectSurfaceCollisionHitOutsideDistance = outCharacterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxOutsideDistance;
  outCharacterColliderSetup.myGroundParams.myCollectSurfaceCollisionHitInsideDistance = outCharacterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxInsideDistance;
  outCharacterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleDownhill = true;
  outCharacterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill = true;
  if (simplifiedCreationParams.myShouldNotFallFromEdges) {
    outCharacterColliderSetup.myGroundParams.myMovementMustStayOnSurface = true;
    outCharacterColliderSetup.myGroundParams.myMovementMustStayOnSurfaceAngleDownhill = Math.max(60, outCharacterColliderSetup.myGroundParams.mySurfaceAngleToIgnore);
  }
  outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckHeadDistanceToIgnore = simplifiedCreationParams.myMaxWalkableCeilingStepHeight;
  if (simplifiedCreationParams.myCheckCeilings) {
    outCharacterColliderSetup.myCeilingParams.mySurfacePopOutMaxDistance = Math.max(simplifiedCreationParams.myMaxDistanceToPopOutGround, outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckHeadDistanceToIgnore);
    outCharacterColliderSetup.myCeilingParams.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft = outCharacterColliderSetup.myGroundParams.myHorizontalMovementSurfaceAngleToIgnoreMaxHorizontalMovementLeft;
    outCharacterColliderSetup.myCeilingParams.myCollectSurfaceInfo = outCharacterColliderSetup.myGroundParams.myCollectSurfaceInfo;
    outCharacterColliderSetup.myCeilingParams.mySurfaceAngleToIgnore = outCharacterColliderSetup.myGroundParams.mySurfaceAngleToIgnore;
    outCharacterColliderSetup.myCeilingParams.myOnSurfaceMaxOutsideDistance = outCharacterColliderSetup.myGroundParams.myOnSurfaceMaxOutsideDistance;
    outCharacterColliderSetup.myCeilingParams.myOnSurfaceMaxInsideDistance = outCharacterColliderSetup.myGroundParams.myOnSurfaceMaxInsideDistance;
    outCharacterColliderSetup.myCeilingParams.myCollectSurfaceNormalMaxOutsideDistance = outCharacterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxOutsideDistance;
    outCharacterColliderSetup.myCeilingParams.myCollectSurfaceNormalMaxInsideDistance = outCharacterColliderSetup.myGroundParams.myCollectSurfaceNormalMaxInsideDistance;
    outCharacterColliderSetup.myCeilingParams.myCollectSurfaceDistanceOutsideDistance = outCharacterColliderSetup.myGroundParams.myCollectSurfaceDistanceOutsideDistance;
    outCharacterColliderSetup.myCeilingParams.myCollectSurfaceDistanceInsideDistance = outCharacterColliderSetup.myGroundParams.myCollectSurfaceDistanceInsideDistance;
    outCharacterColliderSetup.myCeilingParams.myCollectSurfaceCollisionHitOutsideDistance = outCharacterColliderSetup.myGroundParams.myCollectSurfaceCollisionHitOutsideDistance;
    outCharacterColliderSetup.myCeilingParams.myCollectSurfaceCollisionHitInsideDistance = outCharacterColliderSetup.myGroundParams.myCollectSurfaceCollisionHitInsideDistance;
    outCharacterColliderSetup.myCeilingParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill = outCharacterColliderSetup.myGroundParams.myHorizontalMovementAdjustVerticalMovementOverSurfacePerceivedAngleUphill;
  }
  outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckBlockLayerFlags.copy(simplifiedCreationParams.myHorizontalCheckBlockLayerFlags);
  outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckObjectsToIgnore.pp_copy(simplifiedCreationParams.myHorizontalCheckObjectsToIgnore);
  outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckBlockLayerFlags.copy(simplifiedCreationParams.myVerticalCheckBlockLayerFlags);
  outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckObjectsToIgnore.pp_copy(simplifiedCreationParams.myVerticalCheckObjectsToIgnore);
  if (simplifiedCreationParams.myHorizontalCheckDebugEnabled) {
    outCharacterColliderSetup.myDebugParams.myVisualDebugEnabled = true;
    outCharacterColliderSetup.myDebugParams.myVisualDebugHorizontalMovementCheckEnabled = true;
    outCharacterColliderSetup.myDebugParams.myVisualDebugHorizontalPositionCheckEnabled = true;
    outCharacterColliderSetup.myDebugParams.myVisualDebugSlideEnabled = true;
  }
  if (simplifiedCreationParams.myVerticalCheckDebugEnabled) {
    outCharacterColliderSetup.myDebugParams.myVisualDebugEnabled = true;
    outCharacterColliderSetup.myDebugParams.myVisualDebugVerticalMovementCheckEnabled = true;
    outCharacterColliderSetup.myDebugParams.myVisualDebugVerticalPositionCheckEnabled = true;
  }
  if (simplifiedCreationParams.myAccuracyLevel >= CharacterColliderSetupSimplifiedCreationAccuracyLevel.VERY_LOW) {
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeHalfAngle = 60;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightVerticalCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightVerticalCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckEnabled = false;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckConeHalfSlices = 1;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightCheckSteps = 1;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHorizontalRadialCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalStraightCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices = 4;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceCentralCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadialSteps = 1;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalMovementCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalMovementCheckReductionEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckAllowHitsInsideCollisionIfOneValid = true;
    if (simplifiedCreationParams.myIsPlayer) {
      outCharacterColliderSetup.myWallSlideParams.myWallSlideMaxAttempts = 2;
      outCharacterColliderSetup.myWallSlideParams.my90DegreesWallSlideAdjustDirectionSign = true;
    }
  }
  if (simplifiedCreationParams.myAccuracyLevel >= CharacterColliderSetupSimplifiedCreationAccuracyLevel.LOW) {
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckRadialSteps = 1;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightCheckSteps = 1;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalStraightCentralCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadialSteps = 2;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRotationPerRadialStep = 180 / outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices;
    outCharacterColliderSetup.myWallSlideParams.myWallSlideMaxAttempts = 2;
    outCharacterColliderSetup.myWallSlideParams.myCheckBothWallSlideDirections = false;
    outCharacterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionMode = CharacterColliderSlideFlickerPreventionMode.NONE;
    outCharacterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = false;
    outCharacterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionForceCheckCounter = 0;
    outCharacterColliderSetup.myWallSlideParams.my90DegreesWallSlideAdjustDirectionSign = false;
  }
  if (simplifiedCreationParams.myAccuracyLevel >= CharacterColliderSetupSimplifiedCreationAccuracyLevel.MEDIUM) {
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightHorizontalCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalDiagonalOutwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalOutwardUpwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckConeHalfSlices = 2;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightHorizontalCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHorizontalBorderCheckEnabled = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalMovementCheckPerformCheckOnBothSides = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalPositionCheckPerformCheckOnBothSides = true;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices = 6;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadialSteps = 2;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRotationPerRadialStep = 180 / outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices;
    outCharacterColliderSetup.myWallSlideParams.myWallSlideMaxAttempts = 3;
    outCharacterColliderSetup.myWallSlideParams.my90DegreesWallSlideAdjustDirectionSign = true;
    if (simplifiedCreationParams.myIsPlayer) {
      outCharacterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionMode = CharacterColliderSlideFlickerPreventionMode.USE_PREVIOUS_RESULTS;
      outCharacterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionCheckOnlyIfAlreadySliding = true;
      outCharacterColliderSetup.myWallSlideParams.myWallSlideFlickerPreventionForceCheckCounter = 4;
    }
    outCharacterColliderSetup.mySplitMovementParams.mySplitMovementEnabled = true;
    outCharacterColliderSetup.mySplitMovementParams.mySplitMovementMaxSteps = simplifiedCreationParams.myMaxMovementSteps;
    const safeRadius = simplifiedCreationParams.myRadius * 0.75;
    outCharacterColliderSetup.mySplitMovementParams.mySplitMovementMaxStepLength = safeRadius;
    outCharacterColliderSetup.mySplitMovementParams.mySplitMovementMinStepLength = safeRadius;
  }
  if (simplifiedCreationParams.myAccuracyLevel >= CharacterColliderSetupSimplifiedCreationAccuracyLevel.HIGH) {
    if (outCharacterColliderSetup.myWallSlideParams.myWallSlideEnabled) {
      outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementCheckGetBetterReferenceHit = true;
      outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit = true;
      outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit = true;
    }
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalDiagonalInwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalStraightCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalStraightCentralCheckEnabled = false;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalInwardUpwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalUpwardCentralCheckEnabled = false;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices = 8;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRadialSteps = 2;
    outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceRotationPerRadialStep = 180 / outCharacterColliderSetup.myVerticalCheckParams.myVerticalCheckCircumferenceSlices;
    outCharacterColliderSetup.myWallSlideParams.myWallSlideMaxAttempts = 4;
    if (simplifiedCreationParams.myIsPlayer) {
      outCharacterColliderSetup.myWallSlideParams.myCheckBothWallSlideDirections = true;
    }
    outCharacterColliderSetup.myGroundParams.myBaseInsideCollisionCheckEnabled = true;
    if (simplifiedCreationParams.myCheckCeilings) {
      outCharacterColliderSetup.myCeilingParams.myBaseInsideCollisionCheckEnabled = true;
    }
  }
  if (simplifiedCreationParams.myAccuracyLevel >= CharacterColliderSetupSimplifiedCreationAccuracyLevel.VERY_HIGH) {
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHeightCheckSteps = 2;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementHorizontalRadialCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalOutwardDownwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalDiagonalInwardDownwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightCentralCheckEnabled = false;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalMovementVerticalStraightDiagonalDownwardCentralCheckEnabled = false;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionHeightCheckSteps = 2;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalRadialDiagonalOutwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalBorderDiagonalOutwardCheckEnabled = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHit = true;
    outCharacterColliderSetup.myHorizontalCheckParams.myHorizontalPositionVerticalCheckPerformHorizontalCheckOnHitKeepVerticalHitIfNoHorizontalHit = true;
    outCharacterColliderSetup.myGroundParams.myRecollectSurfaceInfoOnSurfaceCheckFailed = true;
    if (simplifiedCreationParams.myCheckCeilings) {
      outCharacterColliderSetup.myCeilingParams.myRecollectSurfaceInfoOnSurfaceCheckFailed = outCharacterColliderSetup.myGroundParams.myRecollectSurfaceInfoOnSurfaceCheckFailed;
    }
  }
  return outCharacterColliderSetup;
}
function createTeleportColliderSetupFromMovementColliderSetup(movementColliderSetup, outTeleportColliderSetup = new CharacterColliderSetup()) {
  outTeleportColliderSetup.copy(movementColliderSetup);
  outTeleportColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeHalfAngle = 180;
  outTeleportColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckConeHalfSlices = Math.round(outTeleportColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeHalfAngle / movementColliderSetup.myHorizontalCheckParams.myHorizontalCheckConeHalfAngle * movementColliderSetup.myHorizontalCheckParams.myHorizontalPositionCheckConeHalfSlices);
  outTeleportColliderSetup.myHorizontalCheckParams.myHorizontalCheckFixedForwardEnabled = true;
  outTeleportColliderSetup.myHorizontalCheckParams.myHorizontalCheckFixedForward.vec3_set(0, 0, 1);
  return outTeleportColliderSetup;
}
var CharacterColliderSetupUtils = {
  createSimplified,
  createTeleportColliderSetupFromMovementColliderSetup
};

// dist/pp/gameplay/experimental/locomotion/legacy/locomotion/player_head_manager.js
var NonVRReferenceSpaceMode;
(function(NonVRReferenceSpaceMode2) {
  NonVRReferenceSpaceMode2[NonVRReferenceSpaceMode2["NO_FLOOR"] = 0] = "NO_FLOOR";
  NonVRReferenceSpaceMode2[NonVRReferenceSpaceMode2["FLOOR"] = 1] = "FLOOR";
  NonVRReferenceSpaceMode2[NonVRReferenceSpaceMode2["NO_FLOOR_THEN_KEEP_VR"] = 2] = "NO_FLOOR_THEN_KEEP_VR";
  NonVRReferenceSpaceMode2[NonVRReferenceSpaceMode2["FLOOR_THEN_KEEP_VR"] = 3] = "FLOOR_THEN_KEEP_VR";
})(NonVRReferenceSpaceMode || (NonVRReferenceSpaceMode = {}));
var PlayerHeadManagerParams = class {
  mySessionChangeResyncEnabled = false;
  myBlurEndResyncEnabled = false;
  myBlurEndResyncRotation = false;
  myResetTransformOnViewResetEnabled = true;
  myNextEnterSessionResyncHeight = false;
  myEnterSessionResyncHeight = false;
  myExitSessionResyncHeight = false;
  myExitSessionResyncVerticalAngle = false;
  /** For now right tilt is removed even if this setting is `false`, if the vertical angle has to be adjusted */
  myExitSessionRemoveRightTilt = false;
  myExitSessionAdjustMaxVerticalAngle = false;
  myExitSessionMaxVerticalAngle = 0;
  myExitSessionResetNonVRTransformLocal = true;
  myNonVRFloorBasedMode = NonVRReferenceSpaceMode.FLOOR_THEN_KEEP_VR;
  myDefaultHeightNonVR = 0;
  myDefaultHeightVRWithoutFloor = 0;
  /** `null` means just keep the detected one */
  myDefaultHeightVRWithFloor = null;
  /** Can be used to always add a bit of height, for example to compensate the fact
      that the default height is actually the eye height and you may want to also add a forehead offset */
  myForeheadExtraHeight = 0;
  myFeetRotationKeepUp = true;
  myDebugEnabled = false;
  myEngine;
  constructor(engine = Globals.getMainEngine()) {
    this.myEngine = engine;
  }
};
var PlayerHeadManager = class _PlayerHeadManager {
  _myParams;
  _myCurrentHead;
  _myCurrentHeadTransformLocalQuat = quat2_create();
  _mySessionChangeResyncHeadTransform = null;
  /** Needed because VR head takes some frames to get the tracked position */
  _myDelaySessionChangeResyncCounter = 0;
  _myBlurRecoverHeadTransform = null;
  _myDelayBlurEndResyncCounter = 0;
  _myDelayBlurEndResyncTimer = new Timer(5, false);
  _myVisibilityHidden = false;
  _myVisibilityChangeEventListener = null;
  _mySessionActive = false;
  _mySessionBlurred = false;
  _myIsSyncedDelayCounter = 0;
  _myViewResetThisFrame = false;
  _myViewResetEventListener = null;
  _myHeightNonVR = 0;
  _myHeightNonVROnEnterSession = 0;
  _myHeightVRWithoutFloor = null;
  _myHeightVRWithFloor = null;
  _myHeightOffsetWithFloor = 0;
  _myHeightOffsetWithoutFloor = 0;
  _myNextEnterSessionSetHeightVRWithFloor = false;
  _myNextEnterSessionSetHeightVRWithoutFloor = false;
  _myDelayNextEnterSessionSetHeightVRCounter = 0;
  _myLastReferenceSpaceIsFloorBased = null;
  _myActive = true;
  _myDestroyed = false;
  static _myResyncCounterFrames = 3;
  static _myIsSyncedDelayCounterFrames = 1;
  constructor(params = new PlayerHeadManagerParams()) {
    this._myParams = params;
    this._myCurrentHead = Globals.getPlayerObjects(this._myParams.myEngine).myHead;
  }
  start() {
    this._setHeightHeadNonVR(this._myParams.myDefaultHeightNonVR);
    this._setHeightHeadVRWithoutFloor(this._myParams.myDefaultHeightVRWithoutFloor);
    this._setHeightHeadVRWithFloor(this._myParams.myDefaultHeightVRWithFloor);
    this._updateHeightOffset();
    this._setCameraNonXRHeight(this._myHeightNonVR);
    this._myActive = false;
    this.setActive(true);
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      if (this._myActive) {
        XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, true, this._myParams.myEngine);
      } else {
        if (this._myViewResetEventListener != null) {
          XRUtils.getReferenceSpace(this._myParams.myEngine)?.removeEventListener?.("reset", this._myViewResetEventListener);
        }
        if (this._myVisibilityChangeEventListener != null) {
          XRUtils.getSession(this._myParams.myEngine)?.removeEventListener?.("visibilitychange", this._myVisibilityChangeEventListener);
        }
        XRUtils.unregisterSessionStartEndEventListeners(this, this._myParams.myEngine);
        this._onXRSessionEnd();
      }
      this.cancelSync();
    }
  }
  getParams() {
    return this._myParams;
  }
  getPlayer() {
    return Globals.getPlayerObjects(this._myParams.myEngine).myPlayer;
  }
  getHead() {
    return this._myCurrentHead;
  }
  getHeightHead() {
    return this.getHeightEyes() + this._myParams.myForeheadExtraHeight;
  }
  static _getHeightEyesSV = {
    headPosition: vec3_create()
  };
  getHeightEyes() {
    const headPosition = _PlayerHeadManager._getHeightEyesSV.headPosition;
    this._myCurrentHead.pp_getPosition(headPosition);
    const eyesHeight = this._getPositionEyesHeight(headPosition);
    return eyesHeight;
  }
  static _getTransformFeetQuatSV = {
    feetPosition: vec3_create(),
    feetRotationQuat: quat_create()
  };
  getTransformFeetQuat(outTransformQuat = quat2_create()) {
    const feetPosition = _PlayerHeadManager._getTransformFeetQuatSV.feetPosition;
    const feetRotationQuat = _PlayerHeadManager._getTransformFeetQuatSV.feetRotationQuat;
    outTransformQuat.quat2_setPositionRotationQuat(this.getPositionFeet(feetPosition), this.getRotationFeetQuat(feetRotationQuat));
    return outTransformQuat;
  }
  getTransformHeadQuat(outTransformQuat = quat2_create()) {
    return this.getHead().pp_getTransformQuat(outTransformQuat);
  }
  static _getPositionFeetSV = {
    headPosition: vec3_create(),
    playerUp: vec3_create()
  };
  getPositionFeet(outPosition = vec3_create()) {
    const headPosition = _PlayerHeadManager._getPositionFeetSV.headPosition;
    this._myCurrentHead.pp_getPosition(headPosition);
    const headHeight = this._getPositionEyesHeight(headPosition);
    const playerUp = _PlayerHeadManager._getPositionFeetSV.playerUp;
    this.getPlayer().pp_getUp(playerUp);
    outPosition = headPosition.vec3_sub(playerUp.vec3_scale(headHeight, outPosition), outPosition);
    return outPosition;
  }
  getPositionHead(outPosition = vec3_create()) {
    return this._myCurrentHead.pp_getPosition(outPosition);
  }
  static _getRotationFeetQuatSV = {
    playerUp: vec3_create(),
    headForward: vec3_create()
  };
  getRotationFeetQuat(outRotationQuat = quat_create()) {
    const playerUp = _PlayerHeadManager._getRotationFeetQuatSV.playerUp;
    const headForward = _PlayerHeadManager._getRotationFeetQuatSV.headForward;
    this.getPlayer().pp_getUp(playerUp);
    this._myCurrentHead.pp_getForward(headForward);
    const angleWithUp = headForward.vec3_angle(playerUp);
    const mingAngle = 10;
    if (angleWithUp < mingAngle) {
      this._myCurrentHead.pp_getDown(headForward);
    } else if (angleWithUp > 180 - mingAngle) {
      this._myCurrentHead.pp_getUp(headForward);
    }
    headForward.vec3_removeComponentAlongAxis(playerUp, headForward);
    headForward.vec3_normalize(headForward);
    outRotationQuat.quat_setUp(playerUp, headForward);
    return outRotationQuat;
  }
  getRotationHeadQuat(outRotationQuat = quat_create()) {
    return this.getHead().pp_getRotationQuat(outRotationQuat);
  }
  isSynced(ignoreSessionBlurredState = false) {
    return this._myIsSyncedDelayCounter == 0 && this._myDelaySessionChangeResyncCounter == 0 && this._myDelayNextEnterSessionSetHeightVRCounter == 0 && this._myDelayBlurEndResyncCounter == 0 && !this._myDelayBlurEndResyncTimer.isRunning() && (ignoreSessionBlurredState || !this._mySessionBlurred);
  }
  setHeightHead(height, setOnlyForActiveOne = true) {
    this._setHeightHead(height, height, height, setOnlyForActiveOne);
  }
  setHeightHeadNonVR(height) {
    this._setHeightHeadNonVR(height);
    if (!this._mySessionActive) {
      this._updateHeightOffset();
      this._setCameraNonXRHeight(this._myHeightNonVR);
    }
  }
  setHeightHeadVRWithoutFloor(height) {
    this._setHeightHeadVRWithoutFloor(height);
    if (this._mySessionActive) {
      this._updateHeightOffset();
    }
  }
  setHeightHeadVRWithFloor(height = null) {
    this._setHeightHeadVRWithFloor(height);
    if (this._mySessionActive) {
      this._updateHeightOffset();
    }
  }
  resetHeightHeadToDefault(resetOnlyForActiveOne = true) {
    this._setHeightHead(this._myHeightNonVR, this._myHeightVRWithoutFloor, this._myHeightVRWithFloor, resetOnlyForActiveOne);
  }
  resetHeightHeadVRWithFloor() {
    this.setHeightHeadVRWithFloor(null);
  }
  getDefaultHeightHeadNonVR() {
    return this._myHeightNonVR;
  }
  getDefaultHeightHeadVRWithoutFloor() {
    return this._myHeightVRWithoutFloor;
  }
  getDefaultHeightHeadVRWithFloor() {
    return this._myHeightVRWithFloor;
  }
  getForeheadExtraHeight() {
    return this._myParams.myForeheadExtraHeight;
  }
  setForeheadExtraHeight(foreheadExtraHeight, keepSameHeight = false, keepSameHeightOnlyForActiveOne = true) {
    this._myParams.myForeheadExtraHeight = foreheadExtraHeight;
    if (keepSameHeight && (!keepSameHeightOnlyForActiveOne || !this._mySessionActive)) {
      this._setHeightHeadNonVR(this._myHeightNonVR);
    } else {
      this._myHeightNonVR = Math.max(this._myHeightNonVR + (foreheadExtraHeight - this._myParams.myForeheadExtraHeight), this._myParams.myForeheadExtraHeight);
      this._myHeightNonVROnEnterSession = Math.max(this._myHeightNonVROnEnterSession + (foreheadExtraHeight - this._myParams.myForeheadExtraHeight), this._myParams.myForeheadExtraHeight);
    }
    if (keepSameHeight && (!keepSameHeightOnlyForActiveOne || this._mySessionActive)) {
      this._setHeightHeadVRWithoutFloor(this._myHeightVRWithoutFloor);
      this._setHeightHeadVRWithFloor(this._myHeightVRWithFloor);
    } else {
      if (this._myHeightVRWithoutFloor != null) {
        this._myHeightVRWithoutFloor = Math.max(this._myHeightVRWithoutFloor + (foreheadExtraHeight - this._myParams.myForeheadExtraHeight), this._myParams.myForeheadExtraHeight);
      }
      if (this._myHeightVRWithFloor != null) {
        this._myHeightVRWithFloor = Math.max(this._myHeightVRWithFloor + (foreheadExtraHeight - this._myParams.myForeheadExtraHeight), this._myParams.myForeheadExtraHeight);
      }
    }
    if (keepSameHeight) {
      this._updateHeightOffset();
      if (!this._mySessionActive) {
        this._setCameraNonXRHeight(this._myHeightNonVR);
      }
    }
  }
  moveFeet(movement) {
    this.getPlayer().pp_translate(movement);
  }
  moveHead(movement) {
    this.moveFeet(movement);
  }
  static _teleportPositionHeadSV = {
    currentHeadPosition: vec3_create(),
    teleportMovementToPerform: vec3_create()
  };
  teleportPositionHead(teleportPosition) {
    const currentHeadPosition = _PlayerHeadManager._teleportPositionHeadSV.currentHeadPosition;
    const teleportMovementToPerform = _PlayerHeadManager._teleportPositionHeadSV.teleportMovementToPerform;
    this._myCurrentHead.pp_getPosition(currentHeadPosition);
    teleportPosition.vec3_sub(currentHeadPosition, teleportMovementToPerform);
    this.moveFeet(teleportMovementToPerform);
  }
  static _teleportPositionFeetSV = {
    currentFeetPosition: vec3_create(),
    teleportMovementToPerform: vec3_create()
  };
  teleportPositionFeet(teleportPosition) {
    const currentFeetPosition = _PlayerHeadManager._teleportPositionFeetSV.currentFeetPosition;
    const teleportMovementToPerform = _PlayerHeadManager._teleportPositionFeetSV.teleportMovementToPerform;
    this.getPositionFeet(currentFeetPosition);
    teleportPosition.vec3_sub(currentFeetPosition, teleportMovementToPerform);
    this.moveFeet(teleportMovementToPerform);
  }
  static _teleportPlayerToHeadTransformQuatSV = {
    headPosition: vec3_create(),
    playerUp: vec3_create(),
    flatCurrentPlayerPosition: vec3_create(),
    flatNewPlayerPosition: vec3_create(),
    teleportMovement: vec3_create(),
    playerForward: vec3_create(),
    headForward: vec3_create(),
    referenceSpaceForward: vec3_create(),
    referenceSpaceForwardNegated: vec3_create(),
    rotationToPerform: quat_create()
  };
  teleportPlayerToHeadTransformQuat(headTransformQuat) {
    const headPosition = _PlayerHeadManager._teleportPlayerToHeadTransformQuatSV.headPosition;
    headTransformQuat.quat2_getPosition(headPosition);
    const playerUp = _PlayerHeadManager._teleportPlayerToHeadTransformQuatSV.playerUp;
    const flatCurrentPlayerPosition = _PlayerHeadManager._teleportPlayerToHeadTransformQuatSV.flatCurrentPlayerPosition;
    const flatNewPlayerPosition = _PlayerHeadManager._teleportPlayerToHeadTransformQuatSV.flatNewPlayerPosition;
    this.getPlayer().pp_getUp(playerUp);
    this.getPlayer().pp_getPosition(flatCurrentPlayerPosition).vec3_removeComponentAlongAxis(playerUp, flatCurrentPlayerPosition);
    headPosition.vec3_removeComponentAlongAxis(playerUp, flatNewPlayerPosition);
    const teleportMovement = _PlayerHeadManager._teleportPlayerToHeadTransformQuatSV.teleportMovement;
    flatNewPlayerPosition.vec3_sub(flatCurrentPlayerPosition, teleportMovement);
    this.getPlayer().pp_translate(teleportMovement);
    const playerForward = _PlayerHeadManager._teleportPlayerToHeadTransformQuatSV.playerForward;
    const headForward = _PlayerHeadManager._teleportPlayerToHeadTransformQuatSV.headForward;
    this.getPlayer().pp_getForward(playerForward);
    headTransformQuat.quat2_getForward(headForward);
    const rotationToPerform = _PlayerHeadManager._teleportPlayerToHeadTransformQuatSV.rotationToPerform;
    playerForward.vec3_rotationToPivotedQuat(headForward, playerUp, rotationToPerform);
    this.getPlayer().pp_rotateQuat(rotationToPerform);
    this.getPlayer().pp_getForward(playerForward);
    const referenceSpaceForward = _PlayerHeadManager._teleportPlayerToHeadTransformQuatSV.referenceSpaceForward;
    const referenceSpaceForwardNegated = _PlayerHeadManager._teleportPlayerToHeadTransformQuatSV.referenceSpaceForwardNegated;
    Globals.getPlayerObjects(this._myParams.myEngine).myReferenceSpace.pp_getForward(referenceSpaceForward);
    referenceSpaceForward.vec3_negate(referenceSpaceForwardNegated);
    referenceSpaceForwardNegated.vec3_rotationToPivotedQuat(playerForward, playerUp, rotationToPerform);
    this.getPlayer().pp_rotateQuat(rotationToPerform);
  }
  static _rotateFeetQuatSV = {
    playerUp: vec3_create(),
    rotationAxis: vec3_create(),
    currentHeadPosition: vec3_create(),
    currentFeetRotation: quat_create(),
    newFeetRotation: quat_create(),
    fixedNewFeetRotation: quat_create(),
    newFeetForward: vec3_create(),
    fixedRotation: quat_create(),
    newHeadPosition: vec3_create(),
    headAdjustmentMovement: vec3_create()
  };
  rotateFeetQuat(rotationQuat, keepUpOverride = null) {
    const angle2 = rotationQuat.quat_getAngleRadians();
    if (angle2 <= 1e-5) {
      return;
    }
    const currentHeadPosition = _PlayerHeadManager._rotateFeetQuatSV.currentHeadPosition;
    const playerUp = _PlayerHeadManager._rotateFeetQuatSV.playerUp;
    const rotationAxis = _PlayerHeadManager._rotateFeetQuatSV.rotationAxis;
    this._myCurrentHead.pp_getPosition(currentHeadPosition);
    this.getPlayer().pp_getUp(playerUp);
    rotationQuat.quat_getAxis(rotationAxis);
    const fixedRotation = _PlayerHeadManager._rotateFeetQuatSV.fixedRotation;
    if (!rotationAxis.vec3_isOnAxis(playerUp) && (keepUpOverride == null && this._myParams.myFeetRotationKeepUp || keepUpOverride)) {
      const currentFeetRotation = _PlayerHeadManager._rotateFeetQuatSV.currentFeetRotation;
      this.getRotationFeetQuat(currentFeetRotation);
      const newFeetRotation = _PlayerHeadManager._rotateFeetQuatSV.newFeetRotation;
      const newFeetForward = _PlayerHeadManager._rotateFeetQuatSV.newFeetForward;
      currentFeetRotation.quat_rotateQuat(rotationQuat, newFeetRotation);
      newFeetRotation.quat_getForward(newFeetForward);
      const fixedNewFeetRotation = _PlayerHeadManager._rotateFeetQuatSV.fixedNewFeetRotation;
      fixedNewFeetRotation.quat_copy(newFeetRotation);
      fixedNewFeetRotation.quat_setUp(playerUp, newFeetForward);
      currentFeetRotation.quat_rotationToQuat(fixedNewFeetRotation, fixedRotation);
    } else {
      fixedRotation.quat_copy(rotationQuat);
    }
    this.getPlayer().pp_rotateAroundQuat(fixedRotation, currentHeadPosition);
    const newHeadPosition = _PlayerHeadManager._rotateFeetQuatSV.newHeadPosition;
    this._myCurrentHead.pp_getPosition(newHeadPosition);
    const headAdjustmentMovement = _PlayerHeadManager._rotateFeetQuatSV.headAdjustmentMovement;
    currentHeadPosition.vec3_sub(newHeadPosition, headAdjustmentMovement);
    if (headAdjustmentMovement.vec3_length() > 1e-5) {
      this.moveFeet(headAdjustmentMovement);
    }
  }
  static _rotateHeadQuatSV = {
    newHeadRotation: quat_create(),
    newHeadUp: vec3_create()
  };
  // #TODO Rotate feet with this and then rotate head freely if possible
  rotateHeadQuat(rotationQuat) {
    if (this.canRotateHead()) {
      this._myCurrentHead.pp_rotateQuat(rotationQuat);
      const newHeadRotation = _PlayerHeadManager._rotateHeadQuatSV.newHeadRotation;
      this._myCurrentHead.pp_getRotationQuat(newHeadRotation);
      Globals.getPlayerObjects(this._myParams.myEngine).myHead.pp_setRotationQuat(newHeadRotation);
      if (!this._mySessionActive) {
        const newHeadUp = _PlayerHeadManager._rotateHeadQuatSV.newHeadUp;
        newHeadRotation.quat_rotateAxisRadians(Math.PI, newHeadRotation.quat_getUp(newHeadUp), newHeadRotation);
        Globals.getPlayerObjects(this._myParams.myEngine).myCameraNonXR.pp_setRotationQuat(newHeadRotation);
      }
    }
  }
  canRotateFeet() {
    return true;
  }
  canRotateHead() {
    return !this._mySessionActive;
  }
  static _setRotationFeetQuatSV = {
    currentRotationQuat: quat_create(),
    rotationQuatToRotate: quat_create()
  };
  setRotationFeetQuat(rotationQuat, keepUpOverride = null) {
    const currentRotationQuat = _PlayerHeadManager._setRotationFeetQuatSV.currentRotationQuat;
    const rotationQuatToRotate = _PlayerHeadManager._setRotationFeetQuatSV.rotationQuatToRotate;
    this.getRotationFeetQuat(currentRotationQuat);
    currentRotationQuat.quat_rotationToQuat(rotationQuat, rotationQuatToRotate);
    this.rotateFeetQuat(rotationQuatToRotate, keepUpOverride);
  }
  static _setRotationHeadQuatSV = {
    currentRotationQuat: quat_create(),
    rotationQuatToRotate: quat_create()
  };
  setRotationHeadQuat(rotationQuat) {
    const currentRotationQuat = _PlayerHeadManager._setRotationHeadQuatSV.currentRotationQuat;
    const rotationQuatToRotate = _PlayerHeadManager._setRotationHeadQuatSV.rotationQuatToRotate;
    this.getRotationHeadQuat(currentRotationQuat);
    currentRotationQuat.quat_rotationToQuat(rotationQuat, rotationQuatToRotate);
    this.rotateHeadQuat(rotationQuatToRotate);
  }
  static _lookAtFeetSV = {
    direction: vec3_create(),
    feetPosition: vec3_create()
  };
  lookAtFeet(position, up, keepUpOverride = null) {
    const feetPosition = _PlayerHeadManager._lookAtFeetSV.feetPosition;
    const direction = _PlayerHeadManager._lookAtFeetSV.direction;
    this.getPositionFeet(feetPosition);
    position.vec3_sub(feetPosition, direction).vec3_normalize(direction);
    this.lookToFeet(direction, up, keepUpOverride);
  }
  static _lookToFeetSV = {
    feetRotation: quat_create()
  };
  lookToFeet(direction, up, keepUpOverride = null) {
    const feetRotation = _PlayerHeadManager._lookToFeetSV.feetRotation;
    this.getRotationFeetQuat(feetRotation);
    feetRotation.quat_setForward(direction, up);
    this.setRotationFeetQuat(feetRotation, keepUpOverride);
  }
  static _lookAtHeadSV = {
    direction: vec3_create(),
    headPosition: vec3_create()
  };
  lookAtHead(position, up) {
    const headPosition = _PlayerHeadManager._lookAtHeadSV.headPosition;
    const direction = _PlayerHeadManager._lookAtHeadSV.direction;
    this.getPositionHead(headPosition);
    position.vec3_sub(headPosition, direction).vec3_normalize(direction);
    this.lookToHead(direction, up);
  }
  static _lookToHeadSV = {
    headRotation: quat_create()
  };
  lookToHead(direction, up) {
    const headRotation = _PlayerHeadManager._lookToHeadSV.headRotation;
    this.getRotationHeadQuat(headRotation);
    headRotation.quat_setForward(direction, up);
    this.setRotationHeadQuat(headRotation);
  }
  resetCameraNonXR() {
    Globals.getPlayerObjects(this._myParams.myEngine).myCameraNonXR.pp_resetTransformLocal();
    this._setCameraNonXRHeight(this._myHeightNonVR);
  }
  cancelSync() {
    this._myIsSyncedDelayCounter = 0;
    this._myDelaySessionChangeResyncCounter = 0;
    this._myDelayBlurEndResyncCounter = 0;
    this._myDelayBlurEndResyncTimer.reset();
    this._mySessionChangeResyncHeadTransform = null;
    this._myBlurRecoverHeadTransform = null;
  }
  cancelNextEnterSessionSetHeight() {
    this._myDelayNextEnterSessionSetHeightVRCounter--;
    this._myNextEnterSessionSetHeightVRWithFloor = false;
    this._myNextEnterSessionSetHeightVRWithoutFloor = false;
  }
  update(dt) {
    if (!this._myActive)
      return;
    this._myViewResetThisFrame = false;
    if (this._myIsSyncedDelayCounter != 0) {
      this._myIsSyncedDelayCounter--;
      this._myIsSyncedDelayCounter = Math.max(0, this._myIsSyncedDelayCounter);
    }
    if (this._myDelaySessionChangeResyncCounter > 0) {
      this._myDelaySessionChangeResyncCounter--;
      if (this._myDelaySessionChangeResyncCounter == 0) {
        this._sessionChangeResync();
        this._myIsSyncedDelayCounter = _PlayerHeadManager._myIsSyncedDelayCounterFrames;
      }
    }
    if (this._myDelayBlurEndResyncCounter > 0 && !this._myDelayBlurEndResyncTimer.isRunning()) {
      this._myDelayBlurEndResyncCounter--;
      if (this._myDelayBlurEndResyncCounter == 0) {
        this._blurEndResync();
        this._myIsSyncedDelayCounter = _PlayerHeadManager._myIsSyncedDelayCounterFrames;
      }
    }
    if (this._myDelayBlurEndResyncTimer.isRunning()) {
      if (this._myDelayBlurEndResyncCounter > 0) {
        this._myDelayBlurEndResyncCounter--;
      } else {
        this._myDelayBlurEndResyncTimer.update(dt);
        if (this._myDelayBlurEndResyncTimer.isDone()) {
          this._blurEndResync();
          this._myIsSyncedDelayCounter = _PlayerHeadManager._myIsSyncedDelayCounterFrames;
        }
      }
    }
    if (this._myDelayNextEnterSessionSetHeightVRCounter > 0) {
      this._myDelayNextEnterSessionSetHeightVRCounter--;
      if (this._myDelayNextEnterSessionSetHeightVRCounter == 0) {
        if (this._mySessionActive) {
          const isFloor = XRUtils.isReferenceSpaceFloorBased(this._myParams.myEngine);
          if (isFloor && this._myNextEnterSessionSetHeightVRWithFloor) {
            const currentHeadPosition = this._myCurrentHead.pp_getPosition();
            const floorHeight = this._myHeightVRWithFloor - this._myParams.myForeheadExtraHeight;
            const currentEyeHeight = this._getPositionEyesHeight(currentHeadPosition);
            this._myHeightOffsetWithFloor = this._myHeightOffsetWithFloor + (floorHeight - currentEyeHeight);
            this._updateHeightOffset();
            this._myNextEnterSessionSetHeightVRWithFloor = false;
          } else if (!isFloor && this._myNextEnterSessionSetHeightVRWithoutFloor) {
            const currentHeadPosition = this._myCurrentHead.pp_getPosition();
            const floorHeight = this._myHeightVRWithoutFloor - this._myParams.myForeheadExtraHeight;
            const currentEyeHeight = this._getPositionEyesHeight(currentHeadPosition);
            this._myHeightOffsetWithoutFloor = this._myHeightOffsetWithoutFloor + (floorHeight - currentEyeHeight);
            this._updateHeightOffset();
            this._myNextEnterSessionSetHeightVRWithoutFloor = false;
          }
        }
      }
    }
    if (this.isSynced()) {
      this._myCurrentHead.pp_getTransformLocalQuat(this._myCurrentHeadTransformLocalQuat);
    }
    if (this._myParams.myDebugEnabled && Globals.isDebugEnabled(this._myParams.myEngine)) {
      this._debugUpdate(dt);
    }
  }
  _setHeightHead(heightNonVR, heightVRWithoutFloor, heightVRWithFloor, setOnlyForActiveOne = true) {
    if (!setOnlyForActiveOne || !this._mySessionActive) {
      this._setHeightHeadNonVR(heightNonVR);
    }
    if (!setOnlyForActiveOne || this._mySessionActive) {
      this._setHeightHeadVRWithoutFloor(heightVRWithoutFloor);
      this._setHeightHeadVRWithFloor(heightVRWithFloor);
    }
    this._updateHeightOffset();
    if (!this._mySessionActive) {
      this._setCameraNonXRHeight(this._myHeightNonVR);
    }
  }
  _setHeightHeadNonVR(height) {
    this._myHeightNonVR = Math.max(height, this._myParams.myForeheadExtraHeight);
    this._myHeightNonVROnEnterSession = this._myHeightNonVR;
  }
  _setHeightHeadVRWithoutFloor(heightWithoutFloor) {
    if (heightWithoutFloor != null) {
      this._myHeightVRWithoutFloor = Math.max(heightWithoutFloor, this._myParams.myForeheadExtraHeight);
      this._myNextEnterSessionSetHeightVRWithoutFloor = false;
      if (this._mySessionActive) {
        this._myHeightOffsetWithoutFloor = this._myHeightOffsetWithoutFloor + (this._myHeightVRWithoutFloor - this.getHeightHead());
      } else {
        this._myNextEnterSessionSetHeightVRWithoutFloor = true;
      }
    } else {
      this._myHeightVRWithoutFloor = null;
      this._myHeightOffsetWithoutFloor = 0;
    }
  }
  _setHeightHeadVRWithFloor(heightWithFloor) {
    if (heightWithFloor != null) {
      this._myHeightVRWithFloor = Math.max(heightWithFloor, this._myParams.myForeheadExtraHeight);
      this._myNextEnterSessionSetHeightVRWithFloor = false;
      if (this._mySessionActive) {
        this._myHeightOffsetWithFloor = this._myHeightOffsetWithFloor + (this._myHeightVRWithFloor - this.getHeightHead());
      } else {
        this._myNextEnterSessionSetHeightVRWithFloor = true;
      }
    } else {
      this._myHeightVRWithFloor = null;
      this._myHeightOffsetWithFloor = 0;
    }
  }
  _shouldNonVRUseVRWithFloor() {
    return this._myLastReferenceSpaceIsFloorBased == null && this._myParams.myNonVRFloorBasedMode == NonVRReferenceSpaceMode.FLOOR_THEN_KEEP_VR || this._myLastReferenceSpaceIsFloorBased != null && this._myLastReferenceSpaceIsFloorBased && (this._myParams.myNonVRFloorBasedMode == NonVRReferenceSpaceMode.NO_FLOOR_THEN_KEEP_VR || this._myParams.myNonVRFloorBasedMode == NonVRReferenceSpaceMode.FLOOR_THEN_KEEP_VR);
  }
  _shouldNonVRUseVRWithoutFloor() {
    return this._myLastReferenceSpaceIsFloorBased == null && this._myParams.myNonVRFloorBasedMode == NonVRReferenceSpaceMode.NO_FLOOR_THEN_KEEP_VR || this._myLastReferenceSpaceIsFloorBased != null && !this._myLastReferenceSpaceIsFloorBased && (this._myParams.myNonVRFloorBasedMode == NonVRReferenceSpaceMode.NO_FLOOR_THEN_KEEP_VR || this._myParams.myNonVRFloorBasedMode == NonVRReferenceSpaceMode.FLOOR_THEN_KEEP_VR);
  }
  static _setCameraNonXRHeightSV = {
    cameraNonVRPosition: vec3_create(),
    cameraNonVRPositionLocalToPlayer: vec3_create(),
    adjustedCameraNonVRPosition: vec3_create(),
    playerTranform: mat4_create()
  };
  _setCameraNonXRHeight(height) {
    const eyeHeight = height - this._myParams.myForeheadExtraHeight;
    const cameraNonVRPosition = _PlayerHeadManager._setCameraNonXRHeightSV.cameraNonVRPosition;
    const cameraNonVRPositionLocalToPlayer = _PlayerHeadManager._setCameraNonXRHeightSV.cameraNonVRPositionLocalToPlayer;
    const adjustedCameraNonVRPosition = _PlayerHeadManager._setCameraNonXRHeightSV.adjustedCameraNonVRPosition;
    const playerTranform = _PlayerHeadManager._setCameraNonXRHeightSV.playerTranform;
    Globals.getPlayerObjects(this._myParams.myEngine).myCameraNonXR.pp_getPosition(cameraNonVRPosition);
    cameraNonVRPosition.vec3_convertPositionToLocal(this.getPlayer().pp_getTransform(playerTranform), cameraNonVRPositionLocalToPlayer);
    cameraNonVRPositionLocalToPlayer.vec3_set(cameraNonVRPositionLocalToPlayer[0], eyeHeight, cameraNonVRPositionLocalToPlayer[2]);
    cameraNonVRPositionLocalToPlayer.vec3_convertPositionToWorld(this.getPlayer().pp_getTransform(playerTranform), adjustedCameraNonVRPosition);
    Globals.getPlayerObjects(this._myParams.myEngine).myCameraNonXR.pp_setPosition(adjustedCameraNonVRPosition);
  }
  static _getPositionEyesHeightSV = {
    playerPosition: vec3_create(),
    playerUp: vec3_create(),
    heightVector: vec3_create()
  };
  _getPositionEyesHeight(position) {
    const playerPosition = _PlayerHeadManager._getPositionEyesHeightSV.playerPosition;
    const playerUp = _PlayerHeadManager._getPositionEyesHeightSV.playerUp;
    this.getPlayer().pp_getPosition(playerPosition);
    this.getPlayer().pp_getUp(playerUp);
    const heightVector = _PlayerHeadManager._getPositionEyesHeightSV.heightVector;
    position.vec3_sub(playerPosition, heightVector).vec3_componentAlongAxis(playerUp, heightVector);
    let height = heightVector.vec3_length();
    if (!playerUp.vec3_isConcordant(heightVector)) {
      height = -height;
    }
    return height;
  }
  // #TODO What happens if the player go in the blurred state before the scene has loaded?
  _onXRSessionStart(manualCall, session) {
    const nonVRCurrentEyesHeight = this._getPositionEyesHeight(Globals.getPlayerObjects(this._myParams.myEngine).myCameraNonXR.pp_getPosition());
    this._myHeightNonVROnEnterSession = nonVRCurrentEyesHeight + this._myParams.myForeheadExtraHeight;
    this._myBlurRecoverHeadTransform = null;
    this._myVisibilityHidden = false;
    this._myDelaySessionChangeResyncCounter = 0;
    this._myDelayBlurEndResyncCounter = 0;
    this._myDelayBlurEndResyncTimer.reset();
    this._myDelayNextEnterSessionSetHeightVRCounter = 0;
    const referenceSpace = XRUtils.getReferenceSpace(this._myParams.myEngine);
    if (referenceSpace.addEventListener != null) {
      this._myViewResetEventListener = this._onViewReset.bind(this);
      referenceSpace.addEventListener("reset", this._myViewResetEventListener);
    }
    this._myLastReferenceSpaceIsFloorBased = XRUtils.isReferenceSpaceFloorBased(this._myParams.myEngine);
    this._myVisibilityChangeEventListener = function(event) {
      if (event.session.visibilityState != "visible") {
        if (!this._mySessionBlurred) {
          this._onXRSessionBlurStart(event.session);
        }
        this._myVisibilityHidden = session.visibilityState == "hidden";
      } else {
        if (this._mySessionBlurred) {
          this._onXRSessionBlurEnd(event.session);
        }
        this._myVisibilityHidden = false;
      }
    }.bind(this);
    session.addEventListener("visibilitychange", this._myVisibilityChangeEventListener);
    if (this._myParams.mySessionChangeResyncEnabled && !manualCall && this._myActive) {
      if (this._myDelaySessionChangeResyncCounter == 0) {
        this._mySessionChangeResyncHeadTransform = this._getHeadTransformFromLocal(this._myCurrentHeadTransformLocalQuat);
      }
      this._myDelaySessionChangeResyncCounter = _PlayerHeadManager._myResyncCounterFrames;
    } else {
      this._myDelaySessionChangeResyncCounter = 0;
      this._mySessionChangeResyncHeadTransform = null;
    }
    if (this._myActive) {
      if (this._myNextEnterSessionSetHeightVRWithFloor || this._myNextEnterSessionSetHeightVRWithoutFloor) {
        this._myDelayNextEnterSessionSetHeightVRCounter = _PlayerHeadManager._myResyncCounterFrames;
      }
    } else {
      this._myNextEnterSessionSetHeightVRWithFloor = false;
      this._myNextEnterSessionSetHeightVRWithoutFloor = false;
    }
    this._mySessionActive = true;
    this._mySessionBlurred = false;
    if (this._myActive) {
      this._updateHeightOffset();
    }
  }
  _onXRSessionEnd() {
    if (this._myParams.mySessionChangeResyncEnabled && this._myActive) {
      if (this._myDelaySessionChangeResyncCounter == 0) {
        let previousHeadTransform = this._getHeadTransformFromLocal(this._myCurrentHeadTransformLocalQuat);
        if (this._myBlurRecoverHeadTransform != null) {
          previousHeadTransform = this._myBlurRecoverHeadTransform;
        }
        this._mySessionChangeResyncHeadTransform = previousHeadTransform;
      }
      this._myDelaySessionChangeResyncCounter = _PlayerHeadManager._myResyncCounterFrames;
    } else {
      this._myDelaySessionChangeResyncCounter = 0;
      this._mySessionChangeResyncHeadTransform = null;
    }
    this._myDelayNextEnterSessionSetHeightVRCounter = 0;
    this._myVisibilityChangeEventListener = null;
    this._myViewResetEventListener = null;
    this._myBlurRecoverHeadTransform = null;
    this._myVisibilityHidden = false;
    this._myDelayBlurEndResyncCounter = 0;
    this._myDelayBlurEndResyncTimer.reset();
    this._mySessionActive = false;
    this._mySessionBlurred = false;
    if (this._myActive) {
      this._updateHeightOffset();
      if (this._myParams.myExitSessionResetNonVRTransformLocal) {
        this.resetCameraNonXR();
      } else {
        this._setCameraNonXRHeight(this._myHeightNonVROnEnterSession);
      }
    }
  }
  _onXRSessionBlurStart(session) {
    if (this._myActive) {
      if (this._myParams.myBlurEndResyncEnabled && this._myBlurRecoverHeadTransform == null && this._mySessionActive) {
        if (this._myDelaySessionChangeResyncCounter > 0) {
          this._myBlurRecoverHeadTransform = this._mySessionChangeResyncHeadTransform;
        } else {
          this._myBlurRecoverHeadTransform = this._getHeadTransformFromLocal(this._myCurrentHeadTransformLocalQuat);
        }
      } else if (!this._mySessionActive || !this._myParams.myBlurEndResyncEnabled) {
        this._myBlurRecoverHeadTransform = null;
      }
    }
    this._myDelayBlurEndResyncCounter = 0;
    this._mySessionBlurred = true;
  }
  _onXRSessionBlurEnd(session) {
    if (this._myActive) {
      if (this._myDelaySessionChangeResyncCounter == 0) {
        if (this._myParams.myBlurEndResyncEnabled && this._myBlurRecoverHeadTransform != null && this._mySessionActive) {
          this._myDelayBlurEndResyncCounter = _PlayerHeadManager._myResyncCounterFrames;
          if (this._myVisibilityHidden) {
          }
        } else {
          this._myBlurRecoverHeadTransform = null;
          this._myDelayBlurEndResyncCounter = 0;
        }
      } else {
        this._myDelaySessionChangeResyncCounter = _PlayerHeadManager._myResyncCounterFrames;
        this._myBlurRecoverHeadTransform = null;
      }
    }
    this._mySessionBlurred = false;
  }
  static _onViewResetSV = {
    identityTransformQuat: Quat2Utils.identity(quat2_create()),
    prevHeadPosition: vec3_create(),
    resetHeadPosition: vec3_create()
  };
  _onViewReset() {
    if (this._myActive) {
      if (!this._myViewResetThisFrame && this._myParams.myResetTransformOnViewResetEnabled && this._mySessionActive && this.isSynced()) {
        this._myViewResetThisFrame = true;
        const previousHeadTransformQuat = this._getHeadTransformFromLocal(this._myCurrentHeadTransformLocalQuat);
        this.teleportPlayerToHeadTransformQuat(previousHeadTransformQuat);
        const isFloor = XRUtils.isReferenceSpaceFloorBased(this._myParams.myEngine);
        if (!isFloor) {
          const identityTransformQuat = _PlayerHeadManager._onViewResetSV.identityTransformQuat;
          const resetHeadTransformQuat = this._getHeadTransformFromLocal(identityTransformQuat);
          const prevHeadPosition = _PlayerHeadManager._onViewResetSV.prevHeadPosition;
          const resetHeadPosition = _PlayerHeadManager._onViewResetSV.resetHeadPosition;
          const prevHeadHeight = this._getPositionEyesHeight(previousHeadTransformQuat.quat2_getPosition(prevHeadPosition));
          const currentHeadHeight = this._getPositionEyesHeight(resetHeadTransformQuat.quat2_getPosition(resetHeadPosition));
          this._myHeightOffsetWithoutFloor = this._myHeightOffsetWithoutFloor + (prevHeadHeight - currentHeadHeight);
          this._updateHeightOffset();
        }
      }
    }
  }
  static _blurEndResyncSV = {
    playerUp: vec3_create(),
    currentHeadPosition: vec3_create(),
    recoverHeadPosition: vec3_create(),
    flatCurrentHeadPosition: vec3_create(),
    flatRecoverHeadPosition: vec3_create(),
    recoverMovement: vec3_create(),
    recoverHeadForward: vec3_create(),
    currentHeadForward: vec3_create(),
    rotationToPerform: quat_create()
  };
  _blurEndResync() {
    if (this._myBlurRecoverHeadTransform != null) {
      if (this._mySessionChangeResyncHeadTransform != null) {
        this._myBlurRecoverHeadTransform = null;
        this._sessionChangeResync();
      } else {
        const playerUp = _PlayerHeadManager._blurEndResyncSV.playerUp;
        this.getPlayer().pp_getUp(playerUp);
        const currentHeadPosition = _PlayerHeadManager._blurEndResyncSV.currentHeadPosition;
        const recoverHeadPosition = _PlayerHeadManager._blurEndResyncSV.recoverHeadPosition;
        this._myCurrentHead.pp_getPosition(currentHeadPosition);
        this._myBlurRecoverHeadTransform.quat2_getPosition(recoverHeadPosition);
        const flatCurrentHeadPosition = _PlayerHeadManager._blurEndResyncSV.flatCurrentHeadPosition;
        const flatRecoverHeadPosition = _PlayerHeadManager._blurEndResyncSV.flatRecoverHeadPosition;
        currentHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatCurrentHeadPosition);
        recoverHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatRecoverHeadPosition);
        const recoverMovement = _PlayerHeadManager._blurEndResyncSV.recoverMovement;
        flatRecoverHeadPosition.vec3_sub(flatCurrentHeadPosition, recoverMovement);
        this.moveFeet(recoverMovement);
        const recoverHeadForward = _PlayerHeadManager._blurEndResyncSV.recoverHeadForward;
        const currentHeadForward = _PlayerHeadManager._blurEndResyncSV.currentHeadForward;
        const rotationToPerform = _PlayerHeadManager._blurEndResyncSV.rotationToPerform;
        this._myBlurRecoverHeadTransform.quat2_getForward(recoverHeadForward);
        this._myCurrentHead.pp_getForward(currentHeadForward);
        currentHeadForward.vec3_rotationToPivotedQuat(recoverHeadForward, playerUp, rotationToPerform);
        if (this._myParams.myBlurEndResyncRotation) {
          this.rotateFeetQuat(rotationToPerform);
        }
        this._myBlurRecoverHeadTransform = null;
      }
    }
  }
  static _sessionChangeResyncSV = {
    currentHeadPosition: vec3_create(),
    resyncHeadPosition: vec3_create(),
    resyncHeadRotation: quat_create(),
    playerUp: vec3_create(),
    flatCurrentHeadPosition: vec3_create(),
    flatResyncHeadPosition: vec3_create(),
    resyncMovement: vec3_create(),
    resyncHeadForward: vec3_create(),
    resyncHeadUp: vec3_create(),
    resyncHeadRight: vec3_create(),
    playerPosition: vec3_create(),
    newPlayerPosition: vec3_create(),
    fixedHeadRight: vec3_create(),
    fixedHeadLeft: vec3_create(),
    fixedHeadUp: vec3_create(),
    fixedHeadForward: vec3_create(),
    fixedHeadRotation: quat_create()
  };
  _sessionChangeResync() {
    if (this._myBlurRecoverHeadTransform == null && this._mySessionChangeResyncHeadTransform != null) {
      if (this._mySessionActive) {
        const currentHeadPosition = _PlayerHeadManager._sessionChangeResyncSV.currentHeadPosition;
        const resyncHeadPosition = _PlayerHeadManager._sessionChangeResyncSV.resyncHeadPosition;
        const resyncHeadRotation = _PlayerHeadManager._sessionChangeResyncSV.resyncHeadRotation;
        this._myCurrentHead.pp_getPosition(currentHeadPosition);
        this._mySessionChangeResyncHeadTransform.quat2_getPosition(resyncHeadPosition);
        this._mySessionChangeResyncHeadTransform.quat2_getRotationQuat(resyncHeadRotation);
        const playerUp = _PlayerHeadManager._sessionChangeResyncSV.playerUp;
        this.getPlayer().pp_getUp(playerUp);
        const flatCurrentHeadPosition = _PlayerHeadManager._sessionChangeResyncSV.flatCurrentHeadPosition;
        const flatResyncHeadPosition = _PlayerHeadManager._sessionChangeResyncSV.flatResyncHeadPosition;
        currentHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatCurrentHeadPosition);
        resyncHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatResyncHeadPosition);
        const resyncMovement = _PlayerHeadManager._sessionChangeResyncSV.resyncMovement;
        flatResyncHeadPosition.vec3_sub(flatCurrentHeadPosition, resyncMovement);
        this.moveFeet(resyncMovement);
        if (this._myParams.myEnterSessionResyncHeight || this._myParams.myNextEnterSessionResyncHeight) {
          this._myParams.myNextEnterSessionResyncHeight = false;
          const resyncHeadHeight = this._getPositionEyesHeight(resyncHeadPosition);
          const currentHeadHeight = this._getPositionEyesHeight(currentHeadPosition);
          this._myHeightVRWithoutFloor = resyncHeadHeight + this._myParams.myForeheadExtraHeight;
          this._myHeightVRWithFloor = resyncHeadHeight + this._myParams.myForeheadExtraHeight;
          this._myHeightOffsetWithFloor = this._myHeightOffsetWithFloor + (resyncHeadHeight - currentHeadHeight);
          this._myHeightOffsetWithoutFloor = this._myHeightOffsetWithoutFloor + (resyncHeadHeight - currentHeadHeight);
          this._updateHeightOffset();
          this._myNextEnterSessionSetHeightVRWithFloor = false;
          this._myNextEnterSessionSetHeightVRWithoutFloor = false;
        }
        this._resyncHeadRotationForward(resyncHeadRotation);
      } else {
        const playerUp = _PlayerHeadManager._sessionChangeResyncSV.playerUp;
        this.getPlayer().pp_getUp(playerUp);
        const resyncHeadPosition = _PlayerHeadManager._sessionChangeResyncSV.resyncHeadPosition;
        const flatResyncHeadPosition = _PlayerHeadManager._sessionChangeResyncSV.flatResyncHeadPosition;
        this._mySessionChangeResyncHeadTransform.quat2_getPosition(resyncHeadPosition);
        resyncHeadPosition.vec3_removeComponentAlongAxis(playerUp, flatResyncHeadPosition);
        const playerPosition = _PlayerHeadManager._sessionChangeResyncSV.playerPosition;
        const newPlayerPosition = _PlayerHeadManager._sessionChangeResyncSV.newPlayerPosition;
        this.getPlayer().pp_getPosition(playerPosition);
        flatResyncHeadPosition.vec3_add(playerPosition.vec3_componentAlongAxis(playerUp, newPlayerPosition), newPlayerPosition);
        this.getPlayer().pp_setPosition(newPlayerPosition);
        Globals.getPlayerObjects(this._myParams.myEngine).myCameraNonXR.pp_resetPositionLocal();
        if (this._myParams.myExitSessionResyncHeight) {
          const resyncHeadHeight = this._getPositionEyesHeight(resyncHeadPosition);
          this._myHeightNonVR = resyncHeadHeight + this._myParams.myForeheadExtraHeight;
        }
        this._updateHeightOffset();
        if (this._myParams.myExitSessionResyncHeight || this._myParams.myExitSessionResetNonVRTransformLocal) {
          this._setCameraNonXRHeight(this._myHeightNonVR);
        } else {
          this._setCameraNonXRHeight(this._myHeightNonVROnEnterSession);
        }
        const resyncHeadRotation = _PlayerHeadManager._sessionChangeResyncSV.resyncHeadRotation;
        this._mySessionChangeResyncHeadTransform.quat2_getRotationQuat(resyncHeadRotation);
        if (this._myParams.myExitSessionRemoveRightTilt || this._myParams.myExitSessionAdjustMaxVerticalAngle || !this._myParams.myExitSessionResyncVerticalAngle) {
          const resyncHeadForward = _PlayerHeadManager._sessionChangeResyncSV.resyncHeadForward;
          const resyncHeadUp = _PlayerHeadManager._sessionChangeResyncSV.resyncHeadUp;
          resyncHeadRotation.quat_getForward(resyncHeadForward);
          resyncHeadRotation.quat_getUp(resyncHeadUp);
          const fixedHeadRight = _PlayerHeadManager._sessionChangeResyncSV.fixedHeadRight;
          resyncHeadForward.vec3_cross(playerUp, fixedHeadRight);
          fixedHeadRight.vec3_normalize(fixedHeadRight);
          if (!resyncHeadUp.vec3_isConcordant(playerUp)) {
            const angleForwardUp = resyncHeadForward.vec3_angle(playerUp);
            const negateAngle = 45;
            if (angleForwardUp > 180 - negateAngle || angleForwardUp < negateAngle) {
              fixedHeadRight.vec3_negate(fixedHeadRight);
            }
          }
          if (fixedHeadRight.vec3_isZero(1e-6)) {
            resyncHeadRotation.quat_getRight(fixedHeadRight);
          }
          const fixedHeadUp = _PlayerHeadManager._sessionChangeResyncSV.fixedHeadUp;
          const fixedHeadForward = _PlayerHeadManager._sessionChangeResyncSV.fixedHeadForward;
          fixedHeadRight.vec3_cross(resyncHeadForward, fixedHeadUp);
          fixedHeadUp.vec3_normalize(fixedHeadUp);
          fixedHeadUp.vec3_cross(fixedHeadRight, fixedHeadForward);
          fixedHeadForward.vec3_normalize(fixedHeadForward);
          const fixedHeadRotation = _PlayerHeadManager._sessionChangeResyncSV.fixedHeadRotation;
          const fixedHeadLeft = _PlayerHeadManager._sessionChangeResyncSV.fixedHeadLeft;
          fixedHeadRotation.quat_fromAxes(fixedHeadRight.vec3_negate(fixedHeadLeft), fixedHeadUp, fixedHeadForward);
          resyncHeadRotation.quat_copy(fixedHeadRotation);
        }
        if (this._myParams.myExitSessionAdjustMaxVerticalAngle || !this._myParams.myExitSessionResyncVerticalAngle) {
          const resyncHeadUp = _PlayerHeadManager._sessionChangeResyncSV.resyncHeadUp;
          const resyncHeadRight = _PlayerHeadManager._sessionChangeResyncSV.resyncHeadRight;
          resyncHeadRotation.quat_getUp(resyncHeadUp);
          resyncHeadRotation.quat_getRight(resyncHeadRight);
          let maxVerticalAngle = Math.max(0, this._myParams.myExitSessionMaxVerticalAngle - 1e-4);
          if (!this._myParams.myExitSessionResyncVerticalAngle) {
            maxVerticalAngle = 0;
          }
          const angleWithUp = Math.pp_angleClamp(resyncHeadUp.vec3_angleSigned(playerUp, resyncHeadRight));
          if (Math.abs(angleWithUp) > maxVerticalAngle) {
            const fixAngle = (Math.abs(angleWithUp) - maxVerticalAngle) * Math.pp_sign(angleWithUp);
            resyncHeadRotation.quat_rotateAxis(fixAngle, resyncHeadRight, resyncHeadRotation);
          }
        }
        this.setRotationHeadQuat(resyncHeadRotation);
      }
      this._mySessionChangeResyncHeadTransform = null;
    }
  }
  static _setReferenceSpaceHeightOffsetSV = {
    referenceSpacePosition: vec3_create(),
    referenceSpacePositionLocalToPlayer: vec3_create(),
    adjustedReferenceSpacePosition: vec3_create(),
    playerTransform: mat4_create()
  };
  _setReferenceSpaceHeightOffset(offset, amountToRemove) {
    if (offset != null) {
      const referenceSpacePosition = _PlayerHeadManager._setReferenceSpaceHeightOffsetSV.referenceSpacePosition;
      const referenceSpacePositionLocalToPlayer = _PlayerHeadManager._setReferenceSpaceHeightOffsetSV.referenceSpacePositionLocalToPlayer;
      const playerTransform = _PlayerHeadManager._setReferenceSpaceHeightOffsetSV.playerTransform;
      Globals.getPlayerObjects(this._myParams.myEngine).myReferenceSpace.pp_getPosition(referenceSpacePosition);
      referenceSpacePosition.vec3_convertPositionToLocal(this.getPlayer().pp_getTransform(playerTransform), referenceSpacePositionLocalToPlayer);
      referenceSpacePositionLocalToPlayer.vec3_set(referenceSpacePositionLocalToPlayer[0], offset - amountToRemove, referenceSpacePositionLocalToPlayer[2]);
      const adjustedReferenceSpacePosition = _PlayerHeadManager._setReferenceSpaceHeightOffsetSV.adjustedReferenceSpacePosition;
      referenceSpacePositionLocalToPlayer.vec3_convertPositionToWorld(this.getPlayer().pp_getTransform(playerTransform), adjustedReferenceSpacePosition);
      Globals.getPlayerObjects(this._myParams.myEngine).myReferenceSpace.pp_setPosition(adjustedReferenceSpacePosition);
    }
  }
  _updateHeightOffset() {
    if (this._mySessionActive) {
      if (XRUtils.isReferenceSpaceFloorBased(this._myParams.myEngine)) {
        this._setReferenceSpaceHeightOffset(this._myHeightOffsetWithFloor, 0);
      } else {
        this._setReferenceSpaceHeightOffset(this._myHeightOffsetWithoutFloor, 0);
      }
    } else {
      if (this._shouldNonVRUseVRWithFloor()) {
        this._setReferenceSpaceHeightOffset(this._myHeightOffsetWithFloor, 0);
      } else if (this._shouldNonVRUseVRWithoutFloor()) {
        this._setReferenceSpaceHeightOffset(this._myHeightOffsetWithoutFloor, 0);
      } else if (this._myParams.myNonVRFloorBasedMode == NonVRReferenceSpaceMode.FLOOR) {
        this._setReferenceSpaceHeightOffset(0, 0);
      } else {
        this._setReferenceSpaceHeightOffset(this._myHeightNonVR, this._myParams.myForeheadExtraHeight);
      }
    }
  }
  _getHeadTransformFromLocal(transformLocal) {
    return this._myCurrentHead.pp_convertTransformLocalToWorldQuat(transformLocal);
  }
  static _resyncHeadRotationForwardSV = {
    playerUp: vec3_create(),
    resyncHeadForward: vec3_create(),
    resyncHeadUp: vec3_create(),
    fixedResyncHeadRotation: quat_create()
  };
  _resyncHeadRotationForward(resyncHeadRotation) {
    const playerUp = _PlayerHeadManager._resyncHeadRotationForwardSV.playerUp;
    const resyncHeadForward = _PlayerHeadManager._resyncHeadRotationForwardSV.resyncHeadForward;
    const resyncHeadUp = _PlayerHeadManager._resyncHeadRotationForwardSV.resyncHeadUp;
    this.getPlayer().pp_getUp(playerUp);
    resyncHeadRotation.quat_getForward(resyncHeadForward);
    resyncHeadRotation.quat_getUp(resyncHeadUp);
    const fixedResyncHeadRotation = _PlayerHeadManager._resyncHeadRotationForwardSV.fixedResyncHeadRotation;
    fixedResyncHeadRotation.quat_copy(resyncHeadRotation);
    fixedResyncHeadRotation.quat_setUp(playerUp, resyncHeadForward);
    if (!resyncHeadUp.vec3_isConcordant(playerUp)) {
      fixedResyncHeadRotation.quat_rotateAxis(180, playerUp, fixedResyncHeadRotation);
    }
    this.setRotationFeetQuat(fixedResyncHeadRotation);
  }
  _debugUpdate(dt) {
    Globals.getDebugVisualManager(this._myParams.myEngine).drawLineEnd(0, this.getPositionFeet(), this.getPositionHead(), vec4_create(1, 0, 0, 1), 0.01);
    console.error(this.getHeightEyes());
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/gameplay/experimental/locomotion/legacy/locomotion/player_transform_manager.js
var PlayerTransformManagerSyncFlag;
(function(PlayerTransformManagerSyncFlag2) {
  PlayerTransformManagerSyncFlag2[PlayerTransformManagerSyncFlag2["BODY_COLLIDING"] = 0] = "BODY_COLLIDING";
  PlayerTransformManagerSyncFlag2[PlayerTransformManagerSyncFlag2["HEAD_COLLIDING"] = 1] = "HEAD_COLLIDING";
  PlayerTransformManagerSyncFlag2[PlayerTransformManagerSyncFlag2["FAR"] = 2] = "FAR";
  PlayerTransformManagerSyncFlag2[PlayerTransformManagerSyncFlag2["FLOATING"] = 3] = "FLOATING";
  PlayerTransformManagerSyncFlag2[PlayerTransformManagerSyncFlag2["HEIGHT_COLLIDING"] = 4] = "HEIGHT_COLLIDING";
})(PlayerTransformManagerSyncFlag || (PlayerTransformManagerSyncFlag = {}));
var PlayerTransformManagerParams = class {
  myPlayerHeadManager;
  myMovementCollisionCheckParams;
  /** Can be left `null` and will be generated from the `myMovementCollisionCheckParams` */
  myTeleportCollisionCheckParams = null;
  myTeleportCollisionCheckParamsCopyFromMovement = false;
  myTeleportCollisionCheckParamsCheck360 = false;
  myTeleportCollisionCheckParamsGroundAngleToIgnore = null;
  /**
   * This make it so if the valid position after syncing with real has some snapping, the real position too will also adjust to it
   * For example, with this off, if you move in real life over ramps the real life height will not change to avoid motion sickness,
   * but if you prefer to also go up and down, you need to enable this
   */
  myApplyRealToValidAdjustmentsToRealPositionToo = false;
  /**
   * Does not prevent (for now at least) from colliding if you stand up and your head goes inside the ceiling, in that case the height
   * is not adjusted to prevent that and the view will be occluded
   */
  myPreventRealFromColliding = false;
  myAlwaysSyncPositionWithReal = false;
  myAlwaysSyncHeadPositionWithReal = false;
  myIgnoreUpwardMovementToRealIfValidOnGround = false;
  /**
   * If the real position is far, body will be considered colliding
   * If the body is colliding, the floating check is skipped
   */
  mySyncEnabledFlagMap = /* @__PURE__ */ new Map();
  mySyncPositionFlagMap = /* @__PURE__ */ new Map();
  mySyncPositionHeadFlagMap = /* @__PURE__ */ new Map();
  mySyncRotationFlagMap = /* @__PURE__ */ new Map();
  mySyncHeightFlagMap = /* @__PURE__ */ new Map();
  /** Used to make the character fall if it's leaning too much */
  myIsLeaningValidAboveDistance = false;
  myLeaningValidDistance = 0;
  /** Settings for both hop and lean */
  /**
   * With {@link myRealMovementAllowVerticalAdjustments} enabled these "ValidIfVerticalMovement" flags does not work properly,
   * since the adjustments can add vertical movement just due to snaps
   */
  myIsFloatingValidIfVerticalMovement = false;
  myIsFloatingValidIfVerticalMovementAndRealOnGround = false;
  // #TODO This is more an override
  myIsFloatingValidIfRealOnGround = false;
  myIsFloatingValidIfSteepGround = false;
  myIsFloatingValidIfVerticalMovementAndSteepGround = false;
  myFloatingSplitCheckEnabled = false;
  myFloatingSplitCheckMinLength = null;
  myFloatingSplitCheckMaxLength = null;
  myFloatingSplitCheckStepEqualLength = false;
  myFloatingSplitCheckStepEqualLengthMinLength = 0;
  /**
   * Can be useful if using the exact height is giving you issues like too close too ceilings, or view occluded too easily
   */
  myExtraHeight = 0;
  myMaxDistanceFromRealToSyncEnabled = false;
  /**
   * Max distance to resync valid with real
   * If your real position is farther the body will be considered as colliding
   */
  myMaxDistanceFromRealToSync = 0;
  myMaxDistanceFromHeadRealToSyncEnabled = false;
  /**
   * Max distance to resync valid head with real head
   * If you real head is farther the head will be considered as colliding
   * Vertically, the max distance can be higher if the current height is higher
   * Since the head might have been reset to feet
   */
  myMaxDistanceFromHeadRealToSync = 0;
  /**
   * If this is enabled, the head will do this max amount of steps to reach the real head, but every step might be longer
   * than the safe max step
   * This means that the movement to reach the real head might not be as precise and can allow clipping through objects,
   * but it will be more performant
   *
   * Even though the max distance from the head can be already used to limit the amount of steps, when the head is reset
   * to feet, it's allowed to perform the whole height movement, even if above the max distance
   * If this adjustment movement is too heavy, this can limit it, even though might cause the valid head to move to invalid places
   */
  myMaxHeadToRealHeadSteps = null;
  myHeadRadius = 0;
  myHeadHeight = 0;
  myHeadCollisionBlockLayerFlags = new PhysicsLayerFlags();
  myHeadCollisionObjectsToIgnore = [];
  myHeadCollisionBlockColliderType = RaycastBlockColliderType.BOTH;
  /**
   * Can be used if when resetting to feet there might be dynamic objects which you would like to exclude for this reset check,
   * but you might still to normally avoid, for example for object you can grab and therefore put close to the head, which are not a big deal
   * and you can accept being able to see inside them when resetting the head, but not for normal movements
   */
  myHeadCollisionBlockLayerFlagsForResetToFeet = null;
  myRotateOnlyIfSynced = false;
  myResetRealResetRotationIfUpChanged = false;
  /**
   * This make it so the head must be able to reach from the feet to the real head, sort of
   * like you were teleported in a space squashed to your feet and then have to get up
   * It can be used to prevent being able to see through the floor, since when the head is reset to the real one
   * if the real one is on the other side of the above floor there would be no collision
   * The risk is that, if you have objects close to your feet, your head could get stuck on them while trying to "get up"
   * and the view could be obscured thinking you have those objects in your view
   */
  myResetHeadToFeetInsteadOfReal = false;
  /** This other flag is to fix the above issue, doing the "squash and get up" only if the head is not reachable normally
      The above issue can still happen but should be more rare, only if you teleport to a place where there could be garbage stuff */
  myResetHeadToFeetInsteadOfRealOnlyIfRealNotReachable = false;
  myResetHeadToFeetMoveTowardReal = false;
  /* Can be used to specify that the head should reset a bit above the actual feet level, so to avoid small objects that could very frequently
     happen to be close to the floor */
  myResetHeadToFeetUpOffset = 0;
  myResetHeadToFeetGroudnAngleIgnoreEnabled = false;
  myResetHeadToRealMinDistance = 0;
  // #TODO Set valid if head synced (head manager) (not sure what I meant with this?)
  /** This true means that the real movement should also snap on ground or fix the vertical to pop from it
      You may want this if u want that while real moving u can also climb stairs */
  myRealMovementAllowVerticalAdjustments = false;
  // #TODO Real movement apply vertical snap or not (other option to apply gravity) 
  // (gravity inside this class?) only when movement is applied not for head only)
  myUpdatePositionValid = false;
  myUpdatePositionHeadValid = false;
  myUpdateRealPositionValid = false;
  myUpdateRealPositionHeadValid = false;
  myMinHeight = null;
  myMaxHeight = null;
  /**
   * These and the callbacks does not makes much sense
   * The colliding things are made to not sync the real position, but if the height is below and the body is not colliding
   * There is not reason not to resync, even if u put the real back on the valid the height will stay the same
   * If someone puts the head in the ground, there is no way for me to resync and make the head pop out sadly
   * In this case u either accept that u can move without seeing, or stop moving until the obscure is on
   */
  /** Could be ignored and added with the custom check callback if u want it */
  myIsBodyCollidingWhenHeightBelowValue = null;
  /** Could be ignored and added with the custom check callback if u want it */
  myIsBodyCollidingWhenHeightAboveValue = null;
  myIsBodyCollidingExtraCheckCallback = null;
  myIsLeaningExtraCheckCallback = null;
  myIsHoppingExtraCheckCallback = null;
  myIsFarExtraCheckCallback = null;
  myAllowUpdateValidToRealWhenBlurred = false;
  myResetToValidOnEnterSession = false;
  myResetToValidOnExitSession = false;
  myResetToValidOnSessionHiddenEnd = false;
  myAlwaysResetRealPositionNonVR = false;
  myAlwaysResetRealRotationNonVR = false;
  myAlwaysResetRealHeightNonVR = false;
  myAlwaysResetRealPositionVR = false;
  myAlwaysResetRealRotationVR = false;
  myAlwaysResetRealHeightVR = false;
  myNeverResetRealPositionNonVR = false;
  myNeverResetRealRotationNonVR = false;
  myNeverResetRealHeightNonVR = false;
  myResetRealHeightNonVROnExitSession = false;
  myNeverResetRealPositionVR = false;
  myNeverResetRealRotationVR = false;
  myNeverResetRealHeightVR = false;
  myResetRealOnMove = false;
  myResetRealOnTeleport = false;
  mySyncPositionDisabled = false;
  myDebugEnabled = false;
  myEngine;
  constructor(engine = Globals.getMainEngine()) {
    this.myEngine = engine;
  }
};
var PlayerTransformManager = class _PlayerTransformManager {
  _myParams;
  _myRealMovementCollisionCheckParams;
  _myHeadCollisionCheckParams;
  _myCollisionRuntimeParams = new CollisionRuntimeParams();
  _myPlayerLocomotionTeleport = null;
  _myValidPosition = vec3_create();
  _myValidRotationQuat = quat_create();
  _myValidHeight = 0;
  _myValidPositionHead = vec3_create();
  _myValidPositionHeadBackupForResetToFeet = vec3_create();
  _myIsBodyColliding = false;
  _myIsHeadColliding = false;
  _myIsLeaning = false;
  _myIsHopping = false;
  _myIsFar = false;
  _myIsHeightColliding = false;
  _myLastValidMovementDirection = vec3_create();
  _myIsPositionValid = false;
  _myIsPositionHeadValid = false;
  _myIsRealPositionValid = false;
  _myIsRealPositionHeadValid = false;
  _myResetRealOnHeadSynced = false;
  _myResetHeadToFeetDirty = false;
  _myResetHeadToFeetOnNextUpdateValidToReal = false;
  _myVisibilityChangeEventListener = null;
  _mySessionHasBeenHidden = false;
  _myActive = true;
  _myDestroyed = false;
  constructor(params) {
    this._myParams = params;
    this._generateRealMovementParamsFromMovementParams();
    if (this._myParams.myTeleportCollisionCheckParamsCopyFromMovement) {
      this._generateTeleportParamsFromMovementParams();
    }
    this._setupHeadCollisionCheckParams();
  }
  start() {
    this.resetToReal(true, true, true, true, false, true);
    this._myActive = false;
    this.setActive(true);
  }
  getParams() {
    return this._myParams;
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      if (this._myActive) {
        XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, true, this._myParams.myEngine);
      } else {
        if (this._myVisibilityChangeEventListener != null) {
          XRUtils.getSession(this._myParams.myEngine)?.removeEventListener("visibilitychange", this._myVisibilityChangeEventListener);
        }
        XRUtils.unregisterSessionStartEndEventListeners(this, this._myParams.myEngine);
      }
    }
  }
  // #TODO update should be before to check the new valid transform and if the head new transform is fine
  // then update movements, so that they will use the proper transform
  // pre/post update?
  // For sliding if previous frame no horizontal movement then reset sliding on pre update
  // In generale capire come fare per risolvere i problemi quando c'è un move solo verticale che sputtana i dati dello sliding precedente
  // che servono per far slidare bene anche dopo, magari un flag per dire non aggiornare le cose relative al movimento orizzontale
  // o un move check solo verticale
  update(dt) {
    if (!this._myActive)
      return;
    if (this._myResetRealOnHeadSynced) {
      if (this.getPlayerHeadManager().isSynced()) {
        this._myResetRealOnHeadSynced = false;
        if (XRUtils.isSessionActive(this._myParams.myEngine)) {
          this.resetReal(!this._myParams.myNeverResetRealPositionVR, !this._myParams.myNeverResetRealRotationVR, !this._myParams.myNeverResetRealHeightVR, true, true);
        } else {
          this.resetReal(!this._myParams.myNeverResetRealPositionNonVR, !this._myParams.myNeverResetRealRotationNonVR, !this._myParams.myNeverResetRealHeightNonVR && this._myParams.myResetRealHeightNonVROnExitSession, true, true);
        }
      }
    }
    this._updateValidToReal(dt);
    this._updatePositionsValid(dt);
    this._updateCollisionHeight();
    if (this._myParams.myDebugEnabled && Globals.isDebugEnabled(this._myParams.myEngine)) {
      this._debugUpdate(dt);
    }
  }
  // #TODO Collision runtime will copy the result, so that u can use that for later reference like if it was sliding
  // Maybe there should be a way to sum all the things happened for proper movement in a summary runtime
  // or maybe the move should be done once per frame, or at least in theory
  // Move should move the valid transform, but also move the player object so that they head, even is colliding is dragged with it
  // Also teleport, should get the difference from previous and move the player object, this will keep the relative position head-to-valid
  static _moveSV = {
    fixedMovement: vec3_create(),
    transformQuat: quat2_create(),
    transformUp: vec3_create(),
    fixedVerticalMovement: vec3_create()
  };
  move(movement, forceMove = false, useHighestHeight = false, collisionCheckParams, outCollisionRuntimeParams = null) {
    if (this._myPlayerLocomotionTeleport != null) {
      this._myPlayerLocomotionTeleport.cancelTeleport();
    }
    this.checkMovement(movement, void 0, useHighestHeight, collisionCheckParams, this._myCollisionRuntimeParams);
    if (outCollisionRuntimeParams != null) {
      outCollisionRuntimeParams.copy(this._myCollisionRuntimeParams);
    }
    const fixedMovement = _PlayerTransformManager._moveSV.fixedMovement;
    if (!forceMove) {
      fixedMovement.vec3_copy(this._myCollisionRuntimeParams.myFixedMovement);
    } else {
      fixedMovement.vec3_copy(movement);
    }
    if (!fixedMovement.vec3_isZero(1e-5)) {
      this._myValidPosition.vec3_add(fixedMovement, this._myValidPosition);
      this.getPlayerHeadManager().moveFeet(fixedMovement);
      const fixedVerticalMovement = _PlayerTransformManager._moveSV.fixedVerticalMovement;
      const transformQuat2 = _PlayerTransformManager._moveSV.transformQuat;
      const transformUp = _PlayerTransformManager._moveSV.transformUp;
      this.getTransformQuat(transformQuat2);
      transformQuat2.quat2_getUp(transformUp);
      if (fixedMovement.vec3_removeComponentAlongAxis(transformUp, fixedVerticalMovement).vec3_length() > 1e-4) {
        fixedMovement.vec3_normalize(this._myLastValidMovementDirection);
      }
    }
    if (this._myParams.myResetRealOnMove) {
      if (!this.isSynced()) {
        if (XRUtils.isSessionActive(this._myParams.myEngine)) {
          this.resetReal(!this._myParams.myNeverResetRealPositionVR, !this._myParams.myNeverResetRealRotationVR, !this._myParams.myNeverResetRealHeightVR, true);
        } else {
          this.resetReal(!this._myParams.myNeverResetRealPositionNonVR, !this._myParams.myNeverResetRealRotationNonVR, !this._myParams.myNeverResetRealHeightNonVR, true);
        }
      }
    }
  }
  static _checkMovementSV = {
    currentTransformQuat: quat2_create()
  };
  checkMovement(movement, currentTransformQuat, useHighestHeight = false, collisionCheckParams, outCollisionRuntimeParams) {
    if (currentTransformQuat == null) {
      currentTransformQuat = _PlayerTransformManager._checkMovementSV.currentTransformQuat;
      this.getTransformQuat(currentTransformQuat);
    }
    let adjustedCollisionCheckParams = collisionCheckParams;
    if (collisionCheckParams == null) {
      adjustedCollisionCheckParams = this._myParams.myMovementCollisionCheckParams;
      this._updateCollisionHeight(useHighestHeight);
    } else if (useHighestHeight) {
      adjustedCollisionCheckParams = collisionCheckParams;
      this._updateCollisionHeight(useHighestHeight, adjustedCollisionCheckParams);
    }
    if (outCollisionRuntimeParams == null) {
      outCollisionRuntimeParams = new CollisionRuntimeParams();
      outCollisionRuntimeParams.copy(this._myCollisionRuntimeParams);
    }
    CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).move(movement, currentTransformQuat, adjustedCollisionCheckParams, outCollisionRuntimeParams);
    if (collisionCheckParams == null) {
      this._updateCollisionHeight();
    }
    return outCollisionRuntimeParams;
  }
  static _teleportPositionSV = {
    teleportTransformQuat: quat2_create()
  };
  teleportPosition(teleportPosition, forceTeleport = false, forceTeleportSkipCollisionCheck = false, useHighestHeight = false, collisionCheckParams, outCollisionRuntimeParams = null) {
    const teleportTransformQuat = _PlayerTransformManager._teleportPositionSV.teleportTransformQuat;
    this.getTransformQuat(teleportTransformQuat);
    teleportTransformQuat.quat2_setPosition(teleportPosition);
    this.teleportTransformQuat(teleportTransformQuat, forceTeleport, forceTeleportSkipCollisionCheck, useHighestHeight, collisionCheckParams, outCollisionRuntimeParams);
  }
  static _teleportPositionRotationQuatSV = {
    teleportTransformQuat: quat2_create()
  };
  teleportPositionRotationQuat(teleportPosition, rotationQuat, forceTeleport = false, forceTeleportSkipCollisionCheck = false, useHighestHeight = false, collisionCheckParams, outCollisionRuntimeParams = null) {
    const teleportTransformQuat = _PlayerTransformManager._teleportPositionRotationQuatSV.teleportTransformQuat;
    this.getTransformQuat(teleportTransformQuat);
    teleportTransformQuat.quat2_setPositionRotationQuat(teleportPosition, rotationQuat);
    this.teleportTransformQuat(teleportTransformQuat, forceTeleport, forceTeleportSkipCollisionCheck, useHighestHeight, collisionCheckParams, outCollisionRuntimeParams);
  }
  static _teleportTransformQuatSV = {
    currentPosition: vec3_create(),
    teleportPosition: vec3_create(),
    teleportRotation: quat_create(),
    fixedMovement: vec3_create(),
    transformQuat: quat2_create(),
    transformUp: vec3_create(),
    flatTeleportForward: vec3_create()
  };
  teleportTransformQuat(teleportTransformQuat, forceTeleport = false, forceTeleportSkipCollisionCheck = false, useHighestHeight = false, collisionCheckParams, outCollisionRuntimeParams = null) {
    if (this._myPlayerLocomotionTeleport != null) {
      this._myPlayerLocomotionTeleport.cancelTeleport();
    }
    if (!forceTeleport || !forceTeleportSkipCollisionCheck) {
      this.checkTeleportToTransformQuat(teleportTransformQuat, void 0, useHighestHeight, collisionCheckParams, this._myCollisionRuntimeParams);
    }
    if (outCollisionRuntimeParams != null) {
      outCollisionRuntimeParams.copy(this._myCollisionRuntimeParams);
    }
    const currentPosition = _PlayerTransformManager._teleportTransformQuatSV.currentPosition;
    const teleportPosition = _PlayerTransformManager._teleportTransformQuatSV.teleportPosition;
    const teleportRotation = _PlayerTransformManager._teleportTransformQuatSV.teleportRotation;
    this.getPosition(currentPosition);
    teleportTransformQuat.quat2_getPosition(teleportPosition);
    teleportTransformQuat.quat2_getRotationQuat(teleportRotation);
    const fixedMovement = _PlayerTransformManager._teleportTransformQuatSV.fixedMovement;
    fixedMovement.vec3_zero();
    if (!forceTeleport) {
      if (!this._myCollisionRuntimeParams.myTeleportCanceled) {
        this._myCollisionRuntimeParams.myFixedTeleportPosition.vec3_sub(currentPosition, fixedMovement);
      }
    } else {
      teleportPosition.vec3_sub(currentPosition, fixedMovement);
    }
    if (!this._myCollisionRuntimeParams.myTeleportCanceled || forceTeleport) {
      this._myValidRotationQuat.quat_copy(teleportRotation);
      this.getPlayerHeadManager().setRotationFeetQuat(teleportRotation);
    }
    if (!fixedMovement.vec3_isZero(1e-5)) {
      this._myValidPosition.vec3_add(fixedMovement, this._myValidPosition);
      this.getPlayerHeadManager().moveFeet(fixedMovement);
      const transformQuat2 = _PlayerTransformManager._teleportTransformQuatSV.transformQuat;
      const transformUp = _PlayerTransformManager._teleportTransformQuatSV.transformUp;
      const flatTeleportForward = _PlayerTransformManager._teleportTransformQuatSV.flatTeleportForward;
      this.getTransformQuat(transformQuat2);
      transformQuat2.quat2_getUp(transformUp);
      if (this._myCollisionRuntimeParams.myTeleportForward.vec3_removeComponentAlongAxis(transformUp, flatTeleportForward).vec3_length() > 1e-4) {
        flatTeleportForward.vec3_normalize(this._myLastValidMovementDirection);
      }
    }
    if (this._myParams.myResetRealOnTeleport) {
      if (!this.isSynced()) {
        if (XRUtils.isSessionActive(this._myParams.myEngine)) {
          this.resetReal(!this._myParams.myNeverResetRealPositionVR, !this._myParams.myNeverResetRealRotationVR, !this._myParams.myNeverResetRealHeightVR, true);
        } else {
          this.resetReal(!this._myParams.myNeverResetRealPositionNonVR, !this._myParams.myNeverResetRealRotationNonVR, !this._myParams.myNeverResetRealHeightNonVR, true);
        }
      }
    }
  }
  static _checkTeleportToTransformQuatSV = {
    currentTransformQuat: quat2_create(),
    currentPosition: vec3_create(),
    teleportPosition: vec3_create(),
    teleportRotation: quat_create(),
    rotatedTransformQuat: quat2_create()
  };
  checkTeleportToTransformQuat(teleportTransformQuat, currentTransformQuat, useHighestHeight = false, collisionCheckParams, outCollisionRuntimeParams) {
    if (currentTransformQuat == null) {
      currentTransformQuat = _PlayerTransformManager._checkTeleportToTransformQuatSV.currentTransformQuat;
      this.getTransformQuat(currentTransformQuat);
    }
    const currentPosition = _PlayerTransformManager._checkTeleportToTransformQuatSV.currentPosition;
    const teleportPosition = _PlayerTransformManager._checkTeleportToTransformQuatSV.teleportPosition;
    const teleportRotation = _PlayerTransformManager._checkTeleportToTransformQuatSV.teleportRotation;
    const rotatedTransformQuat = _PlayerTransformManager._checkTeleportToTransformQuatSV.rotatedTransformQuat;
    currentTransformQuat.quat2_getPosition(currentPosition);
    teleportTransformQuat.quat2_getPosition(teleportPosition);
    teleportTransformQuat.quat2_getRotationQuat(teleportRotation);
    rotatedTransformQuat.quat2_setPositionRotationQuat(currentPosition, teleportRotation);
    let adjustedCollisionCheckParams = collisionCheckParams;
    if (collisionCheckParams == null) {
      adjustedCollisionCheckParams = this._myParams.myTeleportCollisionCheckParams;
      this._updateCollisionHeight(useHighestHeight);
    } else if (useHighestHeight) {
      adjustedCollisionCheckParams = collisionCheckParams;
      this._updateCollisionHeight(useHighestHeight, adjustedCollisionCheckParams);
    }
    if (outCollisionRuntimeParams == null) {
      outCollisionRuntimeParams = new CollisionRuntimeParams();
      outCollisionRuntimeParams.copy(this._myCollisionRuntimeParams);
    }
    CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).teleport(teleportPosition, rotatedTransformQuat, adjustedCollisionCheckParams, outCollisionRuntimeParams);
    if (collisionCheckParams == null) {
      this._updateCollisionHeight();
    }
    return outCollisionRuntimeParams;
  }
  checkTransformQuat(transformQuat2, collisionCheckParams, outCollisionRuntimeParams) {
    if (collisionCheckParams == null) {
      collisionCheckParams = this._myParams.myMovementCollisionCheckParams;
    }
    if (outCollisionRuntimeParams == null) {
      outCollisionRuntimeParams = new CollisionRuntimeParams();
      outCollisionRuntimeParams.copy(this._myCollisionRuntimeParams);
    }
    CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).positionCheck(true, transformQuat2, collisionCheckParams, outCollisionRuntimeParams);
    return outCollisionRuntimeParams;
  }
  /** Quick way to force teleport to a position and reset the real to this */
  forceTeleportAndReset(teleportPosition, teleportRotationQuat, forceTeleportSkipCollisionCheck = false, useHighestHeight = false, collisionCheckParams, outCollisionRuntimeParams = null) {
    this.teleportPositionRotationQuat(teleportPosition, teleportRotationQuat, true, forceTeleportSkipCollisionCheck, useHighestHeight, collisionCheckParams, outCollisionRuntimeParams);
    this.resetReal(true, true, void 0, true, void 0, true);
  }
  rotateQuat(rotationQuat) {
    this._myValidRotationQuat.quat_rotateQuat(rotationQuat, this._myValidRotationQuat);
    this.getPlayerHeadManager().rotateFeetQuat(rotationQuat);
  }
  static _setRotationQuatSV = {
    rotationToPerform: quat_create()
  };
  setRotationQuat(rotationQuat) {
    const rotationToPerform = _PlayerTransformManager._setRotationQuatSV.rotationToPerform;
    this._myValidRotationQuat.quat_rotationToQuat(rotationQuat, rotationToPerform);
    this.rotateQuat(rotationToPerform);
  }
  static _setHeightSV = {
    transformQuat: quat_create(),
    transformUp: vec3_create(),
    rotationQuat: quat_create(),
    horizontalDirection: vec3_create(),
    collisionRuntimeParams: new CollisionRuntimeParams()
  };
  setHeight(height, forceSet = false) {
    const fixedHeight = Math.pp_clamp(height, this._myParams.myMinHeight ?? void 0, this._myParams.myMaxHeight ?? void 0);
    const previousHeight = this.getHeight();
    this._myValidHeight = fixedHeight;
    this._updateCollisionHeight();
    const transformQuat2 = _PlayerTransformManager._setHeightSV.transformQuat;
    const transformUp = _PlayerTransformManager._setHeightSV.transformUp;
    const rotationQuat = _PlayerTransformManager._setHeightSV.rotationQuat;
    const horizontalDirection = _PlayerTransformManager._setHeightSV.horizontalDirection;
    this.getTransformQuat(transformQuat2);
    transformQuat2.quat2_getUp(transformUp);
    transformQuat2.quat2_getRotationQuat(rotationQuat);
    this._myLastValidMovementDirection.vec3_removeComponentAlongAxis(transformUp, horizontalDirection);
    if (!horizontalDirection.vec3_isZero(1e-5)) {
      horizontalDirection.vec3_normalize(horizontalDirection);
      rotationQuat.quat_setUp(transformUp, horizontalDirection);
      transformQuat2.quat2_setRotationQuat(rotationQuat);
    }
    const collisionRuntimeParams = _PlayerTransformManager._setHeightSV.collisionRuntimeParams;
    collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
    const debugBackup = this._myParams.myMovementCollisionCheckParams.myDebugEnabled;
    this._myParams.myMovementCollisionCheckParams.myDebugEnabled = false;
    CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).positionCheck(true, transformQuat2, this._myParams.myMovementCollisionCheckParams, collisionRuntimeParams);
    this._myParams.myMovementCollisionCheckParams.myDebugEnabled = debugBackup;
    if (collisionRuntimeParams.myIsPositionOk || forceSet) {
      this.getPlayerHeadManager().setHeightHead(this.getHeight(), true);
    } else {
      this._myValidHeight = previousHeight;
    }
    this._updateCollisionHeight();
  }
  getPlayer() {
    return this._myParams.myPlayerHeadManager.getPlayer();
  }
  getHead() {
    return this._myParams.myPlayerHeadManager.getHead();
  }
  getTransformQuat(outTransformQuat = quat2_create()) {
    return outTransformQuat.quat2_setPositionRotationQuat(this.getPosition(this._myValidPosition), this.getRotationQuat(this._myValidRotationQuat));
  }
  getPosition(outPosition = vec3_create()) {
    return outPosition.vec3_copy(this._myValidPosition);
  }
  getRotationQuat(outRotationQuat = quat_create()) {
    return outRotationQuat.quat_copy(this._myValidRotationQuat);
  }
  getPositionHead(outPosition = vec3_create()) {
    return outPosition.vec3_copy(this._myValidPositionHead);
  }
  getTransformHeadQuat(outTransformQuat = quat2_create()) {
    return outTransformQuat.quat2_setPositionRotationQuat(this.getPositionHead(this._myValidPositionHead), this.getRotationQuat(this._myValidRotationQuat));
  }
  getHeight() {
    return this._myValidHeight;
  }
  getTransformRealQuat(outTransformQuat = quat2_create()) {
    return this.getPlayerHeadManager().getTransformFeetQuat(outTransformQuat);
  }
  getPositionReal(outPosition = vec3_create()) {
    return this.getPlayerHeadManager().getPositionFeet(outPosition);
  }
  getRotationRealQuat(outRotationQuat = quat_create()) {
    return this.getPlayerHeadManager().getRotationFeetQuat(outRotationQuat);
  }
  getPositionHeadReal(outPosition = vec3_create()) {
    return this.getPlayerHeadManager().getPositionHead(outPosition);
  }
  getTransformHeadRealQuat(outTransformQuat = quat2_create()) {
    return this.getPlayerHeadManager().getTransformHeadQuat(outTransformQuat);
  }
  getHeightReal() {
    return this._myParams.myPlayerHeadManager.getHeightHead();
  }
  isSynced(syncFlagMap = null) {
    const isBodyColliding = this.isBodyColliding() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.BODY_COLLIDING));
    const isHeadColliding = this.isHeadColliding() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.HEAD_COLLIDING));
    const isFar = this.isFar() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.FAR));
    const isFloating = this.isFloating() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.FLOATING));
    const isHeightColliding = this.isHeightColliding() && (syncFlagMap == null || syncFlagMap.get(PlayerTransformManagerSyncFlag.HEIGHT_COLLIDING));
    return !isBodyColliding && !isHeadColliding && !isFar && !isFloating && !isHeightColliding;
  }
  static _resetRealSV = {
    realUp: vec3_create(),
    validUp: vec3_create(),
    position: vec3_create(),
    rotationQuat: quat_create(),
    positionHeadReal: vec3_create(),
    validPositionHeadBackupForResetToFeet: vec3_create()
  };
  resetReal(resetPosition2 = true, resetRotation2 = false, resetHeight = false, resetHeadToReal = true, updateValidToReal = false, ignoreResetHeadMinDistance = false) {
    const playerHeadManager = this.getPlayerHeadManager();
    const position = _PlayerTransformManager._resetRealSV.position;
    if (resetPosition2) {
      playerHeadManager.teleportPositionFeet(this.getPosition(position));
    }
    const realUp = _PlayerTransformManager._resetRealSV.realUp;
    const rotationQuat = _PlayerTransformManager._resetRealSV.rotationQuat;
    const validUp = _PlayerTransformManager._resetRealSV.validUp;
    this.getPlayerHeadManager().getRotationFeetQuat(rotationQuat).quat_getUp(realUp);
    this.getRotationQuat(rotationQuat).quat_getUp(validUp);
    if (resetRotation2 || realUp.vec3_angle(validUp) > Math.PP_EPSILON_DEGREES && this._myParams.myResetRealResetRotationIfUpChanged) {
      playerHeadManager.setRotationFeetQuat(this.getRotationQuat(rotationQuat), false);
    }
    if (resetHeight) {
      playerHeadManager.setHeightHead(this.getHeight(), true);
    }
    if (resetHeadToReal) {
      const positionHeadReal = _PlayerTransformManager._resetRealSV.positionHeadReal;
      this.getPositionHeadReal(positionHeadReal);
      const distanceToRealHead = this._myValidPositionHead.vec3_distance(positionHeadReal);
      if (ignoreResetHeadMinDistance || distanceToRealHead >= this._myParams.myResetHeadToRealMinDistance) {
        if (this._myParams.myResetHeadToFeetInsteadOfRealOnlyIfRealNotReachable) {
          this._myResetHeadToFeetOnNextUpdateValidToReal = true;
          const validPositionHeadBackupForResetToFeet = _PlayerTransformManager._resetRealSV.validPositionHeadBackupForResetToFeet;
          validPositionHeadBackupForResetToFeet.vec3_copy(this._myValidPositionHead);
          this.resetHeadToFeet();
          this._myValidPositionHeadBackupForResetToFeet.vec3_copy(validPositionHeadBackupForResetToFeet);
        } else if (this._myParams.myResetHeadToFeetInsteadOfReal) {
          this.resetHeadToFeet();
        } else {
          this.resetHeadToReal();
        }
      }
    }
    if (updateValidToReal) {
      this._updateValidToReal(0);
    }
  }
  updateValidToReal() {
    this._updateValidToReal(0);
  }
  updateValidHeadToRealHead() {
    this._updateValidHeadToRealHead(0);
  }
  updateValidHeadToRealHeadIfNeeded() {
    if (this._myResetHeadToFeetDirty) {
      this._updateValidHeadToRealHead(0);
    }
  }
  resetToReal(resetPosition2 = true, resetRotation2 = true, resetHeight = true, resetPositionHead = true, updateValidToReal = false, resetToPlayerInsteadOfHead = false) {
    if (resetPosition2) {
      if (resetToPlayerInsteadOfHead) {
        this.getPlayerHeadManager().getPlayer().pp_getPosition(this._myValidPosition);
      } else {
        this.getPositionReal(this._myValidPosition);
      }
    }
    if (resetPositionHead) {
      if (!this._myParams.myAlwaysSyncPositionWithReal) {
        this.getPositionHeadReal(this._myValidPositionHead);
        this._myValidPositionHeadBackupForResetToFeet.vec3_copy(this._myValidPositionHead);
        this._myResetHeadToFeetOnNextUpdateValidToReal = false;
        this._myResetHeadToFeetDirty = false;
      }
    }
    if (resetRotation2) {
      if (resetToPlayerInsteadOfHead) {
        this.getPlayerHeadManager().getPlayer().pp_getRotationQuat(this._myValidRotationQuat);
      } else {
        this.getRotationRealQuat(this._myValidRotationQuat);
      }
    }
    if (resetHeight) {
      this._myValidHeight = Math.pp_clamp(this.getHeightReal(), this._myParams.myMinHeight ?? void 0, this._myParams.myMaxHeight ?? void 0);
    }
    if (updateValidToReal) {
      this._updateValidToReal(0);
    }
  }
  resetHeadToReal() {
    if (!this._myParams.myAlwaysSyncPositionWithReal) {
      this.getPositionHeadReal(this._myValidPositionHead);
      this._myValidPositionHeadBackupForResetToFeet.vec3_copy(this._myValidPositionHead);
      this._myResetHeadToFeetOnNextUpdateValidToReal = false;
      this._myResetHeadToFeetDirty = false;
    }
  }
  static _resetHeadToFeetSV = {
    transformQuat: quat2_create(),
    headUp: vec3_create()
  };
  resetHeadToFeet() {
    this.getPosition(this._myValidPositionHead);
    const transformQuat2 = _PlayerTransformManager._resetHeadToFeetSV.transformQuat;
    const headUp = _PlayerTransformManager._resetHeadToFeetSV.headUp;
    this.getTransformHeadQuat(transformQuat2);
    transformQuat2.quat2_getUp(headUp);
    this._myValidPositionHead.vec3_add(headUp.vec3_scale(this._myHeadCollisionCheckParams.myHeight / 2 + 1e-5 + this._myParams.myResetHeadToFeetUpOffset, headUp), this._myValidPositionHead);
    this._myValidPositionHeadBackupForResetToFeet.vec3_copy(this._myValidPositionHead);
    this._myResetHeadToFeetDirty = true;
  }
  isBodyColliding() {
    return this._myIsBodyColliding;
  }
  isHeadColliding() {
    return this._myIsHeadColliding;
  }
  isFloating() {
    return this.isLeaning() || this.isHopping();
  }
  isLeaning() {
    return this._myIsLeaning;
  }
  isHopping() {
    return this._myIsHopping;
  }
  isFar() {
    return this._myIsFar;
  }
  isHeightColliding() {
    return this._myIsHeightColliding;
  }
  static _getDistanceToRealSV = {
    position: vec3_create(),
    realPosition: vec3_create()
  };
  getDistanceToReal() {
    const realPosition = _PlayerTransformManager._getDistanceToRealSV.realPosition;
    const position = _PlayerTransformManager._getDistanceToRealSV.position;
    this.getPositionReal(realPosition);
    return realPosition.vec3_distance(this.getPosition(position));
  }
  static _getDistanceToRealHeadSV = {
    position: vec3_create(),
    realPosition: vec3_create()
  };
  getDistanceToRealHead() {
    const realPosition = _PlayerTransformManager._getDistanceToRealSV.realPosition;
    const position = _PlayerTransformManager._getDistanceToRealSV.position;
    this.getPositionHeadReal(realPosition);
    return realPosition.vec3_distance(this.getPositionHead(position));
  }
  getPlayerHeadManager() {
    return this._myParams.myPlayerHeadManager;
  }
  getMovementCollisionCheckParams() {
    return this._myParams.myMovementCollisionCheckParams;
  }
  getTeleportCollisionCheckParams() {
    return this._myParams.myTeleportCollisionCheckParams;
  }
  getHeadCollisionCheckParams() {
    return this._myHeadCollisionCheckParams;
  }
  /**
   * This should be used anytime the movement `CollisionCheckParams` are updated,
   * so that the other `CollisionCheckParams` are synced with that (if needed)
   *
   * The head `CollisionCheckParams` are another set of params which are not synced automatically
   * If you want to apply some changes made to the movement params to the head ones too, for example
   * a new object to ignore, you need to also manually update them
   */
  movementCollisionCheckParamsUpdated() {
    if (this._myParams.myTeleportCollisionCheckParamsCopyFromMovement) {
      this._generateTeleportParamsFromMovementParams();
    }
    this._generateRealMovementParamsFromMovementParams();
  }
  getCollisionRuntimeParams() {
    return this._myCollisionRuntimeParams;
  }
  isPositionValid() {
    return this._myIsPositionValid;
  }
  isPositionHeadValid() {
    return this._myIsPositionHeadValid;
  }
  isPositionRealValid() {
    return this._myIsRealPositionValid;
  }
  isPositionHeadRealValid() {
    return this._myIsRealPositionHeadValid;
  }
  setPlayerLocomotionTeleport(playerLocomotionTeleport) {
    this._myPlayerLocomotionTeleport = playerLocomotionTeleport;
  }
  _updateCollisionHeight(useHighestHeight = false, collisionCheckParams) {
    const validHeight = this.getHeight();
    const realHeight = this.getHeightReal();
    const highestHeight = Math.max(validHeight, realHeight);
    const colliderHeight = (useHighestHeight ? highestHeight : validHeight) + this._myParams.myExtraHeight;
    if (collisionCheckParams == null) {
      this._myParams.myMovementCollisionCheckParams.myHeight = colliderHeight;
      this._myParams.myTeleportCollisionCheckParams.myHeight = colliderHeight;
      this._myRealMovementCollisionCheckParams.myHeight = Math.max(realHeight, this._myParams.myMinHeight ?? -Number.MAX_VALUE) + this._myParams.myExtraHeight;
    } else {
      collisionCheckParams.myHeight = colliderHeight;
    }
  }
  _setupHeadCollisionCheckParams() {
    this._myHeadCollisionCheckParams = new CollisionCheckParams();
    const params = this._myHeadCollisionCheckParams;
    params.myRadius = this._myParams.myHeadRadius;
    params.myDistanceFromFeetToIgnore = 0;
    params.myDistanceFromHeadToIgnore = 0;
    params.mySplitMovementEnabled = true;
    params.mySplitMovementMaxLengthEnabled = true;
    params.mySplitMovementMaxLength = params.myRadius * 0.75;
    params.mySplitMovementMinLengthEnabled = true;
    params.mySplitMovementMinLength = params.mySplitMovementMaxLength;
    if (this._myParams.myMaxHeadToRealHeadSteps != null) {
      params.mySplitMovementMaxStepsEnabled = true;
      params.mySplitMovementMaxSteps = this._myParams.myMaxHeadToRealHeadSteps;
      params.mySplitMovementMaxLengthLastStepCanBeLonger = true;
    }
    params.mySplitMovementStopWhenHorizontalMovementCanceled = true;
    params.mySplitMovementStopWhenVerticalMovementCanceled = true;
    params.mySplitMovementStopWhenVerticalMovementReduced = true;
    params.myHorizontalMovementCheckEnabled = true;
    params.myHorizontalMovementRadialStepAmount = 1;
    params.myHorizontalMovementCheckDiagonalOutward = true;
    params.myHorizontalMovementCheckDiagonalInward = true;
    params.myHorizontalMovementCheckVerticalDiagonalUpwardOutward = true;
    params.myHorizontalMovementCheckVerticalDiagonalUpwardInward = true;
    params.myHorizontalPositionCheckEnabled = true;
    params.myHalfConeAngle = 180;
    params.myHalfConeSliceAmount = 3;
    params.myCheckConeBorder = true;
    params.myCheckConeRay = true;
    params.myHorizontalPositionCheckVerticalIgnoreHitsInsideCollision = false;
    params.myHorizontalPositionCheckVerticalDirectionType = 0;
    params.myHeight = this._myParams.myHeadHeight;
    params.myPositionOffsetLocal.vec3_set(0, -params.myHeight / 2, 0);
    params.myCheckHeight = true;
    params.myCheckHeightVerticalMovement = true;
    params.myCheckHeightVerticalPosition = true;
    params.myHeightCheckStepAmountMovement = 2;
    params.myHeightCheckStepAmountPosition = 2;
    params.myCheckHeightTopMovement = true;
    params.myCheckHeightTopPosition = true;
    params.myCheckVerticalStraight = true;
    params.myCheckVerticalFixedForwardEnabled = true;
    params.myCheckVerticalFixedForward = vec3_create(0, 0, 1);
    params.myCheckHorizontalFixedForwardEnabled = true;
    params.myCheckHorizontalFixedForward = vec3_create(0, 0, 1);
    params.myVerticalMovementCheckEnabled = true;
    params.myVerticalPositionCheckEnabled = true;
    params.myCheckVerticalBothDirection = true;
    params.myCheckVerticalPositionBothDirection = true;
    params.myGroundCircumferenceAddCenter = true;
    params.myGroundCircumferenceSliceAmount = 6;
    params.myGroundCircumferenceStepAmount = 2;
    params.myGroundCircumferenceRotationPerStep = 30;
    params.myFeetRadius = params.myRadius;
    params.myHorizontalBlockLayerFlags.copy(this._myParams.myHeadCollisionBlockLayerFlags);
    params.myHorizontalObjectsToIgnore.pp_copy(this._myParams.myHeadCollisionObjectsToIgnore);
    params.myHorizontalBlockColliderType = this._myParams.myHeadCollisionBlockColliderType;
    params.myVerticalBlockLayerFlags.copy(this._myParams.myHeadCollisionBlockLayerFlags);
    params.myVerticalObjectsToIgnore.pp_copy(this._myParams.myHeadCollisionObjectsToIgnore);
    params.myVerticalBlockColliderType = this._myParams.myHeadCollisionBlockColliderType;
    params.mySlidingEnabled = false;
    params.mySnapOnGroundEnabled = false;
    params.mySnapOnCeilingEnabled = false;
    params.myGroundPopOutEnabled = false;
    params.myCeilingPopOutEnabled = false;
    params.myAdjustVerticalMovementWithGroundAngleDownhill = false;
    params.myAdjustVerticalMovementWithGroundAngleUphill = false;
    params.myAdjustVerticalMovementWithCeilingAngleDownhill = false;
    params.myAdjustVerticalMovementWithCeilingAngleUphill = false;
    params.myAdjustHorizontalMovementWithGroundAngleDownhill = false;
    params.myAdjustHorizontalMovementWithCeilingAngleDownhill = false;
    params.myVerticalMovementReduceEnabled = false;
    params.myDebugEnabled = false;
    params.myDebugHorizontalMovementEnabled = false;
    params.myDebugHorizontalPositionEnabled = false;
    params.myDebugVerticalMovementEnabled = false;
    params.myDebugVerticalPositionEnabled = false;
    params.myDebugSlidingEnabled = false;
    params.myDebugGroundInfoEnabled = false;
    params.myDebugCeilingInfoEnabled = false;
    params.myDebugRuntimeParamsEnabled = false;
    params.myDebugMovementEnabled = false;
  }
  _generateTeleportParamsFromMovementParams() {
    if (this._myParams.myTeleportCollisionCheckParams == null) {
      this._myParams.myTeleportCollisionCheckParams = new CollisionCheckParams();
    }
    if (this._myParams.myTeleportCollisionCheckParamsCheck360) {
      this._myParams.myTeleportCollisionCheckParams = CollisionCheckUtils.generate360TeleportParamsFromMovementParams(this._myParams.myMovementCollisionCheckParams, this._myParams.myTeleportCollisionCheckParams);
    } else {
      this._myParams.myTeleportCollisionCheckParams.copy(this._myParams.myMovementCollisionCheckParams);
    }
    if (this._myParams.myTeleportCollisionCheckParamsGroundAngleToIgnore != null) {
      this._myParams.myTeleportCollisionCheckParams.myGroundAngleToIgnore = this._myParams.myTeleportCollisionCheckParamsGroundAngleToIgnore;
    }
  }
  _generateRealMovementParamsFromMovementParams() {
    if (this._myRealMovementCollisionCheckParams == null) {
      this._myRealMovementCollisionCheckParams = new CollisionCheckParams();
    }
    const params = this._myRealMovementCollisionCheckParams;
    params.copy(this._myParams.myMovementCollisionCheckParams);
    params.mySplitMovementStopWhenHorizontalMovementCanceled = true;
    params.mySplitMovementStopWhenVerticalMovementCanceled = true;
    params._myInternalSplitMovementMaxStepsDisabled = true;
    params.mySlidingEnabled = false;
    if (!this._myParams.myRealMovementAllowVerticalAdjustments) {
      params.mySnapOnGroundEnabled = false;
      params.mySnapOnCeilingEnabled = false;
      params.myGroundPopOutEnabled = false;
      params.myCeilingPopOutEnabled = false;
      params.myAdjustVerticalMovementWithGroundAngleDownhill = false;
      params.myAdjustVerticalMovementWithGroundAngleUphill = false;
      params.myAdjustVerticalMovementWithCeilingAngleDownhill = false;
      params.myAdjustVerticalMovementWithCeilingAngleUphill = false;
      params.myAdjustHorizontalMovementWithGroundAngleDownhill = false;
      params.myAdjustHorizontalMovementWithCeilingAngleDownhill = false;
      params.myVerticalMovementReduceEnabled = false;
    }
    params.myDebugEnabled = false;
    params.myDebugHorizontalMovementEnabled = false;
    params.myDebugHorizontalPositionEnabled = false;
    params.myDebugVerticalMovementEnabled = false;
    params.myDebugVerticalPositionEnabled = false;
    params.myDebugSlidingEnabled = false;
    params.myDebugGroundInfoEnabled = false;
    params.myDebugCeilingInfoEnabled = false;
    params.myDebugRuntimeParamsEnabled = false;
    params.myDebugMovementEnabled = false;
  }
  _onXRSessionStart(manualCall, session) {
    if (!manualCall) {
      if (this._myActive) {
        if (this._myParams.myResetToValidOnEnterSession) {
          this._myResetRealOnHeadSynced = true;
        }
      }
    }
    this._myVisibilityChangeEventListener = function(event) {
      if (event.session.visibilityState == "hidden") {
        this._mySessionHasBeenHidden = true;
      } else if (this._mySessionHasBeenHidden) {
        this._mySessionHasBeenHidden = false;
        if (this._myParams.myResetToValidOnSessionHiddenEnd) {
          this._myResetRealOnHeadSynced = true;
        }
      }
    }.bind(this);
    session.addEventListener("visibilitychange", this._myVisibilityChangeEventListener);
  }
  _onXRSessionEnd() {
    if (this._myActive) {
      if (this._myParams.myResetToValidOnExitSession) {
        this._myResetRealOnHeadSynced = true;
      }
    }
    this._myVisibilityChangeEventListener = null;
  }
  static _updatePositionsValidSV = {
    transformQuat: quat2_create(),
    collisionRuntimeParams: new CollisionRuntimeParams(),
    headCollisionRuntimeParams: new CollisionRuntimeParams(),
    transformUp: vec3_create(),
    horizontalDirection: vec3_create(),
    rotationQuat: quat_create()
  };
  _updatePositionsValid(dt) {
    this._updateCollisionHeight();
    if (this._myParams.myUpdatePositionValid) {
      const transformQuat2 = _PlayerTransformManager._updatePositionsValidSV.transformQuat;
      const transformUp = _PlayerTransformManager._updatePositionsValidSV.transformUp;
      const rotationQuat = _PlayerTransformManager._updatePositionsValidSV.rotationQuat;
      const horizontalDirection = _PlayerTransformManager._updatePositionsValidSV.horizontalDirection;
      this.getTransformQuat(transformQuat2);
      transformQuat2.quat2_getUp(transformUp);
      transformQuat2.quat2_getRotationQuat(rotationQuat);
      this._myLastValidMovementDirection.vec3_removeComponentAlongAxis(transformUp, horizontalDirection);
      if (!horizontalDirection.vec3_isZero(1e-5)) {
        horizontalDirection.vec3_normalize(horizontalDirection);
        rotationQuat.quat_setUp(transformUp, horizontalDirection);
        transformQuat2.quat2_setRotationQuat(rotationQuat);
      }
      const collisionRuntimeParams = _PlayerTransformManager._updatePositionsValidSV.collisionRuntimeParams;
      collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
      const debugBackup = this._myParams.myMovementCollisionCheckParams.myDebugEnabled;
      this._myParams.myMovementCollisionCheckParams.myDebugEnabled = false;
      CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).positionCheck(true, transformQuat2, this._myParams.myMovementCollisionCheckParams, collisionRuntimeParams);
      this._myParams.myMovementCollisionCheckParams.myDebugEnabled = debugBackup;
      this._myIsPositionValid = collisionRuntimeParams.myIsPositionOk;
    } else {
      this._myIsPositionValid = true;
    }
    if (this._myParams.myUpdatePositionHeadValid) {
      const transformQuat2 = _PlayerTransformManager._updatePositionsValidSV.transformQuat;
      this.getTransformHeadQuat(transformQuat2);
      const headCollisionRuntimeParams = _PlayerTransformManager._updatePositionsValidSV.headCollisionRuntimeParams;
      headCollisionRuntimeParams.reset();
      const debugBackup = this._myHeadCollisionCheckParams.myDebugEnabled;
      this._myHeadCollisionCheckParams.myDebugEnabled = false;
      CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).positionCheck(true, transformQuat2, this._myHeadCollisionCheckParams, headCollisionRuntimeParams);
      this._myHeadCollisionCheckParams.myDebugEnabled = debugBackup;
      this._myIsPositionHeadValid = headCollisionRuntimeParams.myIsPositionOk;
    } else {
      this._myIsPositionHeadValid = true;
    }
    if (this._myParams.myUpdateRealPositionValid) {
      const transformQuat2 = _PlayerTransformManager._updatePositionsValidSV.transformQuat;
      const transformUp = _PlayerTransformManager._updatePositionsValidSV.transformUp;
      const rotationQuat = _PlayerTransformManager._updatePositionsValidSV.rotationQuat;
      const horizontalDirection = _PlayerTransformManager._updatePositionsValidSV.horizontalDirection;
      this.getTransformRealQuat(transformQuat2);
      transformQuat2.quat2_getUp(transformUp);
      transformQuat2.quat2_getRotationQuat(rotationQuat);
      this._myLastValidMovementDirection.vec3_removeComponentAlongAxis(transformUp, horizontalDirection);
      if (!horizontalDirection.vec3_isZero(1e-5)) {
        horizontalDirection.vec3_normalize(horizontalDirection);
        rotationQuat.quat_setUp(transformUp, horizontalDirection);
        transformQuat2.quat2_setRotationQuat(rotationQuat);
      }
      const collisionRuntimeParams = _PlayerTransformManager._updatePositionsValidSV.collisionRuntimeParams;
      collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
      const debugBackup = this._myParams.myMovementCollisionCheckParams.myDebugEnabled;
      this._myParams.myMovementCollisionCheckParams.myDebugEnabled = false;
      CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).positionCheck(true, transformQuat2, this._myParams.myMovementCollisionCheckParams, collisionRuntimeParams);
      this._myIsRealPositionValid = collisionRuntimeParams.myIsPositionOk;
      this._myParams.myMovementCollisionCheckParams.myDebugEnabled = debugBackup;
    } else {
      this._myIsRealPositionValid = true;
    }
    if (this._myParams.myUpdateRealPositionHeadValid) {
      const transformQuat2 = _PlayerTransformManager._updatePositionsValidSV.transformQuat;
      this.getTransformHeadRealQuat(transformQuat2);
      const headCollisionRuntimeParams = _PlayerTransformManager._updatePositionsValidSV.headCollisionRuntimeParams;
      headCollisionRuntimeParams.reset();
      const debugBackup = this._myHeadCollisionCheckParams.myDebugEnabled;
      this._myHeadCollisionCheckParams.myDebugEnabled = false;
      CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).positionCheck(true, transformQuat2, this._myHeadCollisionCheckParams, headCollisionRuntimeParams);
      this._myHeadCollisionCheckParams.myDebugEnabled = debugBackup;
      this._myIsRealPositionHeadValid = headCollisionRuntimeParams.myIsPositionOk;
    } else {
      this._myIsRealPositionHeadValid = true;
    }
  }
  static _updateValidToRealSV = {
    movementToCheck: vec3_create(),
    position: vec3_create(),
    positionReal: vec3_create(),
    transformQuat: quat2_create(),
    collisionRuntimeParams: new CollisionRuntimeParams(),
    newValidMovementDirection: vec3_create(),
    newValidVerticalMovementDirection: vec3_create(),
    newPosition: vec3_create(),
    movementStep: vec3_create(),
    currentMovementStep: vec3_create(),
    transformUp: vec3_create(),
    verticalMovement: vec3_create(),
    movementChecked: vec3_create(),
    newFeetPosition: vec3_create(),
    floatingTransformQuat: quat2_create(),
    rotationQuat: quat_create(),
    horizontalDirection: vec3_create()
  };
  _updateValidToReal(dt) {
    const isHeadSynced = this.getPlayerHeadManager().isSynced(this._myParams.myAllowUpdateValidToRealWhenBlurred);
    this._updateCollisionHeight();
    const position = _PlayerTransformManager._updateValidToRealSV.position;
    const positionReal = _PlayerTransformManager._updateValidToRealSV.positionReal;
    const movementToCheck = _PlayerTransformManager._updateValidToRealSV.movementToCheck;
    this.getPositionReal(positionReal).vec3_sub(this.getPosition(position), movementToCheck);
    this._myIsFar = false;
    if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.FAR)) {
      if (this._myParams.myMaxDistanceFromRealToSyncEnabled && movementToCheck.vec3_length() > this._myParams.myMaxDistanceFromRealToSync) {
        this._myIsFar = true;
      } else if (this._myParams.myIsFarExtraCheckCallback != null && this._myParams.myIsFarExtraCheckCallback(this)) {
        this._myIsFar = true;
      }
    }
    const collisionRuntimeParams = _PlayerTransformManager._updateValidToRealSV.collisionRuntimeParams;
    const transformQuat2 = _PlayerTransformManager._updateValidToRealSV.transformQuat;
    const newPosition = _PlayerTransformManager._updateValidToRealSV.newPosition;
    const transformUp = _PlayerTransformManager._updateValidToRealSV.transformUp;
    this.getTransformQuat(transformQuat2);
    newPosition.vec3_copy(positionReal);
    transformQuat2.quat2_getUp(transformUp);
    this._myIsBodyColliding = false;
    if (!this._myIsFar && this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.BODY_COLLIDING)) {
      const realHeight = this.getHeightReal();
      if (Math.pp_clamp(realHeight, this._myParams.myIsBodyCollidingWhenHeightBelowValue ?? void 0, this._myParams.myIsBodyCollidingWhenHeightAboveValue ?? void 0) != realHeight) {
        this._myIsBodyColliding = true;
      } else {
        collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
        CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).updateSurfaceInfo(transformQuat2, this._myParams.myMovementCollisionCheckParams, collisionRuntimeParams);
        if (collisionRuntimeParams.myIsOnGround && this._myParams.myIgnoreUpwardMovementToRealIfValidOnGround) {
          const valueAlongUp = movementToCheck.vec3_valueAlongAxis(transformUp);
          if (valueAlongUp >= 0) {
            movementToCheck.vec3_removeComponentAlongAxis(transformUp, movementToCheck);
          }
        }
        CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).move(movementToCheck, transformQuat2, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
        if (!collisionRuntimeParams.myHorizontalMovementCanceled && !collisionRuntimeParams.myVerticalMovementCanceled) {
          if (this._myParams.myIsBodyCollidingExtraCheckCallback != null && this._myParams.myIsBodyCollidingExtraCheckCallback(this)) {
            this._myIsBodyColliding = true;
          } else {
            this._myIsBodyColliding = false;
            newPosition.vec3_copy(collisionRuntimeParams.myNewPosition);
            movementToCheck.vec3_copy(collisionRuntimeParams.myFixedMovement);
          }
        } else {
          this._myIsBodyColliding = true;
        }
      }
    } else if (this._myIsFar) {
      this._myIsBodyColliding = true;
    }
    if (this._myParams.myAlwaysSyncPositionWithReal) {
      newPosition.vec3_copy(positionReal);
    }
    this._myIsLeaning = false;
    this._myIsHopping = false;
    if (!this._myIsBodyColliding && this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.FLOATING)) {
      collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
      const floatingTransformQuat = _PlayerTransformManager._updateValidToRealSV.floatingTransformQuat;
      floatingTransformQuat.quat2_setPositionRotationQuat(this._myValidPosition, this._myValidRotationQuat);
      CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).updateSurfaceInfo(floatingTransformQuat, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
      if (collisionRuntimeParams.myIsOnGround) {
        const verticalMovement = _PlayerTransformManager._updateValidToRealSV.verticalMovement;
        movementToCheck.vec3_componentAlongAxis(transformUp, verticalMovement);
        const isVertical = !verticalMovement.vec3_isZero(1e-5);
        if (!isVertical || !this._myParams.myIsFloatingValidIfVerticalMovement) {
          let movementStepAmount = 1;
          const movementStep = _PlayerTransformManager._updateValidToRealSV.movementStep;
          movementStep.vec3_copy(movementToCheck);
          if (!movementToCheck.vec3_isZero(1e-5) && this._myParams.myFloatingSplitCheckEnabled) {
            const minLength = this._myParams.myFloatingSplitCheckMinLength;
            const maxLength = this._myParams.myFloatingSplitCheckMaxLength;
            const movementLength = movementToCheck.vec3_length();
            const stepLength = Math.pp_clamp(movementLength, minLength ?? void 0, maxLength ?? void 0);
            movementStepAmount = Math.ceil(movementLength / stepLength);
            movementStep.vec3_normalize(movementStep).vec3_scale(stepLength, movementStep);
            movementStepAmount = Math.max(1, movementStepAmount);
            if (movementStepAmount == 1) {
              movementStep.vec3_copy(movementToCheck);
            }
          }
          const isOnValidGroundAngle = collisionRuntimeParams.myGroundAngle <= this._myRealMovementCollisionCheckParams.myGroundAngleToIgnore + 1e-4;
          const movementChecked = _PlayerTransformManager._updateValidToRealSV.movementChecked;
          const newFeetPosition = _PlayerTransformManager._updateValidToRealSV.newFeetPosition;
          movementChecked.vec3_zero();
          newFeetPosition.vec3_copy(this._myValidPosition);
          collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
          let atLeastOneNotOnGround = false;
          let isOneOnGroundBetweenNoGround = false;
          let isLastOnGround = false;
          let isOneOnSteepGround = false;
          const isOnGroundIfInsideHitBackup = this._myRealMovementCollisionCheckParams.myIsOnGroundIfInsideHit;
          this._myRealMovementCollisionCheckParams.myIsOnGroundIfInsideHit = true;
          const currentMovementStep = _PlayerTransformManager._updateValidToRealSV.currentMovementStep;
          for (let i = 0; i < movementStepAmount; i++) {
            if (movementStepAmount == 1 || i != movementStepAmount - 1) {
              currentMovementStep.vec3_copy(movementStep);
            } else {
              movementToCheck.vec3_sub(movementChecked, currentMovementStep);
            }
            newFeetPosition.vec3_add(currentMovementStep, newFeetPosition);
            floatingTransformQuat.quat2_setPositionRotationQuat(newFeetPosition, this._myValidRotationQuat);
            collisionRuntimeParams.copy(this._myCollisionRuntimeParams);
            CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).updateSurfaceInfo(floatingTransformQuat, this._myRealMovementCollisionCheckParams, collisionRuntimeParams);
            movementChecked.vec3_add(currentMovementStep, movementChecked);
            if (!collisionRuntimeParams.myIsOnGround) {
              atLeastOneNotOnGround = true;
            } else {
              if (collisionRuntimeParams.myGroundAngle > this._myRealMovementCollisionCheckParams.myGroundAngleToIgnore + 1e-4) {
                isOneOnSteepGround = true;
              }
              if (atLeastOneNotOnGround) {
                isOneOnGroundBetweenNoGround = true;
              }
              if (i == movementStepAmount - 1) {
                isLastOnGround = true;
              }
            }
          }
          this._myRealMovementCollisionCheckParams.myIsOnGroundIfInsideHit = isOnGroundIfInsideHitBackup;
          const isFloatingOnSteepGroundFail = isOneOnSteepGround && isOnValidGroundAngle && !this._myParams.myIsFloatingValidIfSteepGround && (!isVertical || !this._myParams.myIsFloatingValidIfVerticalMovementAndSteepGround);
          if (atLeastOneNotOnGround || isFloatingOnSteepGroundFail) {
            if (isOneOnGroundBetweenNoGround) {
              this._myIsHopping = true;
            } else {
              this._myIsLeaning = true;
            }
          } else {
            this._myIsLeaning = false;
            this._myIsHopping = false;
            if (this._myParams.myIsLeaningExtraCheckCallback != null && this._myParams.myIsLeaningExtraCheckCallback(this)) {
              this._myIsLeaning = true;
            } else if (this._myParams.myIsHoppingExtraCheckCallback != null && this._myParams.myIsHoppingExtraCheckCallback(this)) {
              this._myIsHopping = true;
            }
          }
          if (this._myIsLeaning) {
            const distance2 = movementToCheck.vec3_length();
            if (this._myParams.myIsLeaningValidAboveDistance && distance2 > this._myParams.myLeaningValidDistance) {
              this._myIsLeaning = false;
            }
          }
          if (this._myIsLeaning || this._myIsHopping) {
            if (isLastOnGround && this._myParams.myIsFloatingValidIfRealOnGround) {
              this._myIsLeaning = false;
              this._myIsHopping = false;
            } else if (isLastOnGround && isVertical && this._myParams.myIsFloatingValidIfVerticalMovementAndRealOnGround) {
              this._myIsLeaning = false;
              this._myIsHopping = false;
            }
          }
        }
      }
    }
    if (isHeadSynced) {
      if ((this.isSynced(this._myParams.mySyncPositionFlagMap) || this._myParams.myAlwaysSyncPositionWithReal) && !this._myParams.mySyncPositionDisabled && (this._myPlayerLocomotionTeleport == null || !this._myPlayerLocomotionTeleport.isTeleporting())) {
        const newValidMovementDirection = _PlayerTransformManager._updateValidToRealSV.newValidMovementDirection;
        const newValidVerticalMovementDirection = _PlayerTransformManager._updateValidToRealSV.newValidVerticalMovementDirection;
        newPosition.vec3_sub(this._myValidPosition, newValidMovementDirection);
        if (newValidMovementDirection.vec3_removeComponentAlongAxis(transformUp, newValidVerticalMovementDirection).vec3_length() > 1e-4) {
          newValidMovementDirection.vec3_normalize(this._myLastValidMovementDirection);
        }
        this._myValidPosition.vec3_copy(newPosition);
        if (this._myParams.myApplyRealToValidAdjustmentsToRealPositionToo) {
          this.resetReal(true, false, false, false, false, false);
        }
      }
      if (this.isSynced(this._myParams.mySyncRotationFlagMap)) {
        this.getRotationRealQuat(this._myValidRotationQuat);
      }
    }
    const newHeight = Math.pp_clamp(this.getHeightReal(), this._myParams.myMinHeight ?? void 0, this._myParams.myMaxHeight ?? void 0);
    this._myIsHeightColliding = false;
    if (this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.HEIGHT_COLLIDING)) {
      const transformQuat3 = _PlayerTransformManager._updateValidToRealSV.transformQuat;
      const transformUp2 = _PlayerTransformManager._updateValidToRealSV.transformUp;
      const rotationQuat = _PlayerTransformManager._updateValidToRealSV.rotationQuat;
      const horizontalDirection = _PlayerTransformManager._updateValidToRealSV.horizontalDirection;
      this.getTransformQuat(transformQuat3);
      transformQuat3.quat2_getUp(transformUp2);
      transformQuat3.quat2_getRotationQuat(rotationQuat);
      this._myLastValidMovementDirection.vec3_removeComponentAlongAxis(transformUp2, horizontalDirection);
      if (!horizontalDirection.vec3_isZero(1e-5)) {
        horizontalDirection.vec3_normalize(horizontalDirection);
        rotationQuat.quat_setUp(transformUp2, horizontalDirection);
        transformQuat3.quat2_setRotationQuat(rotationQuat);
      }
      const collisionRuntimeParams2 = _PlayerTransformManager._updateValidToRealSV.collisionRuntimeParams;
      collisionRuntimeParams2.copy(this._myCollisionRuntimeParams);
      const debugBackup = this._myParams.myMovementCollisionCheckParams.myDebugEnabled;
      const heightBackup = this._myParams.myMovementCollisionCheckParams.myHeight;
      this._myParams.myMovementCollisionCheckParams.myHeight = newHeight + this._myParams.myExtraHeight;
      this._myParams.myMovementCollisionCheckParams.myDebugEnabled = false;
      CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).positionCheck(true, transformQuat3, this._myParams.myMovementCollisionCheckParams, collisionRuntimeParams2);
      this._myParams.myMovementCollisionCheckParams.myDebugEnabled = debugBackup;
      this._myParams.myMovementCollisionCheckParams.myHeight = heightBackup;
      this._myIsHeightColliding = !collisionRuntimeParams2.myIsPositionOk;
    }
    if (isHeadSynced) {
      if (this.isSynced(this._myParams.mySyncHeightFlagMap)) {
        this._myValidHeight = newHeight;
        this._updateCollisionHeight();
      }
      if (this._myParams.myPreventRealFromColliding) {
        this.resetReal(true, false, false, false, false, false);
      }
    }
    this._updateValidHeadToRealHead(dt);
  }
  static _updateValidHeadToRealHeadSV = {
    movementToCheck: vec3_create(),
    horizontalMovementToCheck: vec3_create(),
    verticalMovementToCheck: vec3_create(),
    position: vec3_create(),
    positionReal: vec3_create(),
    transformQuat: quat2_create(),
    collisionRuntimeParams: new CollisionRuntimeParams(),
    bodyRotationQuat: quat_create(),
    bodyUp: vec3_create(),
    bodyPosition: vec3_create(),
    newPositionHead: vec3_create(),
    backupHorizontalBlockLayerFlags: new PhysicsLayerFlags(),
    backupVerticalBlockLayerFlags: new PhysicsLayerFlags()
  };
  _updateValidHeadToRealHead(dt) {
    const isHeadSynced = this.getPlayerHeadManager().isSynced(this._myParams.myAllowUpdateValidToRealWhenBlurred);
    this._myIsHeadColliding = false;
    const backupHorizontalBlockLayerFlags = _PlayerTransformManager._updateValidHeadToRealHeadSV.backupHorizontalBlockLayerFlags;
    const backupVerticalBlockLayerFlags = _PlayerTransformManager._updateValidHeadToRealHeadSV.backupVerticalBlockLayerFlags;
    backupHorizontalBlockLayerFlags.copy(this._myHeadCollisionCheckParams.myHorizontalBlockLayerFlags);
    backupVerticalBlockLayerFlags.copy(this._myHeadCollisionCheckParams.myVerticalBlockLayerFlags);
    const backupVerticalMovementReduceEnabled = this._myHeadCollisionCheckParams.myVerticalMovementReduceEnabled;
    const backupGroundAngleToIgnore = this._myHeadCollisionCheckParams.myGroundAngleToIgnore;
    const backupGroundAngleToIgnoreWithPerceivedAngle = this._myHeadCollisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle;
    const backupHorizontalMovementGroundAngleIgnoreHeight = this._myHeadCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreHeight;
    const backupHorizontalPositionGroundAngleIgnoreHeight = this._myHeadCollisionCheckParams.myHorizontalPositionGroundAngleIgnoreHeight;
    const backupHorizontalMovementGroundAngleIgnoreMaxMovementLeft = this._myHeadCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft;
    let headReducedVerticalMovementFeetAdjustment = false;
    const newPositionHead = _PlayerTransformManager._updateValidHeadToRealHeadSV.newPositionHead;
    const positionReal = _PlayerTransformManager._updateValidHeadToRealHeadSV.positionReal;
    let firstHeadCollidingCheckDone = false;
    do {
      if (isHeadSynced) {
        if (firstHeadCollidingCheckDone && this._myResetHeadToFeetOnNextUpdateValidToReal) {
          this._myResetHeadToFeetOnNextUpdateValidToReal = false;
          this.resetHeadToFeet();
        }
      }
      let resetHeadToFeetDirty = this._myResetHeadToFeetDirty;
      if (this._myResetHeadToFeetOnNextUpdateValidToReal) {
        this._myValidPositionHead.vec3_copy(this._myValidPositionHeadBackupForResetToFeet);
        if (isHeadSynced) {
          this._myResetHeadToFeetDirty = false;
        }
        resetHeadToFeetDirty = false;
      }
      if (resetHeadToFeetDirty) {
        if (this._myParams.myHeadCollisionBlockLayerFlagsForResetToFeet != null) {
          this._myHeadCollisionCheckParams.myHorizontalBlockLayerFlags.copy(this._myParams.myHeadCollisionBlockLayerFlagsForResetToFeet);
          this._myHeadCollisionCheckParams.myVerticalBlockLayerFlags.copy(this._myParams.myHeadCollisionBlockLayerFlagsForResetToFeet);
        }
        if (this._myParams.myResetHeadToFeetMoveTowardReal) {
          this._myHeadCollisionCheckParams.myVerticalMovementReduceEnabled = true;
        }
        if (this._myParams.myResetHeadToFeetGroudnAngleIgnoreEnabled) {
          this._myHeadCollisionCheckParams.myGroundAngleToIgnore = this._myParams.myMovementCollisionCheckParams.myGroundAngleToIgnore;
          this._myHeadCollisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle = this._myParams.myMovementCollisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle;
          this._myHeadCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreHeight = this._myParams.myMovementCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreHeight;
          this._myHeadCollisionCheckParams.myHorizontalPositionGroundAngleIgnoreHeight = this._myParams.myMovementCollisionCheckParams.myHorizontalPositionGroundAngleIgnoreHeight;
          this._myHeadCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = this._myParams.myMovementCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft;
        }
        if (isHeadSynced) {
          this._myResetHeadToFeetDirty = false;
        }
      } else {
        this._myHeadCollisionCheckParams.myHorizontalBlockLayerFlags.copy(backupHorizontalBlockLayerFlags);
        this._myHeadCollisionCheckParams.myVerticalBlockLayerFlags.copy(backupVerticalBlockLayerFlags);
        this._myHeadCollisionCheckParams.myVerticalMovementReduceEnabled = backupVerticalMovementReduceEnabled;
        this._myHeadCollisionCheckParams.myGroundAngleToIgnore = backupGroundAngleToIgnore;
        this._myHeadCollisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle = backupGroundAngleToIgnoreWithPerceivedAngle;
        this._myHeadCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreHeight = backupHorizontalMovementGroundAngleIgnoreHeight;
        this._myHeadCollisionCheckParams.myHorizontalPositionGroundAngleIgnoreHeight = backupHorizontalPositionGroundAngleIgnoreHeight;
        this._myHeadCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = backupHorizontalMovementGroundAngleIgnoreMaxMovementLeft;
      }
      const position = _PlayerTransformManager._updateValidHeadToRealHeadSV.position;
      const movementToCheck = _PlayerTransformManager._updateValidHeadToRealHeadSV.movementToCheck;
      this.getPositionHeadReal(positionReal).vec3_sub(this.getPositionHead(position), movementToCheck);
      const collisionRuntimeParams = _PlayerTransformManager._updateValidHeadToRealHeadSV.collisionRuntimeParams;
      collisionRuntimeParams.reset();
      const transformQuat2 = _PlayerTransformManager._updateValidHeadToRealHeadSV.transformQuat;
      this.getTransformHeadQuat(transformQuat2);
      newPositionHead.vec3_copy(positionReal);
      let isHeadFar = false;
      if (this._myParams.myMaxDistanceFromHeadRealToSyncEnabled) {
        isHeadFar = movementToCheck.vec3_length() > this._myParams.myMaxDistanceFromHeadRealToSync;
        if (isHeadFar) {
          const horizontalMovementToCheck = _PlayerTransformManager._updateValidHeadToRealHeadSV.horizontalMovementToCheck;
          const verticalMovementToCheck = _PlayerTransformManager._updateValidHeadToRealHeadSV.verticalMovementToCheck;
          const bodyRotationQuat = _PlayerTransformManager._updateValidHeadToRealHeadSV.bodyRotationQuat;
          const bodyUp = _PlayerTransformManager._updateValidHeadToRealHeadSV.bodyUp;
          this.getRotationQuat(bodyRotationQuat);
          bodyRotationQuat.quat_getUp(bodyUp);
          movementToCheck.vec3_componentAlongAxis(bodyUp, verticalMovementToCheck);
          movementToCheck.vec3_sub(verticalMovementToCheck, horizontalMovementToCheck);
          isHeadFar = horizontalMovementToCheck.vec3_length() > this._myParams.myMaxDistanceFromHeadRealToSync;
          if (!isHeadFar) {
            const bodyPosition = _PlayerTransformManager._updateValidHeadToRealHeadSV.bodyPosition;
            this.getPosition(bodyPosition);
            const bodyUpValue = bodyPosition.vec3_valueAlongAxis(bodyUp);
            const headUpValue = position.vec3_valueAlongAxis(bodyUp);
            const headRealUpValue = positionReal.vec3_valueAlongAxis(bodyUp);
            const isHeadBetweenBodyAndHeadReal = headRealUpValue >= headUpValue && headRealUpValue >= bodyUpValue && headUpValue >= bodyUpValue - 1e-4;
            if (!isHeadBetweenBodyAndHeadReal) {
              isHeadFar = true;
            } else {
              const heightToCheck = this.getPlayerHeadManager().getHeightEyes() + this._myHeadCollisionCheckParams.myRadius;
              const isHeadRealBelowHeight = headRealUpValue - bodyUpValue <= heightToCheck;
              if (!isHeadRealBelowHeight) {
                isHeadFar = true;
              } else {
                isHeadFar = false;
              }
            }
          }
        }
      }
      if (!isHeadFar && this._myParams.mySyncEnabledFlagMap.get(PlayerTransformManagerSyncFlag.HEAD_COLLIDING)) {
        CollisionCheckBridge.getCollisionCheck(this._myParams.myEngine).move(movementToCheck, transformQuat2, this._myHeadCollisionCheckParams, collisionRuntimeParams);
        if (!collisionRuntimeParams.myHorizontalMovementCanceled && !collisionRuntimeParams.myVerticalMovementCanceled) {
          if (!backupVerticalMovementReduceEnabled && collisionRuntimeParams.myHasReducedVerticalMovement) {
            this._myIsHeadColliding = true;
            headReducedVerticalMovementFeetAdjustment = true;
          } else {
            this._myIsHeadColliding = false;
          }
          newPositionHead.vec3_copy(collisionRuntimeParams.myNewPosition);
        } else {
          this._myIsHeadColliding = true;
        }
      } else if (isHeadFar) {
        this._myIsHeadColliding = true;
      }
      firstHeadCollidingCheckDone = true;
    } while (this._myIsHeadColliding && isHeadSynced && this._myResetHeadToFeetOnNextUpdateValidToReal);
    {
      this._myHeadCollisionCheckParams.myHorizontalBlockLayerFlags.copy(backupHorizontalBlockLayerFlags);
      this._myHeadCollisionCheckParams.myVerticalBlockLayerFlags.copy(backupVerticalBlockLayerFlags);
      this._myHeadCollisionCheckParams.myVerticalMovementReduceEnabled = backupVerticalMovementReduceEnabled;
      this._myHeadCollisionCheckParams.myGroundAngleToIgnore = backupGroundAngleToIgnore;
      this._myHeadCollisionCheckParams.myGroundAngleToIgnoreWithPerceivedAngle = backupGroundAngleToIgnoreWithPerceivedAngle;
      this._myHeadCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreHeight = backupHorizontalMovementGroundAngleIgnoreHeight;
      this._myHeadCollisionCheckParams.myHorizontalPositionGroundAngleIgnoreHeight = backupHorizontalPositionGroundAngleIgnoreHeight;
      this._myHeadCollisionCheckParams.myHorizontalMovementGroundAngleIgnoreMaxMovementLeft = backupHorizontalMovementGroundAngleIgnoreMaxMovementLeft;
    }
    if (isHeadSynced) {
      this._myResetHeadToFeetOnNextUpdateValidToReal = false;
      this._myResetHeadToFeetDirty = false;
    }
    if (this._myParams.myAlwaysSyncHeadPositionWithReal) {
      newPositionHead.vec3_copy(positionReal);
    }
    const backupIsHeadColliding = this._myIsHeadColliding;
    if (headReducedVerticalMovementFeetAdjustment) {
      this._myIsHeadColliding = false;
    }
    if (isHeadSynced) {
      if (this.isSynced(this._myParams.mySyncPositionHeadFlagMap) || this._myParams.myAlwaysSyncHeadPositionWithReal || this.isSynced(this._myParams.mySyncPositionFlagMap) && this._myParams.myAlwaysSyncPositionWithReal) {
        this._myValidPositionHead.vec3_copy(newPositionHead);
        this._myValidPositionHeadBackupForResetToFeet.vec3_copy(this._myValidPositionHead);
      }
    }
    if (headReducedVerticalMovementFeetAdjustment) {
      this._myIsHeadColliding = backupIsHeadColliding;
    }
  }
  _debugUpdate(dt) {
    Globals.getDebugVisualManager(this._myParams.myEngine).drawPoint(0, this._myValidPosition, vec4_create(1, 0, 0, 1), 0.05);
    Globals.getDebugVisualManager(this._myParams.myEngine).drawLineEnd(0, this._myValidPosition, this.getPositionReal(), vec4_create(1, 0, 0, 1), 0.05);
    Globals.getDebugVisualManager(this._myParams.myEngine).drawLine(0, this._myValidPosition, this._myValidRotationQuat.quat_getForward(), 0.15, vec4_create(0, 1, 0, 1), 0.025);
    Globals.getDebugVisualManager(this._myParams.myEngine).drawPoint(0, this._myValidPositionHead, vec4_create(1, 1, 0, 1), 0.05);
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion_rotate.js
var PlayerLocomotionRotateParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myPlayerTransformManager = null;
    this.myHorizontalRotationEnabled = true;
    this.myVerticalRotationEnabled = true;
    this.myMaxRotationSpeed = 0;
    this.myIsSnapTurn = false;
    this.mySnapTurnOnlyVR = false;
    this.mySnapTurnAngle = 0;
    this.mySmoothSnapEnabled = false;
    this.mySmoothSnapSpeedDegrees = 0;
    this.myRotationMinStickIntensityThreshold = 0;
    this.mySnapTurnActivateThreshold = 0;
    this.mySnapTurnResetThreshold = 0;
    this.myClampVerticalAngle = true;
    this.myMaxVerticalAngle = 89;
    this.myHandedness = Handedness.RIGHT;
    this.myEngine = engine;
  }
};
var PlayerLocomotionRotate = class {
  constructor(params) {
    this._myParams = params;
    this._mySnapCharge = false;
    this._mySmoothSnapHorizontalRunning = false;
    this._mySmoothSnapHorizontalAngleToPerform = 0;
    this._mySmoothSnapVerticalRunning = false;
    this._mySmoothSnapVerticalAngleToPerform = 0;
  }
  start() {
  }
  stop() {
    this._mySmoothSnapHorizontalRunning = false;
    this._mySmoothSnapHorizontalAngleToPerform = 0;
    this._mySmoothSnapVerticalRunning = false;
    this._mySmoothSnapVerticalAngleToPerform = 0;
  }
  getParams() {
    return this._myParams;
  }
  update(dt) {
    if (this._myParams.myHorizontalRotationEnabled) {
      this._rotateHeadHorizontally(dt);
    }
    if (this._myParams.myVerticalRotationEnabled && this._myParams.myPlayerTransformManager.getPlayerHeadManager().canRotateHead()) {
      this._rotateHeadVertically(dt);
    }
  }
  _rotateHeadHorizontally(dt) {
  }
  _rotateHeadVertically(dt) {
  }
};
PlayerLocomotionRotate.prototype._rotateHeadHorizontally = function() {
  let playerRotationQuat = quat_create();
  let playerUp = vec3_create();
  let headRotation = quat_create();
  return function _rotateHeadHorizontally(dt) {
    playerUp = this._myParams.myPlayerTransformManager.getRotationQuat(playerRotationQuat).quat_getUp(playerUp);
    headRotation.quat_identity();
    let axes = Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
    if (!this._myParams.myIsSnapTurn || this._myParams.mySnapTurnOnlyVR && !XRUtils.isSessionActive(this._myParams.myEngine)) {
      if (Math.abs(axes[0]) > this._myParams.myRotationMinStickIntensityThreshold) {
        let rotationIntensity = -axes[0];
        let speed = Math.pp_lerp(0, this._myParams.myMaxRotationSpeed, Math.abs(rotationIntensity)) * Math.pp_sign(rotationIntensity);
        headRotation.quat_fromAxis(speed * dt, playerUp);
      }
    } else {
      if (!this._mySnapCharge) {
        if (Math.abs(axes.vec2_length()) < this._myParams.mySnapTurnResetThreshold) {
          this._mySnapCharge = true;
        }
      } else if (!this._mySmoothSnapHorizontalRunning) {
        if (Math.abs(axes[0]) > this._myParams.mySnapTurnActivateThreshold) {
          let angleToRotate = -Math.pp_sign(axes[0]) * this._myParams.mySnapTurnAngle;
          if (!this._myParams.mySmoothSnapEnabled) {
            headRotation.quat_fromAxis(angleToRotate, playerUp);
          } else {
            this._mySmoothSnapHorizontalRunning = true;
            this._mySmoothSnapHorizontalAngleToPerform = angleToRotate;
          }
          this._mySnapCharge = false;
        }
      }
    }
    if (this._mySmoothSnapHorizontalRunning) {
      let angleToRotate = Math.pp_sign(this._mySmoothSnapHorizontalAngleToPerform) * (this._myParams.mySmoothSnapSpeedDegrees * dt);
      if (Math.abs(angleToRotate) > Math.abs(this._mySmoothSnapHorizontalAngleToPerform) - Math.PP_EPSILON) {
        angleToRotate = this._mySmoothSnapHorizontalAngleToPerform;
      }
      headRotation.quat_fromAxis(angleToRotate, playerUp);
      this._mySmoothSnapHorizontalAngleToPerform -= angleToRotate;
      if (Math.abs(this._mySmoothSnapHorizontalAngleToPerform) < Math.PP_EPSILON) {
        this._mySmoothSnapHorizontalRunning = false;
        this._mySmoothSnapHorizontalAngleToPerform = 0;
      }
    }
    if (headRotation.quat_getAngle() > Math.PP_EPSILON_DEGREES) {
      this._myParams.myPlayerTransformManager.rotateQuat(headRotation);
    }
  };
}();
PlayerLocomotionRotate.prototype._rotateHeadVertically = function() {
  let headForward = vec3_create();
  let headUp = vec3_create();
  let playerRotationQuat = quat_create();
  let referenceUp = vec3_create();
  let referenceUpNegate = vec3_create();
  let referenceRight = vec3_create();
  let newUp = vec3_create();
  let headRotation = quat_create();
  return function _rotateHeadVertically(dt) {
    let head = this._myParams.myPlayerTransformManager.getPlayerHeadManager().getHead();
    headForward = head.pp_getForward(headForward);
    headUp = head.pp_getUp(headUp);
    referenceUp = this._myParams.myPlayerTransformManager.getRotationRealQuat(playerRotationQuat).quat_getUp(referenceUp);
    referenceUpNegate = referenceUp.vec3_negate(referenceUpNegate);
    referenceRight = headForward.vec3_cross(referenceUp, referenceRight);
    let minAngle = 1;
    if (headForward.vec3_angle(referenceUp) < minAngle) {
      referenceRight = headUp.vec3_negate(referenceRight).vec3_cross(referenceUp, referenceRight);
    } else if (headForward.vec3_angle(referenceUpNegate) < minAngle) {
      referenceRight = headUp.vec3_cross(referenceUp, referenceRight);
    } else if (!headUp.vec3_isConcordant(referenceUp)) {
      referenceRight.vec3_negate(referenceRight);
    }
    referenceRight.vec3_normalize(referenceRight);
    let axes = Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
    let angleToRotate = 0;
    if (!this._myParams.myIsSnapTurn || this._myParams.mySnapTurnOnlyVR && !XRUtils.isSessionActive(this._myParams.myEngine)) {
      if (Math.abs(axes[1]) > this._myParams.myRotationMinStickIntensityThreshold) {
        let rotationIntensity = axes[1];
        angleToRotate = Math.pp_lerp(0, this._myParams.myMaxRotationSpeed, Math.abs(rotationIntensity)) * Math.pp_sign(rotationIntensity) * dt;
      }
    } else {
      if (!this._mySnapCharge) {
        if (Math.abs(axes.vec2_length()) < this._myParams.mySnapTurnResetThreshold) {
          this._mySnapCharge = true;
        }
      } else if (!this._mySmoothSnapVerticalRunning) {
        if (Math.abs(axes[1]) > this._myParams.mySnapTurnActivateThreshold) {
          angleToRotate = Math.pp_sign(axes[1]) * this._myParams.mySnapTurnAngle;
          let angleWithUp = Math.pp_angleClamp(headUp.vec3_angleSigned(referenceUp, referenceRight));
          let snapStep = Math.round(angleWithUp / this._myParams.mySnapTurnAngle);
          let snapAngle = Math.pp_angleClamp(snapStep * this._myParams.mySnapTurnAngle);
          let angleToAlign = -Math.pp_angleDistanceSigned(angleWithUp, snapAngle);
          if (Math.abs(angleToAlign) > 1) {
            if (Math.pp_sign(angleToRotate) == Math.pp_sign(angleToAlign)) {
              angleToRotate = angleToAlign;
            } else {
              angleToRotate = -Math.pp_sign(angleToAlign) * this._myParams.mySnapTurnAngle + angleToAlign;
            }
          } else if (Math.abs(angleToAlign) > Math.PP_EPSILON_DEGREES) {
            angleToRotate += angleToAlign;
          }
          if (this._myParams.mySmoothSnapEnabled) {
            this._mySmoothSnapVerticalRunning = true;
            this._mySmoothSnapVerticalAngleToPerform = angleToRotate;
          }
          this._mySnapCharge = false;
        }
      }
    }
    if (this._mySmoothSnapVerticalRunning) {
      angleToRotate = Math.pp_sign(this._mySmoothSnapVerticalAngleToPerform) * (this._myParams.mySmoothSnapSpeedDegrees * dt);
      if (Math.abs(angleToRotate) > Math.abs(this._mySmoothSnapVerticalAngleToPerform) - Math.PP_EPSILON) {
        angleToRotate = this._mySmoothSnapVerticalAngleToPerform;
      }
      this._mySmoothSnapVerticalAngleToPerform -= angleToRotate;
      if (Math.abs(this._mySmoothSnapVerticalAngleToPerform) < Math.PP_EPSILON) {
        this._mySmoothSnapVerticalRunning = false;
        this._mySmoothSnapVerticalAngleToPerform = 0;
      }
    }
    if (angleToRotate != 0) {
      headRotation.quat_fromAxis(angleToRotate, referenceRight);
      this._myParams.myPlayerTransformManager.getPlayerHeadManager().rotateHeadQuat(headRotation);
      if (this._myParams.myClampVerticalAngle) {
        let maxVerticalAngle = Math.max(0, this._myParams.myMaxVerticalAngle - 1e-4);
        newUp = head.pp_getUp(newUp);
        let angleWithUp = Math.pp_angleClamp(newUp.vec3_angleSigned(referenceUp, referenceRight));
        if (Math.abs(angleWithUp) > maxVerticalAngle) {
          let fixAngle = (Math.abs(angleWithUp) - maxVerticalAngle) * Math.pp_sign(angleWithUp);
          headRotation.quat_fromAxis(fixAngle, referenceRight);
          this._myParams.myPlayerTransformManager.getPlayerHeadManager().rotateHeadQuat(headRotation);
        }
      }
    }
  };
}();

// dist/pp/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion_movement.js
var PlayerLocomotionMovementRuntimeParams = class {
  constructor() {
    this.myIsFlying = false;
    this.myGravitySpeed = 0;
    this.myIsTeleportDetecting = false;
    this.myIsTeleporting = false;
    this.myTeleportJustPerformed = false;
  }
};
var PlayerLocomotionMovement = class {
  constructor(locomotionRuntimeParams) {
    this._myLocomotionRuntimeParams = locomotionRuntimeParams;
    this._myActive = false;
  }
  getRuntimeParams() {
    return this._myLocomotionRuntimeParams;
  }
  start() {
  }
  stop() {
  }
  setActive(active) {
    this._myActive = active;
  }
  isActive() {
    return this._myActive;
  }
  canStop() {
    return true;
  }
};

// dist/pp/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion.js
import { Emitter as Emitter13, PhysXComponent as PhysXComponent10 } from "@wonderlandengine/api";

// dist/pp/input/gamepad/cauldron/gamepad_utils.js
var _mySimultaneousPressMaxDelay = 0.15;
var _mySimultaneousTouchMaxDelay = 0.15;
function setSimultaneousPressMaxDelay(simultaneousPressMaxDelay) {
  _mySimultaneousPressMaxDelay = simultaneousPressMaxDelay;
}
function setSimultaneousTouchMaxDelay(simultaneousTouchMaxDelay) {
  _mySimultaneousTouchMaxDelay = simultaneousTouchMaxDelay;
}
function getSimultaneousPressMaxDelay() {
  return _mySimultaneousPressMaxDelay;
}
function getSimultaneousTouchMaxDelay() {
  return _mySimultaneousTouchMaxDelay;
}
function isAnyButtonPressStart(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let atLeastOneButtonPressStart = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (button.isPressStart(multiplePressCount)) {
        atLeastOneButtonPressStart = true;
        break;
      }
    }
    if (atLeastOneButtonPressStart) {
      break;
    }
  }
  return atLeastOneButtonPressStart;
}
function areButtonsPressStart(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let areButtonPressedRecently = true;
  let atLeastOneButtonPressStart = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (!(button.myPressed && (multiplePressCount == null || button.myMultiplePressStartCount == multiplePressCount) && button.myTimePressed < _mySimultaneousPressMaxDelay)) {
        areButtonPressedRecently = false;
        break;
      }
      if (button.isPressStart(multiplePressCount)) {
        atLeastOneButtonPressStart = true;
      }
    }
    if (!areButtonPressedRecently) {
      break;
    }
  }
  return areButtonPressedRecently && atLeastOneButtonPressStart;
}
function isAnyButtonPressEnd(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let atLeastOneButtonPressEnd = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (button.isPressEnd(multiplePressCount)) {
        atLeastOneButtonPressEnd = true;
        break;
      }
    }
    if (atLeastOneButtonPressEnd) {
      break;
    }
  }
  return atLeastOneButtonPressEnd;
}
function areButtonsPressEnd(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let areButtonNotPressedRecently = true;
  let atLeastOneButtonPressEnd = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (!(!button.myPressed && (multiplePressCount == null || button.myMultiplePressEndCount == multiplePressCount) && button.myTimeNotPressed < _mySimultaneousPressMaxDelay)) {
        areButtonNotPressedRecently = false;
        break;
      }
      if (button.isPressEnd(multiplePressCount)) {
        atLeastOneButtonPressEnd = true;
      }
    }
    if (!areButtonNotPressedRecently) {
      break;
    }
  }
  return areButtonNotPressedRecently && atLeastOneButtonPressEnd;
}
function isAnyButtonTouchStart(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let atLeastOneButtonTouchStart = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (button.isTouchStart(multiplePressCount)) {
        atLeastOneButtonTouchStart = true;
        break;
      }
    }
    if (atLeastOneButtonTouchStart) {
      break;
    }
  }
  return atLeastOneButtonTouchStart;
}
function areButtonsTouchStart(...gamepadButtonIDsList) {
  let multipleTouchCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multipleTouchCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let areButtonTouchedRecently = true;
  let atLeastOneButtonTouchStart = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (!(button.myTouched && (multipleTouchCount == null || button.myMultipleTouchStartCount == multipleTouchCount) && button.myTimeTouched < _mySimultaneousTouchMaxDelay)) {
        areButtonTouchedRecently = false;
        break;
      }
      if (button.isTouchStart(multipleTouchCount)) {
        atLeastOneButtonTouchStart = true;
      }
    }
    if (!areButtonTouchedRecently) {
      break;
    }
  }
  return areButtonTouchedRecently && atLeastOneButtonTouchStart;
}
function isAnyButtonTouchEnd(...gamepadButtonIDsList) {
  let multiplePressCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multiplePressCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let atLeastOneButtonTouchEnd = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (button.isTouchEnd(multiplePressCount)) {
        atLeastOneButtonTouchEnd = true;
        break;
      }
    }
    if (atLeastOneButtonTouchEnd) {
      break;
    }
  }
  return atLeastOneButtonTouchEnd;
}
function areButtonsTouchEnd(...gamepadButtonIDsList) {
  let multipleTouchCount = null;
  let realGamepadButtonIDsList = gamepadButtonIDsList;
  if (!isNaN(gamepadButtonIDsList[0])) {
    multipleTouchCount = gamepadButtonIDsList[0];
    realGamepadButtonIDsList = gamepadButtonIDsList.slice(1);
  }
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    if (gamepadButtonIDs.length == 1) {
      for (let key in GamepadButtonID) {
        gamepadButtonIDs.push(GamepadButtonID[key]);
      }
    }
  }
  let areButtonNotTouchedRecently = true;
  let atLeastOneButtonTouchEnd = false;
  for (let gamepadButtonIDs of realGamepadButtonIDsList) {
    let gamepad = gamepadButtonIDs[0];
    for (let i = 1; i < gamepadButtonIDs.length; i++) {
      let buttonID = gamepadButtonIDs[i];
      let button = gamepad.getButtonInfo(buttonID);
      if (!(!button.myTouched && (multipleTouchCount == null || button.myMultipleTouchEndCount == multipleTouchCount) && button.myTimeNotTouched < _mySimultaneousTouchMaxDelay)) {
        areButtonNotTouchedRecently = false;
        break;
      }
      if (button.isTouchEnd(multipleTouchCount)) {
        atLeastOneButtonTouchEnd = true;
      }
    }
    if (!areButtonNotTouchedRecently) {
      break;
    }
  }
  return areButtonNotTouchedRecently && atLeastOneButtonTouchEnd;
}
var GamepadUtils = {
  setSimultaneousPressMaxDelay,
  setSimultaneousTouchMaxDelay,
  getSimultaneousPressMaxDelay,
  getSimultaneousTouchMaxDelay,
  isAnyButtonPressStart,
  areButtonsPressStart,
  isAnyButtonPressEnd,
  areButtonsPressEnd,
  isAnyButtonTouchStart,
  areButtonsTouchStart,
  isAnyButtonTouchEnd,
  areButtonsTouchEnd
};

// dist/pp/gameplay/experimental/locomotion/legacy/locomotion/player_obscure_manager.js
var PlayerObscureManagerParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myPlayerTransformManager = null;
    this.myPlayerLocomotionTeleport = null;
    this.myEnabled = true;
    this.myObscureObject = null;
    this.myObscureMaterial = null;
    this.myObscureRadius = 0;
    this.myObscureFadeOutSeconds = 0.1;
    this.myObscureFadeInSeconds = 0.1;
    this.myObscureFadeEasingFunction = EasingFunction.linear;
    this.myObscureIfPositionHeadNotValid = false;
    this.myDistanceToStartObscureWhenHeadColliding = 0;
    this.myDistanceToStartObscureWhenBodyColliding = 0;
    this.myDistanceToStartObscureWhenFloating = 0;
    this.myDistanceToStartObscureWhenFar = 0;
    this.myRelativeDistanceToMaxObscureWhenHeadColliding = 0;
    this.myRelativeDistanceToMaxObscureWhenBodyColliding = 0;
    this.myRelativeDistanceToMaxObscureWhenFloating = 0;
    this.myRelativeDistanceToMaxObscureWhenFar = 0;
    this.myObscureLevelRelativeDistanceEasingFunction = EasingFunction.linear;
    this.myDisableObscureWhileTeleporting = true;
    this.myDisableObscureWhileTeleportingDuration = null;
    this.myEngine = engine;
  }
};
var PlayerObscureManager = class {
  constructor(params) {
    this._myParams = params;
    this._myObscureMaterial = null;
    this._myObscureParentObject = null;
    this._myCurrentObscureLevel = 0;
    this._myTargetObscureLevel = 0;
    this._myLastTargetObscureLevel = null;
    this._myLastIsFadingIn = null;
    this._myInstantObscureFramesCount = 0;
    this._myFadeTimer = new Timer(0, false);
    this._myDisableObscureWhileTeleportingTimer = null;
    if (this._myParams.myDisableObscureWhileTeleportingDuration != null) {
      this._myDisableObscureWhileTeleportingTimer = new Timer(this._myParams.myDisableObscureWhileTeleportingDuration);
    } else {
      this._myDisableObscureWhileTeleportingTimer = new Timer(0, false);
    }
    this._myFSM = new FSM();
    this._myFSM.addState("init");
    this._myFSM.addState("inactive");
    this._myFSM.addState("idle", this._idleUpdate.bind(this));
    this._myFSM.addState("fading", this._fadingUpdate.bind(this));
    this._myFSM.addTransition("init", "inactive", "end", this._setObscureLevel.bind(this, 0));
    this._myFSM.addTransition("inactive", "idle", "start");
    this._myFSM.addTransition("idle", "fading", "fade", this._startFading.bind(this));
    this._myFSM.addTransition("fading", "idle", "done", this._fadingDone.bind(this));
    this._myFSM.addTransition("inactive", "inactive", "stop", this._setObscureLevel.bind(this, 0));
    this._myFSM.addTransition("idle", "inactive", "stop", this._setObscureLevel.bind(this, 0));
    this._myFSM.addTransition("fading", "inactive", "stop", this._setObscureLevel.bind(this, 0));
    this._myFSM.init("init");
    this._setupVisuals();
    this._myFSM.perform("end");
    this._myActive = false;
    this.setActive(true);
    this._myDestroyed = false;
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      if (this._myActive) {
        XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), false, false, this._myParams.myEngine);
      } else {
        XRUtils.unregisterSessionStartEndEventListeners(this, this._myParams.myEngine);
        this._setObscureLevel(0);
      }
    }
  }
  isActive() {
    return this._myActive;
  }
  start() {
    this._myFSM.perform("start");
  }
  stop() {
    this._myFSM.perform("stop");
  }
  getParams() {
    return this._myParams;
  }
  update(dt) {
    if (!this._myActive)
      return;
    if (!this._myParams.myPlayerLocomotionTeleport.isTeleporting()) {
      if (this._myParams.myDisableObscureWhileTeleportingDuration != null) {
        this._myDisableObscureWhileTeleportingTimer.start();
      } else {
        this._myDisableObscureWhileTeleportingTimer.reset();
      }
    } else {
      this._myDisableObscureWhileTeleportingTimer.update(dt);
    }
    this._myObscureParentObject.pp_resetTransformLocal();
    this._updateObscured();
    this._myFSM.update(dt);
    this._setObscureVisible(this.isObscured());
    if (this._myInstantObscureFramesCount > 0) {
      this._myInstantObscureFramesCount--;
    }
  }
  isStarted() {
    return !this._myFSM.isInState("inactive");
  }
  isObscured() {
    return this._myCurrentObscureLevel > 0;
  }
  isFading() {
    return this._myFSM.isInState("fading");
  }
  isFadingIn() {
    return this.isFading() && this._myCurrentObscureLevel > this._myTargetObscureLevel;
  }
  isFadingOut() {
    return this.isFading() && this._myCurrentObscureLevel <= this._myTargetObscureLevel;
  }
  getObscureLevel() {
    return this._myCurrentObscureLevel;
  }
  getTargetObscureLevel() {
    return this._myTargetObscureLevel;
  }
  getCurrentObscureLevel() {
    return this._myCurrentObscureLevel;
  }
  overrideObscureLevel(obscureLevel, instantFade = false) {
    if (!this._myActive)
      return;
    this._myObscureLevelOverride = obscureLevel;
    if (instantFade && this.isStarted()) {
      this._setObscureLevel(obscureLevel);
    }
  }
  resetObscureLevelOverride() {
    this._myObscureLevelOverride = null;
  }
  _idleUpdate(dt) {
    if (Math.abs(this._myTargetObscureLevel - this._myCurrentObscureLevel) > Math.PP_EPSILON) {
      if (this._myInstantObscureFramesCount > 0) {
        this._setObscureAlpha(this._myTargetObscureLevel);
        this._myCurrentObscureLevel = this._myTargetObscureLevel;
      } else {
        this._myFSM.perform("fade");
      }
    }
  }
  _fadingUpdate(dt) {
    if (Math.abs(this._myTargetObscureLevel - this._myCurrentObscureLevel) <= Math.PP_EPSILON) {
      this._myFSM.perform("done");
      return;
    }
    if (this._myLastTargetObscureLevel != this._myTargetObscureLevel) {
      this._refreshFadeTimer();
      this._myLastTargetObscureLevel = this._myTargetObscureLevel;
    }
    this._myFadeTimer.update(dt);
    if (this._myInstantObscureFramesCount > 0) {
      this._myFadeTimer.end();
    }
    let newObscureLevel = this._myParams.myObscureFadeEasingFunction(this._myFadeTimer.getPercentage());
    let isFadingIn = this._myCurrentObscureLevel > this._myTargetObscureLevel;
    if (!isFadingIn) {
      newObscureLevel = Math.min(newObscureLevel, this._myTargetObscureLevel);
    } else {
      newObscureLevel = Math.pp_clamp(1 - newObscureLevel, 0, 1);
      newObscureLevel = Math.max(newObscureLevel, this._myTargetObscureLevel);
    }
    this._setObscureAlpha(newObscureLevel);
    this._myCurrentObscureLevel = newObscureLevel;
    if (Math.abs(this._myTargetObscureLevel - this._myCurrentObscureLevel) <= Math.PP_EPSILON || this._myFadeTimer.isDone()) {
      this._myFSM.perform("done");
    }
  }
  _startFading() {
    this._myLastTargetObscureLevel = null;
    this._myLastIsFadingIn = null;
  }
  _fadingDone() {
    this._setObscureLevel(this._myTargetObscureLevel);
  }
  _refreshFadeTimer() {
    let isFadingIn = this._myCurrentObscureLevel > this._myTargetObscureLevel;
    if (this._myLastIsFadingIn != isFadingIn) {
      this._setFadeTimerToObscureLevel(isFadingIn);
    }
    this._myLastIsFadingIn = isFadingIn;
  }
  _setFadeTimerToObscureLevel(isFadingIn) {
    let percentage = 0;
    let closestPercentage = 0;
    let steps = 1e3;
    let increment = 1 / steps;
    while (percentage < 1) {
      if (Math.abs(this._myParams.myObscureFadeEasingFunction(percentage) - this._myCurrentObscureLevel) < Math.abs(this._myParams.myObscureFadeEasingFunction(closestPercentage) - this._myCurrentObscureLevel)) {
        closestPercentage = percentage;
      }
      percentage += increment;
    }
    if (Math.abs(this._myParams.myObscureFadeEasingFunction(1) - this._myCurrentObscureLevel) < Math.abs(this._myParams.myObscureFadeEasingFunction(closestPercentage) - this._myCurrentObscureLevel)) {
      closestPercentage = 1;
    }
    if (isFadingIn) {
      this._myFadeTimer.start(this._myParams.myObscureFadeInSeconds);
      this._myFadeTimer.setPercentage(Math.pp_clamp(1 - closestPercentage, 0, 1));
    } else {
      this._myFadeTimer.start(this._myParams.myObscureFadeOutSeconds);
      this._myFadeTimer.setPercentage(Math.pp_clamp(closestPercentage, 0, 1));
    }
  }
  _setObscureLevel(obscureLevel) {
    this._myTargetObscureLevel = obscureLevel;
    this._myCurrentObscureLevel = obscureLevel;
    this._setObscureAlpha(obscureLevel);
    this._setObscureVisible(this.isObscured());
  }
  _setObscureAlpha(alpha) {
    if (this._myParams.myObscureObject == null) {
      MaterialUtils.setAlpha(this._myObscureMaterial, alpha);
    } else {
      MaterialUtils.setObjectAlpha(this._myParams.myObscureObject, alpha);
    }
  }
  _updateObscured() {
    this._myTargetObscureLevel = 0;
    if (this._myParams.myEnabled) {
      if (this._myObscureLevelOverride != null) {
        this._myTargetObscureLevel = this._myObscureLevelOverride;
      } else if (!this._myParams.myPlayerLocomotionTeleport.isTeleporting() || !this._myParams.myDisableObscureWhileTeleporting || this._myDisableObscureWhileTeleportingTimer.isDone()) {
        if (!this._myParams.myPlayerTransformManager.isPositionHeadValid() && this._myParams.myObscureIfPositionHeadNotValid) {
          let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(1);
          this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
        } else if (this._myParams.myPlayerTransformManager.isHeadColliding()) {
          let distance2 = this._myParams.myPlayerTransformManager.getDistanceToRealHead();
          let relativeDistance = distance2 - this._myParams.myDistanceToStartObscureWhenHeadColliding;
          if (relativeDistance >= 0) {
            let relativeDistancePercentage = Math.pp_clamp(relativeDistance / this._myParams.myRelativeDistanceToMaxObscureWhenHeadColliding, 0, 1);
            if (isNaN(relativeDistancePercentage)) {
              relativeDistancePercentage = 1;
            }
            let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(relativeDistancePercentage);
            this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
          }
        }
        if (this._myParams.myPlayerTransformManager.isBodyColliding()) {
          let distance2 = this._myParams.myPlayerTransformManager.getDistanceToReal();
          let relativeDistance = distance2 - this._myParams.myDistanceToStartObscureWhenBodyColliding;
          if (relativeDistance >= 0) {
            let relativeDistancePercentage = Math.pp_clamp(relativeDistance / this._myParams.myRelativeDistanceToMaxObscureWhenBodyColliding, 0, 1);
            if (isNaN(relativeDistancePercentage)) {
              relativeDistancePercentage = 1;
            }
            let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(relativeDistancePercentage);
            this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
          }
        }
        if (this._myParams.myPlayerTransformManager.isFloating()) {
          let distance2 = this._myParams.myPlayerTransformManager.getDistanceToReal();
          let relativeDistance = distance2 - this._myParams.myDistanceToStartObscureWhenFloating;
          if (relativeDistance >= 0) {
            let relativeDistancePercentage = Math.pp_clamp(relativeDistance / this._myParams.myRelativeDistanceToMaxObscureWhenFloating, 0, 1);
            if (isNaN(relativeDistancePercentage)) {
              relativeDistancePercentage = 1;
            }
            let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(relativeDistancePercentage);
            this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
          }
        }
        if (this._myParams.myPlayerTransformManager.isFar()) {
          let distance2 = this._myParams.myPlayerTransformManager.getDistanceToReal();
          let relativeDistance = distance2 - this._myParams.myDistanceToStartObscureWhenFar;
          if (relativeDistance >= 0) {
            let relativeDistancePercentage = Math.pp_clamp(relativeDistance / this._myParams.myRelativeDistanceToMaxObscureWhenFar, 0, 1);
            if (isNaN(relativeDistancePercentage)) {
              relativeDistancePercentage = 1;
            }
            let targetObscureLevel = this._myParams.myObscureLevelRelativeDistanceEasingFunction(relativeDistancePercentage);
            this._myTargetObscureLevel = Math.max(this._myTargetObscureLevel, targetObscureLevel);
          }
        }
      }
    }
  }
  _setupVisuals() {
    this._myObscureMaterial = null;
    if (this._myParams.myObscureMaterial != null) {
      this._myObscureMaterial = this._myParams.myObscureMaterial;
    } else {
      this._myObscureMaterial = Globals.getDefaultMaterials(this._myParams.myEngine).myFlatTransparentNoDepth.clone();
      this._myObscureMaterial.color = vec4_create(0, 0, 0, 1);
    }
    this._myObscureParentObject = Globals.getPlayerObjects(this._myParams.myEngine).myCauldron.pp_addChild();
    let obscureVisualParams = new VisualMeshParams(this._myParams.myEngine);
    obscureVisualParams.myMesh = Globals.getDefaultMeshes(this._myParams.myEngine).myInvertedSphere;
    obscureVisualParams.myMaterial = this._myParams.myObscureMaterial != null ? this._myParams.myObscureMaterial : this._myObscureMaterial;
    obscureVisualParams.myParent = this._myObscureParentObject;
    obscureVisualParams.myLocal = true;
    obscureVisualParams.myTransform.mat4_setScale(vec3_create(this._myParams.myObscureRadius, this._myParams.myObscureRadius, this._myParams.myObscureRadius));
    this._myObscureVisual = new VisualMesh(obscureVisualParams);
    if (this._myParams.myObscureObject != null) {
      this._myParams.myObscureObject.pp_setParent(this._myObscureParentObject, false);
      this._myParams.myObscureObject.pp_resetTransformLocal();
    }
    this._setObscureVisible(false);
  }
  _setObscureVisible(visible) {
    if (this._myParams.myObscureObject == null) {
      this._myObscureVisual.setVisible(visible);
    } else {
      this._myObscureVisual.setVisible(false);
      this._myParams.myObscureObject.pp_setActive(visible);
    }
    if (visible) {
      this._myObscureParentObject.pp_setParent(this._myParams.myPlayerTransformManager.getHead(), false);
    } else {
      this._myObscureParentObject.pp_setParent(Globals.getPlayerObjects(this._myParams.myEngine)?.myCauldron, false);
    }
  }
  _onXRSessionStart() {
    this._myInstantObscureFramesCount = 5;
  }
  _onXRSessionEnd() {
    this._myInstantObscureFramesCount = 5;
  }
  destroy() {
    this._myDestroyed = true;
    this._myObscureVisual.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_detection_state.js
import { PhysXComponent as PhysXComponent9 } from "@wonderlandengine/api";

// dist/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_detection_visualizer.js
var PlayerLocomotionTeleportDetectionVisualizerParams = class {
  constructor() {
    this.myTeleportValidMaterial = null;
    this.myTeleportInvalidMaterial = null;
    this.myTeleportPositionObject = null;
    this.myTeleportPositionObjectRotateWithHead = true;
    this.myTeleportParableLineEndOffset = 0.05;
    this.myTeleportParableMinVerticalDistanceToShowVerticalLine = 0.8;
    this.myTeleportParableShowVerticalLineMaxLength = 0.3;
    this.myTeleportParablePositionUpOffset = 0.05;
    this.myTeleportParablePositionVisualAlignOnSurface = true;
    this.myVisualTeleportPositionLerpEnabled = true;
    this.myVisualTeleportPositionLerpFactor = 10;
    this.myVisualTeleportPositionMinDistanceToResetLerp = 5e-3;
    this.myVisualTeleportPositionMinDistanceToLerp = 0.15;
    this.myVisualTeleportPositionMaxDistanceToLerp = 5;
    this.myVisualTeleportPositionMinDistanceToCloseLerpFactor = 0.02;
    this.myVisualTeleportPositionCloseLerpFactor = 30;
    this.myVisualTeleportPositionMinAngleDistanceToResetLerp = 0.1;
    this.myVisualTeleportPositionMinAngleDistanceToLerp = 1;
    this.myVisualTeleportPositionMaxAngleDistanceToLerp = 180;
  }
};
var PlayerLocomotionTeleportDetectionVisualizer = class {
  constructor(teleportParams, teleportRuntimeParams, detectionRuntimeParams) {
    this._myDetectionRuntimeParams = detectionRuntimeParams;
    this._myTeleportParams = teleportParams;
    this._myTeleportRuntimeParams = teleportRuntimeParams;
    this._myVisualTeleportTransformQuatReset = true;
    this._myVisualTeleportTransformQuat = quat2_create();
    this._myVisualTeleportTransformPositionLerping = false;
    this._myVisualTeleportTransformRotationLerping = false;
    this._setupVisuals();
    this._myDestroyed = false;
  }
  start() {
  }
  end() {
    this._myVisualTeleportTransformQuatReset = true;
    this._myVisualTeleportTransformPositionLerping = false;
    this._myVisualTeleportTransformRotationLerping = false;
    this._hideTeleportPosition();
  }
  update(dt) {
    if (this._myDetectionRuntimeParams.myTeleportDetectionValid) {
      this._showTeleportPosition(dt);
    } else {
      this._myVisualTeleportTransformQuatReset = true;
      this._myVisualTeleportTransformPositionLerping = false;
      this._myVisualTeleportTransformRotationLerping = false;
      this._hideTeleportPosition();
    }
  }
  _showTeleportPosition(dt) {
    this._showTeleportParable(dt);
  }
  _hideTeleportPosition() {
    for (let visualLine of this._myValidVisualLines) {
      visualLine.setVisible(false);
    }
    for (let visualLine of this._myInvalidVisualLines) {
      visualLine.setVisible(false);
    }
    this._myValidVisualPoint.setVisible(false);
    this._myInvalidVisualPoint.setVisible(false);
    this._myValidVisualVerticalArrow.setVisible(false);
    this._myValidVisualTeleportPositionTorus.setVisible(false);
    this._myValidVisualTeleportPositionTorusInner.setVisible(false);
    if (this._myTeleportParams.myVisualizerParams.myTeleportPositionObject != null) {
      this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setActive(false);
    }
  }
  _addVisualLines(amount) {
    for (let i = 0; i < amount; i++) {
      {
        let visualParams = new VisualLineParams(this._myTeleportParams.myEngine);
        if (this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial != null) {
          visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial;
        } else {
          visualParams.myMaterial = this._myTeleportValidMaterial;
        }
        this._myValidVisualLines.push(new VisualLine(visualParams));
      }
      {
        let visualParams = new VisualLineParams(this._myTeleportParams.myEngine);
        if (this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial != null) {
          visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportInvalidMaterial;
        } else {
          visualParams.myMaterial = this._myTeleportInvalidMaterial;
        }
        this._myInvalidVisualLines.push(new VisualLine(visualParams));
      }
    }
  }
  _showTeleportParablePosition(dt) {
  }
  _showTeleportParable(dt) {
  }
  _setupVisuals() {
  }
  destroy() {
    this._myDestroyed = true;
    for (let visual of this._myValidVisualLines) {
      visual.destroy();
    }
    for (let visual of this._myInvalidVisualLines) {
      visual.destroy();
    }
    this._myValidVisualPoint.destroy();
    this._myInvalidVisualPoint.destroy();
    this._myValidVisualVerticalArrow.destroy();
    this._myValidVisualTeleportPositionTorus.destroy();
    this._myValidVisualTeleportPositionTorusInner.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
PlayerLocomotionTeleportDetectionVisualizer.prototype._setupVisuals = function() {
  let innerTorusPosition = vec3_create();
  return function _setupVisuals() {
    this._myTeleportValidMaterial = Globals.getDefaultMaterials(this._myTeleportParams.myEngine).myFlatOpaque.clone();
    this._myTeleportValidMaterial.color = vec4_create(0, 0.5, 1, 1);
    this._myTeleportInvalidMaterial = Globals.getDefaultMaterials(this._myTeleportParams.myEngine).myFlatOpaque.clone();
    this._myTeleportInvalidMaterial.color = vec4_create(0.75, 0.05, 0, 1);
    this._myValidVisualLines = [];
    this._myInvalidVisualLines = [];
    this._addVisualLines(30);
    {
      let visualParams = new VisualPointParams(this._myTeleportParams.myEngine);
      if (this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial != null) {
        visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial;
      } else {
        visualParams.myMaterial = this._myTeleportValidMaterial;
      }
      this._myValidVisualPoint = new VisualPoint(visualParams);
    }
    {
      let visualParams = new VisualPointParams(this._myTeleportParams.myEngine);
      if (this._myTeleportParams.myVisualizerParams.myTeleportInvalidMaterial != null) {
        visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportInvalidMaterial;
      } else {
        visualParams.myMaterial = this._myTeleportInvalidMaterial;
      }
      this._myInvalidVisualPoint = new VisualPoint(visualParams);
    }
    {
      let visualParams = new VisualArrowParams(this._myTeleportParams.myEngine);
      if (this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial != null) {
        visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial;
      } else {
        visualParams.myMaterial = this._myTeleportValidMaterial;
      }
      this._myValidVisualVerticalArrow = new VisualArrow(visualParams);
    }
    this._myVisualTeleportPositionObject = Globals.getPlayerObjects(this._myTeleportParams.myEngine).myCauldron.pp_addChild();
    {
      let visualParams = new VisualTorusParams(this._myTeleportParams.myEngine);
      visualParams.myRadius = 0.175;
      visualParams.mySegmentsAmount = 24;
      visualParams.mySegmentThickness = 0.02;
      if (this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial != null) {
        visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial;
      } else {
        visualParams.myMaterial = this._myTeleportValidMaterial;
      }
      visualParams.myParent = this._myVisualTeleportPositionObject;
      visualParams.myLocal = true;
      this._myValidVisualTeleportPositionTorus = new VisualTorus(visualParams);
    }
    {
      let visualParams = new VisualTorusParams(this._myTeleportParams.myEngine);
      visualParams.myRadius = 0.04;
      visualParams.mySegmentsAmount = 24;
      visualParams.mySegmentThickness = 0.02;
      if (this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial != null) {
        visualParams.myMaterial = this._myTeleportParams.myVisualizerParams.myTeleportValidMaterial;
      } else {
        visualParams.myMaterial = this._myTeleportValidMaterial;
      }
      visualParams.myParent = this._myVisualTeleportPositionObject;
      visualParams.myLocal = true;
      let visualTorusParams = this._myValidVisualTeleportPositionTorus.getParams();
      let innerTorusCenter = (visualTorusParams.myRadius - visualTorusParams.mySegmentThickness / 2) / 2;
      innerTorusPosition.vec3_set(0, 0, innerTorusCenter);
      visualParams.myTransform.mat4_setPosition(innerTorusPosition);
      this._myValidVisualTeleportPositionTorusInner = new VisualTorus(visualParams);
    }
    if (this._myTeleportParams.myVisualizerParams.myTeleportPositionObject != null) {
      this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setParent(this._myVisualTeleportPositionObject);
      this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_resetTransformLocal();
      this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setActive(false);
    }
    this._hideTeleportPosition();
  };
}();
PlayerLocomotionTeleportDetectionVisualizer.prototype._showTeleportParable = function() {
  let currentPosition = vec3_create();
  let nextPosition = vec3_create();
  let playerRotationQuat = quat_create();
  let playerUp = vec3_create();
  let upDifference = vec3_create();
  return function _showTeleportParable(dt) {
    let showParableDistance = Math.max(this._myDetectionRuntimeParams.myParableDistance - this._myTeleportParams.myVisualizerParams.myTeleportParableLineEndOffset);
    let lastParableIndex = this._myDetectionRuntimeParams.myParable.getPositionIndexByDistance(showParableDistance);
    let lastParableIndexDistance = this._myDetectionRuntimeParams.myParable.getDistance(lastParableIndex);
    if (lastParableIndex + 1 > this._myValidVisualLines.length) {
      this._addVisualLines(lastParableIndex + 1, this._myValidVisualLines.length);
    }
    const usedVisualLines = [];
    for (let i = 0; i <= lastParableIndex; i++) {
      currentPosition = this._myDetectionRuntimeParams.myParable.getPosition(i, currentPosition);
      nextPosition = this._myDetectionRuntimeParams.myParable.getPosition(i + 1, nextPosition);
      let visuaLine = this._myDetectionRuntimeParams.myTeleportPositionValid ? this._myValidVisualLines[i] : this._myInvalidVisualLines[i];
      usedVisualLines.push(visuaLine);
      let currentVisualLineParams = visuaLine.getParams();
      if (i == lastParableIndex) {
        let stepLength = Math.max(0, showParableDistance - lastParableIndexDistance);
        nextPosition = nextPosition.vec3_sub(currentPosition, nextPosition).vec3_normalize(nextPosition);
        nextPosition = currentPosition.vec3_add(nextPosition.vec3_scale(stepLength, nextPosition), nextPosition);
      }
      currentVisualLineParams.setStartEnd(currentPosition, nextPosition);
      currentVisualLineParams.myThickness = 5e-3;
      visuaLine.paramsUpdated();
      visuaLine.setVisible(true);
      if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugShowEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
        Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, currentPosition, vec4_create(1, 0, 0, 1), 0.01);
      }
    }
    for (let visualLine of this._myValidVisualLines) {
      if (usedVisualLines.indexOf(visualLine) == -1) {
        visualLine.setVisible(false);
      }
    }
    for (let visualLine of this._myInvalidVisualLines) {
      if (usedVisualLines.indexOf(visualLine) == -1) {
        visualLine.setVisible(false);
      }
    }
    let visualPoint = this._myDetectionRuntimeParams.myTeleportPositionValid ? this._myValidVisualPoint : this._myInvalidVisualPoint;
    let visualPointParams = visualPoint.getParams();
    visualPointParams.myPosition.vec3_copy(nextPosition);
    visualPointParams.myRadius = 0.01;
    visualPoint.paramsUpdated();
    visualPoint.setVisible(true);
    let unusedVisualPoint = this._myDetectionRuntimeParams.myTeleportPositionValid ? this._myInvalidVisualPoint : this._myValidVisualPoint;
    unusedVisualPoint.setVisible(false);
    if (this._myDetectionRuntimeParams.myTeleportPositionValid) {
      playerUp = this._myTeleportParams.myPlayerTransformManager.getRotationRealQuat(playerRotationQuat).quat_getUp(playerUp);
      upDifference = nextPosition.vec3_sub(this._myTeleportRuntimeParams.myTeleportPosition, upDifference).vec3_componentAlongAxis(playerUp, upDifference);
      let upDistance = upDifference.vec3_valueAlongAxis(playerUp);
      if (upDistance >= this._myTeleportParams.myVisualizerParams.myTeleportParableMinVerticalDistanceToShowVerticalLine) {
        let lineLength = Math.min(upDistance - this._myTeleportParams.myVisualizerParams.myTeleportParableMinVerticalDistanceToShowVerticalLine, this._myTeleportParams.myVisualizerParams.myTeleportParableShowVerticalLineMaxLength);
        let visualArrowParams = this._myValidVisualVerticalArrow.getParams();
        visualArrowParams.myStart.vec3_copy(nextPosition);
        visualArrowParams.myDirection = playerUp.vec3_negate(visualArrowParams.myDirection);
        visualArrowParams.myLength = lineLength;
        visualArrowParams.myThickness = 5e-3;
        visualArrowParams.myArrowThickness = visualPointParams.myRadius;
        visualArrowParams.myArrowLength = visualArrowParams.myArrowThickness * 3.5 / 1.5;
        this._myValidVisualVerticalArrow.paramsUpdated();
        this._myValidVisualVerticalArrow.setVisible(true);
      } else {
        this._myValidVisualVerticalArrow.setVisible(false);
      }
      this._showTeleportParablePosition(dt);
    } else {
      this._myValidVisualTeleportPositionTorus.setVisible(false);
      this._myValidVisualTeleportPositionTorusInner.setVisible(false);
      this._myValidVisualVerticalArrow.setVisible(false);
      if (this._myTeleportParams.myVisualizerParams.myTeleportPositionObject != null) {
        this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setActive(false);
      }
      this._myVisualTeleportTransformQuatReset = true;
      this._myVisualTeleportTransformPositionLerping = false;
      this._myVisualTeleportTransformRotationLerping = false;
    }
  };
}();
PlayerLocomotionTeleportDetectionVisualizer.prototype._showTeleportParablePosition = function() {
  let playerUp = vec3_create();
  let feetRotationQuat = quat_create();
  let parableFirstPosition = vec3_create();
  let parableSecondPosition = vec3_create();
  let parableDirection = vec3_create();
  let visualPosition = vec3_create();
  let visualForward = vec3_create();
  let visualRotationQuat = quat_create();
  let currentVisualTeleportTransformQuat = quat2_create();
  let currentVisualTeleportPosition = vec3_create();
  let currentVisualTeleportRotationQuat = quat_create();
  let differenceRotationQuat = quat_create();
  return function _showTeleportParablePosition(dt) {
    this._myTeleportParams.myPlayerTransformManager.getRotationRealQuat(feetRotationQuat);
    feetRotationQuat.quat_getUp(playerUp);
    visualPosition = this._myTeleportRuntimeParams.myTeleportPosition.vec3_add(playerUp.vec3_scale(this._myTeleportParams.myVisualizerParams.myTeleportParablePositionUpOffset, visualPosition), visualPosition);
    if (!this._myDetectionRuntimeParams.myTeleportForward.vec3_isZero(1e-5)) {
      visualForward.vec3_copy(this._myDetectionRuntimeParams.myTeleportForward);
    } else {
      feetRotationQuat.quat_getForward(visualForward);
    }
    if (!this._myTeleportParams.myVisualizerParams.myTeleportPositionObjectRotateWithHead) {
      parableFirstPosition = this._myDetectionRuntimeParams.myParable.getPosition(0, parableFirstPosition);
      parableSecondPosition = this._myDetectionRuntimeParams.myParable.getPosition(1, parableSecondPosition);
      parableDirection = parableSecondPosition.vec3_sub(parableFirstPosition, parableDirection).vec3_removeComponentAlongAxis(playerUp, parableDirection);
      if (parableDirection.vec3_length() > Math.PP_EPSILON) {
        visualForward = parableDirection.vec3_normalize(visualForward);
      }
    }
    if (this._myTeleportParams.myVisualizerParams.myTeleportParablePositionVisualAlignOnSurface) {
      visualRotationQuat.quat_setUp(this._myDetectionRuntimeParams.myTeleportSurfaceNormal, visualForward);
    } else {
      visualRotationQuat.quat_setUp(playerUp, visualForward);
    }
    this._myVisualTeleportTransformQuat.quat2_setPositionRotationQuat(visualPosition, visualRotationQuat);
    if (this._myVisualTeleportTransformQuatReset || !this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionLerpEnabled) {
      this._myVisualTeleportPositionObject.pp_setTransformQuat(this._myVisualTeleportTransformQuat);
      this._myVisualTeleportTransformQuatReset = false;
    } else {
      currentVisualTeleportTransformQuat = this._myVisualTeleportPositionObject.pp_getTransformQuat(currentVisualTeleportTransformQuat);
      currentVisualTeleportPosition = currentVisualTeleportTransformQuat.quat2_getPosition(currentVisualTeleportPosition);
      currentVisualTeleportRotationQuat = currentVisualTeleportTransformQuat.quat2_getRotationQuat(currentVisualTeleportRotationQuat);
      currentVisualTeleportRotationQuat.quat_rotationToQuat(visualRotationQuat, differenceRotationQuat);
      let positionDistance = currentVisualTeleportPosition.vec3_distance(visualPosition);
      let rotationAngleDistance = differenceRotationQuat.quat_getAngle();
      if ((!this._myVisualTeleportTransformPositionLerping || positionDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinDistanceToResetLerp) && (positionDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinDistanceToLerp || positionDistance > this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMaxDistanceToLerp)) {
        this._myVisualTeleportTransformPositionLerping = false;
        currentVisualTeleportPosition.vec3_copy(visualPosition);
      } else {
        this._myVisualTeleportTransformPositionLerping = true;
        let interpolationFactor = this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionLerpFactor * dt;
        if (positionDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinDistanceToCloseLerpFactor) {
          interpolationFactor = this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionCloseLerpFactor * dt;
        }
        currentVisualTeleportPosition.vec3_lerp(visualPosition, interpolationFactor, currentVisualTeleportPosition);
      }
      if ((!this._myVisualTeleportTransformRotationLerping || rotationAngleDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinAngleDistanceToResetLerp) && (rotationAngleDistance < this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMinAngleDistanceToLerp || positionDistance > this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionMaxAngleDistanceToLerp)) {
        this._myVisualTeleportTransformRotationLerping = false;
        currentVisualTeleportRotationQuat.quat_copy(visualRotationQuat);
      } else {
        let interpolationFactor = this._myTeleportParams.myVisualizerParams.myVisualTeleportPositionLerpFactor * dt;
        this._myVisualTeleportTransformRotationLerping = true;
        currentVisualTeleportRotationQuat.quat_slerp(visualRotationQuat, interpolationFactor, currentVisualTeleportRotationQuat);
      }
      currentVisualTeleportTransformQuat.quat2_setPositionRotationQuat(currentVisualTeleportPosition, currentVisualTeleportRotationQuat);
      this._myVisualTeleportPositionObject.pp_setTransformQuat(currentVisualTeleportTransformQuat);
    }
    if (this._myTeleportParams.myVisualizerParams.myTeleportPositionObject == null) {
      {
        let visualParams = this._myValidVisualTeleportPositionTorus.getParams();
        visualParams.myRadius = 0.175;
        visualParams.mySegmentsAmount = 24;
        visualParams.mySegmentThickness = 0.02;
        this._myValidVisualTeleportPositionTorus.paramsUpdated();
      }
      {
        let visualParams = this._myValidVisualTeleportPositionTorusInner.getParams();
        visualParams.myRadius = 0.04;
        visualParams.mySegmentsAmount = 24;
        visualParams.mySegmentThickness = 0.02;
        this._myValidVisualTeleportPositionTorusInner.paramsUpdated();
      }
      this._myValidVisualTeleportPositionTorus.setVisible(true);
      this._myValidVisualTeleportPositionTorusInner.setVisible(true);
    } else {
      this._myValidVisualTeleportPositionTorus.setVisible(false);
      this._myValidVisualTeleportPositionTorusInner.setVisible(false);
      this._myTeleportParams.myVisualizerParams.myTeleportPositionObject.pp_setActive(true);
    }
    if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugShowEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
      Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, this._myTeleportRuntimeParams.myTeleportPosition, vec4_create(0, 0, 1, 1), 0.02);
    }
  };
}();

// dist/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_parable.js
var PlayerLocomotionTeleportParable = class {
  constructor() {
    this._myStartPosition = vec3_create();
    this._myForward = vec3_create();
    this._myUp = vec3_create();
    this._mySpeed = 0;
    this._myGravity = 0;
    this._myStepLength = 0;
  }
  setStartPosition(startPosition) {
    this._myStartPosition.vec3_copy(startPosition);
  }
  setForward(forward) {
    this._myForward.vec3_copy(forward);
  }
  setUp(up) {
    this._myUp.vec3_copy(up);
  }
  setSpeed(speed) {
    this._mySpeed = speed;
  }
  setGravity(gravity) {
    this._myGravity = gravity;
  }
  setStepLength(stepLength) {
    this._myStepLength = stepLength;
  }
  getPosition(positionIndex, outPosition = vec3_create()) {
  }
  getDistance(positionIndex) {
  }
  getPositionIndexByDistance(distance2) {
  }
  getPositionByDistance(distance2, outPosition = vec3_create()) {
  }
  getDistanceOverFlatDistance(flatDistance, maxParableDistance) {
  }
  getFlatDistanceOverDistance(distance2) {
  }
};
PlayerLocomotionTeleportParable.prototype.getPosition = function() {
  let forwardPosition = vec3_create();
  let upPosition = vec3_create();
  return function getPosition4(positionIndex, outPosition = vec3_create()) {
    let deltaTimePerStep = this._myStepLength / this._mySpeed;
    let elapsedTime = deltaTimePerStep * positionIndex;
    forwardPosition = this._myForward.vec3_scale(this._mySpeed * elapsedTime, forwardPosition);
    forwardPosition = forwardPosition.vec3_add(this._myStartPosition, forwardPosition);
    upPosition = this._myUp.vec3_scale(this._myGravity * elapsedTime * elapsedTime / 2, upPosition);
    outPosition = forwardPosition.vec3_add(upPosition, outPosition);
    return outPosition;
  };
}();
PlayerLocomotionTeleportParable.prototype.getDistance = function() {
  let currentPosition = vec3_create();
  let prevPosition = vec3_create();
  return function getDistance(positionIndex) {
    let distance2 = 0;
    prevPosition.vec3_copy(this._myStartPosition);
    for (let i = 1; i <= positionIndex; i++) {
      currentPosition = this.getPosition(i, currentPosition);
      distance2 += currentPosition.vec3_distance(prevPosition);
      prevPosition.vec3_copy(currentPosition);
    }
    return distance2;
  };
}();
PlayerLocomotionTeleportParable.prototype.getPositionIndexByDistance = function() {
  let currentPosition = vec3_create();
  let prevPosition = vec3_create();
  return function getPositionIndexByDistance(distance2) {
    let currentDistance = 0;
    let currentIndex = 0;
    prevPosition = this.getPosition(currentIndex, prevPosition);
    while (currentDistance < distance2) {
      currentPosition = this.getPosition(currentIndex + 1, currentPosition);
      currentDistance += currentPosition.vec3_distance(prevPosition);
      currentIndex++;
      prevPosition.vec3_copy(currentPosition);
    }
    return Math.max(0, currentIndex - 1);
  };
}();
PlayerLocomotionTeleportParable.prototype.getPositionByDistance = function() {
  let currentPosition = vec3_create();
  let prevPosition = vec3_create();
  let prevToCurrent = vec3_create();
  return function getPositionByDistance(distance2, outPosition = vec3_create()) {
    let currentDistance = 0;
    let currentIndex = 0;
    let found = false;
    prevPosition = this.getPosition(currentIndex, prevPosition);
    while (!found) {
      currentPosition = this.getPosition(currentIndex + 1, currentPosition);
      currentDistance += currentPosition.vec3_distance(prevPosition);
      currentIndex++;
      if (currentDistance > distance2) {
        let lengthToRemove = currentDistance - distance2;
        prevToCurrent = currentPosition.vec3_sub(prevPosition, prevToCurrent);
        let lengthToAdd = prevToCurrent.vec3_length() - lengthToRemove;
        prevToCurrent.vec3_normalize(prevToCurrent);
        outPosition = prevPosition.vec3_add(prevToCurrent.vec3_scale(lengthToAdd, outPosition), outPosition);
        found = true;
      }
      prevPosition.vec3_copy(currentPosition);
    }
    return outPosition;
  };
}();
PlayerLocomotionTeleportParable.prototype.getDistanceOverFlatDistance = function() {
  let currentPosition = vec3_create();
  let flatCurrentPosition = vec3_create();
  let flatStartPosition = vec3_create();
  let prevPosition = vec3_create();
  let prevToCurrent = vec3_create();
  let startToCurrentFlat = vec3_create();
  return function getDistanceOverFlatDistance(flatDistance, maxParableDistance) {
    if (flatDistance < 1e-5) {
      return 0;
    }
    let currentDistance = 0;
    let currentIndex = 0;
    flatStartPosition = this._myStartPosition.vec3_removeComponentAlongAxis(this._myUp, flatStartPosition);
    prevPosition = this.getPosition(currentIndex, prevPosition);
    let distanceOverFlatDistance = 0;
    while (currentDistance <= maxParableDistance) {
      currentPosition = this.getPosition(currentIndex + 1, currentPosition);
      currentDistance += currentPosition.vec3_distance(prevPosition);
      currentIndex++;
      flatCurrentPosition = currentPosition.vec3_removeComponentAlongAxis(this._myUp, flatCurrentPosition);
      startToCurrentFlat = flatCurrentPosition.vec3_sub(flatStartPosition, startToCurrentFlat);
      let currentFlatDistance = startToCurrentFlat.vec3_length();
      if (currentFlatDistance >= flatDistance) {
        let flatDifference = currentFlatDistance - flatDistance;
        prevToCurrent = currentPosition.vec3_sub(prevPosition, prevToCurrent);
        let angleWithFlat = prevToCurrent.vec3_angleRadians(startToCurrentFlat);
        let cos = Math.cos(angleWithFlat);
        let lengthToRemove = prevToCurrent.vec3_length();
        if (cos != 0) {
          lengthToRemove = flatDifference / Math.cos(angleWithFlat);
        }
        distanceOverFlatDistance = currentDistance - lengthToRemove;
        break;
      } else {
        distanceOverFlatDistance = currentDistance;
      }
      prevPosition.vec3_copy(currentPosition);
    }
    return Math.min(maxParableDistance, distanceOverFlatDistance);
  };
}();
PlayerLocomotionTeleportParable.prototype.getFlatDistanceOverDistance = function() {
  let positionByDistance = vec3_create();
  let flatPositionByDistance = vec3_create();
  let flatStartPosition = vec3_create();
  return function getFlatDistanceOverDistance(distance2) {
    positionByDistance = this.getPositionByDistance(distance2, positionByDistance);
    flatPositionByDistance = positionByDistance.vec3_removeComponentAlongAxis(this._myUp, flatPositionByDistance);
    flatStartPosition = this._myStartPosition.vec3_removeComponentAlongAxis(this._myUp, flatStartPosition);
    return flatStartPosition.vec3_distance(flatPositionByDistance);
  };
}();

// dist/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_state.js
var PlayerLocomotionTeleportState = class {
  constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
    this._myLocomotionRuntimeParams = locomotionRuntimeParams;
    this._myTeleportParams = teleportParams;
    this._myTeleportRuntimeParams = teleportRuntimeParams;
    this._myTeleportAsMovementFailed = false;
  }
  cancelTeleport() {
  }
  _teleport() {
    this._teleportToPosition(this._myTeleportRuntimeParams.myTeleportPosition, this._myTeleportRuntimeParams.myTeleportForward);
    this._myLocomotionRuntimeParams.myIsTeleporting = false;
    this._myLocomotionRuntimeParams.myTeleportJustPerformed = true;
    this._myTeleportParams.myPlayerTransformManager.resetReal();
  }
  _checkTeleport(teleportPosition, teleportRotationQuat, collisionRuntimeParams, checkTeleportCollisionRuntimeParams = null) {
  }
  _checkTeleportAsMovement(teleportPosition, teleportRotationQuat, collisionRuntimeParams, checkTeleportCollisionRuntimeParams) {
  }
  _teleportToPosition(teleportPosition, teleportForward, collisionRuntimeParams, forceTeleport = false) {
  }
};
PlayerLocomotionTeleportState.prototype._checkTeleport = function() {
  let teleportTransformQuat = quat2_create();
  return function _checkTeleport(teleportPosition, teleportRotationQuat, collisionRuntimeParams, checkTeleportCollisionRuntimeParams = null) {
    teleportTransformQuat.quat2_setPositionRotationQuat(teleportPosition, teleportRotationQuat);
    this._myTeleportParams.myPlayerTransformManager.checkTeleportToTransformQuat(teleportTransformQuat, void 0, true, void 0, collisionRuntimeParams);
    if (checkTeleportCollisionRuntimeParams != null) {
      checkTeleportCollisionRuntimeParams.copy(collisionRuntimeParams);
    }
  };
}();
PlayerLocomotionTeleportState.prototype._checkTeleportAsMovement = function() {
  let checkTeleportMovementCollisionRuntimeParams = new CollisionRuntimeParams();
  let feetRotationQuat = quat_create();
  let playerUp = vec3_create();
  let currentFeetPosition = vec3_create();
  let fixedTeleportPosition = vec3_create();
  let teleportMovement = vec3_create();
  let extraVerticalMovement = vec3_create();
  let movementToTeleportPosition = vec3_create();
  let movementFeetTransformQuat = quat2_create();
  return function _checkTeleportAsMovement(teleportPosition, teleportRotationQuat, collisionRuntimeParams, checkTeleportCollisionRuntimeParams) {
    checkTeleportMovementCollisionRuntimeParams.copy(collisionRuntimeParams);
    this._checkTeleport(teleportPosition, teleportRotationQuat, collisionRuntimeParams, checkTeleportCollisionRuntimeParams);
    if (!collisionRuntimeParams.myTeleportCanceled) {
      let teleportMovementValid = false;
      fixedTeleportPosition.vec3_copy(collisionRuntimeParams.myNewPosition);
      this._myTeleportParams.myPlayerTransformManager.getPosition(currentFeetPosition);
      for (let i = 0; i < this._myTeleportParams.myTeleportAsMovementMaxSteps; i++) {
        teleportMovement = fixedTeleportPosition.vec3_sub(currentFeetPosition, teleportMovement);
        if (this._myTeleportParams.myTeleportAsMovementRemoveVerticalMovement) {
          teleportMovement = teleportMovement.vec3_removeComponentAlongAxis(playerUp, teleportMovement);
        }
        if (this._myTeleportParams.myTeleportAsMovementExtraVerticalMovementPerMeter != 0) {
          let meters = teleportMovement.vec3_length();
          let extraVerticalMovementValue = meters * this._myTeleportParams.myTeleportAsMovementExtraVerticalMovementPerMeter;
          extraVerticalMovement = playerUp.vec3_scale(extraVerticalMovementValue, extraVerticalMovement);
          teleportMovement = teleportMovement.vec3_add(extraVerticalMovement, teleportMovement);
        }
        movementFeetTransformQuat.quat2_setPositionRotationQuat(currentFeetPosition, feetRotationQuat);
        {
          const movementCollisionCheckParams = this._myTeleportParams.myPlayerTransformManager.getMovementCollisionCheckParams();
          const internalSplitMovementMaxStepsDisabledBackup = movementCollisionCheckParams._myInternalSplitMovementMaxStepsDisabled;
          movementCollisionCheckParams._myInternalSplitMovementMaxStepsDisabled = true;
          this._myTeleportParams.myPlayerTransformManager.checkMovement(teleportMovement, movementFeetTransformQuat, true, void 0, checkTeleportMovementCollisionRuntimeParams);
          movementCollisionCheckParams._myInternalSplitMovementMaxStepsDisabled = internalSplitMovementMaxStepsDisabledBackup;
        }
        if (!checkTeleportMovementCollisionRuntimeParams.myHorizontalMovementCanceled && !checkTeleportMovementCollisionRuntimeParams.myVerticalMovementCanceled) {
          movementToTeleportPosition = fixedTeleportPosition.vec3_sub(checkTeleportMovementCollisionRuntimeParams.myNewPosition, movementToTeleportPosition);
          if (movementToTeleportPosition.vec3_length() < this._myTeleportParams.myTeleportAsMovementMaxDistanceFromTeleportPosition + 1e-5) {
            teleportMovementValid = true;
            break;
          } else {
            teleportMovement.vec3_copy(movementToTeleportPosition);
            currentFeetPosition.vec3_copy(checkTeleportMovementCollisionRuntimeParams.myNewPosition);
          }
        } else {
          break;
        }
      }
      if (!teleportMovementValid) {
        collisionRuntimeParams.myTeleportCanceled = true;
      }
      this._myTeleportAsMovementFailed = !teleportMovementValid;
    }
  };
}();
PlayerLocomotionTeleportState.prototype._teleportToPosition = function() {
  let playerUp = vec3_create();
  let newFeetTransformQuat = quat2_create();
  let newFeetRotationQuat = quat_create();
  return function _teleportToPosition(teleportPosition, teleportForward) {
    this._myTeleportAsMovementFailed = false;
    this._myTeleportParams.myPlayerTransformManager.getRotationRealQuat(newFeetRotationQuat);
    if (!teleportForward.vec3_isZero(1e-5)) {
      newFeetRotationQuat.quat_getUp(playerUp);
      newFeetRotationQuat.quat_setUp(playerUp, teleportForward);
    }
    newFeetTransformQuat.quat2_setPositionRotationQuat(teleportPosition, newFeetRotationQuat);
    this._myTeleportParams.myPlayerTransformManager.teleportTransformQuat(newFeetTransformQuat, void 0, void 0, true);
  };
}();

// dist/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_detection_state.js
var PlayerLocomotionTeleportDetectionTeleportHitValidResult = {
  VALID: 0,
  INVALID: 1,
  TOO_HIGH: 2
};
var PlayerLocomotionTeleportDetectionParams = class {
  constructor() {
    this.myMaxDistance = 0;
    this.myMaxHeightDifference = 0;
    this.myGroundAngleToIgnoreUpward = 0;
    this.myMustBeOnGround = false;
    this.myMustBeOnIgnorableGroundAngle = false;
    this.myTeleportBlockLayerFlags = new PhysicsLayerFlags();
    this.myTeleportBlockColliderType = RaycastBlockColliderType.BOTH;
    this.myTeleportFloorLayerFlags = new PhysicsLayerFlags();
    this.myTeleportFloorBlockColliderType = RaycastBlockColliderType.BOTH;
    this.myParableForwardMinAngleToBeValidUp = 30;
    this.myParableForwardMinAngleToBeValidDown = 0;
    this.myTeleportParableStartReferenceObject = null;
    this.myTeleportParableStartPositionOffset = vec3_create(0, -0.04, 0.08);
    this.myTeleportParableStartRotationOffset = vec3_create(30, 0, 0);
    this.myTeleportParableSpeed = 15;
    this.myTeleportParableGravity = -30;
    this.myTeleportParableStepLength = 0.25;
    this.myRotationOnUpMinStickIntensity = 0.5;
    this.myRotationOnUpEnabled = false;
    this.myTeleportFeetPositionMustBeVisible = false;
    this.myTeleportHeadPositionMustBeVisible = false;
    this.myTeleportHeadOrFeetPositionMustBeVisible = false;
    this.myVisibilityCheckRadius = 0.05;
    this.myVisibilityCheckFeetPositionVerticalOffset = 0.1;
    this.myVisibilityCheckDistanceFromHitThreshold = 0.1;
    this.myVisibilityCheckCircumferenceSliceAmount = 6;
    this.myVisibilityCheckCircumferenceStepAmount = 1;
    this.myVisibilityCheckCircumferenceRotationPerStep = 30;
    this.myVisibilityBlockLayerFlags = new PhysicsLayerFlags();
    this.myVisibilityBlockColliderType = RaycastBlockColliderType.BOTH;
    this.myPlayerTransformManagerMustBeSyncedFlagMap = /* @__PURE__ */ new Map();
    this.myPlayerTransformManagerMustBeSyncedFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, false);
    this.myPlayerTransformManagerMustBeSyncedFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, false);
    this.myPlayerTransformManagerMustBeSyncedFlagMap.set(PlayerTransformManagerSyncFlag.FAR, false);
    this.myPlayerTransformManagerMustBeSyncedFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, false);
    this.myPositionRealMaxDistance = null;
    this.myPositionHeadRealMaxDistance = null;
    this.myPositionHeadMustBeValid = false;
  }
};
var PlayerLocomotionTeleportDetectionRuntimeParams = class {
  constructor() {
    this.myTeleportDetectionValid = false;
    this.myTeleportPositionValid = false;
    this.myTeleportSurfaceNormal = vec3_create();
    this.myTeleportForward = vec3_create();
    this.myParable = new PlayerLocomotionTeleportParable();
  }
};
var PlayerLocomotionTeleportDetectionState = class extends PlayerLocomotionTeleportState {
  constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
    super(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myDetectionRuntimeParams = new PlayerLocomotionTeleportDetectionRuntimeParams();
    this._myVisualizer = new PlayerLocomotionTeleportDetectionVisualizer(this._myTeleportParams, this._myTeleportRuntimeParams, this._myDetectionRuntimeParams);
    this._myTeleportRotationOnUpQueue = [];
    for (let i = 0; i < 3; i++) {
      this._myTeleportRotationOnUpQueue.push(0);
    }
    this._myDestroyed = false;
  }
  start() {
    this._myLocomotionRuntimeParams.myIsTeleportDetecting = true;
    for (let i = 0; i < this._myTeleportRotationOnUpQueue.length; i++) {
      this._myTeleportRotationOnUpQueue[i] = 0;
    }
    this._myDetectionRuntimeParams.myTeleportPositionValid = false;
    this._myTeleportRuntimeParams.myTeleportPosition.vec3_zero();
    this._myTeleportRuntimeParams.myTeleportForward.vec3_zero();
    this._myDetectionRuntimeParams.myTeleportForward.vec3_zero();
    this._myDetectionRuntimeParams.myParable.setSpeed(this._myTeleportParams.myDetectionParams.myTeleportParableSpeed);
    this._myDetectionRuntimeParams.myParable.setGravity(this._myTeleportParams.myDetectionParams.myTeleportParableGravity);
    this._myDetectionRuntimeParams.myParable.setStepLength(this._myTeleportParams.myDetectionParams.myTeleportParableStepLength);
    this._myTeleportParams.myPlayerTransformManager.resetReal();
    this._myVisualizer.start();
  }
  end() {
    this._myLocomotionRuntimeParams.myIsTeleportDetecting = false;
    this._myVisualizer.end();
  }
  update(dt, fsm) {
    this._detectTeleportPosition();
    this._myVisualizer.update(dt);
    if (this._confirmTeleport()) {
      if (this._myDetectionRuntimeParams.myTeleportPositionValid) {
        fsm.perform("teleport");
      } else {
        fsm.perform("cancel");
      }
    } else if (this._cancelTeleport()) {
      fsm.perform("cancel");
    }
  }
  _confirmTeleport() {
    let confirmTeleport = false;
    if (!XRUtils.isSessionActive(this._myTeleportParams.myEngine)) {
      if (Globals.getMouse(this._myTeleportParams.myEngine).isInsideView()) {
        confirmTeleport = Globals.getMouse(this._myTeleportParams.myEngine).isButtonPressEnd(MouseButtonID.MIDDLE);
      }
    } else {
      let axes = Globals.getGamepads(this._myTeleportParams.myEngine)[this._myTeleportParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
      if (axes.vec2_length() <= this._myTeleportParams.myStickIdleThreshold) {
        confirmTeleport = true;
      }
    }
    return confirmTeleport;
  }
  _cancelTeleport() {
    let cancelTeleport = false;
    if (!XRUtils.isSessionActive(this._myTeleportParams.myEngine)) {
      cancelTeleport = Globals.getMouse(this._myTeleportParams.myEngine).isButtonPressEnd(MouseButtonID.RIGHT) || !Globals.getMouse(this._myTeleportParams.myEngine).isInsideView();
    } else {
      cancelTeleport = Globals.getGamepads(this._myTeleportParams.myEngine)[this._myTeleportParams.myHandedness].getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed();
    }
    return cancelTeleport;
  }
  _detectTeleportPosition() {
    if (XRUtils.isSessionActive(this._myTeleportParams.myEngine)) {
      this._detectTeleportRotationVR();
      this._detectTeleportPositionVR();
    } else {
      this._detectTeleportPositionNonVR();
    }
    if (!this._myTeleportParams.myPlayerTransformManager.isSynced(this._myTeleportParams.myDetectionParams.myPlayerTransformManagerMustBeSyncedFlagMap)) {
      this._myDetectionRuntimeParams.myTeleportPositionValid = false;
    } else if (this._myTeleportParams.myDetectionParams.myPositionRealMaxDistance != null && this._myTeleportParams.myPlayerTransformManager.getDistanceToReal() > this._myTeleportParams.myDetectionParams.myPositionRealMaxDistance) {
      this._myDetectionRuntimeParams.myTeleportPositionValid = false;
    } else if (this._myTeleportParams.myDetectionParams.myPositionHeadRealMaxDistance != null && this._myTeleportParams.myPlayerTransformManager.getDistanceToRealHead() > this._myTeleportParams.myDetectionParams.myPositionHeadRealMaxDistance) {
      this._myDetectionRuntimeParams.myTeleportPositionValid = false;
    } else if (!this._myTeleportParams.myPlayerTransformManager.isPositionHeadValid() && this._myTeleportParams.myDetectionParams.myPositionHeadMustBeValid) {
      this._myDetectionRuntimeParams.myTeleportPositionValid = false;
    }
  }
  _isTeleportPositionValid(teleportPosition, teleportForward, checkTeleportCollisionRuntimeParams) {
  }
  _isTeleportHitValid(hit, teleportForward, checkTeleportCollisionRuntimeParams) {
  }
  _detectTeleportRotationVR(dt) {
  }
  destroy() {
    this._myDestroyed = true;
    this._myVisualizer.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
PlayerLocomotionTeleportDetectionState.prototype._detectTeleportPositionNonVR = function() {
  let mousePosition = vec3_create();
  let mouseDirection = vec3_create();
  let playerRotationQuat = quat_create();
  let playerUp = vec3_create();
  return function _detectTeleportPositionNonVR(dt) {
    this._myDetectionRuntimeParams.myTeleportPositionValid = false;
    this._myDetectionRuntimeParams.myTeleportDetectionValid = true;
    playerUp = this._myTeleportParams.myPlayerTransformManager.getRotationRealQuat(playerRotationQuat).quat_getUp(playerUp);
    Globals.getMouse(this._myTeleportParams.myEngine).getOriginWorld(mousePosition);
    Globals.getMouse(this._myTeleportParams.myEngine).getDirectionWorld(mouseDirection);
    this._detectTeleportPositionParable(mousePosition, mouseDirection, playerUp);
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._detectTeleportPositionVR = function() {
  let teleportStartTransformLocal = quat2_create();
  let teleportStartTransformWorld = quat2_create();
  let teleportStartPosition = vec3_create();
  let teleportDirection = vec3_create();
  let playerRotationQuat = quat_create();
  let playerUp = vec3_create();
  let playerUpNegate = vec3_create();
  return function _detectTeleportPositionVR(dt) {
    this._myDetectionRuntimeParams.myTeleportPositionValid = false;
    this._myDetectionRuntimeParams.myTeleportDetectionValid = false;
    if (this._myTeleportParams.myDetectionParams.myTeleportParableStartReferenceObject == null) {
      let referenceObject = Globals.getPlayerObjects(this._myTeleportParams.myEngine).myHands[this._myTeleportParams.myHandedness];
      teleportStartTransformLocal.quat2_setPositionRotationDegrees(this._myTeleportParams.myDetectionParams.myTeleportParableStartPositionOffset, this._myTeleportParams.myDetectionParams.myTeleportParableStartRotationOffset);
      teleportStartTransformWorld = referenceObject.pp_convertTransformObjectToWorldQuat(teleportStartTransformLocal, teleportStartTransformWorld);
    } else {
      let referenceObject = this._myTeleportParams.myDetectionParams.myTeleportParableStartReferenceObject;
      referenceObject.pp_getTransformQuat(teleportStartTransformWorld);
    }
    teleportStartPosition = teleportStartTransformWorld.quat2_getPosition(teleportStartPosition);
    teleportDirection = teleportStartTransformWorld.quat2_getForward(teleportDirection);
    playerUp = this._myTeleportParams.myPlayerTransformManager.getRotationRealQuat(playerRotationQuat).quat_getUp(playerUp);
    playerUpNegate = playerUp.vec3_negate(playerUpNegate);
    if (teleportDirection.vec3_angle(playerUp) >= this._myTeleportParams.myDetectionParams.myParableForwardMinAngleToBeValidUp && teleportDirection.vec3_angle(playerUpNegate) >= this._myTeleportParams.myDetectionParams.myParableForwardMinAngleToBeValidDown) {
      this._myDetectionRuntimeParams.myTeleportDetectionValid = true;
    }
    if (this._myDetectionRuntimeParams.myTeleportDetectionValid) {
      this._detectTeleportPositionParable(teleportStartPosition, teleportDirection, playerUp);
    }
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._detectTeleportRotationVR = function() {
  let axesVec3 = vec3_create();
  let axesForward = vec3_create(0, 0, 1);
  let axesUp = vec3_create(0, 1, 0);
  let playerUp = vec3_create();
  let teleportRotationQuat = quat_create();
  return function _detectTeleportRotationVR(dt) {
    if (this._myTeleportParams.myDetectionParams.myRotationOnUpEnabled) {
      let axes = Globals.getGamepads(this._myTeleportParams.myEngine)[this._myTeleportParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
      if (axes.vec2_length() > this._myTeleportParams.myDetectionParams.myRotationOnUpMinStickIntensity) {
        this._myTeleportParams.myPlayerTransformManager.getRotationRealQuat(teleportRotationQuat);
        teleportRotationQuat.quat_getUp(playerUp);
        if (this._myTeleportRotationOnUpQueue[0] != 0) {
          teleportRotationQuat.quat_rotateAxis(this._myTeleportRotationOnUpQueue[0], playerUp, teleportRotationQuat);
          teleportRotationQuat.quat2_getForward(this._myTeleportRuntimeParams.myTeleportForward);
        } else {
          this._myTeleportRuntimeParams.myTeleportForward.vec3_zero();
        }
        axesVec3.vec3_set(axes[0], 0, axes[1]);
        const currentRotationOnUp = axesVec3.vec3_angleSigned(axesForward, axesUp);
        for (let i = 0; i < this._myTeleportRotationOnUpQueue.length - 1; i++) {
          this._myTeleportRotationOnUpQueue[i] = this._myTeleportRotationOnUpQueue[i + 1];
        }
        this._myTeleportRotationOnUpQueue[this._myTeleportRotationOnUpQueue.length - 1] = currentRotationOnUp;
        if (currentRotationOnUp != 0) {
          this._myTeleportParams.myPlayerTransformManager.getRotationRealQuat(teleportRotationQuat);
          teleportRotationQuat.quat_rotateAxis(currentRotationOnUp, playerUp, teleportRotationQuat);
          teleportRotationQuat.quat2_getForward(this._myDetectionRuntimeParams.myTeleportForward);
        } else {
          this._myDetectionRuntimeParams.myTeleportForward.vec3_zero();
        }
      }
    }
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._detectTeleportPositionParable = function() {
  let parablePosition = vec3_create();
  let prevParablePosition = vec3_create();
  let parableFinalPosition = vec3_create();
  let raycastParams = null;
  let raycastResult = new RaycastResults();
  let parableHitPosition = vec3_create();
  let parableHitNormal = vec3_create();
  let verticalHitOrigin = vec3_create();
  let verticalHitDirection = vec3_create();
  let flatTeleportHorizontalHitNormal = vec3_create();
  let flatParableHitNormal = vec3_create();
  let flatParableDirectionNegate = vec3_create();
  let teleportCollisionRuntimeParams = new CollisionRuntimeParams();
  let objectsEqualCallback = (first2, second) => first2 == second;
  return function _detectTeleportPositionParable(startPosition, direction, up) {
    this._myDetectionRuntimeParams.myParable.setStartPosition(startPosition);
    this._myDetectionRuntimeParams.myParable.setForward(direction);
    this._myDetectionRuntimeParams.myParable.setUp(up);
    let currentPositionIndex = 1;
    let positionFlatDistance = 0;
    let positionParableDistance = 0;
    prevParablePosition = this._myDetectionRuntimeParams.myParable.getPosition(currentPositionIndex - 1, prevParablePosition);
    let teleportCollisionCheckParams = this._myTeleportParams.myPlayerTransformManager.getTeleportCollisionCheckParams();
    if (raycastParams == null) {
      raycastParams = new RaycastParams(this._myTeleportParams.myEngine);
    }
    raycastParams.myIgnoreHitsInsideCollision = true;
    raycastParams.myBlockLayerFlags.setMask(this._myTeleportParams.myDetectionParams.myTeleportBlockLayerFlags.getMask());
    raycastParams.myBlockColliderType = this._myTeleportParams.myDetectionParams.myTeleportBlockColliderType;
    raycastParams.myPhysics = Globals.getPhysics(this._myTeleportParams.myEngine);
    raycastParams.myObjectsToIgnore.pp_copy(teleportCollisionCheckParams.myHorizontalObjectsToIgnore);
    for (let objectToIgnore of teleportCollisionCheckParams.myVerticalObjectsToIgnore) {
      raycastParams.myObjectsToIgnore.pp_pushUnique(objectToIgnore, objectsEqualCallback);
    }
    let maxParableDistance = this._myTeleportParams.myDetectionParams.myMaxDistance * 2;
    do {
      parablePosition = this._myDetectionRuntimeParams.myParable.getPosition(currentPositionIndex, parablePosition);
      raycastParams.myOrigin.vec3_copy(prevParablePosition);
      raycastParams.myDirection = parablePosition.vec3_sub(prevParablePosition, raycastParams.myDirection);
      raycastParams.myDistance = raycastParams.myDirection.vec3_length();
      raycastParams.myDirection.vec3_normalize(raycastParams.myDirection);
      raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
      if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
        Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
      }
      prevParablePosition.vec3_copy(parablePosition);
      positionFlatDistance = parablePosition.vec3_sub(startPosition, parablePosition).vec3_removeComponentAlongAxis(up, parablePosition).vec3_length();
      positionParableDistance = this._myDetectionRuntimeParams.myParable.getDistance(currentPositionIndex);
      currentPositionIndex++;
    } while (positionFlatDistance <= this._myTeleportParams.myDetectionParams.myMaxDistance && positionParableDistance <= maxParableDistance && !raycastResult.isColliding());
    let maxParableDistanceOverFlatDistance = this._myDetectionRuntimeParams.myParable.getDistanceOverFlatDistance(this._myTeleportParams.myDetectionParams.myMaxDistance, maxParableDistance);
    let fixedPositionParableDistance = positionParableDistance;
    if (positionParableDistance > maxParableDistanceOverFlatDistance || positionParableDistance > maxParableDistance) {
      fixedPositionParableDistance = Math.min(maxParableDistanceOverFlatDistance, maxParableDistance);
    }
    this._myDetectionRuntimeParams.myParableDistance = fixedPositionParableDistance;
    let hitCollisionValid = false;
    let bottomCheckMaxLength = 100;
    if (raycastResult.isColliding()) {
      let hit = raycastResult.myHits.pp_first();
      let hitParableDistance = positionParableDistance - (raycastParams.myDistance - hit.myDistance);
      if (hitParableDistance <= fixedPositionParableDistance) {
        hitCollisionValid = true;
        this._myDetectionRuntimeParams.myParableDistance = hitParableDistance;
        teleportCollisionRuntimeParams.reset();
        this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit, this._myTeleportRuntimeParams.myTeleportForward, teleportCollisionRuntimeParams) == PlayerLocomotionTeleportDetectionTeleportHitValidResult.VALID;
        this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
        this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
        parableHitPosition.vec3_copy(hit.myPosition);
        parableHitNormal.vec3_copy(hit.myNormal);
        if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed) {
          verticalHitOrigin = hit.myPosition.vec3_add(hit.myNormal.vec3_scale(0.01, verticalHitOrigin), verticalHitOrigin);
          verticalHitDirection = up.vec3_negate(verticalHitDirection);
          raycastParams.myOrigin.vec3_copy(verticalHitOrigin);
          raycastParams.myDirection.vec3_copy(verticalHitDirection);
          raycastParams.myDistance = bottomCheckMaxLength;
          raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
          if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
            Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
          }
          if (raycastResult.isColliding()) {
            let hit2 = raycastResult.myHits.pp_first();
            teleportCollisionRuntimeParams.reset();
            let teleportHitValidResult = this._isTeleportHitValid(hit2, this._myTeleportRuntimeParams.myTeleportForward, teleportCollisionRuntimeParams);
            this._myDetectionRuntimeParams.myTeleportPositionValid = teleportHitValidResult == PlayerLocomotionTeleportDetectionTeleportHitValidResult.VALID;
            this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
            this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
            let teleportPositionIsTooHigh = teleportHitValidResult == PlayerLocomotionTeleportDetectionTeleportHitValidResult.TOO_HIGH;
            if (!teleportPositionIsTooHigh) {
              if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed && teleportCollisionRuntimeParams.myTeleportCanceled && teleportCollisionRuntimeParams.myIsCollidingHorizontally) {
                flatTeleportHorizontalHitNormal = teleportCollisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_removeComponentAlongAxis(up, flatTeleportHorizontalHitNormal);
                if (!flatTeleportHorizontalHitNormal.vec3_isZero(1e-5)) {
                  flatTeleportHorizontalHitNormal.vec3_normalize(flatTeleportHorizontalHitNormal);
                  let backwardStep = teleportCollisionCheckParams.myRadius * 1.1;
                  raycastParams.myOrigin = verticalHitOrigin.vec3_add(flatTeleportHorizontalHitNormal.vec3_scale(backwardStep, raycastParams.myOrigin), raycastParams.myOrigin);
                  raycastParams.myDirection.vec3_copy(verticalHitDirection);
                  raycastParams.myDistance = bottomCheckMaxLength;
                  raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
                  if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
                    Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, raycastParams.myOrigin, vec4_create(0, 0, 0, 1), 0.03);
                    Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
                  }
                  if (raycastResult.isColliding()) {
                    let hit3 = raycastResult.myHits.pp_first();
                    teleportCollisionRuntimeParams.reset();
                    this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit3, this._myTeleportRuntimeParams.myTeleportForward, teleportCollisionRuntimeParams) == PlayerLocomotionTeleportDetectionTeleportHitValidResult.VALID;
                    this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
                    this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
                  }
                }
              } else {
              }
              if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed) {
                flatParableHitNormal = parableHitNormal.vec3_removeComponentAlongAxis(up, flatParableHitNormal);
                if (!flatParableHitNormal.vec3_isZero(1e-5)) {
                  flatParableHitNormal.vec3_normalize(flatParableHitNormal);
                  let backwardStep = teleportCollisionCheckParams.myRadius * 1.1;
                  raycastParams.myOrigin = verticalHitOrigin.vec3_add(flatParableHitNormal.vec3_scale(backwardStep, raycastParams.myOrigin), raycastParams.myOrigin);
                  raycastParams.myDirection.vec3_copy(verticalHitDirection);
                  raycastParams.myDistance = bottomCheckMaxLength;
                  raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
                  if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
                    Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, raycastParams.myOrigin, vec4_create(0, 0, 0, 1), 0.03);
                    Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
                  }
                  if (raycastResult.isColliding()) {
                    let hit3 = raycastResult.myHits.pp_first();
                    teleportCollisionRuntimeParams.reset();
                    this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit3, this._myTeleportRuntimeParams.myTeleportForward, teleportCollisionRuntimeParams) == PlayerLocomotionTeleportDetectionTeleportHitValidResult.VALID;
                    this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
                    this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
                  }
                }
              } else {
              }
              if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed) {
                flatParableDirectionNegate = direction.vec3_negate(flatParableDirectionNegate).vec3_removeComponentAlongAxis(up, flatParableDirectionNegate).vec3_normalize(flatParableDirectionNegate);
                if (!flatParableDirectionNegate.vec3_isZero(1e-5)) {
                  flatParableDirectionNegate.vec3_normalize(flatParableDirectionNegate);
                  let backwardStep = teleportCollisionCheckParams.myRadius * 1.1;
                  raycastParams.myOrigin = verticalHitOrigin.vec3_add(flatParableDirectionNegate.vec3_scale(backwardStep, raycastParams.myOrigin), raycastParams.myOrigin);
                  raycastParams.myDirection.vec3_copy(verticalHitDirection);
                  raycastParams.myDistance = bottomCheckMaxLength;
                  raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
                  if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
                    Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, raycastParams.myOrigin, vec4_create(0, 0, 0, 1), 0.03);
                    Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
                  }
                  if (raycastResult.isColliding()) {
                    let hit3 = raycastResult.myHits.pp_first();
                    teleportCollisionRuntimeParams.reset();
                    this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit3, this._myTeleportRuntimeParams.myTeleportForward, teleportCollisionRuntimeParams) == PlayerLocomotionTeleportDetectionTeleportHitValidResult.VALID;
                    this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
                    this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
                  }
                }
              } else {
              }
            }
          }
        } else {
        }
      }
    }
    if (!hitCollisionValid) {
      parableFinalPosition = this._myDetectionRuntimeParams.myParable.getPositionByDistance(this._myDetectionRuntimeParams.myParableDistance, parableFinalPosition);
      verticalHitOrigin.vec3_copy(parableFinalPosition);
      verticalHitDirection = up.vec3_negate(verticalHitDirection);
      raycastParams.myOrigin.vec3_copy(verticalHitOrigin);
      raycastParams.myDirection.vec3_copy(verticalHitDirection);
      raycastParams.myDistance = bottomCheckMaxLength;
      raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
      if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
        Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
      }
      if (raycastResult.isColliding()) {
        let hit = raycastResult.myHits.pp_first();
        teleportCollisionRuntimeParams.reset();
        let teleportHitValidResult = this._isTeleportHitValid(hit, this._myTeleportRuntimeParams.myTeleportForward, teleportCollisionRuntimeParams);
        this._myDetectionRuntimeParams.myTeleportPositionValid = teleportHitValidResult == PlayerLocomotionTeleportDetectionTeleportHitValidResult.VALID;
        this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
        this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
        let teleportPositionIsTooHigh = teleportHitValidResult == PlayerLocomotionTeleportDetectionTeleportHitValidResult.TOO_HIGH;
        if (!teleportPositionIsTooHigh) {
          if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed && teleportCollisionRuntimeParams.myTeleportCanceled && teleportCollisionRuntimeParams.myIsCollidingHorizontally) {
            flatTeleportHorizontalHitNormal = teleportCollisionRuntimeParams.myHorizontalCollisionHit.myNormal.vec3_removeComponentAlongAxis(up, flatTeleportHorizontalHitNormal);
            if (!flatTeleportHorizontalHitNormal.vec3_isZero(1e-5)) {
              flatTeleportHorizontalHitNormal.vec3_normalize(flatTeleportHorizontalHitNormal);
              let backwardStep = teleportCollisionCheckParams.myRadius * 1.1;
              raycastParams.myOrigin = verticalHitOrigin.vec3_add(flatTeleportHorizontalHitNormal.vec3_scale(backwardStep, raycastParams.myOrigin), raycastParams.myOrigin);
              raycastParams.myDirection.vec3_copy(verticalHitDirection);
              raycastParams.myDistance = bottomCheckMaxLength;
              raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
              if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
                Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, raycastParams.myOrigin, vec4_create(0, 0, 0, 1), 0.03);
                Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
              }
              if (raycastResult.isColliding()) {
                let hit2 = raycastResult.myHits.pp_first();
                teleportCollisionRuntimeParams.reset();
                this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit2, this._myTeleportRuntimeParams.myTeleportForward, teleportCollisionRuntimeParams) == PlayerLocomotionTeleportDetectionTeleportHitValidResult.VALID;
                this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
                this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
              }
            }
          }
          if (!this._myDetectionRuntimeParams.myTeleportPositionValid && !this._myTeleportAsMovementFailed) {
            flatParableDirectionNegate = direction.vec3_negate(flatParableDirectionNegate).vec3_removeComponentAlongAxis(up, flatParableDirectionNegate).vec3_normalize(flatParableDirectionNegate);
            if (!flatParableDirectionNegate.vec3_isZero(1e-5)) {
              flatParableDirectionNegate.vec3_normalize(flatParableDirectionNegate);
              let backwardStep = teleportCollisionCheckParams.myRadius * 1.1;
              raycastParams.myOrigin = verticalHitOrigin.vec3_add(flatParableDirectionNegate.vec3_scale(backwardStep, raycastParams.myOrigin), raycastParams.myOrigin);
              raycastParams.myDirection.vec3_copy(verticalHitDirection);
              raycastParams.myDistance = bottomCheckMaxLength;
              raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
              if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugDetectEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
                Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawPoint(0, raycastParams.myOrigin, vec4_create(0, 0, 0, 1), 0.03);
                Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
              }
              if (raycastResult.isColliding()) {
                let hit2 = raycastResult.myHits.pp_first();
                teleportCollisionRuntimeParams.reset();
                this._myDetectionRuntimeParams.myTeleportPositionValid = this._isTeleportHitValid(hit2, this._myTeleportRuntimeParams.myTeleportForward, teleportCollisionRuntimeParams) == PlayerLocomotionTeleportDetectionTeleportHitValidResult.VALID;
                this._myTeleportRuntimeParams.myTeleportPosition.vec3_copy(teleportCollisionRuntimeParams.myNewPosition);
                this._myDetectionRuntimeParams.myTeleportSurfaceNormal.vec3_copy(teleportCollisionRuntimeParams.myGroundNormal);
              }
            }
          }
        }
      }
    }
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._isTeleportHitValid = function() {
  let playerRotationQuat = quat_create();
  let playerUp = vec3_create();
  return function _isTeleportHitValid(hit, teleportForward, checkTeleportCollisionRuntimeParams) {
    let isValid = PlayerLocomotionTeleportDetectionTeleportHitValidResult.INVALID;
    this._myTeleportAsMovementFailed = false;
    if (hit.isValid() && !hit.myInsideCollision) {
      playerUp = this._myTeleportParams.myPlayerTransformManager.getRotationRealQuat(playerRotationQuat).quat_getUp(playerUp);
      let hitValidEvenWhenNotConcordant = true;
      if (hit.myNormal.vec3_isConcordant(playerUp) || hitValidEvenWhenNotConcordant) {
        const physxComponent = hit.myObject.pp_getComponentSelf(PhysXComponent9);
        if (physxComponent.groupsMask & this._myTeleportParams.myDetectionParams.myTeleportFloorLayerFlags.getMask() && (this._myTeleportParams.myDetectionParams.myTeleportFloorBlockColliderType == RaycastBlockColliderType.BOTH || this._myTeleportParams.myDetectionParams.myTeleportFloorBlockColliderType == RaycastBlockColliderType.TRIGGER && physxComponent.trigger || this._myTeleportParams.myDetectionParams.myTeleportFloorBlockColliderType == RaycastBlockColliderType.NORMAL && !physxComponent.trigger)) {
          isValid = this._isTeleportPositionValid(hit.myPosition, teleportForward, checkTeleportCollisionRuntimeParams);
        }
      }
    }
    return isValid;
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._isTeleportPositionValid = function() {
  let playerUp = vec3_create();
  let teleportRotationQuat = quat_create();
  let feetPosition = vec3_create();
  let differenceOnUpVector = vec3_create();
  let teleportCheckCollisionRuntimeParams = new CollisionRuntimeParams();
  return function _isTeleportPositionValid(teleportPosition, teleportForward, checkTeleportCollisionRuntimeParams) {
    let isValid = PlayerLocomotionTeleportDetectionTeleportHitValidResult.INVALID;
    let positionVisible = this._isTeleportPositionVisible(teleportPosition);
    if (positionVisible) {
      this._myTeleportParams.myPlayerTransformManager.getRotationRealQuat(teleportRotationQuat);
      teleportRotationQuat.quat_getUp(playerUp);
      if (!teleportForward.vec3_isZero(1e-5)) {
        teleportRotationQuat.quat_setUp(playerUp, teleportForward);
      }
      this._myTeleportParams.myPlayerTransformManager.getPosition(feetPosition);
      let differenceOnUp = teleportPosition.vec3_sub(feetPosition, differenceOnUpVector).vec3_componentAlongAxis(playerUp, differenceOnUpVector).vec3_length();
      if (differenceOnUp < this._myTeleportParams.myDetectionParams.myMaxHeightDifference + 1e-5) {
        let teleportCheckValid = false;
        teleportCheckCollisionRuntimeParams.copy(this._myTeleportParams.myPlayerTransformManager.getCollisionRuntimeParams());
        if (!this._myTeleportParams.myPerformTeleportAsMovement) {
          this._checkTeleport(teleportPosition, teleportRotationQuat, teleportCheckCollisionRuntimeParams, checkTeleportCollisionRuntimeParams);
        } else {
          this._checkTeleportAsMovement(teleportPosition, teleportRotationQuat, teleportCheckCollisionRuntimeParams, checkTeleportCollisionRuntimeParams);
        }
        if (!teleportCheckCollisionRuntimeParams.myTeleportCanceled) {
          teleportCheckValid = true;
        }
        let teleportCollisionCheckParams = this._myTeleportParams.myPlayerTransformManager.getTeleportCollisionCheckParams();
        if (teleportCheckValid && (!this._myTeleportParams.myDetectionParams.myMustBeOnGround || teleportCheckCollisionRuntimeParams.myIsOnGround) && (!this._myTeleportParams.myDetectionParams.myMustBeOnIgnorableGroundAngle || teleportCheckCollisionRuntimeParams.myGroundAngle < teleportCollisionCheckParams.myGroundAngleToIgnore + 1e-4)) {
          let groundAngleValid = true;
          let isTeleportingUpward = teleportCheckCollisionRuntimeParams.myNewPosition.vec3_isFartherAlongAxis(feetPosition, playerUp);
          if (isTeleportingUpward) {
            groundAngleValid = teleportCheckCollisionRuntimeParams.myGroundAngle < this._myTeleportParams.myDetectionParams.myGroundAngleToIgnoreUpward + 1e-4;
          }
          if (groundAngleValid) {
            isValid = PlayerLocomotionTeleportDetectionTeleportHitValidResult.VALID;
          }
        }
      } else {
        isValid = PlayerLocomotionTeleportDetectionTeleportHitValidResult.TOO_HIGH;
      }
    }
    return isValid;
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._isTeleportPositionVisible = function() {
  let playerRotationQuat = quat_create();
  let playerUp = vec3_create();
  let offsetFeetTeleportPosition = vec3_create();
  let headTeleportPosition = vec3_create();
  return function _isTeleportPositionVisible(teleportPosition) {
    let isVisible = true;
    if (this._myTeleportParams.myDetectionParams.myTeleportFeetPositionMustBeVisible || this._myTeleportParams.myDetectionParams.myTeleportHeadPositionMustBeVisible || this._myTeleportParams.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible) {
      playerUp = this._myTeleportParams.myPlayerTransformManager.getRotationRealQuat(playerRotationQuat).quat_getUp(playerUp);
      let isHeadVisible = false;
      let isFeetVisible = false;
      if (this._myTeleportParams.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible || this._myTeleportParams.myDetectionParams.myTeleportHeadPositionMustBeVisible) {
        let headheight = this._myTeleportParams.myPlayerTransformManager.getHeightReal();
        headTeleportPosition = teleportPosition.vec3_add(playerUp.vec3_scale(headheight, headTeleportPosition), headTeleportPosition);
        isHeadVisible = this._isPositionVisible(headTeleportPosition);
      } else {
        isHeadVisible = true;
      }
      if (this._myTeleportParams.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible && isHeadVisible) {
        isFeetVisible = true;
      } else {
        if (this._myTeleportParams.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible || this._myTeleportParams.myDetectionParams.myTeleportFeetPositionMustBeVisible && isHeadVisible) {
          offsetFeetTeleportPosition = teleportPosition.vec3_add(playerUp.vec3_scale(this._myTeleportParams.myDetectionParams.myVisibilityCheckFeetPositionVerticalOffset, offsetFeetTeleportPosition), offsetFeetTeleportPosition);
          isFeetVisible = this._isPositionVisible(offsetFeetTeleportPosition);
        } else {
          isFeetVisible = true;
        }
      }
      isVisible = isHeadVisible && isFeetVisible;
    }
    return isVisible;
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._isPositionVisible = function() {
  let playerRotationQuat = quat_create();
  let playerUp = vec3_create();
  let playerPosition = vec3_create();
  let headPosition = vec3_create();
  let standardUp = vec3_create(0, 1, 0);
  let standardUpNegated = vec3_create(0, -1, 0);
  let standardForward = vec3_create(0, 0, 1);
  let referenceUp = vec3_create();
  let direction = vec3_create();
  let fixedRight = vec3_create();
  let fixedForward = vec3_create();
  let fixedUp = vec3_create();
  let raycastEndPosition = vec3_create();
  let raycastParams = null;
  let raycastResult = new RaycastResults();
  let objectsEqualCallback = (first2, second) => first2 == second;
  return function _isPositionVisible(position) {
    let isVisible = true;
    playerUp = this._myTeleportParams.myPlayerTransformManager.getRotationQuat(playerRotationQuat).quat_getUp(playerUp);
    this._myTeleportParams.myPlayerTransformManager.getPosition(playerPosition);
    let headheight = this._myTeleportParams.myPlayerTransformManager.getHeight();
    playerPosition.vec3_add(playerUp.vec3_scale(headheight, headPosition), headPosition);
    direction = position.vec3_sub(headPosition, direction).vec3_normalize(direction);
    referenceUp.vec3_copy(standardUp);
    if (direction.vec3_angle(standardUp) < 1e-4 || direction.vec3_angle(standardUpNegated) < 1e-4) {
      referenceUp.vec3_copy(standardForward);
    }
    fixedRight = direction.vec3_cross(referenceUp, fixedRight);
    fixedUp = fixedRight.vec3_cross(direction, fixedUp);
    fixedForward.vec3_copy(direction);
    fixedUp.vec3_normalize(fixedUp);
    fixedForward.vec3_normalize(fixedForward);
    let checkPositions = this._getVisibilityCheckPositions(headPosition, fixedUp, fixedForward);
    let distance2 = headPosition.vec3_distance(position);
    if (raycastParams == null) {
      raycastParams = new RaycastParams(this._myTeleportParams.myEngine);
    }
    let teleportCollisionCheckParams = this._myTeleportParams.myPlayerTransformManager.getTeleportCollisionCheckParams();
    for (let checkPosition of checkPositions) {
      raycastParams.myOrigin.vec3_copy(checkPosition);
      raycastParams.myDirection.vec3_copy(fixedForward);
      raycastParams.myDistance = distance2;
      raycastParams.myPhysics = Globals.getPhysics(this._myTeleportParams.myEngine);
      raycastParams.myBlockLayerFlags.setMask(this._myTeleportParams.myDetectionParams.myVisibilityBlockLayerFlags.getMask());
      raycastParams.myBlockColliderType = this._myTeleportParams.myDetectionParams.myVisibilityBlockColliderType;
      raycastParams.myObjectsToIgnore.pp_copy(teleportCollisionCheckParams.myHorizontalObjectsToIgnore);
      for (let objectToIgnore of teleportCollisionCheckParams.myVerticalObjectsToIgnore) {
        raycastParams.myObjectsToIgnore.pp_pushUnique(objectToIgnore, objectsEqualCallback);
      }
      raycastParams.myIgnoreHitsInsideCollision = true;
      raycastResult = PhysicsUtils.raycast(raycastParams, raycastResult);
      if (this._myTeleportParams.myDebugEnabled && this._myTeleportParams.myDebugVisibilityEnabled && Globals.isDebugEnabled(this._myTeleportParams.myEngine)) {
        Globals.getDebugVisualManager(this._myTeleportParams.myEngine).drawRaycast(0, raycastResult);
      }
      if (raycastResult.isColliding()) {
        raycastEndPosition = checkPosition.vec3_add(fixedForward.vec3_scale(distance2, raycastEndPosition), raycastEndPosition);
        let hit = raycastResult.myHits.pp_first();
        if (this._myTeleportParams.myDetectionParams.myVisibilityCheckDistanceFromHitThreshold == 0 || hit.myPosition.vec3_distance(raycastEndPosition) > this._myTeleportParams.myDetectionParams.myVisibilityCheckDistanceFromHitThreshold + 1e-5) {
          isVisible = false;
          break;
        }
      }
    }
    return isVisible;
  };
}();
PlayerLocomotionTeleportDetectionState.prototype._getVisibilityCheckPositions = function() {
  let checkPositions = [];
  let cachedCheckPositions = [];
  let currentCachedCheckPositionIndex = 0;
  let _localGetCachedCheckPosition = function() {
    let item = null;
    while (cachedCheckPositions.length <= currentCachedCheckPositionIndex) {
      cachedCheckPositions.push(vec3_create());
    }
    item = cachedCheckPositions[currentCachedCheckPositionIndex];
    currentCachedCheckPositionIndex++;
    return item;
  };
  let currentDirection = vec3_create();
  return function _getVisibilityCheckPositions(position, up, forward) {
    checkPositions.length = 0;
    currentCachedCheckPositionIndex = 0;
    {
      let tempCheckPosition = _localGetCachedCheckPosition();
      tempCheckPosition.vec3_copy(position);
      checkPositions.push(tempCheckPosition);
    }
    let radiusStep = this._myTeleportParams.myDetectionParams.myVisibilityCheckRadius / this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceStepAmount;
    let sliceAngle = 360 / this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceSliceAmount;
    let currentStepRotation = 0;
    for (let i = 0; i < this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceStepAmount; i++) {
      let currentRadius = radiusStep * (i + 1);
      currentDirection = up.vec3_rotateAxis(currentStepRotation, forward, currentDirection);
      for (let j = 0; j < this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceSliceAmount; j++) {
        let tempCheckPosition = _localGetCachedCheckPosition();
        let sliceDirection = currentDirection.vec3_rotateAxis(sliceAngle * j, forward, tempCheckPosition);
        checkPositions.push(position.vec3_add(sliceDirection.vec3_scale(currentRadius, sliceDirection), sliceDirection));
      }
      currentStepRotation += this._myTeleportParams.myDetectionParams.myVisibilityCheckCircumferenceRotationPerStep;
    }
    return checkPositions;
  };
}();

// dist/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_teleport_blink_state.js
import { MeshComponent as MeshComponent11 } from "@wonderlandengine/api";
var PlayerLocomotionTeleportTeleportBlinkState = class extends PlayerLocomotionTeleportState {
  constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
    super(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myBlinkSphere = Globals.getPlayerObjects(this._myTeleportParams.myEngine).myCauldron.pp_addChild();
    this._myBlinkSphereMeshComponent = this._myBlinkSphere.pp_addComponent(MeshComponent11);
    this._myBlinkSphereMeshComponent.mesh = Globals.getDefaultMeshes(this._myTeleportParams.myEngine).myInvertedSphere;
    this._myBlinkSphereMeshComponent.material = Globals.getDefaultMaterials(this._myTeleportParams.myEngine).myFlatTransparentNoDepth.clone();
    this._myBlinkSphereMaterialColor = vec4_create(this._myTeleportParams.myTeleportParams.myBlinkSphereColor[0] / 255, this._myTeleportParams.myTeleportParams.myBlinkSphereColor[1] / 255, this._myTeleportParams.myTeleportParams.myBlinkSphereColor[2] / 255, 0);
    this._myBlinkSphereMeshComponent.material.color = this._myBlinkSphereMaterialColor;
    this._myBlinkSphere.pp_resetTransformLocal();
    this._myBlinkSphere.pp_setScaleLocal(this._myTeleportParams.myTeleportParams.myBlinkSphereScale);
    this._myBlinkSphere.pp_setActive(false);
    this._myFSM = new FSM();
    this._myFSM.addState("init");
    this._myFSM.addState("idle");
    this._myFSM.addState("fade_out", this._fadeOutUpdate.bind(this));
    this._myFSM.addState("wait", new TimerState(this._myTeleportParams.myTeleportParams.myBlinkWaitSeconds, "done"));
    this._myFSM.addState("fade_in", this._fadeInUpdate.bind(this));
    this._myFSM.addTransition("init", "idle", "start");
    this._myFSM.addTransition("idle", "fade_out", "teleport", this._startFadeOut.bind(this));
    this._myFSM.addTransition("fade_out", "wait", "done", this._teleport.bind(this));
    this._myFSM.addTransition("wait", "fade_in", "done", this._startFadeIn.bind(this));
    this._myFSM.addTransition("fade_in", "idle", "done", this._teleportDone.bind(this));
    this._myFSM.addTransition("idle", "idle", "stop");
    this._myFSM.addTransition("fade_out", "idle", "stop", this._stop.bind(this, true));
    this._myFSM.addTransition("wait", "idle", "stop", this._stop.bind(this, false));
    this._myFSM.addTransition("fade_in", "idle", "stop", this._stop.bind(this, false));
    this._myFSM.addTransition("idle", "idle", "cancel");
    this._myFSM.addTransition("fade_out", "idle", "cancel", this._cancel.bind(this));
    this._myFSM.addTransition("wait", "idle", "cancel", this._cancel.bind(this));
    this._myFSM.addTransition("fade_in", "idle", "cancel", this._cancel.bind(this));
    this._myFSM.init("init");
    this._myFSM.perform("start");
    this._myFadeInTimer = new Timer(this._myTeleportParams.myTeleportParams.myBlinkFadeInSeconds);
    this._myFadeOutTimer = new Timer(this._myTeleportParams.myTeleportParams.myBlinkFadeOutSeconds);
    this._myFadeOutAlphaOverTime = new NumberOverFactor(0, 1, 0, 1);
    this._myFadeInAlphaOverTime = new NumberOverFactor(1, 0, 0, 1);
  }
  start(fsm) {
    this._myParentFSM = fsm;
    this._myFSM.perform("teleport");
  }
  end() {
    this._myBlinkSphere.pp_setActive(false);
    this._myBlinkSphere.pp_setParent(Globals.getPlayerObjects(this._myTeleportParams.myEngine).myCauldron, false);
    this._myFSM.perform("stop");
  }
  cancelTeleport() {
    this._myFSM.perform("cancel");
  }
  update(dt, fsm) {
    this._myBlinkSphere.pp_setParent(this._myTeleportParams.myPlayerTransformManager.getPlayerHeadManager().getHead(), false);
    this._myBlinkSphere.pp_resetTransformLocal();
    this._myFSM.update(dt);
  }
  _startFadeOut() {
  }
  _startFadeIn() {
    this._myFadeInTimer.start();
  }
  _fadeOutUpdate(dt, fsm) {
    this._myFadeOutTimer.update(dt);
    let alpha = this._myFadeOutAlphaOverTime.get(this._myFadeOutTimer.getPercentage());
    this._myBlinkSphereMaterialColor[3] = alpha;
    this._myBlinkSphereMeshComponent.material.color = this._myBlinkSphereMaterialColor;
    if (this._myFadeOutTimer.isDone()) {
      fsm.perform("done");
    }
  }
  _fadeInUpdate(dt, fsm) {
    this._myFadeInTimer.update(dt);
    let alpha = this._myFadeInAlphaOverTime.get(this._myFadeInTimer.getPercentage());
    this._myBlinkSphereMaterialColor[3] = alpha;
    this._myBlinkSphereMeshComponent.material.color = this._myBlinkSphereMaterialColor;
    if (this._myFadeInTimer.isDone()) {
      fsm.perform("done");
    }
  }
  _teleportDone() {
    this._myBlinkSphere.pp_setActive(false);
    this._myParentFSM.performDelayed("done");
  }
  _stop(teleport) {
    this._myBlinkSphere.pp_setActive(false);
    if (teleport) {
      this._teleport();
    }
  }
  _cancel() {
    this._myLocomotionRuntimeParams.myIsTeleporting = false;
    this._myBlinkSphere.pp_setActive(false);
    this._myBlinkSphere.pp_setParent(Globals.getPlayerObjects(this._myTeleportParams.myEngine).myCauldron, false);
  }
};
PlayerLocomotionTeleportTeleportBlinkState.prototype._startFadeOut = function() {
  let playerUp = vec3_create();
  let playerForward = vec3_create();
  let flatTeleportForward = vec3_create();
  let feetRotationQuat = quat_create();
  return function _startFadeOut() {
    this._myFadeOutTimer.start();
    this._myBlinkSphereMaterialColor[3] = 0;
    this._myBlinkSphereMeshComponent.material.color = this._myBlinkSphereMaterialColor;
    this._myBlinkSphere.pp_setActive(true);
    if (!this._myTeleportRuntimeParams.myTeleportForward.vec3_isZero(1e-5)) {
      let angleToPerform = 0;
      this._myTeleportParams.myPlayerTransformManager.getRotationRealQuat(feetRotationQuat);
      feetRotationQuat.quat_getUp(playerUp);
      feetRotationQuat.quat_getForward(playerForward);
      this._myTeleportRuntimeParams.myTeleportForward.vec3_removeComponentAlongAxis(playerUp, flatTeleportForward);
      if (!flatTeleportForward.vec3_isZero(1e-5)) {
        flatTeleportForward.vec3_normalize(flatTeleportForward);
        angleToPerform = flatTeleportForward.vec3_angle(playerForward);
      }
      if (angleToPerform < this._myTeleportParams.myTeleportParams.myBlinkRotateMinAngleToRotate) {
        this._myTeleportRuntimeParams.myTeleportForward.vec3_zero();
      }
    }
    this._myLocomotionRuntimeParams.myIsTeleporting = true;
  };
}();

// dist/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_teleport_shift_state.js
var PlayerLocomotionTeleportTeleportShiftState = class extends PlayerLocomotionTeleportState {
  constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
    super(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myFSM = new FSM();
    this._myFSM.addState("init");
    this._myFSM.addState("idle");
    this._myFSM.addState("shifting", this._shiftingUpdate.bind(this));
    this._myFSM.addTransition("init", "idle", "start");
    this._myFSM.addTransition("idle", "shifting", "teleport", this._startShifting.bind(this));
    this._myFSM.addTransition("shifting", "idle", "done", this._teleportDone.bind(this));
    this._myFSM.addTransition("idle", "idle", "stop");
    this._myFSM.addTransition("shifting", "idle", "stop", this._stop.bind(this));
    this._myFSM.addTransition("idle", "idle", "cancel");
    this._myFSM.addTransition("shifting", "idle", "cancel", this._cancel.bind(this));
    this._myFSM.init("init");
    this._myFSM.perform("start");
    this._myShiftMovementTimer = new Timer(this._myTeleportParams.myTeleportParams.myShiftMovementSeconds);
    this._myShiftRotateTimer = new Timer(this._myTeleportParams.myTeleportParams.myShiftRotateSeconds, false);
    this._myFeetStartPosition = vec3_create();
    this._myStartForward = vec3_create();
  }
  start(fsm) {
    this._myParentFSM = fsm;
    this._myFSM.perform("teleport");
  }
  end() {
    this._myFSM.perform("stop");
  }
  update(dt, fsm) {
    this._myFSM.update(dt);
  }
  cancelTeleport() {
    this._myFSM.perform("cancel");
  }
  _startShifting() {
  }
  _cancel() {
    this._myLocomotionRuntimeParams.myIsTeleporting = false;
  }
  _stop() {
    this._teleport();
  }
  _teleportDone() {
    this._teleport();
    this._myParentFSM.performDelayed("done");
  }
  _shiftingUpdate(dt, fsm) {
  }
};
PlayerLocomotionTeleportTeleportShiftState.prototype._startShifting = function() {
  let playerUp = vec3_create();
  let playerForward = vec3_create();
  let flatTeleportForward = vec3_create();
  let feetRotationQuat = quat_create();
  return function _startShifting(dt, fsm) {
    this._myLocomotionRuntimeParams.myIsTeleporting = true;
    this._myFeetStartPosition = this._myTeleportParams.myPlayerTransformManager.getPositionReal(this._myFeetStartPosition);
    this._myShiftMovementTimer.start(this._myTeleportParams.myTeleportParams.myShiftMovementSeconds);
    if (this._myTeleportParams.myTeleportParams.myShiftMovementSecondsMultiplierOverDistanceFunction) {
      let distance2 = this._myTeleportRuntimeParams.myTeleportPosition.vec3_distance(this._myFeetStartPosition);
      let multiplier = this._myTeleportParams.myTeleportParams.myShiftMovementSecondsMultiplierOverDistanceFunction(distance2);
      this._myShiftMovementTimer.start(this._myTeleportParams.myTeleportParams.myShiftMovementSeconds * multiplier);
    }
    if (!this._myTeleportRuntimeParams.myTeleportForward.vec3_isZero(1e-5)) {
      let angleToPerform = 0;
      this._myTeleportParams.myPlayerTransformManager.getRotationRealQuat(feetRotationQuat);
      feetRotationQuat.quat_getUp(playerUp);
      feetRotationQuat.quat_getForward(playerForward);
      this._myTeleportRuntimeParams.myTeleportForward.vec3_removeComponentAlongAxis(playerUp, flatTeleportForward);
      if (!flatTeleportForward.vec3_isZero(1e-5)) {
        flatTeleportForward.vec3_normalize(flatTeleportForward);
        angleToPerform = flatTeleportForward.vec3_angle(playerForward);
      }
      if (angleToPerform < this._myTeleportParams.myTeleportParams.myShiftRotateMinAngleToRotate) {
        this._myTeleportRuntimeParams.myTeleportForward.vec3_zero();
      }
    }
    this._myShiftRotateTimer.reset();
  };
}();
PlayerLocomotionTeleportTeleportShiftState.prototype._shiftingUpdate = function() {
  let movementToTeleportFeet = vec3_create();
  let newFeetPosition = vec3_create();
  let playerUp = vec3_create();
  let playerForward = vec3_create();
  let flatTeleportForward = vec3_create();
  let feetRotationQuat = quat_create();
  let currentRotationQuat = quat_create();
  let targetRotationQuat = quat_create();
  let lerpedRotationQuat = quat_create();
  let lerpedForward = vec3_create();
  let newFeetRotationQuat = quat_create();
  return function _shiftingUpdate(dt, fsm) {
    this._myShiftMovementTimer.update(dt);
    this._myShiftRotateTimer.update(dt);
    if (this._myShiftRotateTimer.isDone() && this._myShiftMovementTimer.isDone()) {
      fsm.perform("done");
    } else {
      newFeetPosition.vec3_copy(this._myTeleportRuntimeParams.myTeleportPosition);
      if (this._myShiftMovementTimer.isStarted() || this._myShiftMovementTimer.isJustDone()) {
        let interpolationFactor = this._myTeleportParams.myTeleportParams.myShiftMovementEasingFunction(this._myShiftMovementTimer.getPercentage());
        if (interpolationFactor >= this._myTeleportParams.myTeleportParams.myShiftRotateStartAfterMovementPercentage && !this._myShiftRotateTimer.isStarted()) {
          let angleToPerform = 0;
          if (!this._myTeleportRuntimeParams.myTeleportForward.vec3_isZero(1e-5)) {
            this._myTeleportParams.myPlayerTransformManager.getRotationRealQuat(feetRotationQuat);
            feetRotationQuat.quat_getUp(playerUp);
            feetRotationQuat.quat_getForward(playerForward);
            this._myTeleportRuntimeParams.myTeleportForward.vec3_removeComponentAlongAxis(playerUp, flatTeleportForward);
            if (!flatTeleportForward.vec3_isZero(1e-5)) {
              flatTeleportForward.vec3_normalize(flatTeleportForward);
              angleToPerform = flatTeleportForward.vec3_angle(playerForward);
            }
            this._myStartForward.vec3_copy(playerForward);
          }
          if (angleToPerform > 0 && angleToPerform >= this._myTeleportParams.myTeleportParams.myShiftRotateMinAngleToRotate) {
            this._myShiftRotateTimer.reset(this._myTeleportParams.myTeleportParams.myShiftRotateSeconds);
            if (this._myTeleportParams.myTeleportParams.myShiftRotateSecondsMultiplierOverAngleFunction) {
              let multiplier = this._myTeleportParams.myTeleportParams.myShiftRotateSecondsMultiplierOverAngleFunction(angleToPerform);
              this._myShiftRotateTimer.reset(this._myTeleportParams.myTeleportParams.myShiftRotateSeconds * multiplier);
            }
          } else {
            this._myTeleportRuntimeParams.myTeleportForward.vec3_zero();
            this._myShiftRotateTimer.reset(0);
          }
          this._myShiftRotateTimer.start();
          this._myShiftRotateTimer.update(dt);
        }
        movementToTeleportFeet = this._myTeleportRuntimeParams.myTeleportPosition.vec3_sub(this._myFeetStartPosition, movementToTeleportFeet);
        movementToTeleportFeet.vec3_scale(interpolationFactor, movementToTeleportFeet);
        newFeetPosition = this._myFeetStartPosition.vec3_add(movementToTeleportFeet, newFeetPosition);
      }
      this._myTeleportParams.myPlayerTransformManager.getRotationRealQuat(newFeetRotationQuat);
      if (!this._myTeleportRuntimeParams.myTeleportForward.vec3_isZero(1e-5)) {
        if (this._myShiftRotateTimer.isRunning() || this._myShiftRotateTimer.isJustDone()) {
          let interpolationFactor = this._myTeleportParams.myTeleportParams.myShiftRotateEasingFunction(this._myShiftRotateTimer.getPercentage());
          newFeetRotationQuat.quat_getUp(playerUp);
          currentRotationQuat.quat_copy(newFeetRotationQuat);
          targetRotationQuat.quat_copy(newFeetRotationQuat);
          currentRotationQuat.quat_setUp(playerUp, this._myStartForward);
          targetRotationQuat.quat_setUp(playerUp, this._myTeleportRuntimeParams.myTeleportForward);
          currentRotationQuat.quat_slerp(targetRotationQuat, interpolationFactor, lerpedRotationQuat);
          newFeetRotationQuat.quat_setUp(playerUp, lerpedRotationQuat.quat_getForward(lerpedForward));
          if (lerpedForward.vec3_angle(this._myTeleportRuntimeParams.myTeleportForward) <= this._myTeleportParams.myTeleportParams.myShiftRotateStopAngleThreshold) {
            this._myShiftRotateTimer.end();
          }
        }
      }
      let playerHeadManager = this._myTeleportParams.myPlayerTransformManager.getPlayerHeadManager();
      playerHeadManager.setRotationFeetQuat(newFeetRotationQuat);
      playerHeadManager.teleportPositionFeet(newFeetPosition);
    }
  };
}();

// dist/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport_teleport_state.js
var PlayerLocomotionTeleportTeleportType = {
  INSTANT: 0,
  BLINK: 1,
  SHIFT: 2
};
var PlayerLocomotionTeleportTeleportParams = class {
  constructor() {
    this.myTeleportType = PlayerLocomotionTeleportTeleportType.SHIFT;
    this.myInstantRotateMinAngleToRotate = 25;
    this.myBlinkFadeOutSeconds = 0.2;
    this.myBlinkFadeInSeconds = 0.2;
    this.myBlinkWaitSeconds = 0.1;
    this.myBlinkSphereColor = vec3_create();
    this.myBlinkSphereScale = 0.5;
    this.myBlinkRotateMinAngleToRotate = 25;
    this.myShiftMovementSeconds = 0.15;
    this.myShiftMovementSecondsMultiplierOverDistanceFunction = null;
    this.myShiftMovementEasingFunction = EasingFunction.easeInOut;
    this.myShiftRotateSeconds = 0.75;
    this.myShiftRotateSecondsMultiplierOverAngleFunction = null;
    this.myShiftRotateEasingFunction = EasingFunction.easeOutWeak;
    this.myShiftRotateStartAfterMovementPercentage = 0.7;
    this.myShiftRotateMinAngleToRotate = 25;
    this.myShiftRotateStopAngleThreshold = 0.25;
    this.myShiftRotateSecondsMultiplierOverAngleFunction = function(angle2) {
      return EasingFunction.easeOut(angle2 / 180);
    };
  }
};
var PlayerLocomotionTeleportTeleportState = class extends PlayerLocomotionTeleportState {
  constructor(teleportParams, teleportRuntimeParams, locomotionRuntimeParams) {
    super(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myFSM = new FSM();
    this._myFSM.addState("init");
    this._myFSM.addState("idle");
    this._myBlinkState = new PlayerLocomotionTeleportTeleportBlinkState(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myShiftState = new PlayerLocomotionTeleportTeleportShiftState(teleportParams, teleportRuntimeParams, locomotionRuntimeParams);
    this._myFSM.addState("instant_teleport", this._instantUpdate.bind(this));
    this._myFSM.addState("blink_teleport", this._myBlinkState);
    this._myFSM.addState("shift_teleport", this._myShiftState);
    this._myFSM.addTransition("init", "idle", "start");
    this._myFSM.addTransition("idle", "instant_teleport", "start_instant", this._startInstantTeleport.bind(this));
    this._myFSM.addTransition("idle", "blink_teleport", "start_blink");
    this._myFSM.addTransition("idle", "shift_teleport", "start_shift");
    this._myFSM.addTransition("instant_teleport", "idle", "done", this._teleportDone.bind(this));
    this._myFSM.addTransition("blink_teleport", "idle", "done", this._teleportDone.bind(this));
    this._myFSM.addTransition("shift_teleport", "idle", "done", this._teleportDone.bind(this));
    this._myFSM.addTransition("idle", "idle", "stop");
    this._myFSM.addTransition("instant_teleport", "idle", "stop", this._instantStop.bind(this));
    this._myFSM.addTransition("blink_teleport", "idle", "stop");
    this._myFSM.addTransition("shift_teleport", "idle", "stop");
    this._myFSM.addTransition("idle", "idle", "cancel");
    this._myFSM.addTransition("instant_teleport", "idle", "cancel", this._cancelInstant.bind(this));
    this._myFSM.addTransition("blink_teleport", "idle", "cancel", this._cancelBlink.bind(this), SkipStateFunction.END);
    this._myFSM.addTransition("shift_teleport", "idle", "cancel", this._cancelShift.bind(this), SkipStateFunction.END);
    this._myFSM.init("init");
    this._myFSM.perform("start");
  }
  start(fsm) {
    this._myParentFSM = fsm;
    switch (this._myTeleportParams.myTeleportParams.myTeleportType) {
      case PlayerLocomotionTeleportTeleportType.INSTANT:
        this._myFSM.perform("start_instant");
        break;
      case PlayerLocomotionTeleportTeleportType.BLINK:
        this._myFSM.perform("start_blink");
        break;
      case PlayerLocomotionTeleportTeleportType.SHIFT:
        this._myFSM.perform("start_shift");
        break;
      default:
        this._myFSM.perform("start_instant");
    }
  }
  end() {
  }
  cancelTeleport() {
    this._myFSM.perform("cancel");
  }
  update(dt, fsm) {
    this._myFSM.update(dt);
  }
  completeTeleport() {
    this._myFSM.perform("stop");
  }
  _startInstantTeleport() {
  }
  _instantUpdate(dt, fsm) {
    this._teleport();
    fsm.perform("done");
  }
  _instantStop(fsm) {
    this._teleport();
  }
  _teleportDone() {
    this._myParentFSM.performDelayed("done");
  }
  _cancelInstant() {
    this._myLocomotionRuntimeParams.myIsTeleporting = false;
  }
  _cancelBlink() {
    this._myBlinkState.cancelTeleport();
  }
  _cancelShift() {
    this._myShiftState.cancelTeleport();
  }
};
PlayerLocomotionTeleportTeleportState.prototype._startInstantTeleport = function() {
  let playerUp = vec3_create();
  let playerForward = vec3_create();
  let flatTeleportForward = vec3_create();
  let feetRotationQuat = quat_create();
  return function _startInstantTeleport() {
    if (!this._myTeleportRuntimeParams.myTeleportForward.vec3_isZero(1e-5)) {
      let angleToPerform = 0;
      this._myTeleportParams.myPlayerTransformManager.getRotationRealQuat(feetRotationQuat);
      feetRotationQuat.quat_getUp(playerUp);
      feetRotationQuat.quat_getForward(playerForward);
      this._myTeleportRuntimeParams.myTeleportForward.vec3_removeComponentAlongAxis(playerUp, flatTeleportForward);
      if (!flatTeleportForward.vec3_isZero(1e-5)) {
        flatTeleportForward.vec3_normalize(flatTeleportForward);
        angleToPerform = flatTeleportForward.vec3_angle(playerForward);
      }
      if (angleToPerform < this._myTeleportParams.myTeleportParams.myInstantRotateMinAngleToRotate) {
        this._myTeleportRuntimeParams.myTeleportForward.vec3_zero();
      }
    }
    this._myLocomotionRuntimeParams.myIsTeleporting = true;
  };
}();

// dist/pp/gameplay/experimental/locomotion/legacy/locomotion/teleport/player_locomotion_teleport.js
var PlayerLocomotionTeleportParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myPlayerTransformManager = null;
    this.myDetectionParams = new PlayerLocomotionTeleportDetectionParams();
    this.myVisualizerParams = new PlayerLocomotionTeleportDetectionVisualizerParams();
    this.myTeleportParams = new PlayerLocomotionTeleportTeleportParams();
    this.myHandedness = Handedness.LEFT;
    this.myPerformTeleportAsMovement = false;
    this.myTeleportAsMovementMaxDistanceFromTeleportPosition = 1e-3;
    this.myTeleportAsMovementMaxSteps = 2;
    this.myTeleportAsMovementRemoveVerticalMovement = true;
    this.myTeleportAsMovementExtraVerticalMovementPerMeter = 1;
    this.myStickIdleThreshold = 0.1;
    this.myAdjustPositionEveryFrame = false;
    this.myGravityAcceleration = 0;
    this.myMaxGravitySpeed = 0;
    this.myEngine = engine;
    this.myDebugEnabled = false;
    this.myDebugDetectEnabled = false;
    this.myDebugShowEnabled = false;
    this.myDebugVisibilityEnabled = false;
  }
};
var PlayerLocomotionTeleportRuntimeParams = class {
  constructor() {
    this.myTeleportPosition = vec3_create();
    this.myTeleportForward = vec3_create(0, 0, 0);
  }
};
var PlayerLocomotionTeleport = class extends PlayerLocomotionMovement {
  constructor(teleportParams, locomotionRuntimeParams) {
    super(locomotionRuntimeParams);
    this._myTeleportParams = teleportParams;
    this._myTeleportRuntimeParams = new PlayerLocomotionTeleportRuntimeParams();
    this._myStickIdleCharge = true;
    this._myDetectionState = new PlayerLocomotionTeleportDetectionState(this._myTeleportParams, this._myTeleportRuntimeParams, this._myLocomotionRuntimeParams);
    this._myTeleportState = new PlayerLocomotionTeleportTeleportState(this._myTeleportParams, this._myTeleportRuntimeParams, this._myLocomotionRuntimeParams);
    this._myFSM = new FSM();
    this._myFSM.addState("init");
    this._myFSM.addState("idle", this._idleUpdate.bind(this));
    this._myFSM.addState("detect", this._myDetectionState);
    this._myFSM.addState("teleport", this._myTeleportState);
    this._myFSM.addTransition("init", "idle", "start");
    this._myFSM.addTransition("idle", "detect", "detect");
    this._myFSM.addTransition("detect", "teleport", "teleport");
    this._myFSM.addTransition("teleport", "idle", "done");
    this._myFSM.addTransition("idle", "idle", "stop");
    this._myFSM.addTransition("detect", "idle", "stop");
    this._myFSM.addTransition("teleport", "idle", "stop", this._completeTeleport.bind(this));
    this._myFSM.addTransition("idle", "idle", "cancel");
    this._myFSM.addTransition("detect", "idle", "cancel");
    this._myFSM.addTransition("teleport", "idle", "cancel", this._cancelTeleport.bind(this), SkipStateFunction.END);
    this._myFSM.init("init");
    this._myFSM.perform("start");
    this._myIsUpdating = false;
    this._myDestroyed = false;
    this.setActive(true);
  }
  start() {
  }
  stop() {
    this._myIsUpdating = true;
    this._myFSM.perform("stop");
    this._myIsUpdating = false;
  }
  cancelTeleport() {
    if (!this._myIsUpdating && this._myFSM.isInState("teleport")) {
      this._myFSM.perform("cancel");
    }
  }
  canStop() {
    return this._myFSM.isInState("idle");
  }
  isTeleporting() {
    return this._myFSM.isInState("teleport");
  }
  getParams() {
    return this._myTeleportParams;
  }
  getTeleportRuntimeParams() {
    return this._myTeleportRuntimeParams;
  }
  update(dt) {
    if (!this.isActive())
      return;
    this._myIsUpdating = true;
    this._prepareCollisionCheckParams();
    this._myLocomotionRuntimeParams.myTeleportJustPerformed = false;
    this._myFSM.update(dt);
    if (!this._myLocomotionRuntimeParams.myIsTeleporting && (this._myTeleportParams.myAdjustPositionEveryFrame || this._myTeleportParams.myGravityAcceleration != 0)) {
      this._applyGravity(dt);
    }
    if (this._myTeleportParams.myPlayerTransformManager.getCollisionRuntimeParams().myIsOnGround) {
      this._myLocomotionRuntimeParams.myIsFlying = false;
    }
    this._myIsUpdating = false;
  }
  _idleUpdate(dt) {
    if (this._startDetecting()) {
      this._myFSM.perform("detect");
    }
  }
  _startDetecting() {
    let startDetecting = false;
    if (!XRUtils.isSessionActive(this._myTeleportParams.myEngine)) {
      startDetecting = Globals.getMouse(this._myTeleportParams.myEngine).isButtonPressStart(MouseButtonID.MIDDLE) && Globals.getMouse(this._myTeleportParams.myEngine).isTargetingRenderCanvas();
    } else {
      let axes = Globals.getGamepads(this._myTeleportParams.myEngine)[this._myTeleportParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
      if (axes.vec2_length() <= this._myTeleportParams.myStickIdleThreshold) {
        this._myStickIdleCharge = true;
      }
      if (this._myStickIdleCharge && axes[1] >= 0.75) {
        this._myStickIdleCharge = false;
        startDetecting = true;
      }
    }
    return startDetecting;
  }
  _completeTeleport() {
    this._myTeleportState.completeTeleport();
  }
  _cancelDetection() {
    this._myDetectionState.cancel();
  }
  _cancelTeleport() {
    this._myTeleportState.cancelTeleport();
  }
  _prepareCollisionCheckParams() {
  }
  destroy() {
    this._myDestroyed = true;
    this._myDetectionState.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
PlayerLocomotionTeleport.prototype._applyGravity = function() {
  let playerRotationQuat = quat_create();
  let playerUp = vec3_create();
  let gravityMovement = vec3_create();
  return function _applyGravity(dt) {
    playerUp = this._myTeleportParams.myPlayerTransformManager.getRotationQuat(playerRotationQuat).quat_getUp(playerUp);
    gravityMovement.vec3_zero();
    if (!this._myLocomotionRuntimeParams.myIsFlying && !this._myLocomotionRuntimeParams.myIsTeleporting) {
      this._myLocomotionRuntimeParams.myGravitySpeed += this._myTeleportParams.myGravityAcceleration * dt;
      if (Math.abs(this._myLocomotionRuntimeParams.myGravitySpeed) > Math.abs(this._myTeleportParams.myMaxGravitySpeed)) {
        this._myLocomotionRuntimeParams.myGravitySpeed = Math.pp_sign(this._myTeleportParams.myGravityAcceleration) * Math.abs(this._myTeleportParams.myMaxGravitySpeed);
      }
      gravityMovement = playerUp.vec3_scale(this._myLocomotionRuntimeParams.myGravitySpeed * dt, gravityMovement);
    } else {
      this._myLocomotionRuntimeParams.myGravitySpeed = 0;
    }
    this._myTeleportParams.myPlayerTransformManager.move(gravityMovement);
    const collisionRuntimeParams = this._myTeleportParams.myPlayerTransformManager.getCollisionRuntimeParams();
    if (this._myLocomotionRuntimeParams.myGravitySpeed > 0 && collisionRuntimeParams.myIsOnCeiling || this._myLocomotionRuntimeParams.myGravitySpeed < 0 && collisionRuntimeParams.myIsOnGround) {
      this._myLocomotionRuntimeParams.myGravitySpeed = 0;
    }
  };
}();

// dist/pp/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion.js
var PlayerLocomotionDirectionReferenceType;
(function(PlayerLocomotionDirectionReferenceType2) {
  PlayerLocomotionDirectionReferenceType2[PlayerLocomotionDirectionReferenceType2["HEAD"] = 0] = "HEAD";
  PlayerLocomotionDirectionReferenceType2[PlayerLocomotionDirectionReferenceType2["HAND"] = 1] = "HAND";
  PlayerLocomotionDirectionReferenceType2[PlayerLocomotionDirectionReferenceType2["CUSTOM_OBJECT"] = 2] = "CUSTOM_OBJECT";
})(PlayerLocomotionDirectionReferenceType || (PlayerLocomotionDirectionReferenceType = {}));
var PlayerLocomotionType;
(function(PlayerLocomotionType2) {
  PlayerLocomotionType2[PlayerLocomotionType2["SMOOTH"] = 0] = "SMOOTH";
  PlayerLocomotionType2[PlayerLocomotionType2["TELEPORT"] = 1] = "TELEPORT";
})(PlayerLocomotionType || (PlayerLocomotionType = {}));
var PlayerLocomotionParams = class {
  myDefaultLocomotionType = PlayerLocomotionType.SMOOTH;
  myAlwaysSmoothForNonVR = false;
  /** Double press main hand thumbstick (default: left) to switch */
  mySwitchLocomotionTypeShortcutEnabled = false;
  myStartIdle = false;
  myPhysicsBlockLayerFlags = new PhysicsLayerFlags();
  myDefaultHeight = 0;
  myMinHeight = 0;
  myCharacterRadius = 0;
  /** Set this to `null` to auto compute the feet radius based on {@link myCharacterRadius} */
  myCharacterFeetRadius = null;
  myForeheadExtraHeight = 0;
  myMaxSpeed = 0;
  myMaxRotationSpeed = 0;
  mySpeedSlowDownPercentageOnWallSlid = 0;
  myGravityAcceleration = 0;
  myMaxGravitySpeed = 0;
  myIsSnapTurn = false;
  mySnapTurnOnlyVR = false;
  mySnapTurnAngle = 0;
  mySnapTurnSpeedDegrees = 0;
  myFlyEnabled = false;
  myStartFlying = false;
  myFlyWithButtonsEnabled = false;
  myFlyWithViewAngleEnabled = false;
  myMinAngleToFlyUpNonVR = 0;
  myMinAngleToFlyDownNonVR = 0;
  myMinAngleToFlyUpVR = 0;
  myMinAngleToFlyDownVR = 0;
  myMinAngleToFlyRight = 0;
  myMainHand = Handedness.LEFT;
  myDirectionInvertForwardWhenUpsideDown = false;
  myVRDirectionReferenceType = PlayerLocomotionDirectionReferenceType.HEAD;
  myVRDirectionReferenceObject = null;
  myTeleportType = PlayerLocomotionTeleportTeleportType.INSTANT;
  myTeleportMaxDistance = 0;
  myTeleportMaxHeightDifference = 0;
  myTeleportFloorLayerFlags = new PhysicsLayerFlags();
  myTeleportRotationOnUpEnabled = false;
  myTeleportValidMaterial = null;
  myTeleportInvalidMaterial = null;
  myTeleportPositionObject = null;
  myTeleportPositionObjectRotateWithHead = false;
  myTeleportParableStartReferenceObject = null;
  myResetRealOnStart = false;
  /**
   * #WARN With `_myResetRealOnStartFramesAmount` at `1` it can happen that you enter the session like 1 frame before the game load
   * and the head pose might have not been properly initialized yet in the WebXR API, so the reset real will not happen has expected
   * Since this is a sort of edge case (either u enter after the load, or you were already in for more than 2-3 frames), and that
   * setting this to more than `1` can cause a visible (even if very short) stutter after the load (due to resetting the head multiple times),
   * it's better to keep this value at `1`
   * A possible effect of the edge case is the view being obscured on start because it thinks you are colliding
   *
   * A value of `3` will make u sure that the head pose will be initialized and the reset real will happen as expected in any case
   * For example, if u have a total fade at start and nothing can be seen aside the clear color for at least, let's say, 10 frames,
   * you can set this to `3` safely, since there will be no visible stutter to be seen (beside the clear color)
   */
  myResetRealOnStartFramesAmount = 0;
  /** Can fix some head through floor issues, when you can move your head completely to the other side of the floor
      If the floors are thick enough that this can't happen, you can leave this to false  */
  myResetHeadToFeetInsteadOfReal = false;
  myResetHeadToRealMinDistance = 0;
  myMaxHeadToRealHeadSteps = null;
  /** Valid means, for example, that the real player has not moved inside a wall by moving in the real space */
  mySyncWithRealWorldPositionOnlyIfValid = false;
  /** Valid means, for example, that the real player has not moved inside a wall by moving in the real space */
  mySyncWithRealHeightOnlyIfValid = false;
  mySnapRealPositionToGround = false;
  myPreventRealFromColliding = false;
  /**
   * This make it so if you move your head inside the ceiling and try to move with the stick, the player will not move as it was stuck with you.
   * It can be useful to avoid being able to move while the view is occluded and find yourself in random places afterwards.
   *
   * If this is set to `false` instead, the player can still move and, for example, exit the zone with the lower ceiling.
   * When this is set to false, you very likely want also {@link myResetHeadToRealMinDistance} set to `0`, otherwise the view occlusion
   * feature can fade to total black when moving in those situation (even if the move is now allowed and works).
   * Setting {@link myResetHeadToRealMinDistance} to `0` is more expensive performance wise, so you might have to compromise.
   */
  myUseHighestColliderHeightWhenManuallyMovingHorizontally = false;
  myViewOcclusionInsideWallsEnabled = false;
  myViewOcclusionLayerFlags = new PhysicsLayerFlags();
  /**
   * To avoid occlusion issues when moving when touching a tilted ceiling (which is not commong anyway),
   * this value should be a bit lower than {@link myCharacterFeetRadius}
   *
   * If you have a high camera near value, you might need to increase this value, even though the view occlusion might become more aggressive
   */
  myViewOcclusionHeadRadius = 0;
  /**
   * Half of this value should be a bit lower than {@link myForeheadExtraHeight} plus {@link myColliderExtraHeight}, otherwise view occlusion might
   * trigger simply when moving under a low ceiling
   *
   * If you have a high camera near value, you might need to increase this value, even though the view occlusion might become more aggressive
   */
  myViewOcclusionHeadHeight = 0;
  myViewOcclusionFadeOutSeconds = 0;
  myViewOcclusionMaxRealHeadDistance = 0;
  mySyncNonVRHeightWithVROnExitSession = false;
  mySyncNonVRVerticalAngleWithVROnExitSession = false;
  mySyncHeadWithRealAfterLocomotionUpdateIfNeeded = false;
  myColliderAccuracy = CharacterColliderSetupSimplifiedCreationAccuracyLevel.VERY_LOW;
  /**
   * If you enable this, you might also want to disable {@link myColliderCheckCeilings},
   * since it doesn't make much sense to check for ceilings when not checking the height
   */
  myColliderCheckOnlyFeet = false;
  /**
   * If you enable this, you might also want to disable {@link myColliderCheckOnlyFeet},
   * since it doesn't make much sense to check for ceilings without also checking the height
   */
  myColliderCheckCeilings = false;
  myColliderSlideAlongWall = false;
  myColliderMaxWalkableGroundAngle = 0;
  /**
   * This is useful if you want the locomotion teleport feature to be able to go downhill
   * on surfaces steeper than {@link myColliderMaxWalkableGroundAngle}
   *
   * By default the locomotion teleport can't go up on surfaces steeper than {@link myColliderMaxWalkableGroundAngle} anyway,
   * no matter, the value of {@link myColliderMaxTeleportableGroundAngle}
   *
   * If you set this to a value bigger than {@link myColliderMaxWalkableGroundAngle} you will be able to teleport in any case on steeper surfaces,
   * so be careful if you want that, even though usually it's safe, since teleport positions, aside from the locomotion teleport ones, are predefined and
   * safe positions
   *
   * The idea is that with the locomotion smooth you can always go downhill but might no be able to climb back up due to the surface beeing steep,
   * this sort of replicates that for the locomotion, letting you teleport down on steep surfaces but not up
   */
  myColliderMaxTeleportableGroundAngle = null;
  myColliderSnapOnGround = false;
  myColliderMaxDistanceToSnapOnGround = 0;
  myColliderMaxDistanceToPopOutGround = 0;
  myColliderMaxWalkableGroundStepHeight = 0;
  /**
   * Allowing walkable steps on ceiling might create issues with view occlusion for the player (especially with a high value)
   * since you can go more under some low ceiling making the occlusion head collide with it
   *
   * Settings it to zero is safer, but means that the ceilings physx must be more flat, because it's easier that a small ceiling bump now blocks you
   *
   * If you want this to be higher than 0, you might also want to increase {@link myColliderExtraHeight} by this value to avoid issue with view occlusion
   * It will need you to be further from ceiling to be able to move under them tho (since it will be like wearing a hat as tall as {@link myColliderExtraHeight})
   */
  myColliderMaxWalkableCeilingStepHeight = 0;
  myColliderPreventFallingFromEdges = false;
  myColliderMaxMovementSteps = null;
  /**
   * Helps staying a little further from the ceiling
   *
   * If you need to increase {@link myViewOcclusionHeadRadius}, also increasing this can help preventing view occlusion happening when shouldn't
   */
  myColliderExtraHeight = 0;
  /** Main hand (default: left) select + thumbstick press, auto switch to smooth */
  myDebugFlyShortcutEnabled = false;
  myDebugFlyMaxSpeedMultiplier = 0;
  /** Main hand (default: left) thumbstick pressed while moving */
  myMoveThroughCollisionShortcutEnabled = false;
  /** Not main hand (default: right) thumbstick pressed while moving */
  myMoveHeadShortcutEnabled = false;
  /** Main hand (default: left) select pressed while moving */
  myTripleSpeedShortcutEnabled = false;
  myDebugHorizontalEnabled = false;
  myDebugVerticalEnabled = false;
  myCollisionCheckDisabled = false;
  myEngine;
  constructor(engine = Globals.getMainEngine()) {
    this.myEngine = engine;
  }
};
var PlayerLocomotion = class {
  _myParams;
  _myPlayerHeadManager;
  _myPlayerTransformManager;
  _myPlayerLocomotionRotate;
  _myPlayerLocomotionSmooth;
  _myPlayerLocomotionTeleport;
  _myPlayerObscureManager;
  _myLocomotionMovementFSM = new FSM();
  _mySwitchToTeleportOnEnterSession = false;
  _myActive = false;
  _myStarted = false;
  _myIdle = false;
  _myResetRealOnStartCounter = 0;
  _myPreUpdateEmitter = new Emitter13();
  _myPostUpdateEmitter = new Emitter13();
  _myDestroyed = false;
  constructor(params) {
    this._myParams = params;
    const collisionCheckParamsMovement = this._setupCollisionCheckParamsMovement();
    const movementRuntimeParams = new PlayerLocomotionMovementRuntimeParams();
    movementRuntimeParams.myIsFlying = this._myParams.myStartFlying;
    {
      const params2 = new PlayerHeadManagerParams(this._myParams.myEngine);
      params2.mySessionChangeResyncEnabled = true;
      params2.myBlurEndResyncEnabled = true;
      params2.myBlurEndResyncRotation = false;
      params2.myEnterSessionResyncHeight = false;
      params2.myExitSessionResyncHeight = this._myParams.mySyncNonVRHeightWithVROnExitSession;
      params2.myExitSessionResyncVerticalAngle = this._myParams.mySyncNonVRVerticalAngleWithVROnExitSession;
      params2.myExitSessionRemoveRightTilt = true;
      params2.myExitSessionAdjustMaxVerticalAngle = true;
      params2.myExitSessionMaxVerticalAngle = 90;
      params2.myNonVRFloorBasedMode = NonVRReferenceSpaceMode.FLOOR_THEN_KEEP_VR;
      params2.myDefaultHeightNonVR = this._myParams.myDefaultHeight;
      params2.myDefaultHeightVRWithoutFloor = this._myParams.myDefaultHeight;
      params2.myForeheadExtraHeight = this._myParams.myForeheadExtraHeight;
      params2.myFeetRotationKeepUp = true;
      params2.myDebugEnabled = false;
      this._myPlayerHeadManager = new PlayerHeadManager(params2);
    }
    {
      const params2 = new PlayerTransformManagerParams(this._myParams.myEngine);
      params2.myPlayerHeadManager = this._myPlayerHeadManager;
      params2.myMovementCollisionCheckParams = collisionCheckParamsMovement;
      params2.myTeleportCollisionCheckParams = null;
      params2.myTeleportCollisionCheckParamsCopyFromMovement = true;
      params2.myTeleportCollisionCheckParamsCheck360 = true;
      params2.myTeleportCollisionCheckParamsGroundAngleToIgnore = this._myParams.myColliderMaxTeleportableGroundAngle;
      params2.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, true);
      params2.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, true);
      params2.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.FAR, true);
      params2.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, true);
      params2.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.HEIGHT_COLLIDING, true);
      params2.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, true);
      params2.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, false);
      params2.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.FAR, true);
      params2.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, true);
      params2.mySyncPositionFlagMap.set(PlayerTransformManagerSyncFlag.HEIGHT_COLLIDING, false);
      params2.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, false);
      params2.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, true);
      params2.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.FAR, false);
      params2.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, false);
      params2.mySyncPositionHeadFlagMap.set(PlayerTransformManagerSyncFlag.HEIGHT_COLLIDING, false);
      params2.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, false);
      params2.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, false);
      params2.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.FAR, false);
      params2.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, false);
      params2.mySyncRotationFlagMap.set(PlayerTransformManagerSyncFlag.HEIGHT_COLLIDING, false);
      params2.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, false);
      params2.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, false);
      params2.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.FAR, false);
      params2.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, false);
      params2.mySyncHeightFlagMap.set(PlayerTransformManagerSyncFlag.HEIGHT_COLLIDING, true);
      params2.myHeadCollisionBlockLayerFlags.copy(this._myParams.myViewOcclusionLayerFlags);
      params2.myHeadCollisionObjectsToIgnore.pp_copy(params2.myMovementCollisionCheckParams.myHorizontalObjectsToIgnore);
      const objectsEqualCallback = (first2, second) => first2 == second;
      for (const objectToIgnore of params2.myMovementCollisionCheckParams.myVerticalObjectsToIgnore) {
        params2.myHeadCollisionObjectsToIgnore.pp_pushUnique(objectToIgnore, objectsEqualCallback);
      }
      params2.myHeadRadius = this._myParams.myViewOcclusionHeadRadius;
      params2.myHeadHeight = this._myParams.myViewOcclusionHeadHeight;
      params2.myExtraHeight = this._myParams.myColliderExtraHeight;
      if (!this._myParams.mySyncWithRealWorldPositionOnlyIfValid) {
        params2.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.BODY_COLLIDING, false);
        params2.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.FAR, false);
        params2.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.FLOATING, false);
        params2.myAlwaysSyncPositionWithReal = true;
      }
      if (!this._myParams.mySyncWithRealHeightOnlyIfValid) {
        params2.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.HEIGHT_COLLIDING, false);
      }
      if (!this._myParams.myViewOcclusionInsideWallsEnabled) {
        params2.mySyncEnabledFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, false);
        params2.myAlwaysSyncHeadPositionWithReal = true;
      } else {
        params2.myUpdatePositionHeadValid = true;
      }
      params2.myApplyRealToValidAdjustmentsToRealPositionToo = this._myParams.mySnapRealPositionToGround;
      params2.myPreventRealFromColliding = this._myParams.myPreventRealFromColliding;
      params2.myMaxDistanceFromRealToSyncEnabled = true;
      params2.myMaxDistanceFromRealToSync = 0.5;
      params2.myMaxDistanceFromHeadRealToSyncEnabled = true;
      params2.myMaxDistanceFromHeadRealToSync = 0.75;
      if (params2.myMovementCollisionCheckParams.mySplitMovementEnabled && params2.myMovementCollisionCheckParams.mySplitMovementMaxStepsEnabled && params2.myMovementCollisionCheckParams.mySplitMovementMaxLengthEnabled) {
        params2.myMaxDistanceFromHeadRealToSync = Math.max(params2.myMaxDistanceFromHeadRealToSync, 1.1 * (params2.myMovementCollisionCheckParams.mySplitMovementMaxSteps * params2.myMovementCollisionCheckParams.mySplitMovementMaxLength));
      }
      params2.myIsFloatingValidIfVerticalMovement = false;
      params2.myIsFloatingValidIfVerticalMovementAndRealOnGround = false;
      params2.myIsFloatingValidIfSteepGround = false;
      params2.myIsFloatingValidIfVerticalMovementAndSteepGround = false;
      params2.myIsFloatingValidIfRealOnGround = false;
      params2.myFloatingSplitCheckEnabled = true;
      params2.myFloatingSplitCheckMinLength = collisionCheckParamsMovement.myFeetRadius * 1.5;
      params2.myFloatingSplitCheckMaxLength = params2.myFloatingSplitCheckMinLength;
      params2.myRealMovementAllowVerticalAdjustments = true;
      params2.myIgnoreUpwardMovementToRealIfValidOnGround = true;
      params2.myUpdateRealPositionValid = false;
      params2.myUpdatePositionValid = false;
      params2.myMinHeight = this._myParams.myMinHeight;
      params2.myIsBodyCollidingWhenHeightBelowValue = null;
      params2.myIsBodyCollidingWhenHeightAboveValue = null;
      params2.myResetToValidOnEnterSession = true;
      params2.myResetToValidOnExitSession = true;
      params2.myResetToValidOnSessionHiddenEnd = true;
      params2.myAlwaysResetRealPositionNonVR = true;
      params2.myAlwaysResetRealRotationNonVR = true;
      params2.myAlwaysResetRealHeightNonVR = true;
      params2.myAlwaysResetRealPositionVR = false;
      params2.myAlwaysResetRealRotationVR = false;
      params2.myAlwaysResetRealHeightVR = false;
      params2.myNeverResetRealPositionNonVR = false;
      params2.myNeverResetRealRotationNonVR = true;
      params2.myNeverResetRealHeightNonVR = false;
      params2.myResetRealHeightNonVROnExitSession = this._myParams.mySyncNonVRHeightWithVROnExitSession;
      params2.myResetHeadToFeetInsteadOfRealOnlyIfRealNotReachable = this._myParams.myResetHeadToFeetInsteadOfReal;
      params2.myResetHeadToRealMinDistance = this._myParams.myResetHeadToRealMinDistance;
      params2.myMaxHeadToRealHeadSteps = this._myParams.myMaxHeadToRealHeadSteps;
      params2.myNeverResetRealPositionVR = false;
      params2.myNeverResetRealRotationVR = false;
      params2.myNeverResetRealHeightVR = true;
      params2.myResetRealResetRotationIfUpChanged = true;
      params2.myResetHeadToFeetMoveTowardReal = true;
      params2.myResetHeadToFeetUpOffset = 0.25;
      params2.myDebugEnabled = false;
      this._myPlayerTransformManager = new PlayerTransformManager(params2);
    }
    {
      const params2 = new PlayerLocomotionRotateParams(this._myParams.myEngine);
      params2.myPlayerTransformManager = this._myPlayerTransformManager;
      params2.myMaxRotationSpeed = this._myParams.myMaxRotationSpeed;
      params2.myIsSnapTurn = this._myParams.myIsSnapTurn;
      params2.mySnapTurnOnlyVR = this._myParams.mySnapTurnOnlyVR;
      params2.mySnapTurnAngle = this._myParams.mySnapTurnAngle;
      if (this._myParams.mySnapTurnSpeedDegrees > MathUtils.EPSILON) {
        params2.mySmoothSnapEnabled = true;
        params2.mySmoothSnapSpeedDegrees = this._myParams.mySnapTurnSpeedDegrees;
      } else {
        params2.mySmoothSnapEnabled = false;
      }
      params2.myRotationMinStickIntensityThreshold = 0.1;
      params2.mySnapTurnActivateThreshold = 0.5;
      params2.mySnapTurnResetThreshold = 0.4;
      params2.myClampVerticalAngle = true;
      params2.myMaxVerticalAngle = 89;
      params2.myHandedness = InputUtils.getOppositeHandedness(this._myParams.myMainHand);
      this._myPlayerLocomotionRotate = new PlayerLocomotionRotate(params2);
    }
    {
      {
        const params2 = new PlayerLocomotionSmoothParams(this._myParams.myEngine);
        params2.myPlayerTransformManager = this._myPlayerTransformManager;
        params2.myHandedness = this._myParams.myMainHand;
        params2.myMaxSpeed = this._myParams.myMaxSpeed;
        params2.mySpeedSlowDownPercentageOnWallSlid = this._myParams.mySpeedSlowDownPercentageOnWallSlid;
        params2.myMovementMinStickIntensityThreshold = 0.1;
        params2.myFlyEnabled = this._myParams.myFlyEnabled;
        params2.myFlyWithButtonsEnabled = this._myParams.myFlyWithButtonsEnabled;
        params2.myFlyWithViewAngleEnabled = this._myParams.myFlyWithViewAngleEnabled;
        params2.myMinAngleToFlyUpNonVR = this._myParams.myMinAngleToFlyUpNonVR;
        params2.myMinAngleToFlyDownNonVR = this._myParams.myMinAngleToFlyDownNonVR;
        params2.myMinAngleToFlyUpVR = this._myParams.myMinAngleToFlyUpVR;
        params2.myMinAngleToFlyDownVR = this._myParams.myMinAngleToFlyDownVR;
        params2.myMinAngleToFlyRight = this._myParams.myMinAngleToFlyRight;
        params2.myGravityAcceleration = this._myParams.myGravityAcceleration;
        params2.myMaxGravitySpeed = this._myParams.myMaxGravitySpeed;
        params2.myDirectionInvertForwardWhenUpsideDown = this._myParams.myDirectionInvertForwardWhenUpsideDown;
        params2.myVRDirectionReferenceType = this._myParams.myVRDirectionReferenceType;
        params2.myVRDirectionReferenceObject = this._myParams.myVRDirectionReferenceObject;
        params2.myUseHighestColliderHeightWhenManuallyMovingHorizontally = this._myParams.myUseHighestColliderHeightWhenManuallyMovingHorizontally;
        params2.myUseHighestColliderHeightWhenManuallyMovingVertically = false;
        params2.myAttemptMoveAgainWhenFailedDueToCeilingPopOut = true;
        params2.myDebugFlyMaxSpeedMultiplier = this._myParams.myDebugFlyMaxSpeedMultiplier;
        params2.myMoveThroughCollisionShortcutEnabled = this._myParams.myMoveThroughCollisionShortcutEnabled;
        params2.myMoveHeadShortcutEnabled = this._myParams.myMoveHeadShortcutEnabled;
        params2.myTripleSpeedShortcutEnabled = this._myParams.myTripleSpeedShortcutEnabled;
        this._myPlayerLocomotionSmooth = new PlayerLocomotionSmooth(params2, movementRuntimeParams);
      }
      {
        const params2 = new PlayerLocomotionTeleportParams(this._myParams.myEngine);
        params2.myPlayerTransformManager = this._myPlayerTransformManager;
        params2.myHandedness = this._myParams.myMainHand;
        params2.myDetectionParams.myMaxDistance = this._myParams.myTeleportMaxDistance;
        params2.myDetectionParams.myMaxHeightDifference = this._myParams.myTeleportMaxHeightDifference;
        params2.myDetectionParams.myGroundAngleToIgnoreUpward = collisionCheckParamsMovement.myGroundAngleToIgnore;
        params2.myDetectionParams.myRotationOnUpEnabled = this._myParams.myTeleportRotationOnUpEnabled;
        params2.myDetectionParams.myMustBeOnGround = true;
        params2.myDetectionParams.myMustBeOnIgnorableGroundAngle = true;
        params2.myDetectionParams.myTeleportBlockLayerFlags.copy(this._myParams.myPhysicsBlockLayerFlags);
        params2.myDetectionParams.myTeleportFloorLayerFlags.copy(this._myParams.myTeleportFloorLayerFlags);
        params2.myDetectionParams.myTeleportFeetPositionMustBeVisible = false;
        params2.myDetectionParams.myTeleportHeadPositionMustBeVisible = false;
        params2.myDetectionParams.myTeleportHeadOrFeetPositionMustBeVisible = true;
        params2.myDetectionParams.myTeleportParableStartReferenceObject = this._myParams.myTeleportParableStartReferenceObject;
        params2.myDetectionParams.myVisibilityBlockLayerFlags.copy(params2.myDetectionParams.myTeleportBlockLayerFlags);
        params2.myDetectionParams.myPlayerTransformManagerMustBeSyncedFlagMap.set(PlayerTransformManagerSyncFlag.HEAD_COLLIDING, false);
        params2.myDetectionParams.myPositionRealMaxDistance = 0.4;
        params2.myDetectionParams.myPositionHeadRealMaxDistance = this._myParams.myViewOcclusionMaxRealHeadDistance / 2;
        params2.myDetectionParams.myPositionHeadMustBeValid = true;
        params2.myTeleportParams.myTeleportType = this._myParams.myTeleportType;
        params2.myVisualizerParams.myTeleportPositionObject = this._myParams.myTeleportPositionObject;
        params2.myVisualizerParams.myTeleportValidMaterial = this._myParams.myTeleportValidMaterial;
        params2.myVisualizerParams.myTeleportInvalidMaterial = this._myParams.myTeleportInvalidMaterial;
        params2.myVisualizerParams.myTeleportPositionObjectRotateWithHead = this._myParams.myTeleportPositionObjectRotateWithHead;
        params2.myPerformTeleportAsMovement = false;
        params2.myTeleportAsMovementRemoveVerticalMovement = true;
        params2.myTeleportAsMovementExtraVerticalMovementPerMeter = -2;
        params2.myGravityAcceleration = this._myParams.myGravityAcceleration;
        params2.myMaxGravitySpeed = this._myParams.myMaxGravitySpeed;
        params2.myDebugEnabled = false;
        params2.myDebugDetectEnabled = true;
        params2.myDebugShowEnabled = true;
        params2.myDebugVisibilityEnabled = false;
        this._myPlayerLocomotionTeleport = new PlayerLocomotionTeleport(params2, movementRuntimeParams);
      }
      this._myPlayerTransformManager.setPlayerLocomotionTeleport(this._myPlayerLocomotionTeleport);
      {
        const params2 = new PlayerObscureManagerParams(this._myParams.myEngine);
        params2.myPlayerTransformManager = this._myPlayerTransformManager;
        params2.myPlayerLocomotionTeleport = this._myPlayerLocomotionTeleport;
        params2.myEnabled = this._myParams.myViewOcclusionInsideWallsEnabled;
        params2.myObscureObject = null;
        params2.myObscureMaterial = null;
        params2.myObscureRadius = 0.5;
        params2.myObscureFadeOutSeconds = this._myParams.myViewOcclusionFadeOutSeconds;
        params2.myObscureFadeInSeconds = 0.25;
        params2.myObscureFadeEasingFunction = EasingFunction.linear;
        params2.myObscureLevelRelativeDistanceEasingFunction = EasingFunction.linear;
        params2.myObscureIfPositionHeadNotValid = true;
        params2.myDistanceToStartObscureWhenBodyColliding = 0.75;
        params2.myDistanceToStartObscureWhenHeadColliding = 0;
        params2.myDistanceToStartObscureWhenFloating = 0.75;
        params2.myDistanceToStartObscureWhenFar = 0.75;
        params2.myRelativeDistanceToMaxObscureWhenBodyColliding = 0.5;
        params2.myRelativeDistanceToMaxObscureWhenHeadColliding = this._myParams.myViewOcclusionMaxRealHeadDistance;
        params2.myRelativeDistanceToMaxObscureWhenFloating = 0.5;
        params2.myRelativeDistanceToMaxObscureWhenFar = 0.5;
        this._myPlayerObscureManager = new PlayerObscureManager(params2);
      }
    }
    this._setupLocomotionMovementFSM();
    this._myResetRealOnStartCounter = this._myParams.myResetRealOnStartFramesAmount;
  }
  start() {
    this._fixAlmostUp();
    this._myPlayerHeadManager.start();
    this._myPlayerTransformManager.start();
    this._myPlayerObscureManager.start();
    this._myPlayerLocomotionRotate.start();
    if (this._myParams.myDefaultLocomotionType == PlayerLocomotionType.SMOOTH) {
      this._myLocomotionMovementFSM.perform("startSmooth");
    } else {
      this._myLocomotionMovementFSM.perform("startTeleport");
    }
    if (this._myParams.myStartIdle) {
      this.setIdle(true);
    }
    this._myStarted = true;
    const currentActive = this._myActive;
    this._myActive = !this._myActive;
    this.setActive(currentActive);
  }
  /** #WARN Only a few params are actually used by this class after the setup phase, like @myCollisionCheckDisabled
      Params like @myMaxSpeed must be edited directly on the PlayerLocomotionSmooth object*/
  getParams() {
    return this._myParams;
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      if (this._myStarted) {
        if (this._myActive) {
          this._myPlayerObscureManager.start();
          if (!this._myIdle) {
            this._myLocomotionMovementFSM.perform("resume");
          }
        } else {
          this._myLocomotionMovementFSM.perform("idle");
          this._myPlayerObscureManager.stop();
        }
      }
    }
    this._myPlayerHeadManager.setActive(this._myActive);
    this._myPlayerTransformManager.setActive(this._myActive);
    this._myPlayerObscureManager.setActive(this._myActive);
    this._myPlayerLocomotionSmooth.setActive(this._myActive);
    this._myPlayerLocomotionTeleport.setActive(this._myActive);
  }
  isActive() {
    return this._myActive;
  }
  isStarted() {
    return this._myStarted;
  }
  canStop() {
    let canStop = false;
    if (this.isSmooth() && this._myPlayerLocomotionSmooth.canStop()) {
      canStop = true;
    } else if (this.isTeleport() && this._myPlayerLocomotionTeleport.canStop()) {
      canStop = true;
    }
    return canStop;
  }
  stop() {
    if (this.isSmooth()) {
      this._myPlayerLocomotionSmooth.stop();
    } else if (this.isTeleport()) {
      this._myPlayerLocomotionTeleport.stop();
    }
  }
  isIdle() {
    return this._myIdle;
  }
  setIdle(idle) {
    if (this._myIdle != idle) {
      this._myIdle = idle;
      if (idle) {
        this._myLocomotionMovementFSM.perform("idle");
      } else {
        this._myLocomotionMovementFSM.perform("resume");
      }
    }
  }
  isSmooth() {
    return this._myLocomotionMovementFSM.isInState("smooth") || this._myLocomotionMovementFSM.isInState("idleSmooth");
  }
  switchToSmooth() {
    this._myLocomotionMovementFSM.perform("switchSmooth");
  }
  isTeleport() {
    return this._myLocomotionMovementFSM.isInState("teleport") || this._myLocomotionMovementFSM.isInState("idleTeleport");
  }
  switchToTeleport() {
    this._myLocomotionMovementFSM.perform("switchTeleport");
  }
  getPlayerLocomotionSmooth() {
    return this._myPlayerLocomotionSmooth;
  }
  getPlayerLocomotionTeleport() {
    return this._myPlayerLocomotionTeleport;
  }
  getPlayerTransformManager() {
    return this._myPlayerTransformManager;
  }
  getPlayerLocomotionRotate() {
    return this._myPlayerLocomotionRotate;
  }
  getPlayerHeadManager() {
    return this._myPlayerHeadManager;
  }
  getPlayerObscureManager() {
    return this._myPlayerObscureManager;
  }
  registerPreUpdateCallback(id, callback) {
    this._myPreUpdateEmitter.add(callback, { id });
  }
  unregisterPreUpdateCallback(id) {
    this._myPreUpdateEmitter.remove(id);
  }
  registerPostUpdateCallback(id, callback) {
    this._myPostUpdateEmitter.add(callback, { id });
  }
  unregisterPostUpdateCallback(id) {
    this._myPostUpdateEmitter.remove(id);
  }
  update(dt) {
    if (!this._myActive)
      return;
    this._myPreUpdateEmitter.notify(dt, this);
    let collisionCheckEnabledBackup = false;
    let maxGravitySpeedBackup = 0;
    if (this._myParams.myCollisionCheckDisabled && Globals.isDebugEnabled(this._myParams.myEngine)) {
      collisionCheckEnabledBackup = CollisionCheckBridge.isCollisionCheckDisabled();
      maxGravitySpeedBackup = this.getPlayerLocomotionSmooth().getParams().myMaxGravitySpeed;
      CollisionCheckBridge.setCollisionCheckDisabled(true);
      this.getPlayerLocomotionSmooth().getParams().myMaxGravitySpeed = 0;
    }
    this._myPlayerHeadManager.update(dt);
    if (this._myParams.myResetRealOnStart && this._myResetRealOnStartCounter > 0) {
      this._myResetRealOnStartCounter--;
      this._myPlayerTransformManager.resetReal(true, true, void 0, void 0, void 0, true);
      this._myPlayerTransformManager.update(dt);
    } else {
      this._myPlayerTransformManager.update(dt);
      if (!this._myPlayerLocomotionSmooth.isDebugFlyEnabled() || !Globals.isDebugEnabled(this._myParams.myEngine)) {
        if (!this._myParams.myAlwaysSmoothForNonVR || XRUtils.isSessionActive(this._myParams.myEngine)) {
          if (this._myParams.mySwitchLocomotionTypeShortcutEnabled && this._getMainHandGamepad().getButtonInfo(GamepadButtonID.THUMBSTICK).isPressEnd(2) && this.canStop()) {
            if (this.isTeleport()) {
              this.switchToSmooth();
            } else {
              this.switchToTeleport();
            }
          }
        }
        if (this._myParams.myAlwaysSmoothForNonVR && !XRUtils.isSessionActive(this._myParams.myEngine)) {
          if (this.isTeleport() && this.canStop()) {
            this._mySwitchToTeleportOnEnterSession = true;
            this.switchToSmooth();
          }
        } else if (this._mySwitchToTeleportOnEnterSession && XRUtils.isSessionActive(this._myParams.myEngine)) {
          if (this.isSmooth() && this.canStop()) {
            this._mySwitchToTeleportOnEnterSession = false;
            this.switchToTeleport();
          }
        }
      }
      if (this._myParams.myDebugFlyShortcutEnabled && Globals.isDebugEnabled(this._myParams.myEngine)) {
        if (GamepadUtils.areButtonsPressEnd([this._getMainHandGamepad(), GamepadButtonID.SELECT, GamepadButtonID.THUMBSTICK])) {
          if (this.isTeleport() && this.canStop()) {
            this.switchToSmooth();
          }
          if (this.isSmooth()) {
            this._myPlayerLocomotionSmooth.setDebugFlyEnabled(!this._myPlayerLocomotionSmooth.isDebugFlyEnabled());
            this._mySwitchToTeleportOnEnterSession = false;
          }
        }
      }
      if (this._myPlayerHeadManager.isSynced()) {
        if (!this._myIdle) {
          this._myPlayerLocomotionRotate.update(dt);
          this._myLocomotionMovementFSM.update(dt);
        }
      }
    }
    if (this._myParams.mySyncHeadWithRealAfterLocomotionUpdateIfNeeded) {
      this._myPlayerTransformManager.updateValidHeadToRealHeadIfNeeded();
    }
    this._myPlayerObscureManager.update(dt);
    if (this._myParams.myCollisionCheckDisabled && Globals.isDebugEnabled(this._myParams.myEngine)) {
      CollisionCheckBridge.setCollisionCheckDisabled(collisionCheckEnabledBackup);
      this.getPlayerLocomotionSmooth().getParams().myMaxGravitySpeed = maxGravitySpeedBackup;
    }
    this._myPostUpdateEmitter.notify(dt, this);
  }
  _setupCollisionCheckParamsMovement() {
    const simplifiedParams = new CharacterColliderSetupSimplifiedCreationParams();
    simplifiedParams.myHeight = this._myParams.myDefaultHeight;
    simplifiedParams.myRadius = this._myParams.myCharacterRadius;
    simplifiedParams.myFeetRadius = this._myParams.myCharacterFeetRadius;
    simplifiedParams.myAccuracyLevel = this._myParams.myColliderAccuracy;
    simplifiedParams.myIsPlayer = true;
    simplifiedParams.myCheckOnlyFeet = this._myParams.myColliderCheckOnlyFeet;
    simplifiedParams.myCheckCeilings = this._myParams.myColliderCheckCeilings;
    simplifiedParams.myShouldSlideAlongWall = this._myParams.myColliderSlideAlongWall;
    simplifiedParams.myCollectGroundInfo = true;
    simplifiedParams.myMaxWalkableGroundAngle = this._myParams.myColliderMaxWalkableGroundAngle;
    simplifiedParams.myMaxDistanceToSnapOnGround = this._myParams.myColliderMaxDistanceToSnapOnGround;
    simplifiedParams.myMaxDistanceToPopOutGround = this._myParams.myColliderMaxDistanceToPopOutGround;
    simplifiedParams.myMaxWalkableGroundStepHeight = this._myParams.myColliderMaxWalkableGroundStepHeight;
    simplifiedParams.myMaxWalkableCeilingStepHeight = this._myParams.myColliderMaxWalkableCeilingStepHeight;
    simplifiedParams.myShouldNotFallFromEdges = this._myParams.myColliderPreventFallingFromEdges;
    simplifiedParams.myMaxMovementSteps = this._myParams.myColliderMaxMovementSteps;
    simplifiedParams.myHorizontalCheckBlockLayerFlags.copy(this._myParams.myPhysicsBlockLayerFlags);
    const physXComponents = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getComponents(PhysXComponent10);
    for (const physXComponent of physXComponents) {
      simplifiedParams.myHorizontalCheckObjectsToIgnore.pp_pushUnique(physXComponent.object, (first2, second) => first2 == second);
    }
    simplifiedParams.myVerticalCheckBlockLayerFlags.copy(simplifiedParams.myHorizontalCheckBlockLayerFlags);
    simplifiedParams.myVerticalCheckObjectsToIgnore.pp_copy(simplifiedParams.myHorizontalCheckObjectsToIgnore);
    simplifiedParams.myHorizontalCheckDebugEnabled = this._myParams.myDebugHorizontalEnabled;
    simplifiedParams.myVerticalCheckDebugEnabled = this._myParams.myDebugVerticalEnabled;
    const colliderSetup = CharacterColliderSetupUtils.createSimplified(simplifiedParams);
    return CollisionCheckBridge.convertCharacterColliderSetupToCollisionCheckParams(colliderSetup);
  }
  _fixAlmostUp() {
    const defaultUp = vec3_create(0, 1, 0);
    const angleWithDefaultUp = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getUp().vec3_angle(defaultUp);
    if (angleWithDefaultUp < 1) {
      const forward = Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_getForward();
      const flatForward = forward.vec3_clone();
      flatForward[1] = 0;
      const defaultForward = vec3_create(0, 0, 1);
      const angleWithDefaultForward = defaultForward.vec3_angleSigned(flatForward, defaultUp);
      Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_resetRotation();
      Globals.getPlayerObjects(this._myParams.myEngine).myPlayer.pp_rotateAxis(angleWithDefaultForward, defaultUp);
    }
  }
  _setupLocomotionMovementFSM() {
    this._myLocomotionMovementFSM.addState("init");
    this._myLocomotionMovementFSM.addState("smooth", (dt) => this._myPlayerLocomotionSmooth.update(dt));
    this._myLocomotionMovementFSM.addState("teleport", (dt) => this._myPlayerLocomotionTeleport.update(dt));
    this._myLocomotionMovementFSM.addState("idleSmooth");
    this._myLocomotionMovementFSM.addState("idleTeleport");
    this._myLocomotionMovementFSM.addTransition("init", "smooth", "startSmooth", function() {
      this._myPlayerLocomotionTeleport.stop();
      this._myPlayerLocomotionSmooth.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("init", "teleport", "startTeleport", function() {
      this._myPlayerLocomotionSmooth.stop();
      this._myPlayerLocomotionTeleport.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("smooth", "teleport", "switchTeleport", function() {
      this._myPlayerLocomotionSmooth.stop();
      this._myPlayerLocomotionTeleport.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("teleport", "smooth", "switchSmooth", function() {
      this._myPlayerLocomotionTeleport.stop();
      this._myPlayerLocomotionSmooth.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("smooth", "idleSmooth", "idle", function() {
      this._myPlayerLocomotionSmooth.stop();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("teleport", "idleTeleport", "idle", function() {
      this._myPlayerLocomotionTeleport.stop();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("idleSmooth", "smooth", "resume", function() {
      this._myPlayerLocomotionSmooth.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("idleTeleport", "teleport", "resume", function() {
      this._myPlayerLocomotionTeleport.start();
    }.bind(this));
    this._myLocomotionMovementFSM.addTransition("idleSmooth", "idleTeleport", "switchTeleport");
    this._myLocomotionMovementFSM.addTransition("idleTeleport", "idleSmooth", "switchSmooth");
    this._myLocomotionMovementFSM.init("init");
  }
  _getMainHandGamepad() {
    return Globals.getGamepads(this._myParams.myEngine)[this._myParams.myMainHand];
  }
  destroy() {
    this._myDestroyed = true;
    this._myPlayerHeadManager.destroy();
    this._myPlayerLocomotionSmooth.destroy();
    this._myPlayerTransformManager.destroy();
    this._myPlayerObscureManager.destroy();
    this._myPlayerLocomotionTeleport.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/gameplay/experimental/locomotion/legacy/locomotion/player_locomotion_smooth.js
var PlayerLocomotionSmoothParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myPlayerTransformManager = null;
    this.myMaxSpeed = 0;
    this.mySpeedSlowDownPercentageOnWallSlid = 0;
    this.myMovementMinStickIntensityThreshold = 0;
    this.myFlyEnabled = false;
    this.myFlyWithButtonsEnabled = false;
    this.myFlyWithViewAngleEnabled = false;
    this.myMinAngleToFlyUpNonVR = 0;
    this.myMinAngleToFlyDownNonVR = 0;
    this.myMinAngleToFlyUpVR = 0;
    this.myMinAngleToFlyDownVR = 0;
    this.myMinAngleToFlyRight = 0;
    this.myGravityAcceleration = 0;
    this.myMaxGravitySpeed = 0;
    this.myDirectionInvertForwardWhenUpsideDown = false;
    this.myVRDirectionReferenceType = PlayerLocomotionDirectionReferenceType.HEAD;
    this.myVRDirectionReferenceObject = null;
    this.myHandedness = Handedness.LEFT;
    this.myUseHighestColliderHeightWhenManuallyMovingHorizontally = false;
    this.myUseHighestColliderHeightWhenManuallyMovingVertically = false;
    this.myAttemptMoveAgainWhenFailedDueToCeilingPopOut = false;
    this.myDebugFlyMaxSpeedMultiplier = 0;
    this.myMoveThroughCollisionShortcutEnabled = false;
    this.myMoveHeadShortcutEnabled = false;
    this.myTripleSpeedShortcutEnabled = false;
    this.myEngine = engine;
  }
};
var PlayerLocomotionSmooth = class extends PlayerLocomotionMovement {
  constructor(params, locomotionRuntimeParams) {
    super(locomotionRuntimeParams);
    this._myParams = params;
    this._myCurrentSpeed = 0;
    this._myLastHorizontalMovement = vec3_create();
    this._myDirectionReference = Globals.getPlayerObjects(this._myParams.myEngine).myHead;
    this._myStickIdleTimer = new Timer(0.25, false);
    let directionConverterNonVRParams = new Direction2DTo3DConverterParams(this._myParams.myEngine);
    directionConverterNonVRParams.myAutoUpdateFlyForward = this._myParams.myFlyEnabled && this._myParams.myFlyWithViewAngleEnabled;
    directionConverterNonVRParams.myAutoUpdateFlyRight = this._myParams.myFlyEnabled && this._myParams.myFlyWithViewAngleEnabled;
    directionConverterNonVRParams.myMinAngleToFlyForwardUp = this._myParams.myMinAngleToFlyUpNonVR;
    directionConverterNonVRParams.myMinAngleToFlyForwardDown = this._myParams.myMinAngleToFlyDownNonVR;
    directionConverterNonVRParams.myMinAngleToFlyRightUp = this._myParams.myMinAngleToFlyRight;
    directionConverterNonVRParams.myMinAngleToFlyRightDown = this._myParams.myMinAngleToFlyRight;
    directionConverterNonVRParams.myInvertForwardWhenUpsideDown = this._myParams.myDirectionInvertForwardWhenUpsideDown;
    let directionConverterVRParams = new Direction2DTo3DConverterParams(this._myParams.myEngine);
    directionConverterVRParams.myAutoUpdateFlyForward = this._myParams.myFlyEnabled && this._myParams.myFlyWithViewAngleEnabled;
    directionConverterVRParams.myAutoUpdateFlyRight = this._myParams.myFlyEnabled && this._myParams.myFlyWithViewAngleEnabled;
    directionConverterVRParams.myMinAngleToFlyForwardUp = this._myParams.myMinAngleToFlyUpVR;
    directionConverterVRParams.myMinAngleToFlyForwardDown = this._myParams.myMinAngleToFlyDownVR;
    directionConverterVRParams.myMinAngleToFlyRightUp = this._myParams.myMinAngleToFlyRight;
    directionConverterVRParams.myMinAngleToFlyRightDown = this._myParams.myMinAngleToFlyRight;
    directionConverterVRParams.myInvertForwardWhenUpsideDown = this._myParams.myDirectionInvertForwardWhenUpsideDown;
    this._myDirectionConverterNonVR = new Direction2DTo3DConverter(directionConverterNonVRParams);
    this._myDirectionConverterVR = new Direction2DTo3DConverter(directionConverterVRParams);
    this._myCurrentDirectionConverter = this._myDirectionConverterNonVR;
    this._myDebugFlyEnabled = false;
    this._myDestroyed = false;
    this.setActive(true);
  }
  start() {
    this._myCurrentSpeed = 0;
    this._myLastHorizontalMovement.vec3_zero();
  }
  setActive(active) {
    if (this.isActive() != active) {
      if (active) {
        XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myParams.myEngine);
      } else {
        XRUtils.unregisterSessionStartEndEventListeners(this, this._myParams.myEngine);
      }
    }
    super.setActive(active);
  }
  getParams() {
    return this._myParams;
  }
  getCurrentSpeed() {
    return this._myCurrentSpeed;
  }
  getLastHorizontalSpeed() {
    return this._myLastHorizontalMovement;
  }
  update(dt) {
  }
  setDebugFlyEnabled(enabled) {
    if (this._myDebugFlyEnabled != enabled) {
      if (!enabled) {
        this._myLocomotionRuntimeParams.myIsFlying = false;
        this._myCurrentDirectionConverter.resetFly();
      }
    }
    this._myDebugFlyEnabled = enabled;
  }
  isDebugFlyEnabled() {
    return this._myDebugFlyEnabled;
  }
  _onXRSessionStart(session) {
  }
  _onXRSessionEnd(session) {
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};
PlayerLocomotionSmooth.prototype.update = function() {
  let playerRotationQuat = quat_create();
  let playerUp = vec3_create();
  let totalMovement = vec3_create();
  let horizontalMovement = vec3_create();
  let verticalMovement = vec3_create();
  let headMovement = vec3_create();
  let direction = vec3_create();
  let directionOnUp = vec3_create();
  let directionReferenceTransformQuat = quat2_create();
  return function update(dt) {
    if (!this.isActive())
      return;
    let debugFlyEnabled = this._myDebugFlyEnabled && Globals.isDebugEnabled(this._myParams.myEngine);
    this._myCurrentSpeed = 0;
    this._myLastHorizontalMovement.vec3_zero();
    playerUp = this._myParams.myPlayerTransformManager.getRotationQuat(playerRotationQuat).quat_getUp(playerUp);
    totalMovement.vec3_zero();
    horizontalMovement.vec3_zero();
    verticalMovement.vec3_zero();
    headMovement.vec3_zero();
    let axes = Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getAxesInfo(GamepadAxesID.THUMBSTICK).getAxes();
    axes[0] = Math.abs(axes[0]) > this._myParams.myMovementMinStickIntensityThreshold ? axes[0] : 0;
    axes[1] = Math.abs(axes[1]) > this._myParams.myMovementMinStickIntensityThreshold ? axes[1] : 0;
    let isManuallyMovingHorizontally = false;
    let isManuallyMovingVertically = false;
    let maxSpeed = this._myParams.myMaxSpeed;
    if (debugFlyEnabled) {
      maxSpeed = maxSpeed * this._myParams.myDebugFlyMaxSpeedMultiplier;
    }
    if (this._myParams.myTripleSpeedShortcutEnabled && Globals.isDebugEnabled(this._myParams.myEngine) || debugFlyEnabled) {
      if (Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.SELECT).isPressed()) {
        maxSpeed *= 3;
      }
    }
    if (debugFlyEnabled && Globals.getGamepads(this._myParams.myEngine)[InputUtils.getOppositeHandedness(this._myParams.myHandedness)].getButtonInfo(GamepadButtonID.SELECT).isPressed()) {
      maxSpeed = this._myParams.myMaxSpeed;
    }
    const collisionRuntimeParams = this._myParams.myPlayerTransformManager.getCollisionRuntimeParams();
    if (!axes.vec2_isZero()) {
      this._myStickIdleTimer.start();
      direction = this._myCurrentDirectionConverter.convertTransformQuat(axes, this._myDirectionReference.pp_getTransformQuat(directionReferenceTransformQuat), playerUp, direction);
      if (!direction.vec3_isZero()) {
        this._myLocomotionRuntimeParams.myIsFlying = this._myLocomotionRuntimeParams.myIsFlying || direction.vec3_componentAlongAxis(playerUp, directionOnUp).vec3_length() > 1e-6;
        if (!this._myLocomotionRuntimeParams.myIsFlying) {
          direction = direction.vec3_removeComponentAlongAxis(playerUp, direction);
        }
        let movementIntensity = axes.vec2_length();
        this._myCurrentSpeed = Math.pp_lerp(0, maxSpeed, movementIntensity);
        if (collisionRuntimeParams.myIsSliding && this._myParams.mySpeedSlowDownPercentageOnWallSlid != 1) {
          let slowPercentage = this._myParams.mySpeedSlowDownPercentageOnWallSlid;
          let slidStrength = Math.pp_mapToRange(Math.abs(collisionRuntimeParams.mySlidingMovementAngle), 0, 90, 0, 1);
          slowPercentage = Math.pp_lerp(1, slowPercentage, slidStrength);
          this._myCurrentSpeed = this._myCurrentSpeed * slowPercentage;
        }
        if (!this._myLocomotionRuntimeParams.myIsFlying) {
          horizontalMovement = direction.vec3_scale(this._myCurrentSpeed * dt, horizontalMovement);
          isManuallyMovingHorizontally = !horizontalMovement.vec3_isZero(1e-6);
        } else {
          totalMovement = direction.vec3_scale(this._myCurrentSpeed * dt, totalMovement);
          horizontalMovement = totalMovement.vec3_removeComponentAlongAxis(playerUp, horizontalMovement);
          verticalMovement = totalMovement.vec3_componentAlongAxis(playerUp, verticalMovement);
          isManuallyMovingHorizontally = !horizontalMovement.vec3_isZero(1e-6);
          isManuallyMovingVertically = !verticalMovement.vec3_isZero(1e-6);
        }
      }
    } else {
      if (this._myStickIdleTimer.isRunning()) {
        this._myStickIdleTimer.update(dt);
        if (this._myStickIdleTimer.isDone()) {
          this._myCurrentDirectionConverter.resetFly();
        }
      }
    }
    if (this._myParams.myFlyEnabled && this._myParams.myFlyWithButtonsEnabled || debugFlyEnabled) {
      if (Globals.getGamepads(this._myParams.myEngine)[InputUtils.getOppositeHandedness(this._myParams.myHandedness)].getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed()) {
        verticalMovement = playerUp.vec3_scale(maxSpeed * dt, verticalMovement);
        this._myLocomotionRuntimeParams.myIsFlying = true;
        isManuallyMovingVertically = true;
      } else if (Globals.getGamepads(this._myParams.myEngine)[InputUtils.getOppositeHandedness(this._myParams.myHandedness)].getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressed()) {
        verticalMovement = playerUp.vec3_scale(-maxSpeed * dt, verticalMovement);
        this._myLocomotionRuntimeParams.myIsFlying = true;
        isManuallyMovingVertically = true;
      }
      if (Globals.getGamepads(this._myParams.myEngine)[InputUtils.getOppositeHandedness(this._myParams.myHandedness)].getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressEnd(2)) {
        this._myLocomotionRuntimeParams.myIsFlying = false;
      }
    }
    if (this._myParams.myMoveHeadShortcutEnabled && Globals.isDebugEnabled(this._myParams.myEngine) && Globals.getGamepads(this._myParams.myEngine)[InputUtils.getOppositeHandedness(this._myParams.myHandedness)].getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed()) {
      headMovement = headMovement.vec3_add(horizontalMovement, headMovement);
      headMovement = headMovement.vec3_add(verticalMovement, headMovement);
      this._myParams.myPlayerTransformManager.getPlayerHeadManager().moveFeet(headMovement);
    } else if (this._myParams.myMoveThroughCollisionShortcutEnabled && Globals.isDebugEnabled(this._myParams.myEngine) && Globals.getGamepads(this._myParams.myEngine)[this._myParams.myHandedness].getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed() || debugFlyEnabled) {
      headMovement = headMovement.vec3_add(horizontalMovement, headMovement);
      headMovement = headMovement.vec3_add(verticalMovement, headMovement);
      this._myParams.myPlayerTransformManager.move(headMovement, true);
      if (isManuallyMovingHorizontally || isManuallyMovingVertically) {
        this._myParams.myPlayerTransformManager.resetReal();
      }
    } else {
      if (!this._myLocomotionRuntimeParams.myIsFlying) {
        this._myLocomotionRuntimeParams.myGravitySpeed += this._myParams.myGravityAcceleration * dt;
        if (Math.abs(this._myLocomotionRuntimeParams.myGravitySpeed) > Math.abs(this._myParams.myMaxGravitySpeed)) {
          this._myLocomotionRuntimeParams.myGravitySpeed = Math.pp_sign(this._myParams.myGravityAcceleration) * Math.abs(this._myParams.myMaxGravitySpeed);
        }
        verticalMovement = playerUp.vec3_scale(this._myLocomotionRuntimeParams.myGravitySpeed * dt, verticalMovement);
      } else {
        this._myLocomotionRuntimeParams.myGravitySpeed = 0;
      }
      let useHighestHeight = (this._myParams.myUseHighestColliderHeightWhenManuallyMovingHorizontally && isManuallyMovingHorizontally || this._myParams.myUseHighestColliderHeightWhenManuallyMovingVertically && isManuallyMovingVertically) && (!isManuallyMovingHorizontally || this._myParams.myUseHighestColliderHeightWhenManuallyMovingHorizontally) && (!isManuallyMovingVertically || this._myParams.myUseHighestColliderHeightWhenManuallyMovingVertically) && (this._myParams.myPlayerTransformManager.getCollisionRuntimeParams().myIsOnGround || this._myLocomotionRuntimeParams.myGravitySpeed == 0);
      headMovement = headMovement.vec3_add(horizontalMovement, headMovement);
      headMovement = headMovement.vec3_add(verticalMovement, headMovement);
      this._myParams.myPlayerTransformManager.move(headMovement, false, useHighestHeight);
      if (this._myParams.myAttemptMoveAgainWhenFailedDueToCeilingPopOut && isManuallyMovingHorizontally && !horizontalMovement.vec3_isZero(1e-6)) {
        const collisionRuntimeParams2 = this._myParams.myPlayerTransformManager.getCollisionRuntimeParams();
        if (collisionRuntimeParams2.myHorizontalMovementCanceled && !collisionRuntimeParams2.myVerticalMovementCanceled && collisionRuntimeParams2.myHasPoppedOutCeiling) {
          this._myParams.myPlayerTransformManager.move(horizontalMovement, false, useHighestHeight);
        }
      }
      if (isManuallyMovingHorizontally || isManuallyMovingVertically) {
        this._myParams.myPlayerTransformManager.resetReal();
        collisionRuntimeParams.myFixedMovement.vec3_removeComponentAlongAxis(collisionRuntimeParams.myOriginalUp, this._myLastHorizontalMovement);
      }
      if (this._myLocomotionRuntimeParams.myGravitySpeed > 0 && collisionRuntimeParams.myIsOnCeiling || this._myLocomotionRuntimeParams.myGravitySpeed < 0 && collisionRuntimeParams.myIsOnGround) {
        this._myLocomotionRuntimeParams.myGravitySpeed = 0;
      }
    }
    if (collisionRuntimeParams.myIsOnGround) {
      this._myLocomotionRuntimeParams.myIsFlying = false;
      this._myCurrentDirectionConverter.resetFly();
    }
  };
}();
PlayerLocomotionSmooth.prototype._onXRSessionStart = /* @__PURE__ */ function() {
  return function _onXRSessionStart(session) {
    switch (this._myParams.myVRDirectionReferenceType) {
      case 0:
        this._myDirectionReference = Globals.getPlayerObjects(this._myParams.myEngine).myHead;
        break;
      case 1:
        this._myDirectionReference = Globals.getPlayerObjects(this._myParams.myEngine).myHands[this._myParams.myHandedness];
        break;
      case 2:
        this._myDirectionReference = this._myParams.myVRDirectionReferenceObject;
        break;
    }
    this._myCurrentDirectionConverter = this._myDirectionConverterVR;
    this._myCurrentDirectionConverter.resetFly();
  };
}();
PlayerLocomotionSmooth.prototype._onXRSessionEnd = /* @__PURE__ */ function() {
  return function _onXRSessionEnd(session) {
    this._myDirectionReference = Globals.getPlayerObjects(this._myParams.myEngine).myHead;
    this._myCurrentDirectionConverter = this._myDirectionConverterNonVR;
    this._myCurrentDirectionConverter.resetFly();
  };
}();

// dist/pp/gameplay/experimental/locomotion/legacy/locomotion/components/player_locomotion_component.js
import { Component as Component44, property as property9 } from "@wonderlandengine/api";
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var PlayerLocomotionComponent = class extends Component44 {
  static TypeName = "pp-player-locomotion";
  _myDefaultLocomotionType;
  _myAlwaysSmoothForNonVR;
  /** Double press main hand thumbstick (default: left) to switch */
  _mySwitchLocomotionTypeShortcutEnabled;
  _myStartIdle;
  _myPhysicsBlockLayerFlags;
  _myDefaultHeight;
  _myMinHeight;
  _myCharacterRadius;
  /** Set this to `-1` to auto compute the feet radius based on {@link _myCharacterRadius} */
  _myCharacterFeetRadius;
  _myForeheadExtraHeight;
  _myMaxSpeed;
  _myMaxRotationSpeed;
  _mySpeedSlowDownPercentageOnWallSlid;
  _myGravityAcceleration;
  _myMaxGravitySpeed;
  _myIsSnapTurn;
  _mySnapTurnOnlyVR;
  _mySnapTurnAngle;
  _mySnapTurnSpeedDegrees;
  _myFlyEnabled;
  _myStartFlying;
  _myFlyWithButtonsEnabled;
  _myFlyWithViewAngleEnabled;
  _myMinAngleToFlyUpNonVR;
  _myMinAngleToFlyDownNonVR;
  _myMinAngleToFlyUpVR;
  _myMinAngleToFlyDownVR;
  _myMinAngleToFlyRight;
  _myMainHand;
  _myDirectionInvertForwardWhenUpsideDown;
  _myVRDirectionReferenceType;
  _myVRDirectionReferenceObject;
  _myTeleportType;
  _myTeleportMaxDistance;
  _myTeleportMaxHeightDifference;
  /** If empty use {@link _myPhysicsBlockLayerFlags} */
  _myTeleportFloorLayerFlags;
  _myTeleportRotationOnUpEnabled;
  _myTeleportValidMaterial;
  _myTeleportInvalidMaterial;
  _myTeleportPositionObject;
  _myTeleportPositionObjectRotateWithHead;
  _myTeleportParableStartReferenceObject;
  _myResetRealOnStart;
  /**
   * #WARN With `_myResetRealOnStartFramesAmount` at `1` it can happen that you enter the session like 1 frame before the game load
   * and the head pose might have not been properly initialized yet in the WebXR API, so the reset real will not happen has expected
   * Since this is a sort of edge case (either u enter after the load, or you were already in for more than 2-3 frames), and that
   * setting this to more than `1` can cause a visible (even if very short) stutter after the load (due to resetting the head multiple times),
   * it's better to keep this value at `1`
   * A possible effect of the edge case is the view being obscured on start because it thinks you are colliding
   *
   * A value of `3` will make u sure that the head pose will be initialized and the reset real will happen as expected in any case
   * For example, if u have a total fade at start and nothing can be seen aside the clear color for at least, let's say, 10 frames,
   * you can set this to `3` safely, since there will be no visible stutter to be seen (beside the clear color)
   */
  _myResetRealOnStartFramesAmount;
  /** Can fix some head through floor issues, when you can move your head completely to the other side of the floor
      If the floors are thick enough that this can't happen, you can leave this to false  */
  _myResetHeadToFeetInsteadOfReal;
  _myResetHeadToRealMinDistance;
  _myMaxHeadToRealHeadSteps;
  /** Valid means, for example, that the real player has not moved inside a wall by moving in the real space */
  _mySyncWithRealWorldPositionOnlyIfValid;
  /** Valid means, for example, that the real player has not moved inside a wall by moving in the real space */
  _mySyncWithRealHeightOnlyIfValid;
  _mySnapRealPositionToGround;
  _myPreventRealFromColliding;
  /**
   * This make it so if you move your head inside the ceiling and try to move with the stick, the player will not move as it was stuck with you.
   * It can be useful to avoid being able to move while the view is occluded and find yourself in random places afterwards.
   *
   * If this is set to `false` instead, the player can still move and, for example, exit the zone with the lower ceiling.
   * When this is set to false, you very likely want also {@link _myResetHeadToRealMinDistance} set to `0`, otherwise the view occlusion
   * feature can fade to total black when moving in those situation (even if the move is now allowed and works).
   * Setting {@link _myResetHeadToRealMinDistance} to `0` is more expensive performance wise, so you might have to compromise.
   */
  _myUseHighestColliderHeightWhenManuallyMovingHorizontally;
  _myViewOcclusionInsideWallsEnabled;
  /** If empty use {@link _myPhysicsBlockLayerFlags} */
  _myViewOcclusionLayerFlags;
  /**
   * To avoid occlusion issues when moving when touching a tilted ceiling (which is not commong anyway),
   * this value should be a bit lower than {@link _myCharacterFeetRadius}
   *
   * If you have a high camera near value, you might need to increase this value, even though the view occlusion might become more aggressive
   */
  _myViewOcclusionHeadRadius;
  /**
   * Half of this value should be a bit lower than {@link _myForeheadExtraHeight} plus {@link _myColliderExtraHeight}, otherwise view occlusion might
   * trigger simply when moving under a low ceiling
   *
   * If you have a high camera near value, you might need to increase this value, even though the view occlusion might become more aggressive
   */
  _myViewOcclusionHeadHeight;
  _myViewOcclusionFadeOutSeconds;
  _myViewOcclusionMaxRealHeadDistance;
  _mySyncNonVRHeightWithVROnExitSession;
  _mySyncNonVRVerticalAngleWithVROnExitSession;
  _mySyncHeadWithRealAfterLocomotionUpdateIfNeeded;
  _myColliderAccuracy;
  /**
   * If you enable this, you might also want to disable {@link _myColliderCheckCeilings},
   * since it doesn't make much sense to check for ceilings when not checking the height
   */
  _myColliderCheckOnlyFeet;
  /**
   * If you enable this, you might also want to disable {@link _myColliderCheckOnlyFeet},
   * since it doesn't make much sense to check for ceilings without also checking the height
   */
  _myColliderCheckCeilings;
  _myColliderSlideAlongWall;
  _myColliderMaxWalkableGroundAngle;
  /**
   * This is useful if you want the locomotion teleport feature to be able to go downhill
   * on surfaces steeper than {@link _myColliderMaxWalkableGroundAngle}
   *
   * By default the locomotion teleport can't go up on surfaces steeper than {@link _myColliderMaxWalkableGroundAngle} anyway,
   * no matter, the value of {@link _myColliderMaxTeleportableGroundAngle}
   *
   * If you set this to a value bigger than {@link _myColliderMaxWalkableGroundAngle} you will be able to teleport in any case on steeper surfaces,
   * so be careful if you want that, even though usually it's safe, since teleport positions, aside from the locomotion teleport ones, are predefined and
   * safe positions
   *
   * The idea is that with the locomotion smooth you can always go downhill but might no be able to climb back up due to the surface beeing steep,
   * this sort of replicates that for the locomotion, letting you teleport down on steep surfaces but not up
   */
  _myColliderMaxTeleportableGroundAngle;
  _myColliderSnapOnGround;
  _myColliderMaxDistanceToSnapOnGround;
  _myColliderMaxDistanceToPopOutGround;
  _myColliderMaxWalkableGroundStepHeight;
  /**
   * Allowing walkable steps on ceiling might create issues with view occlusion for the player (especially with a high value)
   * since you can go more under some low ceiling making the occlusion head collide with it
   *
   * Settings it to zero is safer, but means that the ceilings physx must be more flat, because it's easier that a small ceiling bump now blocks you
   *
   * If you want this to be higher than 0, you might also want to increase {@link _myColliderExtraHeight} by this value to avoid issue with view occlusion
   * It will need you to be further from ceiling to be able to move under them tho (since it will be like wearing a hat as tall as {@link _myColliderExtraHeight})
   */
  _myColliderMaxWalkableCeilingStepHeight;
  _myColliderPreventFallingFromEdges;
  _myColliderMaxMovementSteps;
  /**
   * Helps staying a little further from the ceiling
   *
   * If you need to increase {@link _myViewOcclusionHeadRadius}, also increasing this can help preventing view occlusion happening when shouldn't
   */
  _myColliderExtraHeight;
  /** Main hand (default: left) select + thumbstick press, auto switch to smooth */
  _myDebugFlyShortcutEnabled;
  _myDebugFlyMaxSpeedMultiplier;
  /** Main hand (default: left) thumbstick pressed while moving */
  _myMoveThroughCollisionShortcutEnabled;
  /** Not main hand (default: right) thumbstick pressed while moving */
  _myMoveHeadShortcutEnabled;
  /** Main hand (default: left) select pressed while moving */
  _myTripleSpeedShortcutEnabled;
  _myDebugHorizontalEnabled;
  _myDebugVerticalEnabled;
  _myCollisionCheckDisabled;
  _myRaycastCountLogEnabled;
  _myRaycastVisualDebugEnabled;
  _myPerformanceLogEnabled;
  _myPlayerLocomotion = null;
  _myRegisterToPostPoseUpdateOnNextUpdate = false;
  _myActivateOnNextPostPoseUpdate = false;
  _myDebugPerformanceLogTimer = new Timer(0.5);
  _myDebugPerformanceLogTotalTime = 0;
  _myDebugPerformanceLogFrameCount = 0;
  _start() {
    const params = new PlayerLocomotionParams(this.engine);
    params.myDefaultLocomotionType = this._myDefaultLocomotionType;
    params.myAlwaysSmoothForNonVR = this._myAlwaysSmoothForNonVR;
    params.mySwitchLocomotionTypeShortcutEnabled = this._mySwitchLocomotionTypeShortcutEnabled;
    params.myStartIdle = this._myStartIdle;
    params.myDefaultHeight = this._myDefaultHeight;
    params.myMinHeight = this._myMinHeight;
    params.myMaxSpeed = this._myMaxSpeed;
    params.myMaxRotationSpeed = this._myMaxRotationSpeed;
    params.myGravityAcceleration = this._myGravityAcceleration;
    params.myMaxGravitySpeed = this._myMaxGravitySpeed;
    params.myCharacterRadius = this._myCharacterRadius;
    params.myCharacterFeetRadius = this._myCharacterFeetRadius >= 0 ? this._myCharacterFeetRadius : null;
    params.mySpeedSlowDownPercentageOnWallSlid = this._mySpeedSlowDownPercentageOnWallSlid;
    params.myIsSnapTurn = this._myIsSnapTurn;
    params.mySnapTurnOnlyVR = this._mySnapTurnOnlyVR;
    params.mySnapTurnAngle = this._mySnapTurnAngle;
    params.mySnapTurnSpeedDegrees = this._mySnapTurnSpeedDegrees;
    params.myFlyEnabled = this._myFlyEnabled;
    params.myStartFlying = this._myStartFlying;
    params.myFlyWithButtonsEnabled = this._myFlyWithButtonsEnabled;
    params.myFlyWithViewAngleEnabled = this._myFlyWithViewAngleEnabled;
    params.myMinAngleToFlyUpNonVR = this._myMinAngleToFlyUpNonVR;
    params.myMinAngleToFlyDownNonVR = this._myMinAngleToFlyDownNonVR;
    params.myMinAngleToFlyUpVR = this._myMinAngleToFlyUpVR;
    params.myMinAngleToFlyDownVR = this._myMinAngleToFlyDownVR;
    params.myMinAngleToFlyRight = this._myMinAngleToFlyRight;
    params.myMainHand = InputUtils.getHandednessByIndex(this._myMainHand);
    params.myDirectionInvertForwardWhenUpsideDown = this._myDirectionInvertForwardWhenUpsideDown;
    params.myVRDirectionReferenceType = this._myVRDirectionReferenceType;
    params.myVRDirectionReferenceObject = this._myVRDirectionReferenceObject;
    params.myForeheadExtraHeight = this._myForeheadExtraHeight;
    params.myTeleportType = this._myTeleportType;
    params.myTeleportMaxDistance = this._myTeleportMaxDistance;
    params.myTeleportMaxHeightDifference = this._myTeleportMaxHeightDifference;
    params.myTeleportRotationOnUpEnabled = this._myTeleportRotationOnUpEnabled;
    params.myTeleportValidMaterial = this._myTeleportValidMaterial;
    params.myTeleportInvalidMaterial = this._myTeleportInvalidMaterial;
    params.myTeleportPositionObject = this._myTeleportPositionObject;
    params.myTeleportPositionObjectRotateWithHead = this._myTeleportPositionObjectRotateWithHead;
    params.myTeleportParableStartReferenceObject = this._myTeleportParableStartReferenceObject;
    params.myResetRealOnStart = this._myResetRealOnStart;
    params.myResetRealOnStartFramesAmount = this._myResetRealOnStartFramesAmount;
    params.myResetHeadToFeetInsteadOfReal = this._myResetHeadToFeetInsteadOfReal;
    params.myResetHeadToRealMinDistance = this._myResetHeadToRealMinDistance;
    params.myMaxHeadToRealHeadSteps = this._myMaxHeadToRealHeadSteps > 0 ? this._myMaxHeadToRealHeadSteps : null;
    params.mySyncWithRealWorldPositionOnlyIfValid = this._mySyncWithRealWorldPositionOnlyIfValid;
    params.mySyncWithRealHeightOnlyIfValid = this._mySyncWithRealHeightOnlyIfValid;
    params.mySnapRealPositionToGround = this._mySnapRealPositionToGround;
    params.myPreventRealFromColliding = this._myPreventRealFromColliding;
    params.myUseHighestColliderHeightWhenManuallyMovingHorizontally = this._myUseHighestColliderHeightWhenManuallyMovingHorizontally;
    params.myViewOcclusionInsideWallsEnabled = this._myViewOcclusionInsideWallsEnabled;
    params.myViewOcclusionHeadRadius = this._myViewOcclusionHeadRadius;
    params.myViewOcclusionHeadHeight = this._myViewOcclusionHeadHeight;
    params.myViewOcclusionFadeOutSeconds = this._myViewOcclusionFadeOutSeconds;
    params.myViewOcclusionMaxRealHeadDistance = this._myViewOcclusionMaxRealHeadDistance;
    params.mySyncNonVRHeightWithVROnExitSession = this._mySyncNonVRHeightWithVROnExitSession;
    params.mySyncNonVRVerticalAngleWithVROnExitSession = this._mySyncNonVRVerticalAngleWithVROnExitSession;
    params.mySyncHeadWithRealAfterLocomotionUpdateIfNeeded = this._mySyncHeadWithRealAfterLocomotionUpdateIfNeeded;
    params.myColliderAccuracy = this._myColliderAccuracy;
    params.myColliderCheckOnlyFeet = this._myColliderCheckOnlyFeet;
    params.myColliderCheckCeilings = this._myColliderCheckCeilings;
    params.myColliderSlideAlongWall = this._myColliderSlideAlongWall;
    params.myColliderMaxWalkableGroundAngle = this._myColliderMaxWalkableGroundAngle;
    params.myColliderMaxTeleportableGroundAngle = this._myColliderMaxTeleportableGroundAngle < 0 ? null : this._myColliderMaxTeleportableGroundAngle;
    params.myColliderSnapOnGround = this._myColliderSnapOnGround;
    params.myColliderMaxDistanceToSnapOnGround = this._myColliderMaxDistanceToSnapOnGround;
    params.myColliderMaxDistanceToPopOutGround = this._myColliderMaxDistanceToPopOutGround;
    params.myColliderMaxWalkableGroundStepHeight = this._myColliderMaxWalkableGroundStepHeight;
    params.myColliderMaxWalkableCeilingStepHeight = this._myColliderMaxWalkableCeilingStepHeight;
    params.myColliderPreventFallingFromEdges = this._myColliderPreventFallingFromEdges;
    params.myColliderMaxMovementSteps = this._myColliderMaxMovementSteps > 0 ? this._myColliderMaxMovementSteps : null;
    params.myColliderExtraHeight = this._myColliderExtraHeight;
    params.myDebugFlyShortcutEnabled = this._myDebugFlyShortcutEnabled;
    params.myDebugFlyMaxSpeedMultiplier = this._myDebugFlyMaxSpeedMultiplier;
    params.myMoveThroughCollisionShortcutEnabled = this._myMoveThroughCollisionShortcutEnabled;
    params.myMoveHeadShortcutEnabled = this._myMoveHeadShortcutEnabled;
    params.myTripleSpeedShortcutEnabled = this._myTripleSpeedShortcutEnabled;
    params.myDebugHorizontalEnabled = this._myDebugHorizontalEnabled;
    params.myDebugVerticalEnabled = this._myDebugVerticalEnabled;
    params.myCollisionCheckDisabled = this._myCollisionCheckDisabled;
    params.myPhysicsBlockLayerFlags.copy(this._getPhysicsBlockLayersFlags());
    params.myTeleportFloorLayerFlags.copy(this._getTeleportFloorLayersFlags());
    params.myViewOcclusionLayerFlags.copy(this._getViewOcclusionLayersFlags());
    this._myPlayerLocomotion = new PlayerLocomotion(params);
  }
  update(dt) {
    if (this._myRegisterToPostPoseUpdateOnNextUpdate) {
      Globals.getHeadPose(this.engine).registerPostPoseUpdatedEventListener(this, this.onPostPoseUpdatedEvent.bind(this));
      this._myRegisterToPostPoseUpdateOnNextUpdate = false;
    }
  }
  onPostPoseUpdatedEvent(dt, pose, manualUpdate) {
    if (!this.active || this._myRegisterToPostPoseUpdateOnNextUpdate) {
      Globals.getHeadPose(this.engine)?.unregisterPostPoseUpdatedEventListener(this);
      return;
    }
    if (manualUpdate)
      return;
    let setPlayerLocomotionOnGlobals = false;
    if (this._myActivateOnNextPostPoseUpdate) {
      setPlayerLocomotionOnGlobals = this._onActivate();
      this._myActivateOnNextPostPoseUpdate = false;
    }
    if (!this._myPlayerLocomotion.isStarted()) {
      this._myPlayerLocomotion.start();
    }
    if (!setPlayerLocomotionOnGlobals && Globals.hasPlayerLocomotion(this.engine) && Globals.getPlayerLocomotion(this.engine) != this._myPlayerLocomotion)
      return;
    let startTime = 0;
    if (this._myPerformanceLogEnabled && Globals.isDebugEnabled(this.engine)) {
      startTime = window.performance.now();
    }
    let raycastVisualDebugEnabledBackup = false;
    if (this._myRaycastVisualDebugEnabled && Globals.isDebugEnabled(this.engine)) {
      raycastVisualDebugEnabledBackup = PhysicsUtils.isRaycastVisualDebugEnabled(this.engine.physics);
      PhysicsUtils.setRaycastVisualDebugEnabled(true, this.engine.physics);
    }
    if (this._myRaycastCountLogEnabled && Globals.isDebugEnabled(this.engine)) {
      PhysicsUtils.resetRaycastCount(this.engine.physics);
    }
    this._myPlayerLocomotion.update(dt);
    if (this._myPerformanceLogEnabled && Globals.isDebugEnabled(this.engine)) {
      const endTime = window.performance.now();
      this._myDebugPerformanceLogTotalTime += endTime - startTime;
      this._myDebugPerformanceLogFrameCount++;
      this._myDebugPerformanceLogTimer.update(dt);
      if (this._myDebugPerformanceLogTimer.isDone()) {
        this._myDebugPerformanceLogTimer.start();
        const averageTime = this._myDebugPerformanceLogTotalTime / this._myDebugPerformanceLogFrameCount;
        console.log("Locomotion ms: " + averageTime.toFixed(3));
        this._myDebugPerformanceLogTotalTime = 0;
        this._myDebugPerformanceLogFrameCount = 0;
      }
    }
    if (this._myRaycastVisualDebugEnabled && Globals.isDebugEnabled(this.engine)) {
      PhysicsUtils.setRaycastVisualDebugEnabled(raycastVisualDebugEnabledBackup, this.engine.physics);
    }
    if (this._myRaycastCountLogEnabled && Globals.isDebugEnabled(this.engine)) {
      console.log("Raycast count: " + PhysicsUtils.getRaycastCount(this.engine.physics));
      PhysicsUtils.resetRaycastCount(this.engine.physics);
    }
    if (setPlayerLocomotionOnGlobals && !Globals.hasPlayerLocomotion(this.engine)) {
      Globals.setPlayerLocomotion(this._myPlayerLocomotion, this.engine);
    } else if (setPlayerLocomotionOnGlobals && Globals.getPlayerLocomotion(this.engine) != this._myPlayerLocomotion) {
      this._myPlayerLocomotion.setActive(false);
    }
  }
  getPlayerLocomotion() {
    return this._myPlayerLocomotion;
  }
  onActivate() {
    this._myRegisterToPostPoseUpdateOnNextUpdate = true;
    this._myActivateOnNextPostPoseUpdate = true;
  }
  onDeactivate() {
    Globals.getHeadPose(this.engine)?.unregisterPostPoseUpdatedEventListener(this);
    if (this._myPlayerLocomotion != null) {
      this._myPlayerLocomotion.setActive(false);
      if (Globals.getPlayerLocomotion(this.engine) == this._myPlayerLocomotion) {
        Globals.removePlayerLocomotion(this.engine);
      }
    }
  }
  _onActivate() {
    let setPlayerLocomotionOnGlobals = false;
    if (this._myPlayerLocomotion == null) {
      this._start();
    }
    if (!Globals.hasPlayerLocomotion(this.engine)) {
      this._myPlayerLocomotion.setActive(true);
      setPlayerLocomotionOnGlobals = true;
    }
    return setPlayerLocomotionOnGlobals;
  }
  _getPhysicsBlockLayersFlags() {
    return this._convertStringToLayerFlags(this._myPhysicsBlockLayerFlags);
  }
  _getTeleportFloorLayersFlags() {
    if (this._myTeleportFloorLayerFlags.length == 0) {
      return this._getPhysicsBlockLayersFlags();
    }
    return this._convertStringToLayerFlags(this._myTeleportFloorLayerFlags);
  }
  _getViewOcclusionLayersFlags() {
    if (this._myViewOcclusionLayerFlags.length == 0) {
      return this._getPhysicsBlockLayersFlags();
    }
    return this._convertStringToLayerFlags(this._myViewOcclusionLayerFlags);
  }
  _convertStringToLayerFlags(string) {
    const physicsFlags = new PhysicsLayerFlags();
    const flags = [...string.split(",")];
    for (let i = 0; i < flags.length; i++) {
      physicsFlags.setFlagActive(i, flags[i].trim() == "1");
    }
    return physicsFlags;
  }
  onDestroy() {
    if (this._myPlayerLocomotion != null) {
      this._myPlayerLocomotion.destroy();
    }
  }
};
__decorate9([
  property9.enum(["Smooth", "Teleport"], "Smooth")
], PlayerLocomotionComponent.prototype, "_myDefaultLocomotionType", void 0);
__decorate9([
  property9.bool(true)
], PlayerLocomotionComponent.prototype, "_myAlwaysSmoothForNonVR", void 0);
__decorate9([
  property9.bool(true)
], PlayerLocomotionComponent.prototype, "_mySwitchLocomotionTypeShortcutEnabled", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_myStartIdle", void 0);
__decorate9([
  property9.string("0, 0, 0, 0, 0, 0, 0, 0")
], PlayerLocomotionComponent.prototype, "_myPhysicsBlockLayerFlags", void 0);
__decorate9([
  property9.float(1.7)
], PlayerLocomotionComponent.prototype, "_myDefaultHeight", void 0);
__decorate9([
  property9.float(0.5)
], PlayerLocomotionComponent.prototype, "_myMinHeight", void 0);
__decorate9([
  property9.float(0.3)
], PlayerLocomotionComponent.prototype, "_myCharacterRadius", void 0);
__decorate9([
  property9.float(-1)
], PlayerLocomotionComponent.prototype, "_myCharacterFeetRadius", void 0);
__decorate9([
  property9.float(0.1)
], PlayerLocomotionComponent.prototype, "_myForeheadExtraHeight", void 0);
__decorate9([
  property9.float(2)
], PlayerLocomotionComponent.prototype, "_myMaxSpeed", void 0);
__decorate9([
  property9.float(100)
], PlayerLocomotionComponent.prototype, "_myMaxRotationSpeed", void 0);
__decorate9([
  property9.float(1)
], PlayerLocomotionComponent.prototype, "_mySpeedSlowDownPercentageOnWallSlid", void 0);
__decorate9([
  property9.float(-20)
], PlayerLocomotionComponent.prototype, "_myGravityAcceleration", void 0);
__decorate9([
  property9.float(-15)
], PlayerLocomotionComponent.prototype, "_myMaxGravitySpeed", void 0);
__decorate9([
  property9.bool(true)
], PlayerLocomotionComponent.prototype, "_myIsSnapTurn", void 0);
__decorate9([
  property9.bool(true)
], PlayerLocomotionComponent.prototype, "_mySnapTurnOnlyVR", void 0);
__decorate9([
  property9.float(30)
], PlayerLocomotionComponent.prototype, "_mySnapTurnAngle", void 0);
__decorate9([
  property9.float(0)
], PlayerLocomotionComponent.prototype, "_mySnapTurnSpeedDegrees", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_myFlyEnabled", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_myStartFlying", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_myFlyWithButtonsEnabled", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_myFlyWithViewAngleEnabled", void 0);
__decorate9([
  property9.float(30)
], PlayerLocomotionComponent.prototype, "_myMinAngleToFlyUpNonVR", void 0);
__decorate9([
  property9.float(40)
], PlayerLocomotionComponent.prototype, "_myMinAngleToFlyDownNonVR", void 0);
__decorate9([
  property9.float(30)
], PlayerLocomotionComponent.prototype, "_myMinAngleToFlyUpVR", void 0);
__decorate9([
  property9.float(40)
], PlayerLocomotionComponent.prototype, "_myMinAngleToFlyDownVR", void 0);
__decorate9([
  property9.float(90)
], PlayerLocomotionComponent.prototype, "_myMinAngleToFlyRight", void 0);
__decorate9([
  property9.enum(["Left", "Right"], "Left")
], PlayerLocomotionComponent.prototype, "_myMainHand", void 0);
__decorate9([
  property9.bool(true)
], PlayerLocomotionComponent.prototype, "_myDirectionInvertForwardWhenUpsideDown", void 0);
__decorate9([
  property9.enum(["Head", "Hand", "Custom Object"], "Head")
], PlayerLocomotionComponent.prototype, "_myVRDirectionReferenceType", void 0);
__decorate9([
  property9.object()
], PlayerLocomotionComponent.prototype, "_myVRDirectionReferenceObject", void 0);
__decorate9([
  property9.enum(["Instant", "Blink", "Shift"], "Shift")
], PlayerLocomotionComponent.prototype, "_myTeleportType", void 0);
__decorate9([
  property9.float(3)
], PlayerLocomotionComponent.prototype, "_myTeleportMaxDistance", void 0);
__decorate9([
  property9.float(1.25)
], PlayerLocomotionComponent.prototype, "_myTeleportMaxHeightDifference", void 0);
__decorate9([
  property9.string("")
], PlayerLocomotionComponent.prototype, "_myTeleportFloorLayerFlags", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_myTeleportRotationOnUpEnabled", void 0);
__decorate9([
  property9.material()
], PlayerLocomotionComponent.prototype, "_myTeleportValidMaterial", void 0);
__decorate9([
  property9.material()
], PlayerLocomotionComponent.prototype, "_myTeleportInvalidMaterial", void 0);
__decorate9([
  property9.object()
], PlayerLocomotionComponent.prototype, "_myTeleportPositionObject", void 0);
__decorate9([
  property9.bool(true)
], PlayerLocomotionComponent.prototype, "_myTeleportPositionObjectRotateWithHead", void 0);
__decorate9([
  property9.object()
], PlayerLocomotionComponent.prototype, "_myTeleportParableStartReferenceObject", void 0);
__decorate9([
  property9.bool(true)
], PlayerLocomotionComponent.prototype, "_myResetRealOnStart", void 0);
__decorate9([
  property9.int(1)
], PlayerLocomotionComponent.prototype, "_myResetRealOnStartFramesAmount", void 0);
__decorate9([
  property9.bool(true)
], PlayerLocomotionComponent.prototype, "_myResetHeadToFeetInsteadOfReal", void 0);
__decorate9([
  property9.float(0.25)
], PlayerLocomotionComponent.prototype, "_myResetHeadToRealMinDistance", void 0);
__decorate9([
  property9.int(-1)
], PlayerLocomotionComponent.prototype, "_myMaxHeadToRealHeadSteps", void 0);
__decorate9([
  property9.bool(true)
], PlayerLocomotionComponent.prototype, "_mySyncWithRealWorldPositionOnlyIfValid", void 0);
__decorate9([
  property9.bool(true)
], PlayerLocomotionComponent.prototype, "_mySyncWithRealHeightOnlyIfValid", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_mySnapRealPositionToGround", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_myPreventRealFromColliding", void 0);
__decorate9([
  property9.bool(true)
], PlayerLocomotionComponent.prototype, "_myUseHighestColliderHeightWhenManuallyMovingHorizontally", void 0);
__decorate9([
  property9.bool(true)
], PlayerLocomotionComponent.prototype, "_myViewOcclusionInsideWallsEnabled", void 0);
__decorate9([
  property9.string("")
], PlayerLocomotionComponent.prototype, "_myViewOcclusionLayerFlags", void 0);
__decorate9([
  property9.float(0.145)
], PlayerLocomotionComponent.prototype, "_myViewOcclusionHeadRadius", void 0);
__decorate9([
  property9.float(0.15)
], PlayerLocomotionComponent.prototype, "_myViewOcclusionHeadHeight", void 0);
__decorate9([
  property9.float(0.1)
], PlayerLocomotionComponent.prototype, "_myViewOcclusionFadeOutSeconds", void 0);
__decorate9([
  property9.float(0.025)
], PlayerLocomotionComponent.prototype, "_myViewOcclusionMaxRealHeadDistance", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_mySyncNonVRHeightWithVROnExitSession", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_mySyncNonVRVerticalAngleWithVROnExitSession", void 0);
__decorate9([
  property9.bool(true)
], PlayerLocomotionComponent.prototype, "_mySyncHeadWithRealAfterLocomotionUpdateIfNeeded", void 0);
__decorate9([
  property9.enum(["Very Low", "Low", "Medium", "High", "Very High"], "High")
], PlayerLocomotionComponent.prototype, "_myColliderAccuracy", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_myColliderCheckOnlyFeet", void 0);
__decorate9([
  property9.bool(true)
], PlayerLocomotionComponent.prototype, "_myColliderCheckCeilings", void 0);
__decorate9([
  property9.bool(true)
], PlayerLocomotionComponent.prototype, "_myColliderSlideAlongWall", void 0);
__decorate9([
  property9.float(30)
], PlayerLocomotionComponent.prototype, "_myColliderMaxWalkableGroundAngle", void 0);
__decorate9([
  property9.float(-1)
], PlayerLocomotionComponent.prototype, "_myColliderMaxTeleportableGroundAngle", void 0);
__decorate9([
  property9.bool(true)
], PlayerLocomotionComponent.prototype, "_myColliderSnapOnGround", void 0);
__decorate9([
  property9.float(0.1)
], PlayerLocomotionComponent.prototype, "_myColliderMaxDistanceToSnapOnGround", void 0);
__decorate9([
  property9.float(0.2)
], PlayerLocomotionComponent.prototype, "_myColliderMaxDistanceToPopOutGround", void 0);
__decorate9([
  property9.float(0.1)
], PlayerLocomotionComponent.prototype, "_myColliderMaxWalkableGroundStepHeight", void 0);
__decorate9([
  property9.float(0)
], PlayerLocomotionComponent.prototype, "_myColliderMaxWalkableCeilingStepHeight", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_myColliderPreventFallingFromEdges", void 0);
__decorate9([
  property9.int(3)
], PlayerLocomotionComponent.prototype, "_myColliderMaxMovementSteps", void 0);
__decorate9([
  property9.float(0)
], PlayerLocomotionComponent.prototype, "_myColliderExtraHeight", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_myDebugFlyShortcutEnabled", void 0);
__decorate9([
  property9.float(5)
], PlayerLocomotionComponent.prototype, "_myDebugFlyMaxSpeedMultiplier", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_myMoveThroughCollisionShortcutEnabled", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_myMoveHeadShortcutEnabled", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_myTripleSpeedShortcutEnabled", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_myDebugHorizontalEnabled", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_myDebugVerticalEnabled", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_myCollisionCheckDisabled", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_myRaycastCountLogEnabled", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_myRaycastVisualDebugEnabled", void 0);
__decorate9([
  property9.bool(false)
], PlayerLocomotionComponent.prototype, "_myPerformanceLogEnabled", void 0);

// dist/pp/input/cauldron/components/overlap_cursor_component.js
import { CollisionComponent as CollisionComponent3, Component as Component45, PhysXComponent as PhysXComponent11, property as property10 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget7 } from "@wonderlandengine/components";
var __decorate10 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var OverlapCursorComponent = class _OverlapCursorComponent extends Component45 {
  static TypeName = "pp-overlap-cursor";
  /**
   * This is useful if you want to avoid the cursor entering and exiting the target when very close to the target,
   * due to it flickering between inside and outside.
   * You can scale the collision up a bit so that it needs to move a bit outside to actually exit, so that it will not collide
   *
   * #WARN When using a `PhysXComponent` sadly this require to active and deactivate it to update the extents, which triggers a collision end and a start
   * This is not an issue for the cursor, but if you use the same `PhysXComponent` for other queries, you might have issues due to this
   */
  _myCollisionSizeMultiplierOnOverlap;
  _myValidOverlapAngleFromTargetForward;
  _myLastTarget = null;
  _myPhysXComponent = null;
  _myPhysicsCollisionCollector = null;
  _myPhysXComponentExtents = vec3_create();
  _myCollisionComponent = null;
  _myCollisionComponentExtents = vec3_create();
  _myFakeCursor;
  _myCursorPositionHistory = [];
  _myInvalidOverlapCursorTargets = [];
  _myDoubleClickTimer = 0;
  _myTripleClickTimer = 0;
  _myMultipleClickObject = null;
  static _myMultipleClickDelay = 0.3;
  static _SV = {
    componentEqualCallback(first2, second) {
      return first2 == second;
    }
  };
  init() {
    const fakeCursor = {
      handedness: null,
      handednessTyped: null,
      object: this.object,
      cursorPos: vec3_create()
    };
    this._myFakeCursor = fakeCursor;
    for (let i = 0; i < 5; i++) {
      this._myCursorPositionHistory.push(vec3_create());
    }
  }
  start() {
    this._myPhysXComponent = this.object.pp_getComponent(PhysXComponent11);
    if (this._myPhysXComponent != null) {
      this._myPhysicsCollisionCollector = new PhysicsCollisionCollector(this._myPhysXComponent);
      this._myPhysXComponentExtents.vec3_copy(this._myPhysXComponent.extents);
    }
    this._myCollisionComponent = this.object.pp_getComponent(CollisionComponent3);
    if (this._myCollisionComponent != null) {
      this._myCollisionComponentExtents.vec3_copy(this._myCollisionComponent.extents);
    }
  }
  update(dt) {
    if (this._myDoubleClickTimer > 0) {
      this._myDoubleClickTimer -= dt;
    }
    if (this._myTripleClickTimer > 0) {
      this._myTripleClickTimer -= dt;
    }
    for (let i = this._myCursorPositionHistory.length - 1; i > 0; i--) {
      this._myCursorPositionHistory[i].vec3_copy(this._myCursorPositionHistory[i - 1]);
    }
    this.object.pp_getPosition(this._myCursorPositionHistory[0]);
    this._myFakeCursor.cursorPos.vec3_copy(this._myCursorPositionHistory[0]);
    let bestCursorTarget = null;
    const processedCursorTargets = [];
    if (this._myCollisionComponent != null) {
      const collisions = this._myCollisionComponent.queryOverlaps();
      for (const collision of collisions) {
        if (collision.group & this._myCollisionComponent.group) {
          const target = collision.object.pp_getComponentSelf(CursorTarget7);
          if (target != null && target.active) {
            processedCursorTargets.push(target);
            bestCursorTarget = this._pickBestCursorTarget(bestCursorTarget, target);
          }
        }
      }
    }
    if (this._myPhysicsCollisionCollector != null) {
      this._myPhysicsCollisionCollector.update(dt);
      const collisions = this._myPhysicsCollisionCollector.getCollisions();
      for (const collision of collisions) {
        const target = collision.object.pp_getComponentSelf(CursorTarget7);
        if (target != null && target.active) {
          processedCursorTargets.push(target);
          bestCursorTarget = this._pickBestCursorTarget(bestCursorTarget, target);
        }
      }
    }
    if (this._myInvalidOverlapCursorTargets.length > 0) {
      const componentEqualCallback = _OverlapCursorComponent._SV.componentEqualCallback;
      this._myInvalidOverlapCursorTargets.pp_removeAll((elementToCheck) => {
        return !processedCursorTargets.pp_hasEqual(elementToCheck, componentEqualCallback);
      });
    }
    if (bestCursorTarget == null) {
      this._targetOverlapEnd();
    } else if (bestCursorTarget != this._myLastTarget) {
      this._targetOverlapEnd();
      this._myLastTarget = bestCursorTarget;
      this._targetOverlapStart();
    }
  }
  onActivate() {
    if (this._myPhysicsCollisionCollector != null) {
      this._myPhysicsCollisionCollector.setActive(true);
    }
  }
  onDeactivate() {
    this._targetOverlapEnd();
    if (this._myPhysicsCollisionCollector != null) {
      this._myPhysicsCollisionCollector.setActive(false);
    }
  }
  _targetOverlapStart() {
    if (this._myCollisionSizeMultiplierOnOverlap != 1 && !this._myLastTarget.isSurface) {
      if (this._myPhysXComponent != null) {
        this._myPhysXComponent.extents = this._myPhysXComponentExtents.vec3_scale(this._myCollisionSizeMultiplierOnOverlap);
        this._myPhysicsCollisionCollector.setActive(false);
        this._myPhysXComponent.active = false;
        this._myPhysicsCollisionCollector.setActive(true);
        this._myPhysXComponent.active = true;
      }
      if (this._myCollisionComponent != null) {
        this._myCollisionComponent.extents = this._myCollisionComponentExtents.vec3_scale(this._myCollisionSizeMultiplierOnOverlap);
      }
    }
    this._myLastTarget.onHover.notify(this._myLastTarget.object, this._myFakeCursor);
    this._myLastTarget.onDown.notify(this._myLastTarget.object, this._myFakeCursor);
  }
  _targetOverlapEnd() {
    if (this._myLastTarget != null) {
      if (this._myCollisionSizeMultiplierOnOverlap != 1) {
        if (this._myPhysXComponent != null) {
          this._myPhysXComponent.extents = this._myPhysXComponentExtents;
          this._myPhysicsCollisionCollector.setActive(false);
          this._myPhysXComponent.active = false;
          this._myPhysicsCollisionCollector.setActive(true);
          this._myPhysXComponent.active = true;
        }
        if (this._myCollisionComponent != null) {
          this._myCollisionComponent.extents = this._myCollisionComponentExtents;
        }
      }
      if (!this._myLastTarget.isDestroyed && this._myLastTarget.active) {
        this._myLastTarget.onClick.notify(this._myLastTarget.object, this._myFakeCursor);
        if (this._myTripleClickTimer > 0 && this._myMultipleClickObject && this._myMultipleClickObject == this._myLastTarget.object) {
          this._myLastTarget.onTripleClick.notify(this._myLastTarget.object, this._myFakeCursor);
          this._myTripleClickTimer = 0;
        } else if (this._myDoubleClickTimer > 0 && this._myMultipleClickObject && this._myMultipleClickObject == this._myLastTarget.object) {
          this._myLastTarget.onDoubleClick.notify(this._myLastTarget.object, this._myFakeCursor);
          this._myTripleClickTimer = _OverlapCursorComponent._myMultipleClickDelay;
          this._myDoubleClickTimer = 0;
        } else {
          this._myLastTarget.onSingleClick.notify(this._myLastTarget.object, this._myFakeCursor);
          this._myTripleClickTimer = 0;
          this._myDoubleClickTimer = _OverlapCursorComponent._myMultipleClickDelay;
          this._myMultipleClickObject = this._myLastTarget.object;
        }
        this._myLastTarget.onUp.notify(this._myLastTarget.object, this._myFakeCursor);
        this._myLastTarget.onUpWithDown.notify(this._myLastTarget.object, this._myFakeCursor);
        this._myLastTarget.onUnhover.notify(this._myLastTarget.object, this._myFakeCursor);
      }
      this._myLastTarget = null;
    }
  }
  _pickBestCursorTarget(currentBestCursorTarget, cursorTarget) {
    let bestCursorTarget = currentBestCursorTarget;
    if (cursorTarget == this._myLastTarget) {
      bestCursorTarget = cursorTarget;
    } else {
      const componentEqualCallback = _OverlapCursorComponent._SV.componentEqualCallback;
      if (!this._myInvalidOverlapCursorTargets.pp_hasEqual(cursorTarget, componentEqualCallback)) {
        const isAngleValid = this._isOverlapAngleValid(cursorTarget.object);
        if (isAngleValid) {
          if (bestCursorTarget == null || !cursorTarget.isSurface && bestCursorTarget.isSurface) {
            bestCursorTarget = cursorTarget;
          }
        } else {
          this._myInvalidOverlapCursorTargets.push(cursorTarget);
        }
      }
    }
    return bestCursorTarget;
  }
  static _isOverlapAngleValidSV = {
    cursorPosition: vec3_create(),
    targetPosition: vec3_create(),
    targetForward: vec3_create(),
    directionToCursor: vec3_create()
  };
  _isOverlapAngleValid(targetObject) {
    if (this._myValidOverlapAngleFromTargetForward == 180) {
      return true;
    }
    const targetPosition = _OverlapCursorComponent._isOverlapAngleValidSV.targetPosition;
    const targetForward = _OverlapCursorComponent._isOverlapAngleValidSV.targetForward;
    targetObject.pp_getPosition(targetPosition);
    targetObject.pp_getForward(targetForward);
    const directionToCursor = _OverlapCursorComponent._isOverlapAngleValidSV.directionToCursor;
    this._myCursorPositionHistory.pp_last().vec3_sub(targetPosition, directionToCursor).vec3_normalize(directionToCursor);
    const overlapAngle = directionToCursor.vec3_angle(targetForward);
    return overlapAngle <= this._myValidOverlapAngleFromTargetForward;
  }
};
__decorate10([
  property10.float(1.125)
], OverlapCursorComponent.prototype, "_myCollisionSizeMultiplierOnOverlap", void 0);
__decorate10([
  property10.float(90)
], OverlapCursorComponent.prototype, "_myValidOverlapAngleFromTargetForward", void 0);

// dist/pp/input/cauldron/components/finger_cursor_component.js
import { Collider, CollisionComponent as CollisionComponent4, Component as Component46, PhysXComponent as PhysXComponent12, property as property11, Shape as Shape2 } from "@wonderlandengine/api";
import { Cursor as Cursor4 } from "@wonderlandengine/components";
var __decorate11 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var FingerCursorComponent = class _FingerCursorComponent extends Component46 {
  static TypeName = "pp-finger-cursor";
  _myHandedness;
  _myFinger;
  _myCollisionMode;
  _myCollisionFlags;
  _myCollisionSize;
  _myCollisionSizeMultiplierOnOverlap;
  _myValidOverlapAngleFromTargetForward;
  _myCursorPointerObject;
  _myDisableDefaultCursorOnTrackedHandDetected;
  _myDefaultCursorObject;
  _myHandednessType;
  _myFingerJointID;
  _myDefaultCursorComponent = null;
  _myHandInputSource = null;
  _myForceRefreshActiveCursor = true;
  _myCursorParentObject;
  _myActualCursorParentObject;
  _myOverlapCursorComponent;
  init() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    switch (this._myFinger) {
      case 0:
        this._myFingerJointID = TrackedHandJointID.THUMB_TIP;
        break;
      case 1:
        this._myFingerJointID = TrackedHandJointID.INDEX_FINGER_TIP;
        break;
      case 2:
        this._myFingerJointID = TrackedHandJointID.MIDDLE_FINGER_TIP;
        break;
      case 3:
        this._myFingerJointID = TrackedHandJointID.RING_FINGER_TIP;
        break;
      case 4:
        this._myFingerJointID = TrackedHandJointID.PINKY_FINGER_TIP;
        break;
    }
  }
  start() {
    this._myCursorParentObject = this.object.pp_addChild();
    if (this._myCursorPointerObject == null) {
      this._myActualCursorParentObject = this._myCursorParentObject.pp_addChild();
    } else {
      this._myActualCursorParentObject = this._myCursorPointerObject;
    }
    this._myActualCursorParentObject.pp_setParent(this._myCursorParentObject);
    const physicsFlags = new PhysicsLayerFlags();
    const flags = [...this._myCollisionFlags.split(",")];
    for (let i = 0; i < flags.length; i++) {
      physicsFlags.setFlagActive(i, flags[i].trim() == "1");
    }
    if (this._myCollisionMode == 0) {
      this._myActualCursorParentObject.pp_addComponent(PhysXComponent12, {
        shape: Shape2.Sphere,
        extents: vec3_create(this._myCollisionSize, this._myCollisionSize, this._myCollisionSize),
        kinematic: true,
        trigger: true,
        groupsMask: physicsFlags.getMask()
      });
    } else if (this._myCollisionMode == 1) {
      const collisionComponent = this._myActualCursorParentObject.pp_addComponent(CollisionComponent4);
      collisionComponent.collider = Collider.Sphere;
      collisionComponent.extents = vec3_create(this._myCollisionSize, this._myCollisionSize, this._myCollisionSize);
      collisionComponent.group = physicsFlags.getMask();
    }
    if (this._myDisableDefaultCursorOnTrackedHandDetected) {
      let defaultCursorObject = this.object;
      if (this._myDefaultCursorObject != null) {
        defaultCursorObject = this._myDefaultCursorObject;
      }
      this._myDefaultCursorComponent = defaultCursorObject.pp_getComponent(Cursor4);
    }
    this._myOverlapCursorComponent = this._myActualCursorParentObject.pp_addComponent(OverlapCursorComponent, {
      _myCollisionSizeMultiplierOnOverlap: this._myCollisionSizeMultiplierOnOverlap,
      _myValidOverlapAngleFromTargetForward: this._myValidOverlapAngleFromTargetForward
    });
    this._myCursorParentObject.pp_setActive(false);
  }
  static _updateSV = {
    transformQuat: quat2_create()
  };
  update(dt) {
    const transformQuat2 = _FingerCursorComponent._updateSV.transformQuat;
    this._myCursorParentObject.pp_setTransformQuat(Globals.getPlayerObjects(this.engine).myReferenceSpace.pp_getTransformQuat(transformQuat2));
    this._updateHand();
  }
  onActivate() {
    this._myForceRefreshActiveCursor = true;
  }
  onDeactivate() {
    if (this._myCursorParentObject != null) {
      this._myCursorParentObject.pp_setActive(false);
    }
  }
  _updateHand() {
    let newHandInputSource = null;
    const handPose = Globals.getHandPoses(this.engine)[this._myHandednessType];
    if (handPose.getInputSourceType() == InputSourceType.TRACKED_HAND) {
      newHandInputSource = handPose.getInputSource();
    }
    if (newHandInputSource != null && (this._myHandInputSource == null || this._myForceRefreshActiveCursor)) {
      if (this._myDefaultCursorComponent != null) {
        this._myDefaultCursorComponent.active = false;
      }
      this._myCursorParentObject.pp_setActive(true);
    } else if (newHandInputSource == null && (this._myHandInputSource != null || this._myForceRefreshActiveCursor)) {
      this._myCursorParentObject.pp_setActive(false);
      if (this._myDefaultCursorComponent != null) {
        this._myDefaultCursorComponent.active = true;
      }
    }
    this._myHandInputSource = newHandInputSource;
    if (this._myHandInputSource != null) {
      let tip = null;
      try {
        const xrFrame = XRUtils.getFrame(this.engine);
        if (xrFrame.getJointPose != null) {
          tip = xrFrame.getJointPose(this._myHandInputSource.hand.get(this._myFingerJointID), XRUtils.getReferenceSpace(this.engine)) ?? null;
        }
      } catch (error4) {
      }
      if (tip != null) {
        this._myActualCursorParentObject.pp_setRotationLocalQuat([
          tip.transform.orientation.x,
          tip.transform.orientation.y,
          tip.transform.orientation.z,
          tip.transform.orientation.w
        ]);
        this._myActualCursorParentObject.pp_setPositionLocal([
          tip.transform.position.x,
          tip.transform.position.y,
          tip.transform.position.z
        ]);
      }
    }
  }
};
__decorate11([
  property11.enum(["Left", "Right"], "Left")
], FingerCursorComponent.prototype, "_myHandedness", void 0);
__decorate11([
  property11.enum(["Thumb", "Index", "Middle", "Ring", "Pinky"], "Index")
], FingerCursorComponent.prototype, "_myFinger", void 0);
__decorate11([
  property11.enum(["PhysX", "Collision"], "PhysX")
], FingerCursorComponent.prototype, "_myCollisionMode", void 0);
__decorate11([
  property11.string("0, 0, 0, 0, 0, 0, 0, 0")
], FingerCursorComponent.prototype, "_myCollisionFlags", void 0);
__decorate11([
  property11.float(0.0125)
], FingerCursorComponent.prototype, "_myCollisionSize", void 0);
__decorate11([
  property11.float(1.25)
], FingerCursorComponent.prototype, "_myCollisionSizeMultiplierOnOverlap", void 0);
__decorate11([
  property11.float(90)
], FingerCursorComponent.prototype, "_myValidOverlapAngleFromTargetForward", void 0);
__decorate11([
  property11.object()
], FingerCursorComponent.prototype, "_myCursorPointerObject", void 0);
__decorate11([
  property11.bool(true)
], FingerCursorComponent.prototype, "_myDisableDefaultCursorOnTrackedHandDetected", void 0);
__decorate11([
  property11.object()
], FingerCursorComponent.prototype, "_myDefaultCursorObject", void 0);

// dist/pp/input/cauldron/components/switch_hand_object_component.js
import { Component as Component47, Property as Property30 } from "@wonderlandengine/api";
var SwitchHandObjectComponent = class extends Component47 {
  static TypeName = "pp-switch-hand-object";
  static Properties = {
    _myHandedness: Property30.enum(["Left", "Right"], "Left"),
    _myGamepad: Property30.object(),
    _myTrackedHand: Property30.object(),
    _myDisableHandsWhenNonXR: Property30.bool(true)
  };
  start() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myFirstUpdate = true;
    this._myCurrentInputSourceType = null;
    this._myActivateOnNextUpdate = false;
  }
  update(dt) {
    if (this._myActivateOnNextUpdate) {
      this._onActivate();
      this._myActivateOnNextUpdate = false;
    }
  }
  _start() {
    if (this._myGamepad != null) {
      this._myGamepad.pp_setActive(false);
    }
    if (this._myTrackedHand != null) {
      this._myTrackedHand.pp_setActive(false);
    }
    this._myCurrentInputSourceType = null;
  }
  _onPoseUpdated(dt, pose) {
    if (!this.active || this._myActivateOnNextUpdate) {
      Globals.getHandPose(this._myHandednessType, this.engine)?.unregisterPoseUpdatedEventListener(this);
      return;
    }
    if (this._myFirstUpdate) {
      this._myFirstUpdate = false;
      this._start();
    }
    if (this._myDisableHandsWhenNonXR && !XRUtils.isSessionActive(this.engine)) {
      if (this._myCurrentInputSourceType != null) {
        this._myCurrentInputSourceType = null;
        this._myGamepad.pp_setActive(false);
        this._myTrackedHand.pp_setActive(false);
      }
    } else {
      let inputSourceType = pose.getInputSourceType();
      if (this._myCurrentInputSourceType != inputSourceType) {
        this._myCurrentInputSourceType = inputSourceType;
        if (inputSourceType == InputSourceType.TRACKED_HAND) {
          if (this._myGamepad != null) {
            this._myGamepad.pp_setActive(false);
          }
          if (this._myTrackedHand != null) {
            this._myTrackedHand.pp_setActive(true);
          }
        } else if (inputSourceType == InputSourceType.GAMEPAD) {
          if (this._myTrackedHand != null) {
            this._myTrackedHand.pp_setActive(false);
          }
          if (this._myGamepad != null) {
            this._myGamepad.pp_setActive(true);
          }
        } else if (inputSourceType == null) {
          this._myGamepad.pp_setActive(false);
          this._myTrackedHand.pp_setActive(false);
        }
      }
    }
  }
  onActivate() {
    this._myActivateOnNextUpdate = true;
  }
  _onActivate() {
    Globals.getHandPose(this._myHandednessType, this.engine).registerPoseUpdatedEventListener(this, this._onPoseUpdated.bind(this));
    this._myFirstUpdate = true;
  }
  onDeactivate() {
    Globals.getHandPose(this._myHandednessType, this.engine)?.unregisterPoseUpdatedEventListener(this);
  }
};

// dist/pp/input/cauldron/components/tracked_hand_draw_joint_component.js
import { Component as Component48, MeshComponent as MeshComponent12, Property as Property31 } from "@wonderlandengine/api";
var TrackedHandDrawJointComponent = class extends Component48 {
  static TypeName = "pp-tracked-hand-draw-joint";
  static Properties = {
    _myHandedness: Property31.enum(["Left", "Right"], "Left"),
    _myJointID: Property31.enum([
      "Wrist",
      "Thumb Metacarpal",
      "Thumb Phalanx Proximal",
      "Thumb Phalanx Distal",
      "Thumb Tip",
      "Index Metacarpal",
      "Index Phalanx Proximal",
      "Index Phalanx Intermediate",
      "Index Phalanx Distal",
      "Index Tip",
      "Middle Metacarpal",
      "Middle Phalanx Proximal",
      "Middle Phalanx Intermediate",
      "Middle Phalanx Distal",
      "Middle Tip",
      "Ring Metacarpal",
      "Ring Phalanx Proximal",
      "Ring Phalanx Intermediate",
      "Ring Phalanx Distal",
      "Ring Tip",
      "Pinky Metacarpal",
      "Pinky Phalanx Proximal",
      "Pinky Phalanx Intermediate",
      "Pinky Phalanx Distal",
      "Pinky Tip"
    ], "Wrist"),
    _myJointMesh: Property31.mesh(),
    _myJointMaterial: Property31.material()
  };
  start() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myJointIDType = InputUtils.getJointIDByIndex(this._myJointID);
    this._buildTrackedHandHierarchy();
  }
  update(dt) {
  }
  _buildTrackedHandHierarchy() {
    this._myJointMeshObject = this.object.pp_addChild();
    let mesh = this._myJointMeshObject.pp_addComponent(MeshComponent12);
    mesh.mesh = this._myJointMesh;
    mesh.material = this._myJointMaterial;
    this._myJointMeshObject.pp_setScaleLocal(0);
  }
};
TrackedHandDrawJointComponent.prototype.update = function() {
  let transformQuat2 = quat2_create();
  return function update(dt) {
    let jointPose = Globals.getTrackedHandPose(this._myHandednessType, this.engine).getJointPose(this._myJointIDType);
    this._myJointMeshObject.pp_setTransformLocalQuat(jointPose.getTransformQuat(transformQuat2, null));
    this._myJointMeshObject.pp_setScaleLocal(jointPose.getJointRadius());
  };
}();

// dist/pp/input/cauldron/components/tracked_hand_draw_all_joints_component.js
import { Component as Component49, Property as Property32 } from "@wonderlandengine/api";
var TrackedHandDrawAllJointsComponent = class extends Component49 {
  static TypeName = "pp-tracked-hand-draw-all-joints";
  static Properties = {
    _myHandedness: Property32.enum(["Left", "Right"], "Left"),
    _myHideMetacarpals: Property32.bool(true),
    _myJointMesh: Property32.mesh(),
    _myJointMaterial: Property32.material()
  };
  start() {
    this._buildTrackedHandHierarchy();
  }
  _buildTrackedHandHierarchy() {
    this._myTrackedHandMeshObject = this.object.pp_addChild();
    this._myJointMeshObjectList = [];
    for (let jointIDKey in TrackedHandJointID) {
      let jointID = TrackedHandJointID[jointIDKey];
      if (!this._myHideMetacarpals || jointID != TrackedHandJointID.THUMB_METACARPAL && jointID != TrackedHandJointID.INDEX_FINGER_METACARPAL && jointID != TrackedHandJointID.MIDDLE_FINGER_METACARPAL && jointID != TrackedHandJointID.RING_FINGER_METACARPAL && jointID != TrackedHandJointID.PINKY_FINGER_METACARPAL) {
        let jointObject = this._myTrackedHandMeshObject.pp_addChild();
        this._myJointMeshObjectList[jointID] = jointObject;
        jointObject.pp_addComponent(TrackedHandDrawJointComponent, {
          "_myHandedness": this._myHandedness,
          "_myJointID": TrackedHandJointIDIndex[jointIDKey],
          "_myJointMesh": this._myJointMesh,
          "_myJointMaterial": this._myJointMaterial
        });
      }
    }
  }
};

// dist/pp/input/cauldron/components/tracked_hand_draw_skin_component.js
import { Component as Component50, Property as Property33 } from "@wonderlandengine/api";
var TrackedHandDrawSkinComponent = class extends Component50 {
  static TypeName = "pp-tracked-hand-draw-skin";
  static Properties = {
    _myHandedness: Property33.enum(["Left", "Right"], "Left"),
    _myHandSkin: Property33.skin(null),
    _myIsHandSkinForwardFixed: Property33.bool(false)
    // Should become true when I can manage to create a tracked hand skin with the forward fixed
  };
  start() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._prepareJoints();
  }
  update(dt) {
  }
  _prepareJoints() {
    this._myJoints = [];
    let skinJointIDs = this._myHandSkin.jointIds;
    for (let i = 0; i < skinJointIDs.length; i++) {
      this._myJoints[i] = ObjectUtils.wrapObject(skinJointIDs[i], this.engine);
    }
  }
};
TrackedHandDrawSkinComponent.prototype.update = function() {
  let transformQuat2 = quat2_create();
  return function update(dt) {
    for (let i = 0; i < this._myJoints.length; i++) {
      let jointObject = this._myJoints[i];
      let jointID = jointObject.pp_getName();
      let jointPose = Globals.getTrackedHandPose(this._myHandednessType, this.engine).getJointPose(jointID);
      let jointTransformQuat = jointPose.getTransformQuat(transformQuat2, null);
      if (jointPose.isForwardFixed() != this._myIsHandSkinForwardFixed) {
        jointTransformQuat.quat2_rotateAxis(180, jointTransformQuat.quat2_getUp(), jointTransformQuat);
      }
      jointObject.pp_setTransformLocalQuat(jointTransformQuat);
    }
  };
}();

// dist/pp/input/gamepad/cauldron/gamepad_mesh_animator_component.js
import { Component as Component51, Property as Property34 } from "@wonderlandengine/api";
var GamepadMeshAnimatorComponent = class extends Component51 {
  static TypeName = "pp-gamepad-mesh-animator";
  static Properties = {
    _myHandedness: Property34.enum(["Left", "Right"], "Left"),
    _mySelect: Property34.object(null),
    _mySqueeze: Property34.object(null),
    _myThumbstick: Property34.object(null),
    _myTopButton: Property34.object(null),
    _myBottomButton: Property34.object(null),
    _mySelectRotateAngle: Property34.float(15),
    _mySqueezeRotateAngle: Property34.float(11),
    _myThumbstickRotateAngle: Property34.float(15),
    _myThumbstickPressOffset: Property34.float(625e-6),
    _myTopButtonPressOffset: Property34.float(15e-4),
    _myBottomButtonPressOffset: Property34.float(15e-4),
    _myUsePressForSqueeze: Property34.bool(false),
    _mySqueezePressOffset: Property34.float(15e-4)
  };
  start() {
    if (this._mySelect != null) {
      this._mySelectOriginalRotation = this._mySelect.pp_getRotationLocalQuat();
      this._mySelectOriginalLeft = this._mySelect.pp_getLeftLocal();
    }
    if (this._mySqueeze != null) {
      this._mySqueezeOriginalPosition = this._mySqueeze.pp_getPositionLocal();
      this._mySqueezeOriginalRotation = this._mySqueeze.pp_getRotationLocalQuat();
      this._mySqueezeOriginalLeft = this._mySqueeze.pp_getLeftLocal();
      this._mySqueezeOriginalForward = this._mySqueeze.pp_getForwardLocal();
    }
    if (this._myThumbstick != null) {
      this._myThumbstickOriginalPosition = this._myThumbstick.pp_getPositionLocal();
      this._myThumbstickOriginalRotation = this._myThumbstick.pp_getRotationLocalQuat();
      this._myThumbstickOriginalLeft = this._myThumbstick.pp_getLeftLocal();
      this._myThumbstickOriginalUp = this._myThumbstick.pp_getUpLocal();
      this._myThumbstickOriginalForward = this._myThumbstick.pp_getForwardLocal();
    }
    if (this._myTopButton != null) {
      this._myTopButtonOriginalPosition = this._myTopButton.pp_getPositionLocal();
      this._myTopButtonOriginalUp = this._myTopButton.pp_getUpLocal();
    }
    if (this._myBottomButton != null) {
      this._myBottomButtonOriginalPosition = this._myBottomButton.pp_getPositionLocal();
      this._myBottomButtonOriginalUp = this._myBottomButton.pp_getUpLocal();
    }
    this._myActivateOnNextUpdate = true;
  }
  update(dt) {
    if (this._myActivateOnNextUpdate) {
      this._onActivate();
      this._myActivateOnNextUpdate = false;
    }
  }
  onActivate() {
    this._myActivateOnNextUpdate = true;
  }
  _onActivate() {
    let gamepad = null;
    if (this._myHandedness == HandednessIndex.LEFT) {
      gamepad = Globals.getLeftGamepad(this.engine);
    } else {
      gamepad = Globals.getRightGamepad(this.engine);
    }
    if (this._myThumbstick != null) {
      gamepad.registerButtonEventListener(GamepadButtonID.THUMBSTICK, GamepadButtonEvent.PRESS_START, this, this._thumbstickPressedStart.bind(this));
      gamepad.registerButtonEventListener(GamepadButtonID.THUMBSTICK, GamepadButtonEvent.PRESS_END, this, this._thumbstickPressedEnd.bind(this));
    }
    if (this._myTopButton != null) {
      gamepad.registerButtonEventListener(GamepadButtonID.TOP_BUTTON, GamepadButtonEvent.PRESS_START, this, this._topButtonPressedStart.bind(this));
      gamepad.registerButtonEventListener(GamepadButtonID.TOP_BUTTON, GamepadButtonEvent.PRESS_END, this, this._topButtonPressedEnd.bind(this));
    }
    if (this._myBottomButton != null) {
      gamepad.registerButtonEventListener(GamepadButtonID.BOTTOM_BUTTON, GamepadButtonEvent.PRESS_START, this, this._bottomButtonPressedStart.bind(this));
      gamepad.registerButtonEventListener(GamepadButtonID.BOTTOM_BUTTON, GamepadButtonEvent.PRESS_END, this, this._bottomButtonPressedEnd.bind(this));
    }
    if (this._mySelect != null) {
      gamepad.registerButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.VALUE_CHANGED, this, this._selectValueChanged.bind(this));
    }
    if (this._mySqueeze != null) {
      gamepad.registerButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.VALUE_CHANGED, this, this._squeezeValueChanged.bind(this));
    }
    if (this._myThumbstick != null) {
      gamepad.registerAxesEventListener(GamepadAxesID.THUMBSTICK, GamepadAxesEvent.AXES_CHANGED, this, this._thumbstickValueChanged.bind(this));
    }
  }
  onDeactivate() {
    let gamepad = null;
    if (this._myHandedness == HandednessIndex.LEFT) {
      gamepad = Globals.getLeftGamepad(this.engine);
    } else {
      gamepad = Globals.getRightGamepad(this.engine);
    }
    if (gamepad != null) {
      if (this._myThumbstick != null) {
        gamepad.unregisterButtonEventListener(GamepadButtonID.THUMBSTICK, GamepadButtonEvent.PRESS_START, this);
        gamepad.unregisterButtonEventListener(GamepadButtonID.THUMBSTICK, GamepadButtonEvent.PRESS_END, this);
      }
      if (this._myTopButton != null) {
        gamepad.unregisterButtonEventListener(GamepadButtonID.TOP_BUTTON, GamepadButtonEvent.PRESS_START, this);
        gamepad.unregisterButtonEventListener(GamepadButtonID.TOP_BUTTON, GamepadButtonEvent.PRESS_END, this);
      }
      if (this._myBottomButton != null) {
        gamepad.unregisterButtonEventListener(GamepadButtonID.BOTTOM_BUTTON, GamepadButtonEvent.PRESS_START, this);
        gamepad.unregisterButtonEventListener(GamepadButtonID.BOTTOM_BUTTON, GamepadButtonEvent.PRESS_END, this);
      }
      if (this._mySelect != null) {
        gamepad.unregisterButtonEventListener(GamepadButtonID.SELECT, GamepadButtonEvent.VALUE_CHANGED, this);
      }
      if (this._mySqueeze != null) {
        gamepad.unregisterButtonEventListener(GamepadButtonID.SQUEEZE, GamepadButtonEvent.VALUE_CHANGED, this);
      }
      if (this._myThumbstick != null) {
        gamepad.unregisterAxesEventListener(GamepadAxesID.THUMBSTICK, GamepadAxesEvent.AXES_CHANGED, this);
      }
    }
  }
  _thumbstickPressedStart() {
  }
  _thumbstickPressedEnd(buttonInfo, gamepad) {
    if (!this.active || this._myActivateOnNextUpdate) {
      this.onDeactivate();
      return;
    }
    this._myThumbstick.pp_setPositionLocal(this._myThumbstickOriginalPosition);
  }
  _topButtonPressedStart(buttonInfo, gamepad) {
    if (!this.active || this._myActivateOnNextUpdate) {
      this.onDeactivate();
      return;
    }
    this._myTopButton.pp_translateAxisLocal(-this._myTopButtonPressOffset, this._myTopButtonOriginalUp);
  }
  _topButtonPressedEnd(buttonInfo, gamepad) {
    if (!this.active || this._myActivateOnNextUpdate) {
      this.onDeactivate();
      return;
    }
    this._myTopButton.pp_setPositionLocal(this._myTopButtonOriginalPosition);
  }
  _bottomButtonPressedStart(buttonInfo, gamepad) {
    if (!this.active || this._myActivateOnNextUpdate) {
      this.onDeactivate();
      return;
    }
    this._myBottomButton.pp_translateAxisLocal(-this._myBottomButtonPressOffset, this._myBottomButtonOriginalUp);
  }
  _bottomButtonPressedEnd(buttonInfo, gamepad) {
    if (!this.active || this._myActivateOnNextUpdate) {
      this.onDeactivate();
      return;
    }
    this._myBottomButton.pp_setPositionLocal(this._myBottomButtonOriginalPosition);
  }
  _selectValueChanged(buttonInfo, gamepad) {
    if (!this.active || this._myActivateOnNextUpdate) {
      this.onDeactivate();
      return;
    }
    this._mySelect.pp_setRotationLocalQuat(this._mySelectOriginalRotation);
    if (buttonInfo.getValue() > 1e-5) {
      this._mySelect.pp_rotateAxisLocal(this._mySelectRotateAngle * buttonInfo.getValue(), this._mySelectOriginalLeft);
    }
  }
  _squeezeValueChanged(buttonInfo, gamepad) {
    if (!this.active || this._myActivateOnNextUpdate) {
      this.onDeactivate();
      return;
    }
    this._mySqueeze.pp_setPositionLocal(this._mySqueezeOriginalPosition);
    this._mySqueeze.pp_setRotationLocalQuat(this._mySqueezeOriginalRotation);
    if (buttonInfo.getValue() > 1e-5) {
      if (this._myUsePressForSqueeze) {
        let translation = this._mySqueezePressOffset;
        if (this._myHandedness == 1) {
          translation *= -1;
        }
        this._mySqueeze.pp_translateAxisLocal(translation * buttonInfo.getValue(), this._mySqueezeOriginalLeft);
      } else {
        let rotation = -this._mySqueezeRotateAngle;
        if (this._myHandedness == 1) {
          rotation *= -1;
        }
        this._mySqueeze.pp_rotateAxisLocal(rotation * buttonInfo.getValue(), this._mySqueezeOriginalForward);
      }
    }
  }
  _thumbstickValueChanged(axesInfo, gamepad) {
    if (!this.active || this._myActivateOnNextUpdate) {
      this.onDeactivate();
      return;
    }
    this._myThumbstick.pp_setRotationLocalQuat(this._myThumbstickOriginalRotation);
    let leftRotation = this._myThumbstickRotateAngle * axesInfo.myAxes[1];
    let forwardRotation = this._myThumbstickRotateAngle * axesInfo.myAxes[0];
    if (Math.abs(leftRotation) > 1e-4) {
      this._myThumbstick.pp_rotateAxisLocal(leftRotation, this._myThumbstickOriginalLeft);
    }
    if (Math.abs(forwardRotation) > 1e-4) {
      this._myThumbstick.pp_rotateAxisLocal(forwardRotation, this._myThumbstickOriginalForward);
    }
  }
};
GamepadMeshAnimatorComponent.prototype._thumbstickPressedStart = function() {
  let upTranslation = vec3_create();
  return function _thumbstickPressedStart(buttonInfo, gamepad) {
    if (!this.active || this._myActivateOnNextUpdate) {
      this.onDeactivate();
      return;
    }
    this._myThumbstickOriginalUp.vec3_scale(-this._myThumbstickPressOffset, upTranslation);
    this._myThumbstick.pp_translateLocal(upTranslation);
  };
}();

// dist/pp/input/gamepad/cauldron/gamepad_control_scheme_component.js
import { Alignment as Alignment5, Component as Component52, MeshComponent as MeshComponent13, Property as Property35, TextComponent as TextComponent10, VerticalAlignment as VerticalAlignment5 } from "@wonderlandengine/api";
var GamepadControlSchemeComponent = class extends Component52 {
  static TypeName = "pp-gamepad-control-scheme";
  static Properties = {
    _myShowOnStart: Property35.bool(true),
    _myHandedness: Property35.enum(["Left", "Right"], "Left"),
    _mySelectText: Property35.string(""),
    _mySqueezeText: Property35.string(""),
    _myThumbstickText: Property35.string(""),
    _myBottomButtonText: Property35.string(""),
    _myTopButtonText: Property35.string(""),
    _mySelect: Property35.object(null),
    _mySqueeze: Property35.object(null),
    _myThumbstick: Property35.object(null),
    _myBottomButton: Property35.object(null),
    _myTopButton: Property35.object(null),
    _myTextScaleMultiplier: Property35.float(1),
    _myTextOffsetMultiplier: Property35.float(1),
    _myLineLengthMultiplier: Property35.float(1),
    _myLineThicknessMultiplier: Property35.float(1),
    _myDistanceFromButtonsMultiplier: Property35.float(1),
    _myTextMaterial: Property35.material(),
    _myLineMaterial: Property35.material()
  };
  start() {
    this._myTextMaterialFinal = this._myTextMaterial != null ? this._myTextMaterial : Globals.getDefaultMaterials(this.engine).myText.clone();
    this._myLineMaterialFinal = this._myLineMaterial != null ? this._myLineMaterial : Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myControlSchemeDirection = this._myHandednessType == Handedness.LEFT ? 1 : -1;
    this._myVisible = false;
    this._mySetVisibleNextUpdate = false;
    this._createControlScheme();
    this.setVisible(this._myShowOnStart);
    this._myVisibleBackup = this._myVisible;
  }
  update(dt) {
    if (this._mySetVisibleNextUpdate) {
      this._mySetVisibleNextUpdate = false;
      this.setVisible(false);
      this.setVisible(this._myVisibleBackup);
    }
  }
  onActivate() {
    this._mySetVisibleNextUpdate = true;
  }
  onDeactivate() {
    if (this._myVisible != null) {
      this._myVisibleBackup = this._myVisible;
      this.setVisible(false);
    }
  }
  isVisible() {
    return this._myVisible;
  }
  setVisible(visible) {
    this._myVisible = visible;
    if (this._myParentObject != null) {
      this._myParentObject.pp_setActive(this._myVisible);
      if (this._myVisible) {
        this._hideEmptySchemes();
      }
    }
  }
  setSelectText(text) {
    this._mySelectText = text;
    this._mySelectTextComponent.text = this._mySelectText;
    this.setVisible(this._myVisible);
  }
  setSqueezeText(text) {
    this._mySqueezeText = text;
    this._mySqueezeTextComponent.text = this._mySqueezeText;
    this.setVisible(this._myVisible);
  }
  setThumbstickText(text) {
    this._myThumbstickText = text;
    this._myThumbstickTextComponent.text = this._myThumbstickText;
    this.setVisible(this._myVisible);
  }
  setBottomButtonText(text) {
    this._myBottomButtonText = text;
    this._myBottomButtonTextComponent.text = this._myBottomButtonText;
    this.setVisible(this._myVisible);
  }
  setTopButtonText(text) {
    this._myTopButtonText = text;
    this._myTopButtonTextComponent.text = this._myTopButtonText;
    this.setVisible(this._myVisible);
  }
  _createControlScheme() {
    this._myParentObject = this.object.pp_addChild();
    let distanceFromButton = 0.02 * this._myDistanceFromButtonsMultiplier;
    let lineLength = 0.0935 * this._myLineLengthMultiplier;
    let referenceObject = this._myThumbstick;
    this._mySelectObject = this._myParentObject.pp_addChild();
    this._mySelectTextComponent = this._addScheme(this._mySelect, referenceObject, vec3_create(0, 0, distanceFromButton), vec3_create(lineLength * this._myControlSchemeDirection, 0, 0), this._mySelectObject);
    this._mySelectTextComponent.text = this._mySelectText;
    this._mySqueezeObject = this._myParentObject.pp_addChild();
    this._mySqueezeTextComponent = this._addScheme(this._mySqueeze, referenceObject, vec3_create(distanceFromButton * this._myControlSchemeDirection, 0, 0), vec3_create(lineLength * this._myControlSchemeDirection, 0, 0), this._mySqueezeObject);
    this._mySqueezeTextComponent.text = this._mySqueezeText;
    this._myThumbstickObject = this._myParentObject.pp_addChild();
    this._myThumbstickTextComponent = this._addScheme(this._myThumbstick, referenceObject, vec3_create(0, distanceFromButton, 0), vec3_create(-lineLength * this._myControlSchemeDirection, 0, 0), this._myThumbstickObject);
    this._myThumbstickTextComponent.text = this._myThumbstickText;
    let thumbstickPositionLocal = this._myThumbstick.pp_getPositionLocal();
    let thumbstickUpLocal = this._myThumbstick.pp_getUpLocal();
    {
      let bottomButtonPositionLocal = this._myBottomButton.pp_getPositionLocal();
      let difference = bottomButtonPositionLocal.vec3_sub(thumbstickPositionLocal);
      let differenceOnUp = difference.vec3_valueAlongAxis(thumbstickUpLocal);
      this._myBottomButtonObject = this._myParentObject.pp_addChild();
      this._myBottomButtonTextComponent = this._addScheme(this._myBottomButton, referenceObject, vec3_create(0, distanceFromButton - differenceOnUp, 0), vec3_create(0, 0, -lineLength), this._myBottomButtonObject);
      this._myBottomButtonTextComponent.text = this._myBottomButtonText;
    }
    {
      let topButtonPositionLocal = this._myTopButton.pp_getPositionLocal();
      let difference = topButtonPositionLocal.vec3_sub(thumbstickPositionLocal);
      let differenceOnUp = difference.vec3_valueAlongAxis(thumbstickUpLocal);
      this._myTopButtonObject = this._myParentObject.pp_addChild();
      this._myTopButtonTextComponent = this._addScheme(this._myTopButton, referenceObject, vec3_create(0, distanceFromButton - differenceOnUp, 0), vec3_create(-lineLength * this._myControlSchemeDirection, 0, 0).vec3_rotateAxis(-45 * this._myControlSchemeDirection, vec3_create(0, 1, 0)), this._myTopButtonObject);
      this._myTopButtonTextComponent.text = this._myTopButtonText;
    }
  }
  _addScheme(buttonObject, referenceObject, startOffset, endOffset, parentObject) {
    let buttonPosition = buttonObject.pp_getPositionLocal();
    let referenceForward = referenceObject.pp_getForwardLocal();
    let referenceRight = referenceObject.pp_getRightLocal();
    let referenceUp = referenceObject.pp_getUpLocal();
    let lineStart = buttonPosition.vec3_add(referenceRight.vec3_scale(startOffset[0]));
    lineStart.vec3_add(referenceUp.vec3_scale(startOffset[1]), lineStart);
    lineStart.vec3_add(referenceForward.vec3_scale(startOffset[2]), lineStart);
    let lineEnd = lineStart.vec3_add(referenceRight.vec3_scale(endOffset[0]));
    lineEnd.vec3_add(referenceUp.vec3_scale(endOffset[1]), lineEnd);
    lineEnd.vec3_add(referenceForward.vec3_scale(endOffset[2]), lineEnd);
    let textOffset = 0.01 * this._myTextOffsetMultiplier;
    let textPosition = lineEnd.vec3_add(referenceForward.vec3_scale(-textOffset));
    this._addLine(lineStart, lineEnd, parentObject);
    let textComponent = this._addText(textPosition, referenceForward, referenceUp, parentObject);
    return textComponent;
  }
  _addLine(start, end, parentObject) {
    let lineDirection = end.vec3_sub(start);
    let length6 = lineDirection.vec3_length();
    lineDirection.vec3_normalize(lineDirection);
    let lineParentObject = parentObject.pp_addChild();
    let lineObject = lineParentObject.pp_addChild();
    let lineMesh = lineObject.pp_addComponent(MeshComponent13);
    lineMesh.mesh = Globals.getDefaultMeshes(this.engine).myCylinder;
    lineMesh.material = this._myLineMaterialFinal;
    lineParentObject.pp_setPositionLocal(start);
    let thickness = 1e-3 * this._myLineThicknessMultiplier;
    lineObject.pp_scaleObject(vec3_create(thickness / 2, length6 / 2, thickness / 2));
    lineObject.pp_setUpLocal(lineDirection);
    lineObject.pp_translateObject(vec3_create(0, length6 / 2, 0));
  }
  _addText(position, forward, up, parentObject) {
    let textObject = parentObject.pp_addChild();
    textObject.pp_setPositionLocal(position);
    textObject.pp_lookToLocal(up, forward);
    textObject.pp_scaleObject(0.0935 * this._myTextScaleMultiplier);
    let textComponent = textObject.pp_addComponent(TextComponent10);
    textComponent.alignment = Alignment5.Center;
    textComponent.verticalAlignment = VerticalAlignment5.Top;
    textComponent.material = this._myTextMaterialFinal;
    return textComponent;
  }
  _hideEmptySchemes() {
    if (this._mySelectText.length == 0) {
      this._mySelectObject.pp_setActive(false);
    }
    if (this._mySqueezeText.length == 0) {
      this._mySqueezeObject.pp_setActive(false);
    }
    if (this._myThumbstickText.length == 0) {
      this._myThumbstickObject.pp_setActive(false);
    }
    if (this._myBottomButtonText.length == 0) {
      this._myBottomButtonObject.pp_setActive(false);
    }
    if (this._myTopButtonText.length == 0) {
      this._myTopButtonObject.pp_setActive(false);
    }
  }
};

// dist/pp/input/gamepad/virtual_gamepad/virtual_gamepad_icon.js
var VirtualGamepadIconType = {
  NONE: 0,
  LABEL: 1,
  IMAGE: 2,
  DOT: 3,
  CIRCLE: 4,
  SQUARE: 5,
  RING: 6,
  FRAME: 7
};
var VirtualGamepadIconParams = class {
  constructor() {
    this.myBackgroundColor = "";
    this.myBackgroundPressedColor = "";
    this.myIconColor = "";
    this.myIconPressedColor = "";
    this.myIconType = VirtualGamepadIconType.NONE;
    this.myOverallHoveredBrightness = 1;
    this.myLabel = "";
    this.myLabelFontSize = 0;
    this.myLabelFontFamily = "";
    this.myLabelFontWeight = "";
    this.myImageURL = "";
    this.myImagePressedBrightness = 1;
  }
};
var VirtualGamepadIcon = class {
  constructor(iconElementParent, iconParams, minSizeMultiplier, scale4, engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myParams = iconParams;
    this._myIconContainerElement = null;
    this._myBackgroundElement = null;
    this._myIconElement = null;
    this._myPressed = false;
    this._myMouseHover = false;
    this._myMouseHoverEnabled = true;
    this._myDestroyed = false;
    this._build(iconElementParent, minSizeMultiplier, scale4);
  }
  update(dt) {
    if (this._myPressed || !this._myMouseHover || !this._myMouseHoverEnabled) {
      this._myIconContainerElement.style.filter = "none";
    } else {
      this._myIconContainerElement.style.filter = "brightness(" + this._myParams.myOverallHoveredBrightness + ")";
    }
  }
  reset() {
    this.setPressed(false);
    this._myMouseHover = false;
    this._myIconContainerElement.style.filter = "none";
  }
  setPressed(pressed) {
    if (this._myPressed != pressed) {
      this._myPressed = pressed;
      if (this._myPressed) {
        this._myBackgroundElement.style.fill = this._myParams.myBackgroundPressedColor;
        if (this._myIconElement != null) {
          if (this._myIconElement.style.strokeWidth.length > 0) {
            this._myIconElement.style.stroke = this._myParams.myIconPressedColor;
          } else {
            this._myIconElement.style.fill = this._myParams.myIconPressedColor;
          }
          if (this._myParams.myIconType == VirtualGamepadIconType.IMAGE) {
            this._myIconElement.style.filter = "brightness(" + this._myParams.myImagePressedBrightness + ")";
          }
        }
      } else {
        this._myBackgroundElement.style.fill = this._myParams.myBackgroundColor;
        if (this._myIconElement != null) {
          if (this._myIconElement.style.strokeWidth.length > 0) {
            this._myIconElement.style.stroke = this._myParams.myIconColor;
          } else {
            this._myIconElement.style.fill = this._myParams.myIconColor;
          }
          if (this._myParams.myIconType == VirtualGamepadIconType.IMAGE) {
            this._myIconElement.style.filter = "none";
          }
        }
      }
    }
  }
  onMouseEnter() {
    this._myMouseHover = true;
  }
  onMouseLeave() {
    this._myMouseHover = false;
  }
  setMouseHoverEnabled(enabled) {
    this._myMouseHoverEnabled = enabled;
  }
  _build(iconElementParent, minSizeMultiplier, scale4) {
    this._myIconContainerElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this._myIconContainerElement.style.position = "absolute";
    this._myIconContainerElement.style.width = "100%";
    this._myIconContainerElement.style.height = "100%";
    iconElementParent.appendChild(this._myIconContainerElement);
    this._myBackgroundElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this._myBackgroundElement.setAttributeNS(null, "cx", "50%");
    this._myBackgroundElement.setAttributeNS(null, "cy", "50%");
    this._myBackgroundElement.setAttributeNS(null, "r", "50%");
    this._myBackgroundElement.style.fill = this._myParams.myBackgroundColor;
    this._myIconContainerElement.appendChild(this._myBackgroundElement);
    switch (this._myParams.myIconType) {
      case VirtualGamepadIconType.NONE:
        break;
      case VirtualGamepadIconType.LABEL:
        this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
        this._myIconElement.setAttributeNS(null, "x", "50%");
        this._myIconElement.setAttributeNS(null, "y", "50%");
        this._myIconElement.style.textAlign = "center";
        this._myIconElement.style.textAnchor = "middle";
        this._myIconElement.style.dominantBaseline = "central";
        this._myIconElement.style.alignmentBaseline = "central";
        this._myIconElement.style.fontFamily = this._myParams.myLabelFontFamily;
        this._myIconElement.style.fontWeight = this._myParams.myLabelFontWeight;
        this._myIconElement.style.fontSize = this._createSizeValue(this._myParams.myLabelFontSize * scale4, minSizeMultiplier);
        this._myIconElement.style.fill = this._myParams.myIconColor;
        this._myIconElement.textContent = this._myParams.myLabel;
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.IMAGE:
        this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "image");
        this._myIconElement.setAttributeNS(null, "x", "0%");
        this._myIconElement.setAttributeNS(null, "y", "0%");
        this._myIconElement.setAttribute("href", this._myParams.myImageURL);
        this._myIconElement.style.width = "100%";
        this._myIconElement.style.height = "100%";
        this._myIconElement.style.filter = "none";
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.DOT:
        this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        this._myIconElement.setAttributeNS(null, "cx", "50%");
        this._myIconElement.setAttributeNS(null, "cy", "50%");
        this._myIconElement.setAttributeNS(null, "r", "17.5%");
        this._myIconElement.style.fill = this._myParams.myIconColor;
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.CIRCLE:
        this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        this._myIconElement.setAttributeNS(null, "cx", "50%");
        this._myIconElement.setAttributeNS(null, "cy", "50%");
        this._myIconElement.setAttributeNS(null, "r", "24%");
        this._myIconElement.style.fill = this._myParams.myIconColor;
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.SQUARE:
        this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        this._myIconElement.setAttributeNS(null, "x", "28%");
        this._myIconElement.setAttributeNS(null, "y", "28%");
        this._myIconElement.setAttributeNS(null, "rx", "10%");
        this._myIconElement.setAttributeNS(null, "ry", "10%");
        this._myIconElement.setAttributeNS(null, "width", "44%");
        this._myIconElement.setAttributeNS(null, "height", "44%");
        this._myIconElement.style.fill = this._myParams.myIconColor;
        this._myIconElement.style.transformOrigin = "center";
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.RING:
        this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        this._myIconElement.setAttributeNS(null, "cx", "50%");
        this._myIconElement.setAttributeNS(null, "cy", "50%");
        this._myIconElement.setAttributeNS(null, "r", "20%");
        this._myIconElement.style.fill = "#00000000";
        this._myIconElement.style.stroke = this._myParams.myIconColor;
        this._myIconElement.style.strokeWidth = "10%";
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
      case VirtualGamepadIconType.FRAME:
        this._myIconElement = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        this._myIconElement.setAttributeNS(null, "x", "31.5%");
        this._myIconElement.setAttributeNS(null, "y", "31.5%");
        this._myIconElement.setAttributeNS(null, "rx", "10%");
        this._myIconElement.setAttributeNS(null, "ry", "10%");
        this._myIconElement.setAttributeNS(null, "width", "37%");
        this._myIconElement.setAttributeNS(null, "height", "37%");
        this._myIconElement.style.fill = "#00000000";
        this._myIconElement.style.stroke = this._myParams.myIconColor;
        this._myIconElement.style.strokeWidth = "10%";
        this._myIconElement.style.transformOrigin = "center";
        this._myIconContainerElement.appendChild(this._myIconElement);
        break;
    }
  }
  _createSizeValue(value, minSizeMultiplier) {
    return "min(" + value.toFixed(3) + "vmax," + (value * minSizeMultiplier).toFixed(3) + "vw)";
  }
  _invertColors() {
    if (this._myIconElement.style.strokeWidth.length > 0) {
      this._myBackgroundElement.style.fill = this._myParams.myIconColor;
      this._myIconElement.style.fill = this._myParams.myIconColor;
      this._myIconElement.style.stroke = this._myParams.myBackgroundColor;
    } else {
      this._myBackgroundElement.style.fill = this._myParams.myIconColor;
      this._myIconElement.style.fill = this._myParams.myBackgroundColor;
    }
  }
  destroy() {
    this._myDestroyed = true;
    this._myIconContainerElement.remove();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/input/gamepad/virtual_gamepad/virtual_gamepad_params.js
var VirtualGamepadButtonParams = class {
  constructor() {
    this.myIconParams = new VirtualGamepadIconParams();
  }
};
var VirtualGamepadThumbstickParams = class {
  constructor() {
    this.myBackgroundColor = "";
    this.myMaxDistanceFromCenterMultiplier = 1;
    this.myReleaseTransitionSeconds = 0.2;
    this.myMoveTransitionSeconds = 0;
    this.myIncludeBackgroundToDetection = false;
    this.myIconParams = new VirtualGamepadIconParams();
  }
};
var VirtualGamepadParams = class {
  constructor(engine = Globals.getMainEngine()) {
    this.myShowOnDesktop = false;
    this.myShowOnMobile = false;
    this.myShowOnHeadset = false;
    this.myAutoUpdateVisibility = false;
    this.myOpacity = 1;
    this.myInterfaceScale = 1;
    this.myMarginScale = 1;
    this.myReleaseOnPointerLeave = true;
    this.myStopPropagatingMouseDownEvents = true;
    this.myButtonParams = [];
    this.myButtonParams[Handedness.LEFT] = [];
    this.myButtonParams[Handedness.RIGHT] = [];
    this.myButtonParams[Handedness.LEFT][VirtualGamepadButtonID.SECOND_BUTTON] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.LEFT][VirtualGamepadButtonID.FIRST_BUTTON] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.LEFT][VirtualGamepadButtonID.FIFTH_BUTTON] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.LEFT][VirtualGamepadButtonID.THIRD_BUTTON] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.LEFT][VirtualGamepadButtonID.FOURTH_BUTTON] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.RIGHT][VirtualGamepadButtonID.SECOND_BUTTON] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.RIGHT][VirtualGamepadButtonID.FIRST_BUTTON] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.RIGHT][VirtualGamepadButtonID.FIFTH_BUTTON] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.RIGHT][VirtualGamepadButtonID.THIRD_BUTTON] = new VirtualGamepadButtonParams();
    this.myButtonParams[Handedness.RIGHT][VirtualGamepadButtonID.FOURTH_BUTTON] = new VirtualGamepadButtonParams();
    this.myThumbstickParams = [];
    this.myThumbstickParams[Handedness.LEFT] = [];
    this.myThumbstickParams[Handedness.RIGHT] = [];
    this.myThumbstickParams[Handedness.LEFT][VirtualGamepadAxesID.FIRST_AXES] = new VirtualGamepadThumbstickParams();
    this.myThumbstickParams[Handedness.RIGHT][VirtualGamepadAxesID.FIRST_AXES] = new VirtualGamepadThumbstickParams();
    this.myButtonsEnabled = [];
    this.myButtonsEnabled[Handedness.LEFT] = [];
    this.myButtonsEnabled[Handedness.RIGHT] = [];
    this.myButtonsEnabled[Handedness.LEFT][VirtualGamepadButtonID.FIRST_BUTTON] = false;
    this.myButtonsEnabled[Handedness.LEFT][VirtualGamepadButtonID.SECOND_BUTTON] = false;
    this.myButtonsEnabled[Handedness.LEFT][VirtualGamepadButtonID.THIRD_BUTTON] = false;
    this.myButtonsEnabled[Handedness.LEFT][VirtualGamepadButtonID.FOURTH_BUTTON] = false;
    this.myButtonsEnabled[Handedness.LEFT][VirtualGamepadButtonID.FIFTH_BUTTON] = false;
    this.myButtonsEnabled[Handedness.RIGHT][VirtualGamepadButtonID.FIRST_BUTTON] = false;
    this.myButtonsEnabled[Handedness.RIGHT][VirtualGamepadButtonID.SECOND_BUTTON] = false;
    this.myButtonsEnabled[Handedness.RIGHT][VirtualGamepadButtonID.THIRD_BUTTON] = false;
    this.myButtonsEnabled[Handedness.RIGHT][VirtualGamepadButtonID.FOURTH_BUTTON] = false;
    this.myButtonsEnabled[Handedness.RIGHT][VirtualGamepadButtonID.FIFTH_BUTTON] = false;
    this.myThumbsticksEnabled = [];
    this.myThumbsticksEnabled[Handedness.LEFT] = [];
    this.myThumbsticksEnabled[Handedness.RIGHT] = [];
    this.myThumbsticksEnabled[Handedness.LEFT][VirtualGamepadAxesID.FIRST_AXES] = false;
    this.myThumbsticksEnabled[Handedness.RIGHT][VirtualGamepadAxesID.FIRST_AXES] = false;
    this.myValidPointerButtons = [];
    this.myMarginLeft = 0;
    this.myMarginRight = 0;
    this.myMarginBottom = 0;
    this.myThumbstickSize = 0;
    this.myButtonSize = 0;
    this.myButtonsRingRadius = 0;
    this.myButtonsRingStartAngle = 0;
    this.myButtonsRingEndAngle = 0;
    this.myFontSize = 0;
    this.myMinSizeMultiplier = 0;
    this.myDisableMouseHoverWhenPressed = false;
    this.myEngine = engine;
  }
  defaultConfig() {
    this.myShowOnMobile = true;
    this.myAutoUpdateVisibility = true;
    this.myOpacity = 0.5;
    let backgroundColor = "#616161";
    let iconColor = "#e0e0e0";
    let buttonHoveredBrightness = 0.75;
    let thumbstickHoveredBrightness = 0.75;
    let thumbstickIncludeBackgroundToDetection = true;
    for (let handedness in this.myButtonParams) {
      for (let gamepadButtonID in this.myButtonParams[handedness]) {
        let buttonParams = this.myButtonParams[handedness][gamepadButtonID];
        buttonParams.myIconParams.myBackgroundColor = backgroundColor;
        buttonParams.myIconParams.myBackgroundPressedColor = iconColor;
        buttonParams.myIconParams.myIconColor = iconColor;
        buttonParams.myIconParams.myIconPressedColor = backgroundColor;
        buttonParams.myIconParams.myOverallHoveredBrightness = buttonHoveredBrightness;
      }
    }
    this.myButtonParams[Handedness.LEFT][VirtualGamepadButtonID.FIRST_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.SQUARE;
    this.myButtonParams[Handedness.RIGHT][VirtualGamepadButtonID.FIRST_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.SQUARE;
    this.myButtonParams[Handedness.LEFT][VirtualGamepadButtonID.SECOND_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.FRAME;
    this.myButtonParams[Handedness.RIGHT][VirtualGamepadButtonID.SECOND_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.FRAME;
    this.myButtonParams[Handedness.LEFT][VirtualGamepadButtonID.THIRD_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.CIRCLE;
    this.myButtonParams[Handedness.RIGHT][VirtualGamepadButtonID.THIRD_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.CIRCLE;
    this.myButtonParams[Handedness.LEFT][VirtualGamepadButtonID.FOURTH_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.RING;
    this.myButtonParams[Handedness.RIGHT][VirtualGamepadButtonID.FOURTH_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.RING;
    this.myButtonParams[Handedness.LEFT][VirtualGamepadButtonID.FIFTH_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.DOT;
    this.myButtonParams[Handedness.RIGHT][VirtualGamepadButtonID.FIFTH_BUTTON].myIconParams.myIconType = VirtualGamepadIconType.DOT;
    for (let handedness in this.myThumbstickParams) {
      for (let gamepadAxesID in this.myThumbstickParams[handedness]) {
        let thumbstickParams = this.myThumbstickParams[handedness][gamepadAxesID];
        thumbstickParams.myBackgroundColor = backgroundColor;
        thumbstickParams.myIconParams.myBackgroundColor = iconColor;
        thumbstickParams.myIconParams.myBackgroundPressedColor = iconColor;
        thumbstickParams.myIconParams.myIconColor = backgroundColor;
        thumbstickParams.myIconParams.myIconPressedColor = backgroundColor;
        thumbstickParams.myIconParams.myOverallHoveredBrightness = thumbstickHoveredBrightness;
        thumbstickParams.myIncludeBackgroundToDetection = thumbstickIncludeBackgroundToDetection;
      }
    }
    this.myButtonsEnabled[Handedness.LEFT][VirtualGamepadButtonID.FIRST_BUTTON] = true;
    this.myButtonsEnabled[Handedness.LEFT][VirtualGamepadButtonID.SECOND_BUTTON] = true;
    this.myButtonsEnabled[Handedness.LEFT][VirtualGamepadButtonID.THIRD_BUTTON] = true;
    this.myButtonsEnabled[Handedness.LEFT][VirtualGamepadButtonID.FOURTH_BUTTON] = true;
    this.myButtonsEnabled[Handedness.LEFT][VirtualGamepadButtonID.FIFTH_BUTTON] = true;
    this.myButtonsEnabled[Handedness.RIGHT][VirtualGamepadButtonID.FIRST_BUTTON] = true;
    this.myButtonsEnabled[Handedness.RIGHT][VirtualGamepadButtonID.SECOND_BUTTON] = true;
    this.myButtonsEnabled[Handedness.RIGHT][VirtualGamepadButtonID.THIRD_BUTTON] = true;
    this.myButtonsEnabled[Handedness.RIGHT][VirtualGamepadButtonID.FOURTH_BUTTON] = true;
    this.myButtonsEnabled[Handedness.RIGHT][VirtualGamepadButtonID.FIFTH_BUTTON] = true;
    this.myThumbsticksEnabled[Handedness.LEFT][VirtualGamepadAxesID.FIRST_AXES] = true;
    this.myThumbsticksEnabled[Handedness.RIGHT][VirtualGamepadAxesID.FIRST_AXES] = true;
    this.myMarginLeft = 3;
    this.myMarginRight = 3;
    this.myMarginBottom = 3;
    this.myThumbstickSize = 15;
    this.myButtonSize = 5;
    this.myButtonsRingRadius = 12;
    this.myButtonsRingStartAngle = 385;
    this.myButtonsRingEndAngle = 245;
    this.myMinSizeMultiplier = 5 / 3;
    this.myDisableMouseHoverWhenPressed = true;
    this.myValidPointerButtons = [0];
  }
};

// dist/pp/input/gamepad/virtual_gamepad/virtual_gamepad_virtual_button.js
var VirtualGamepadVirtualButton = class {
  constructor(buttonElementParent, virtualGamepadParams, virtualButtonHandedness, virtualGamepadButtonID) {
    this._myButtonElement = null;
    this._myButtonIcon = null;
    this._myButtonDetectionElement = null;
    this._myActive = true;
    this._myPointerID = null;
    this._myPointerButton = null;
    this._myPressed = false;
    this._myVirtualGamepadParams = virtualGamepadParams;
    this._myParams = this._myVirtualGamepadParams.myButtonParams[virtualButtonHandedness][virtualGamepadButtonID];
    this._myButtonElementParent = buttonElementParent;
    this._build(virtualButtonHandedness, virtualGamepadButtonID);
    this._myPointerDownEventListener = this._onPointerDown.bind(this, this._myVirtualGamepadParams.myStopPropagatingPointerDownEvents);
    this._myPointerUpEventListener = this._onPointerUp.bind(this);
    this._myPointerLeaveEventListener = this._onPointerLeave.bind(this);
    this._myMouseEnterEventListener = this._onButtonEnter.bind(this);
    this._myMouseLeaveEventListener = this._onButtonLeave.bind(this);
    this._myButtonDetectionElement.addEventListener("pointerdown", this._myPointerDownEventListener);
    document.body.addEventListener("pointerup", this._myPointerUpEventListener);
    if (this._myVirtualGamepadParams.myReleaseOnPointerLeave) {
      document.body.addEventListener("pointerleave", this._myPointerLeaveEventListener);
    }
    this._myButtonDetectionElement.addEventListener("mouseenter", this._myMouseEnterEventListener);
    this._myButtonDetectionElement.addEventListener("mouseleave", this._myMouseLeaveEventListener);
    this._myDestroyed = false;
  }
  isPressed() {
    return this._myActive && this._myPressed;
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      this.reset();
      this._myButtonIcon.reset();
      if (this._myActive) {
        this._myButtonDetectionElement.addEventListener("pointerdown", this._myPointerDownEventListener);
        document.body.addEventListener("pointerup", this._myPointerUpEventListener);
        if (this._myVirtualGamepadParams.myReleaseOnPointerLeave) {
          document.body.addEventListener("pointerleave", this._myPointerLeaveEventListener);
        }
        this._myButtonDetectionElement.addEventListener("mouseenter", this._myMouseEnterEventListener);
        this._myButtonDetectionElement.addEventListener("mouseleave", this._myMouseLeaveEventListener);
        this._myButtonElementParent.appendChild(this._myButtonContainer);
      } else {
        this._myButtonDetectionElement.removeEventListener("pointerdown", this._myPointerDownEventListener);
        document.body.removeEventListener("pointerup", this._myPointerUpEventListener);
        document.body.removeEventListener("pointerleave", this._myPointerLeaveEventListener);
        this._myButtonDetectionElement.removeEventListener("mouseenter", this._myMouseEnterEventListener);
        this._myButtonDetectionElement.removeEventListener("mouseleave", this._myMouseLeaveEventListener);
        this._myButtonContainer.remove();
      }
    }
  }
  setMouseHoverEnabled(hoverActive) {
    this._myButtonIcon.setMouseHoverEnabled(hoverActive);
  }
  reset() {
    this._myButtonIcon.setPressed(false);
    this._myPressed = false;
    this._myPointerID = null;
    this._myPointerButton = null;
  }
  update(dt) {
    this._myButtonIcon.update(dt);
  }
  _onPointerDown(stopPropagatingPointerDownEvents, event) {
    if (!this._myActive)
      return;
    if (this._myPressed)
      return;
    if (!this._myVirtualGamepadParams.myValidPointerButtons.pp_hasEqual(event.button))
      return;
    if (stopPropagatingPointerDownEvents) {
      event.stopPropagation();
    }
    event.preventDefault();
    this._myButtonIcon.setPressed(true);
    this._myPointerID = event.pointerId;
    this._myPointerButton = event.button;
    this._myPressed = true;
  }
  _onPointerUp(event) {
    if (!this._myActive)
      return;
    if (!this._myPressed)
      return;
    if (this._myPointerID != event.pointerId)
      return;
    if (this._myPointerButton != null && this._myPointerButton != event.button)
      return;
    this.reset();
  }
  _onPointerLeave(event) {
    if (!this._myActive)
      return;
    if (this._myPointerID != event.pointerId)
      return;
    this.reset();
  }
  _onButtonEnter(event) {
    if (!this._myActive)
      return;
    this._myButtonIcon.onMouseEnter(event);
  }
  _onButtonLeave(event) {
    if (!this._myActive)
      return;
    this._myButtonIcon.onMouseLeave(event);
  }
  _build(virtualButtonHandedness, virtualButtonIndex) {
    let buttonSize = this._myVirtualGamepadParams.myButtonSize * this._myVirtualGamepadParams.myInterfaceScale;
    let buttonsRingRadius = this._myVirtualGamepadParams.myButtonsRingRadius * this._myVirtualGamepadParams.myInterfaceScale;
    let thumbstickSize = this._myVirtualGamepadParams.myThumbstickSize * this._myVirtualGamepadParams.myInterfaceScale;
    let marginBottom = this._myVirtualGamepadParams.myMarginBottom * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let marginLeft = this._myVirtualGamepadParams.myMarginLeft * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let marginRight = this._myVirtualGamepadParams.myMarginRight * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let buttonRingStartAngle = this._myVirtualGamepadParams.myButtonsRingStartAngle;
    let buttonRingEndAngle = this._myVirtualGamepadParams.myButtonsRingEndAngle;
    let minSizeMultiplier = Math.max(1, this._myVirtualGamepadParams.myMinSizeMultiplier / this._myVirtualGamepadParams.myInterfaceScale);
    let buttonsAmount = this._myVirtualGamepadParams.myButtonsEnabled[Handedness.LEFT].length;
    let angleStep = (buttonRingEndAngle - buttonRingStartAngle) / (buttonsAmount - 1);
    let currentAngle = Math.pp_angleClamp(buttonRingStartAngle + angleStep * virtualButtonIndex);
    if (virtualButtonHandedness == Handedness.RIGHT) {
      currentAngle = 270 + (270 - currentAngle);
      currentAngle = Math.pp_angleClamp(currentAngle, true);
    }
    let counterAngle = 360 - currentAngle;
    this._myButtonContainer = document.createElement("div");
    this._myButtonContainer.style.position = "absolute";
    this._myButtonContainer.style.width = this._createSizeValue(buttonSize, minSizeMultiplier);
    this._myButtonContainer.style.height = this._createSizeValue(buttonSize, minSizeMultiplier);
    let centerOnThumbstickBottom = marginBottom + thumbstickSize / 2 - buttonSize / 2;
    this._myButtonContainer.style.bottom = this._createSizeValue(centerOnThumbstickBottom, minSizeMultiplier);
    if (virtualButtonHandedness == Handedness.LEFT) {
      let centerOnThumbstickLeft = marginLeft + thumbstickSize / 2 - buttonSize / 2;
      this._myButtonContainer.style.left = this._createSizeValue(centerOnThumbstickLeft, minSizeMultiplier);
    } else {
      let centerOnThumbstickRight = marginRight + thumbstickSize / 2 - buttonSize / 2;
      this._myButtonContainer.style.right = this._createSizeValue(centerOnThumbstickRight, minSizeMultiplier);
    }
    this._myButtonContainer.style.transform = "rotate(" + currentAngle + "deg) translateX(" + this._createSizeValue(buttonsRingRadius, minSizeMultiplier) + ")";
    this._myButtonElementParent.appendChild(this._myButtonContainer);
    this._myButtonElement = document.createElement("div");
    this._myButtonElement.style.position = "absolute";
    this._myButtonElement.style.width = "100%";
    this._myButtonElement.style.height = "100%";
    this._myButtonElement.style.transform = "rotate(" + counterAngle + "deg)";
    this._myButtonContainer.appendChild(this._myButtonElement);
    this._myButtonIcon = new VirtualGamepadIcon(this._myButtonElement, this._myParams.myIconParams, minSizeMultiplier, this._myVirtualGamepadParams.myInterfaceScale, this._myVirtualGamepadParams.myEngine);
    let buttonElementStill = document.createElement("div");
    buttonElementStill.style.position = "absolute";
    buttonElementStill.style.width = "100%";
    buttonElementStill.style.height = "100%";
    buttonElementStill.style.transform = "rotate(" + counterAngle + "deg)";
    this._myButtonContainer.appendChild(buttonElementStill);
    let buttonDetectionElementSVG = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    buttonDetectionElementSVG.style.position = "absolute";
    buttonDetectionElementSVG.style.width = "100%";
    buttonDetectionElementSVG.style.height = "100%";
    buttonElementStill.appendChild(buttonDetectionElementSVG);
    let buttonDetectionElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    buttonDetectionElement.setAttributeNS(null, "cx", "50%");
    buttonDetectionElement.setAttributeNS(null, "cy", "50%");
    buttonDetectionElement.setAttributeNS(null, "r", "50%");
    buttonDetectionElement.style.fill = "#00000000";
    buttonDetectionElementSVG.appendChild(buttonDetectionElement);
    this._myButtonDetectionElement = buttonDetectionElement;
  }
  _createSizeValue(value, minSizeMultiplier) {
    return "min(" + value.toFixed(3) + "vmax," + (value * minSizeMultiplier).toFixed(3) + "vw)";
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
    this._myButtonIcon.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/input/gamepad/virtual_gamepad/virtual_gamepad_virtual_thumbstick.js
var VirtualGamepadVirtualThumbstick = class {
  constructor(thumbstickElementParent, virtualGamepadParams, virtualThumbstickHandedness, virtualGamepadAxesID) {
    this._myThumbstickElement = null;
    this._myThumbstickIcon = null;
    this._myThumbstickBackground = null;
    this._myThumbstickBackgroundResizeObserver = null;
    this._myThumbstickBackgroundWidth = 0;
    this._myThumbstickDetectionElement = null;
    this._myActive = true;
    this._myPointerID = null;
    this._myPointerButton = null;
    this._myThumbstickDragStartPosition = vec2_create();
    this._myAxes = vec2_create();
    this._myPressed = false;
    this._myVirtualGamepadParams = virtualGamepadParams;
    this._myParams = this._myVirtualGamepadParams.myThumbstickParams[virtualThumbstickHandedness][virtualGamepadAxesID];
    this._myThumbstickElementParent = thumbstickElementParent;
    this._build(virtualThumbstickHandedness);
    this._myPointerDownEventListener = this._onPointerDown.bind(this, this._myVirtualGamepadParams.myStopPropagatingPointerDownEvents);
    this._myPointerUpEventListener = this._onPointerUp.bind(this);
    this._myPointerMoveEventListener = this._onPointerMove.bind(this);
    this._myPointerLeaveEventListener = this._onPointerLeave.bind(this);
    this._myMouseEnterEventListener = this._onThumbstickEnter.bind(this);
    this._myMouseLeaveEventListener = this._onThumbstickLeave.bind(this);
    this._myThumbstickDetectionElement.addEventListener("pointerdown", this._myPointerDownEventListener);
    document.body.addEventListener("pointerup", this._myPointerUpEventListener);
    document.body.addEventListener("pointermove", this._myPointerMoveEventListener);
    if (this._myVirtualGamepadParams.myReleaseOnPointerLeave) {
      document.body.addEventListener("pointerleave", this._myPointerLeaveEventListener);
    }
    this._myThumbstickDetectionElement.addEventListener("mouseenter", this._myMouseEnterEventListener);
    this._myThumbstickDetectionElement.addEventListener("mouseleave", this._myMouseLeaveEventListener);
    this._myDestroyed = false;
  }
  isPressed() {
    return this._myActive && this._myPressed;
  }
  getAxes() {
    return this._myAxes;
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      this.reset();
      this._myThumbstickIcon.reset();
      if (this._myActive) {
        this._myThumbstickDetectionElement.addEventListener("pointerdown", this._myPointerDownEventListener);
        document.body.addEventListener("pointerup", this._myPointerUpEventListener);
        document.body.addEventListener("pointermove", this._myPointerMoveEventListener);
        if (this._myVirtualGamepadParams.myReleaseOnPointerLeave) {
          document.body.addEventListener("pointerleave", this._myPointerLeaveEventListener);
        }
        this._myThumbstickDetectionElement.addEventListener("mouseenter", this._myMouseEnterEventListener);
        this._myThumbstickDetectionElement.addEventListener("mouseleave", this._myMouseLeaveEventListener);
        this._myThumbstickBackgroundResizeObserver.observe(this._myThumbstickBackground);
        this._myThumbstickElementParent.appendChild(this._myThumbstickContainer);
      } else {
        this._myThumbstickDetectionElement.removeEventListener("pointerdown", this._myPointerDownEventListener);
        document.body.removeEventListener("pointerup", this._myPointerUpEventListener);
        document.body.removeEventListener("pointermove", this._myPointerMoveEventListener);
        document.body.removeEventListener("pointerleave", this._myPointerLeaveEventListener);
        this._myThumbstickDetectionElement.removeEventListener("mouseenter", this._myMouseEnterEventListener);
        this._myThumbstickDetectionElement.removeEventListener("mouseleave", this._myPointerUpEventLis_myMouseLeaveEventListenertener);
        this._myThumbstickBackgroundResizeObserver.disconnect();
        this._myThumbstickContainer.remove();
      }
    }
  }
  setMouseHoverEnabled(hoverActive) {
    this._myThumbstickIcon.setMouseHoverEnabled(hoverActive);
  }
  reset() {
    this._myThumbstickIcon.setPressed(false);
    this._myAxes[0] = 0;
    this._myAxes[1] = 0;
    this._myPressed = false;
    this._myPointerID = null;
    this._myPointerButton = null;
    this._myThumbstickElement.style.transition = "all " + this._myParams.myReleaseTransitionSeconds + "s ease 0s";
    this._myThumbstickElement.style.transform = "translate(0px, 0px)";
  }
  update(dt) {
    this._myThumbstickIcon.update(dt);
  }
  _onPointerDown(stopPropagatingPointerDownEvents, event) {
    if (!this._myActive)
      return;
    if (this._myPressed)
      return;
    if (!this._myVirtualGamepadParams.myValidPointerButtons.pp_hasEqual(event.button))
      return;
    if (stopPropagatingPointerDownEvents) {
      event.stopPropagation();
    }
    event.preventDefault();
    this._myThumbstickIcon.setPressed(true);
    this._myPointerID = event.pointerId;
    this._myPointerButton = event.button;
    this._myThumbstickDragStartPosition[0] = event.clientX;
    this._myThumbstickDragStartPosition[1] = event.clientY;
    this._myPressed = true;
  }
  _onPointerUp(event) {
    if (!this._myActive)
      return;
    if (!this._myPressed)
      return;
    if (this._myPointerID != event.pointerId)
      return;
    if (this._myPointerButton != null && this._myPointerButton != event.button)
      return;
    this.reset();
  }
  _onPointerLeave(event) {
    if (!this._myActive)
      return;
    if (this._myPointerID != event.pointerId)
      return;
    this.reset();
  }
  _onThumbstickEnter(event) {
    this._myThumbstickIcon.onMouseEnter(event);
  }
  _onThumbstickLeave(event) {
    this._myThumbstickIcon.onMouseLeave(event);
  }
  _onPointerMove(event) {
    if (!this._myActive)
      return;
    if (!this._myPressed)
      return;
    if (event.pointerId != this._myPointerID)
      return;
    let mouseX = event.clientX;
    let mouseY = event.clientY;
    let maxDistanceFromCenter = this._myThumbstickBackgroundWidth / 2 * this._myParams.myMaxDistanceFromCenterMultiplier;
    let xDiff = mouseX - this._myThumbstickDragStartPosition[0];
    let yDiff = mouseY - this._myThumbstickDragStartPosition[1];
    let angle2 = Math.atan2(yDiff, xDiff);
    let distanceFromDragStart = Math.min(maxDistanceFromCenter, Math.hypot(xDiff, yDiff));
    let translateThumbstickX = distanceFromDragStart * Math.cos(angle2);
    let translateThumbstickY = distanceFromDragStart * Math.sin(angle2);
    this._myThumbstickElement.style.transition = "all " + this._myParams.myMoveTransitionSeconds + "s ease-out 0s";
    this._myThumbstickElement.style.transform = "translate(" + translateThumbstickX + "px, " + translateThumbstickY + "px)";
    this._myAxes[0] = translateThumbstickX / maxDistanceFromCenter;
    this._myAxes[1] = -(translateThumbstickY / maxDistanceFromCenter);
  }
  _build(virtualThumbstickHandedness) {
    let thumbstickSize = this._myVirtualGamepadParams.myThumbstickSize * this._myVirtualGamepadParams.myInterfaceScale;
    let marginBottom = this._myVirtualGamepadParams.myMarginBottom * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let marginLeft = this._myVirtualGamepadParams.myMarginLeft * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let marginRight = this._myVirtualGamepadParams.myMarginRight * this._myVirtualGamepadParams.myInterfaceScale * this._myVirtualGamepadParams.myMarginScale;
    let minSizeMultiplier = Math.max(1, this._myVirtualGamepadParams.myMinSizeMultiplier / this._myVirtualGamepadParams.myInterfaceScale);
    this._myThumbstickContainer = document.createElement("div");
    this._myThumbstickContainer.style.position = "absolute";
    this._myThumbstickContainer.style.width = this._createSizeValue(thumbstickSize, minSizeMultiplier);
    this._myThumbstickContainer.style.height = this._createSizeValue(thumbstickSize, minSizeMultiplier);
    this._myThumbstickContainer.style.bottom = this._createSizeValue(marginBottom, minSizeMultiplier);
    if (virtualThumbstickHandedness == Handedness.LEFT) {
      this._myThumbstickContainer.style.left = this._createSizeValue(marginLeft, minSizeMultiplier);
    } else {
      this._myThumbstickContainer.style.right = this._createSizeValue(marginRight, minSizeMultiplier);
    }
    this._myThumbstickElementParent.appendChild(this._myThumbstickContainer);
    let thumbstickContainerSVG = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    thumbstickContainerSVG.style.position = "absolute";
    thumbstickContainerSVG.style.width = "100%";
    thumbstickContainerSVG.style.height = "100%";
    this._myThumbstickContainer.appendChild(thumbstickContainerSVG);
    this._myThumbstickBackground = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    this._myThumbstickBackground.setAttributeNS(null, "cx", "50%");
    this._myThumbstickBackground.setAttributeNS(null, "cy", "50%");
    this._myThumbstickBackground.setAttributeNS(null, "r", "48%");
    this._myThumbstickBackground.style.fill = this._myParams.myBackgroundColor;
    thumbstickContainerSVG.appendChild(this._myThumbstickBackground);
    this._myThumbstickElement = document.createElement("div");
    this._myThumbstickElement.style.position = "absolute";
    this._myThumbstickElement.style.width = "34%";
    this._myThumbstickElement.style.height = "34%";
    this._myThumbstickElement.style.top = "33%";
    this._myThumbstickElement.style.left = "33%";
    this._myThumbstickContainer.appendChild(this._myThumbstickElement);
    this._myThumbstickIcon = new VirtualGamepadIcon(this._myThumbstickElement, this._myParams.myIconParams, minSizeMultiplier, this._myVirtualGamepadParams.myScale, this._myVirtualGamepadParams.myEngine);
    if (this._myParams.myIncludeBackgroundToDetection) {
      let thumbstickBackgroundDetectionElementSVG = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      thumbstickBackgroundDetectionElementSVG.style.position = "absolute";
      thumbstickBackgroundDetectionElementSVG.style.width = "100%";
      thumbstickBackgroundDetectionElementSVG.style.height = "100%";
      this._myThumbstickContainer.appendChild(thumbstickBackgroundDetectionElementSVG);
      let thumbstickBackgroundDetectionElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      thumbstickBackgroundDetectionElement.setAttributeNS(null, "cx", "50%");
      thumbstickBackgroundDetectionElement.setAttributeNS(null, "cy", "50%");
      thumbstickBackgroundDetectionElement.setAttributeNS(null, "r", "48%");
      thumbstickBackgroundDetectionElement.style.fill = "#00000000";
      thumbstickBackgroundDetectionElementSVG.appendChild(thumbstickBackgroundDetectionElement);
      this._myThumbstickDetectionElement = thumbstickBackgroundDetectionElement;
    } else {
      let thumbstickElementStill = document.createElement("div");
      thumbstickElementStill.style.position = "absolute";
      thumbstickElementStill.style.width = "34%";
      thumbstickElementStill.style.height = "34%";
      thumbstickElementStill.style.top = "33%";
      thumbstickElementStill.style.left = "33%";
      this._myThumbstickContainer.appendChild(thumbstickElementStill);
      let thumbstickDetectionElementSVG = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      thumbstickDetectionElementSVG.style.position = "absolute";
      thumbstickDetectionElementSVG.style.width = "100%";
      thumbstickDetectionElementSVG.style.height = "100%";
      thumbstickElementStill.appendChild(thumbstickDetectionElementSVG);
      let thumbstickDetectionElement = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      thumbstickDetectionElement.setAttributeNS(null, "cx", "50%");
      thumbstickDetectionElement.setAttributeNS(null, "cy", "50%");
      thumbstickDetectionElement.setAttributeNS(null, "r", "50%");
      thumbstickDetectionElement.style.fill = "#00000000";
      thumbstickDetectionElementSVG.appendChild(thumbstickDetectionElement);
      this._myThumbstickDetectionElement = thumbstickDetectionElement;
    }
    this._myThumbstickBackgroundResizeObserver = new ResizeObserver(() => {
      let backgroundRect = this._myThumbstickBackground.getBoundingClientRect();
      this._myThumbstickBackgroundWidth = backgroundRect.width;
    });
  }
  _createSizeValue(value, minSizeMultiplier) {
    return "min(" + value.toFixed(3) + "vmax," + (value * minSizeMultiplier).toFixed(3) + "vw)";
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
    this._myThumbstickIcon.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/input/gamepad/virtual_gamepad/virtual_gamepad.js
var VirtualGamepadButtonID = {
  FIRST_BUTTON: 0,
  SECOND_BUTTON: 1,
  THIRD_BUTTON: 2,
  FOURTH_BUTTON: 3,
  FIFTH_BUTTON: 4
};
var VirtualGamepadAxesID = {
  FIRST_AXES: 0
};
var VirtualGamepad = class {
  constructor(params = new VirtualGamepadParams()) {
    this._myParams = params;
    this._myVisible = true;
    this._myVirtualGamepadContainer = null;
    this._myVirtualGamepadVirtualButtons = [];
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT] = [];
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT] = [];
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT][VirtualGamepadButtonID.FIRST_BUTTON] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT][VirtualGamepadButtonID.SECOND_BUTTON] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT][VirtualGamepadButtonID.THIRD_BUTTON] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT][VirtualGamepadButtonID.FOURTH_BUTTON] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.LEFT][VirtualGamepadButtonID.FIFTH_BUTTON] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT][VirtualGamepadButtonID.FIRST_BUTTON] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT][VirtualGamepadButtonID.SECOND_BUTTON] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT][VirtualGamepadButtonID.THIRD_BUTTON] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT][VirtualGamepadButtonID.FOURTH_BUTTON] = null;
    this._myVirtualGamepadVirtualButtons[Handedness.RIGHT][VirtualGamepadButtonID.FIFTH_BUTTON] = null;
    this._myButtonsAmount = this._myVirtualGamepadVirtualButtons[Handedness.LEFT].length;
    this._myVirtualGamepadVirtualThumbsticks = [];
    this._myVirtualGamepadVirtualThumbsticks[Handedness.LEFT] = [];
    this._myVirtualGamepadVirtualThumbsticks[Handedness.RIGHT] = [];
    this._myVirtualGamepadVirtualThumbsticks[Handedness.LEFT][VirtualGamepadAxesID.FIRST_AXES] = null;
    this._myVirtualGamepadVirtualThumbsticks[Handedness.RIGHT][VirtualGamepadAxesID.FIRST_AXES] = null;
    this._myGestureStartEventListener = null;
    this._myDestroyed = false;
  }
  isVisible() {
    return this._myVisible;
  }
  setVisible(visible) {
    if (this._myVisible != visible) {
      this._myVisible = visible;
      if (this._myVirtualGamepadContainer != null) {
        for (let handedness in this._myVirtualGamepadVirtualButtons) {
          for (let virtualGamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
            let button = this._myVirtualGamepadVirtualButtons[handedness][virtualGamepadButtonID];
            if (button != null) {
              button.setActive(this._myVisible);
            }
          }
        }
        for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
          for (let virtualGamepadAxesID in this._myVirtualGamepadVirtualThumbsticks[handedness]) {
            let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][virtualGamepadAxesID];
            if (thumbstick != null) {
              thumbstick.setActive(this._myVisible);
            }
          }
        }
        if (this._myVisible) {
          document.body.appendChild(this._myVirtualGamepadContainer);
        } else {
          this._myVirtualGamepadContainer?.remove();
        }
      }
      if (this._myVisible) {
        document.addEventListener("gesturestart", this._myGestureStartEventListener);
      } else {
        document.removeEventListener("gesturestart", this._myGestureStartEventListener);
      }
    }
  }
  isButtonPressed(handedness, virtualGamepadButtonID) {
    if (!this._myVisible)
      return false;
    let button = this._myVirtualGamepadVirtualButtons[handedness][virtualGamepadButtonID];
    if (button != null) {
      return button.isPressed();
    }
    return false;
  }
  getAxes(handedness, virtualGamepadAxesID, outAxes = vec2_create(0, 0)) {
    if (!this._myVisible)
      return outAxes;
    let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][virtualGamepadAxesID];
    if (thumbstick != null) {
      outAxes.vec2_copy(thumbstick.getAxes());
    }
    return outAxes;
  }
  start() {
    this._buildVirtualGamepad();
    let currentVisible = this._myVisible;
    this._myVisible = !this._myVisible;
    this.setVisible(currentVisible);
  }
  update(dt) {
    if (this._myParams.myAutoUpdateVisibility) {
      if (XRUtils.isSessionActive(this._myParams.myEngine) && XRUtils.isVRSupported(this._myParams.myEngine)) {
        this.setVisible(false);
      } else if (this._myParams.myShowOnDesktop && BrowserUtils.isDesktop() && !XRUtils.isVRSupported(this._myParams.myEngine)) {
        this.setVisible(true);
      } else if (this._myParams.myShowOnHeadset && BrowserUtils.isDesktop() && XRUtils.isVRSupported(this._myParams.myEngine)) {
        this.setVisible(true);
      } else if (this._myParams.myShowOnMobile && BrowserUtils.isMobile()) {
        this.setVisible(true);
      } else {
        this.setVisible(false);
      }
    }
    if (this._myVisible) {
      for (let handedness in this._myVirtualGamepadVirtualButtons) {
        for (let virtualGamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
          let button = this._myVirtualGamepadVirtualButtons[handedness][virtualGamepadButtonID];
          if (button != null) {
            button.update(dt);
          }
        }
      }
      for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
        for (let virtualGamepadAxesID in this._myVirtualGamepadVirtualThumbsticks[handedness]) {
          let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][virtualGamepadAxesID];
          if (thumbstick != null) {
            thumbstick.update(dt);
          }
        }
      }
      this._setMouseHoverEnabled(!(this._myParams.myDisableMouseHoverWhenPressed && this._isAnyElementPressed()));
    }
  }
  _buildVirtualGamepad() {
    this._setupDocumentBody();
    this._myVirtualGamepadContainer = document.createElement("div");
    this._myVirtualGamepadContainer.style.display = "block";
    this._myVirtualGamepadContainer.style.opacity = this._myParams.myOpacity.toString();
    document.body.appendChild(this._myVirtualGamepadContainer);
    let leftDiv = document.createElement("div");
    this._myVirtualGamepadContainer.appendChild(leftDiv);
    let rightDiv = document.createElement("div");
    this._myVirtualGamepadContainer.appendChild(rightDiv);
    for (let virtualGamepadButtonID in this._myParams.myButtonsEnabled[Handedness.LEFT]) {
      if (this._myParams.myButtonsEnabled[Handedness.LEFT][virtualGamepadButtonID] != null) {
        let enabled = this._myParams.myButtonsEnabled[Handedness.LEFT][virtualGamepadButtonID];
        if (enabled) {
          this._buildButton(leftDiv, Handedness.LEFT, virtualGamepadButtonID);
        }
      }
      if (this._myParams.myButtonsEnabled[Handedness.RIGHT][virtualGamepadButtonID] != null) {
        let enabled = this._myParams.myButtonsEnabled[Handedness.RIGHT][virtualGamepadButtonID];
        if (enabled) {
          this._buildButton(rightDiv, Handedness.RIGHT, virtualGamepadButtonID);
        }
      }
    }
    for (let virtualGamepadAxesID in this._myParams.myThumbsticksEnabled[Handedness.LEFT]) {
      if (this._myParams.myThumbsticksEnabled[Handedness.LEFT][virtualGamepadAxesID] != null) {
        let enabled = this._myParams.myThumbsticksEnabled[Handedness.LEFT][virtualGamepadAxesID];
        if (enabled) {
          this._buildThumbstick(leftDiv, Handedness.LEFT, virtualGamepadAxesID);
        }
      }
      if (this._myParams.myThumbsticksEnabled[Handedness.RIGHT][virtualGamepadAxesID] != null) {
        let enabled = this._myParams.myThumbsticksEnabled[Handedness.RIGHT][virtualGamepadAxesID];
        if (enabled) {
          this._buildThumbstick(rightDiv, Handedness.RIGHT, virtualGamepadAxesID);
        }
      }
    }
  }
  _setupDocumentBody() {
    document.body.style.overflow = "hidden";
    document.body.style.userSelect = "none";
    document.body.style.webkitUserSelect = "none";
    document.body.style.webkitTapHighlightColor = "transparent";
    document.body.style.touchAction = "none";
    this._myGestureStartEventListener = function(e) {
      e.preventDefault();
    };
    document.addEventListener("gesturestart", this._myGestureStartEventListener);
  }
  _buildButton(buttonElementParent, virtualButtonHandedness, virtualGamepadButtonID) {
    let virtualGamepadVirtualButton = new VirtualGamepadVirtualButton(buttonElementParent, this._myParams, virtualButtonHandedness, virtualGamepadButtonID);
    this._myVirtualGamepadVirtualButtons[virtualButtonHandedness][virtualGamepadButtonID] = virtualGamepadVirtualButton;
  }
  _buildThumbstick(thumbstickElementParent, virtualThumbstickHandedness, virtualGamepadAxesID) {
    let virtualGamepadVirtualThumbstick = new VirtualGamepadVirtualThumbstick(thumbstickElementParent, this._myParams, virtualThumbstickHandedness, virtualGamepadAxesID);
    this._myVirtualGamepadVirtualThumbsticks[virtualThumbstickHandedness][virtualGamepadAxesID] = virtualGamepadVirtualThumbstick;
  }
  _createSizeValue(value, minSizeMultiplier) {
    return "min(" + value.toFixed(3) + "vmax," + (value * minSizeMultiplier).toFixed(3) + "vw)";
  }
  _isAnyElementPressed() {
    let anyElementPressed = false;
    for (let handedness in this._myVirtualGamepadVirtualButtons) {
      for (let virtualGamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
        let button = this._myVirtualGamepadVirtualButtons[handedness][virtualGamepadButtonID];
        if (button != null && button.isPressed()) {
          anyElementPressed = true;
          break;
        }
      }
    }
    if (!anyElementPressed) {
      for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
        for (let virtualGamepadAxesID in this._myVirtualGamepadVirtualThumbsticks[handedness]) {
          let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][virtualGamepadAxesID];
          if (thumbstick != null && thumbstick.isPressed()) {
            anyElementPressed = true;
            break;
          }
        }
      }
    }
    return anyElementPressed;
  }
  _setMouseHoverEnabled(hoverActive) {
    for (let handedness in this._myVirtualGamepadVirtualButtons) {
      for (let virtualGamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
        let button = this._myVirtualGamepadVirtualButtons[handedness][virtualGamepadButtonID];
        if (button != null) {
          button.setMouseHoverEnabled(hoverActive);
        }
      }
    }
    for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
      for (let virtualGamepadAxesID in this._myVirtualGamepadVirtualThumbsticks[handedness]) {
        let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][virtualGamepadAxesID];
        if (thumbstick != null) {
          thumbstick.setMouseHoverEnabled(hoverActive);
        }
      }
    }
  }
  destroy() {
    this._myDestroyed = true;
    this.setVisible(false);
    for (let handedness in this._myVirtualGamepadVirtualButtons) {
      for (let virtualGamepadButtonID in this._myVirtualGamepadVirtualButtons[handedness]) {
        let button = this._myVirtualGamepadVirtualButtons[handedness][virtualGamepadButtonID];
        if (button != null) {
          button.destroy();
        }
      }
    }
    for (let handedness in this._myVirtualGamepadVirtualThumbsticks) {
      for (let virtualGamepadAxesID in this._myVirtualGamepadVirtualThumbsticks[handedness]) {
        let thumbstick = this._myVirtualGamepadVirtualThumbsticks[handedness][virtualGamepadAxesID];
        if (thumbstick != null) {
          thumbstick.destroy();
        }
      }
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/input/gamepad/gamepad_cores/virtual_gamepad_gamepad_core.js
var VirtualGamepadGamepadCore = class extends GamepadCore {
  constructor(virtualGamepad, handPose, gamepadToVirtualGamepadButtonIDMap = null, gamepadToVirtualGamepadAxesIDMap = null) {
    super(handPose);
    this.myGamepadToVirtualGamepadButtonIDMap = /* @__PURE__ */ new Map();
    if (gamepadToVirtualGamepadButtonIDMap == null) {
      this.myGamepadToVirtualGamepadButtonIDMap.set(GamepadButtonID.SQUEEZE, [this.getHandedness(), VirtualGamepadButtonID.FIRST_BUTTON]);
      this.myGamepadToVirtualGamepadButtonIDMap.set(GamepadButtonID.SELECT, [this.getHandedness(), VirtualGamepadButtonID.SECOND_BUTTON]);
      this.myGamepadToVirtualGamepadButtonIDMap.set(GamepadButtonID.TOP_BUTTON, [this.getHandedness(), VirtualGamepadButtonID.THIRD_BUTTON]);
      this.myGamepadToVirtualGamepadButtonIDMap.set(GamepadButtonID.BOTTOM_BUTTON, [this.getHandedness(), VirtualGamepadButtonID.FOURTH_BUTTON]);
      this.myGamepadToVirtualGamepadButtonIDMap.set(GamepadButtonID.THUMBSTICK, [this.getHandedness(), VirtualGamepadButtonID.FIFTH_BUTTON]);
    } else {
      this.myGamepadToVirtualGamepadButtonIDMap = gamepadToVirtualGamepadButtonIDMap;
    }
    this.myGamepadToVirtualGamepadAxesIDMap = /* @__PURE__ */ new Map();
    if (gamepadToVirtualGamepadAxesIDMap == null) {
      this.myGamepadToVirtualGamepadAxesIDMap.set(GamepadAxesID.THUMBSTICK, [this.getHandedness(), VirtualGamepadAxesID.FIRST_AXES]);
    } else {
      this.myGamepadToVirtualGamepadAxesIDMap = gamepadToVirtualGamepadAxesIDMap;
    }
    this._myVirtualGamepad = virtualGamepad;
    this._myButtonData = new GamepadRawButtonData();
    this._myAxesData = new GamepadRawAxesData();
    this._myHapticActuators = [];
  }
  isGamepadCoreActive() {
    return this.isActive() && this._myVirtualGamepad.isVisible();
  }
  getButtonData(buttonID) {
    this._myButtonData.reset();
    if (this.isGamepadCoreActive()) {
      const virtualGamepadButtonInfo = this.myGamepadToVirtualGamepadButtonIDMap.get(buttonID);
      if (virtualGamepadButtonInfo != null && this._myVirtualGamepad.isButtonPressed(virtualGamepadButtonInfo[0], virtualGamepadButtonInfo[1])) {
        this._myButtonData.myPressed = true;
        this._myButtonData.myTouched = true;
        this._myButtonData.myValue = 1;
      }
    }
    return this._myButtonData;
  }
  getAxesData(axesID) {
    this._myAxesData.reset();
    if (this.isGamepadCoreActive()) {
      const virtualGamepadAxesInfo = this.myGamepadToVirtualGamepadAxesIDMap.get(axesID);
      if (virtualGamepadAxesInfo != null) {
        this._myVirtualGamepad.getAxes(virtualGamepadAxesInfo[0], virtualGamepadAxesInfo[1], this._myAxesData.myAxes);
      }
    }
    return this._myAxesData;
  }
  getHapticActuators() {
    return this._myHapticActuators;
  }
};

// dist/pp/input/gamepad/virtual_gamepad/virtual_gamepad_component.js
import { Component as Component53, Property as Property36 } from "@wonderlandengine/api";
var VirtualGamepadComponent = class extends Component53 {
  static TypeName = "pp-virtual-gamepad";
  static Properties = {
    _myShowOnDesktop: Property36.bool(false),
    // You may have to enable headset too
    _myShowOnMobile: Property36.bool(true),
    _myShowOnHeadset: Property36.bool(false),
    // Not 100% reliable, this is true if the device supports XR and it is Desktop
    _myAddToUniversalGamepad: Property36.bool(true),
    _myOpacity: Property36.float(0.5),
    _myIconColor: Property36.string("#e0e0e0"),
    _myBackgroundColor: Property36.string("#616161"),
    _myInterfaceScale: Property36.float(1),
    _myMarginScale: Property36.float(1),
    ADVANCED_PARAMS_BELOW: Property36.string(""),
    _myLabelFontSize: Property36.float(2),
    _myLabelFontFamily: Property36.string("sans-serif"),
    _myLabelFontWeight: Property36.string("bold"),
    _myImagePressedBrightness: Property36.float(0.5),
    _myLeftFirstButtonEnabled: Property36.bool(true),
    _myLeftFirstButtonGamepadButtonID: Property36.enum(["Select", "Squeeze", "Thumbstick", "Top Button", "Bottom Button", "Left Button", "Right Button", "Menu", "Touchpad", "Thumb Rest"], "Squeeze"),
    _myLeftFirstButtonGamepadHandedness: Property36.enum(["Left", "Right"], "Left"),
    _myLeftFirstButtonIconType: Property36.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Square"),
    _myLeftFirstButtonIconLabelOrImageUrl: Property36.string(""),
    _myLeftSecondButtonEnabled: Property36.bool(true),
    _myLeftSecondButtonGamepadButtonID: Property36.enum(["Select", "Squeeze", "Thumbstick", "Top Button", "Bottom Button", "Left Button", "Right Button", "Menu", "Touchpad", "Thumb Rest"], "Select"),
    _myLeftSecondButtonGamepadHandedness: Property36.enum(["Left", "Right"], "Left"),
    _myLeftSecondButtonIconType: Property36.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Frame"),
    _myLeftSecondButtonIconLabelOrImageUrl: Property36.string(""),
    _myLeftThirdButtonEnabled: Property36.bool(true),
    _myLeftThirdButtonGamepadButtonID: Property36.enum(["Select", "Squeeze", "Thumbstick", "Top Button", "Bottom Button", "Left Button", "Right Button", "Menu", "Touchpad", "Thumb Rest"], "Top Button"),
    _myLeftThirdButtonGamepadHandedness: Property36.enum(["Left", "Right"], "Left"),
    _myLeftThirdButtonIconType: Property36.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Circle"),
    _myLeftThirdButtonIconLabelOrImageUrl: Property36.string(""),
    _myLeftFourthButtonEnabled: Property36.bool(true),
    _myLeftFourthButtonGamepadButtonID: Property36.enum(["Select", "Squeeze", "Thumbstick", "Top Button", "Bottom Button", "Left Button", "Right Button", "Menu", "Touchpad", "Thumb Rest"], "Bottom Button"),
    _myLeftFourthButtonGamepadHandedness: Property36.enum(["Left", "Right"], "Left"),
    _myLeftFourthButtonIconType: Property36.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Ring"),
    _myLeftFourthButtonIconLabelOrImageUrl: Property36.string(""),
    _myLeftFifthButtonEnabled: Property36.bool(true),
    _myLeftFifthButtonGamepadButtonID: Property36.enum(["Select", "Squeeze", "Thumbstick", "Top Button", "Bottom Button", "Left Button", "Right Button", "Menu", "Touchpad", "Thumb Rest"], "Thumbstick"),
    _myLeftFifthButtonGamepadHandedness: Property36.enum(["Left", "Right"], "Left"),
    _myLeftFifthButtonIconType: Property36.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Dot"),
    _myLeftFifthButtonIconLabelOrImageUrl: Property36.string(""),
    _myLeftThumbstickEnabled: Property36.bool(true),
    _myLeftThumbstickGamepadHandedness: Property36.enum(["Left", "Right"], "Left"),
    _myRightFirstButtonEnabled: Property36.bool(true),
    _myRightFirstButtonGamepadButtonID: Property36.enum(["Select", "Squeeze", "Thumbstick", "Top Button", "Bottom Button", "Left Button", "Right Button", "Menu", "Touchpad", "Thumb Rest"], "Squeeze"),
    _myRightFirstButtonGamepadHandedness: Property36.enum(["Left", "Right"], "Right"),
    _myRightFirstButtonIconType: Property36.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Square"),
    _myRightFirstButtonIconLabelOrImageUrl: Property36.string(""),
    _myRightSecondButtonEnabled: Property36.bool(true),
    _myRightSecondButtonGamepadButtonID: Property36.enum(["Select", "Squeeze", "Thumbstick", "Top Button", "Bottom Button", "Left Button", "Right Button", "Menu", "Touchpad", "Thumb Rest"], "Select"),
    _myRightSecondButtonGamepadHandedness: Property36.enum(["Left", "Right"], "Right"),
    _myRightSecondButtonIconType: Property36.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Frame"),
    _myRightSecondButtonIconLabelOrImageUrl: Property36.string(""),
    _myRightThirdButtonEnabled: Property36.bool(true),
    _myRightThirdButtonGamepadButtonID: Property36.enum(["Select", "Squeeze", "Thumbstick", "Top Button", "Bottom Button", "Left Button", "Right Button", "Menu", "Touchpad", "Thumb Rest"], "Top Button"),
    _myRightThirdButtonGamepadHandedness: Property36.enum(["Left", "Right"], "Right"),
    _myRightThirdButtonIconType: Property36.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Circle"),
    _myRightThirdButtonIconLabelOrImageUrl: Property36.string(""),
    _myRightFourthButtonEnabled: Property36.bool(true),
    _myRightFourthButtonGamepadButtonID: Property36.enum(["Select", "Squeeze", "Thumbstick", "Top Button", "Bottom Button", "Left Button", "Right Button", "Menu", "Touchpad", "Thumb Rest"], "Bottom Button"),
    _myRightFourthButtonGamepadHandedness: Property36.enum(["Left", "Right"], "Right"),
    _myRightFourthButtonIconType: Property36.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Ring"),
    _myRightFourthButtonIconLabelOrImageUrl: Property36.string(""),
    _myRightFifthButtonEnabled: Property36.bool(true),
    _myRightFifthButtonGamepadButtonID: Property36.enum(["Select", "Squeeze", "Thumbstick", "Top Button", "Bottom Button", "Left Button", "Right Button", "Menu", "Touchpad", "Thumb Rest"], "Thumbstick"),
    _myRightFifthButtonGamepadHandedness: Property36.enum(["Left", "Right"], "Right"),
    _myRightFifthButtonIconType: Property36.enum(["None", "Label", "Image", "Dot", "Circle", "Square", "Ring", "Frame"], "Dot"),
    _myRightFifthButtonIconLabelOrImageUrl: Property36.string(""),
    _myRightThumbstickEnabled: Property36.bool(true),
    _myRightThumbstickGamepadHandedness: Property36.enum(["Left", "Right"], "Right")
  };
  start() {
    let params = new VirtualGamepadParams(this.engine);
    params.defaultConfig();
    for (let handedness in params.myButtonParams) {
      for (let gamepadButtonID in params.myButtonParams[handedness]) {
        let buttonParams = params.myButtonParams[handedness][gamepadButtonID];
        buttonParams.myIconParams.myBackgroundColor = this._myBackgroundColor;
        buttonParams.myIconParams.myBackgroundPressedColor = this._myIconColor;
        buttonParams.myIconParams.myIconColor = this._myIconColor;
        buttonParams.myIconParams.myIconPressedColor = this._myBackgroundColor;
      }
    }
    for (let handedness in params.myThumbstickParams) {
      for (let gamepadAxesID in params.myThumbstickParams[handedness]) {
        let thumbstickParams = params.myThumbstickParams[handedness][gamepadAxesID];
        thumbstickParams.myBackgroundColor = this._myBackgroundColor;
        thumbstickParams.myIconParams.myBackgroundColor = this._myIconColor;
        thumbstickParams.myIconParams.myBackgroundPressedColor = this._myIconColor;
        thumbstickParams.myIconParams.myIconColor = this._myBackgroundColor;
        thumbstickParams.myIconParams.myIconPressedColor = this._myBackgroundColor;
      }
    }
    params.myOpacity = this._myOpacity;
    params.myInterfaceScale = this._myInterfaceScale;
    params.myMarginScale = this._myMarginScale;
    params.myShowOnDesktop = this._myShowOnDesktop;
    params.myShowOnMobile = this._myShowOnMobile;
    params.myShowOnHeadset = this._myShowOnHeadset;
    if (params.myShowOnDesktop || params.myShowOnMobile || params.myShowOnHeadset) {
      params.myAutoUpdateVisibility = true;
    } else {
      params.myAutoUpdateVisibility = false;
    }
    this._advancedConfig(params);
    this._myVirtualGamepad = new VirtualGamepad(params);
    this._myVirtualGamepad.setVisible(false);
    this._myVirtualGamepad.start();
    this._myFirstUpdate = true;
    this._myLeftVirtualGamepadGamepadCore = null;
    this._myRightVirtualGamepadGamepadCore = null;
    this._myActivateOnNextUpdate = false;
  }
  update(dt) {
    if (this._myActivateOnNextUpdate) {
      this._onActivate();
      this._myActivateOnNextUpdate = false;
    }
    if (this._myFirstUpdate) {
      this._myFirstUpdate = false;
      if (this._myAddToUniversalGamepad) {
        this._addToUniversalGamepad();
      }
    }
    this._myVirtualGamepad.update(dt);
  }
  _advancedConfig(params) {
    {
      let buttonParams = params.myButtonParams[Handedness.LEFT][VirtualGamepadButtonID.SECOND_BUTTON];
      buttonParams.myIconParams.myIconType = this._myLeftSecondButtonIconType;
      buttonParams.myIconParams.myLabel = this._myLeftSecondButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myLeftSecondButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      params.myButtonsEnabled[Handedness.LEFT][VirtualGamepadButtonID.SECOND_BUTTON] = this._myLeftSecondButtonEnabled;
    }
    {
      let buttonParams = params.myButtonParams[Handedness.LEFT][VirtualGamepadButtonID.FIRST_BUTTON];
      buttonParams.myIconParams.myIconType = this._myLeftFirstButtonIconType;
      buttonParams.myIconParams.myLabel = this._myLeftFirstButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myLeftFirstButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      params.myButtonsEnabled[Handedness.LEFT][VirtualGamepadButtonID.FIRST_BUTTON] = this._myLeftFirstButtonEnabled;
    }
    {
      let buttonParams = params.myButtonParams[Handedness.LEFT][VirtualGamepadButtonID.FIFTH_BUTTON];
      buttonParams.myIconParams.myIconType = this._myLeftFifthButtonIconType;
      buttonParams.myIconParams.myLabel = this._myLeftFifthButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myLeftFifthButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      params.myButtonsEnabled[Handedness.LEFT][VirtualGamepadButtonID.FIFTH_BUTTON] = this._myLeftFifthButtonEnabled;
    }
    {
      let buttonParams = params.myButtonParams[Handedness.LEFT][VirtualGamepadButtonID.THIRD_BUTTON];
      buttonParams.myIconParams.myIconType = this._myLeftThirdButtonIconType;
      buttonParams.myIconParams.myLabel = this._myLeftThirdButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myLeftThirdButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      params.myButtonsEnabled[Handedness.LEFT][VirtualGamepadButtonID.THIRD_BUTTON] = this._myLeftThirdButtonEnabled;
    }
    {
      let buttonParams = params.myButtonParams[Handedness.LEFT][VirtualGamepadButtonID.FOURTH_BUTTON];
      buttonParams.myIconParams.myIconType = this._myLeftFourthButtonIconType;
      buttonParams.myIconParams.myLabel = this._myLeftFourthButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myLeftFourthButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      params.myButtonsEnabled[Handedness.LEFT][VirtualGamepadButtonID.FOURTH_BUTTON] = this._myLeftFourthButtonEnabled;
    }
    {
      let buttonParams = params.myButtonParams[Handedness.RIGHT][VirtualGamepadButtonID.SECOND_BUTTON];
      buttonParams.myIconParams.myIconType = this._myRightSecondButtonIconType;
      buttonParams.myIconParams.myLabel = this._myRightSecondButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myRightSecondButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      params.myButtonsEnabled[Handedness.RIGHT][VirtualGamepadButtonID.SECOND_BUTTON] = this._myRightSecondButtonEnabled;
    }
    {
      let buttonParams = params.myButtonParams[Handedness.RIGHT][VirtualGamepadButtonID.FIRST_BUTTON];
      buttonParams.myIconParams.myIconType = this._myRightFirstButtonIconType;
      buttonParams.myIconParams.myLabel = this._myRightFirstButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myRightFirstButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      params.myButtonsEnabled[Handedness.RIGHT][VirtualGamepadButtonID.FIRST_BUTTON] = this._myRightFirstButtonEnabled;
    }
    {
      let buttonParams = params.myButtonParams[Handedness.RIGHT][VirtualGamepadButtonID.FIFTH_BUTTON];
      buttonParams.myIconParams.myIconType = this._myRightFifthButtonIconType;
      buttonParams.myIconParams.myLabel = this._myRightFifthButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myRightFifthButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      params.myButtonsEnabled[Handedness.RIGHT][VirtualGamepadButtonID.FIFTH_BUTTON] = this._myRightFifthButtonEnabled;
    }
    {
      let buttonParams = params.myButtonParams[Handedness.RIGHT][VirtualGamepadButtonID.THIRD_BUTTON];
      buttonParams.myIconParams.myIconType = this._myRightThirdButtonIconType;
      buttonParams.myIconParams.myLabel = this._myRightThirdButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myRightThirdButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      params.myButtonsEnabled[Handedness.RIGHT][VirtualGamepadButtonID.THIRD_BUTTON] = this._myRightThirdButtonEnabled;
    }
    {
      let buttonParams = params.myButtonParams[Handedness.RIGHT][VirtualGamepadButtonID.FOURTH_BUTTON];
      buttonParams.myIconParams.myIconType = this._myRightFourthButtonIconType;
      buttonParams.myIconParams.myLabel = this._myRightFourthButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myImageURL = this._myRightFourthButtonIconLabelOrImageUrl;
      buttonParams.myIconParams.myLabelFontSize = this._myLabelFontSize;
      buttonParams.myIconParams.myLabelFontFamily = this._myLabelFontFamily;
      buttonParams.myIconParams.myLabelFontWeight = this._myLabelFontWeight;
      buttonParams.myIconParams.myImagePressedBrightness = this._myImagePressedBrightness;
      params.myButtonsEnabled[Handedness.RIGHT][VirtualGamepadButtonID.FOURTH_BUTTON] = this._myRightFourthButtonEnabled;
    }
    params.myThumbsticksEnabled[Handedness.LEFT][VirtualGamepadAxesID.FIRST_AXES] = this._myLeftThumbstickEnabled;
    params.myThumbsticksEnabled[Handedness.RIGHT][VirtualGamepadAxesID.FIRST_AXES] = this._myRightThumbstickEnabled;
  }
  _addToUniversalGamepad() {
    const leftGamepadToVirtualGamepadButtonIDMap = /* @__PURE__ */ new Map();
    const rightGamepadToVirtualGamepadButtonIDMap = /* @__PURE__ */ new Map();
    if (this._myLeftFirstButtonEnabled) {
      if (InputUtils.getHandednessByIndex(this._myLeftFirstButtonGamepadHandedness) == Handedness.LEFT) {
        leftGamepadToVirtualGamepadButtonIDMap.set(this._gamepadPropertyButtonIDToEnum(this._myLeftFirstButtonGamepadButtonID), [Handedness.LEFT, VirtualGamepadButtonID.FIRST_BUTTON]);
      } else {
        rightGamepadToVirtualGamepadButtonIDMap.set(this._gamepadPropertyButtonIDToEnum(this._myLeftFirstButtonGamepadButtonID), [Handedness.LEFT, VirtualGamepadButtonID.FIRST_BUTTON]);
      }
    }
    if (this._myLeftSecondButtonEnabled) {
      if (InputUtils.getHandednessByIndex(this._myLeftSecondButtonGamepadHandedness) == Handedness.LEFT) {
        leftGamepadToVirtualGamepadButtonIDMap.set(this._gamepadPropertyButtonIDToEnum(this._myLeftSecondButtonGamepadButtonID), [Handedness.LEFT, VirtualGamepadButtonID.SECOND_BUTTON]);
      } else {
        rightGamepadToVirtualGamepadButtonIDMap.set(this._gamepadPropertyButtonIDToEnum(this._myLeftSecondButtonGamepadButtonID), [Handedness.LEFT, VirtualGamepadButtonID.SECOND_BUTTON]);
      }
    }
    if (this._myLeftThirdButtonEnabled) {
      if (InputUtils.getHandednessByIndex(this._myLeftThirdButtonGamepadHandedness) == Handedness.LEFT) {
        leftGamepadToVirtualGamepadButtonIDMap.set(this._gamepadPropertyButtonIDToEnum(this._myLeftThirdButtonGamepadButtonID), [Handedness.LEFT, VirtualGamepadButtonID.THIRD_BUTTON]);
      } else {
        rightGamepadToVirtualGamepadButtonIDMap.set(this._gamepadPropertyButtonIDToEnum(this._myLeftThirdButtonGamepadButtonID), [Handedness.LEFT, VirtualGamepadButtonID.THIRD_BUTTON]);
      }
    }
    if (this._myLeftFourthButtonEnabled) {
      if (InputUtils.getHandednessByIndex(this._myLeftFourthButtonGamepadHandedness) == Handedness.LEFT) {
        leftGamepadToVirtualGamepadButtonIDMap.set(this._gamepadPropertyButtonIDToEnum(this._myLeftFourthButtonGamepadButtonID), [Handedness.LEFT, VirtualGamepadButtonID.FOURTH_BUTTON]);
      } else {
        rightGamepadToVirtualGamepadButtonIDMap.set(this._gamepadPropertyButtonIDToEnum(this._myLeftFourthButtonGamepadButtonID), [Handedness.LEFT, VirtualGamepadButtonID.FOURTH_BUTTON]);
      }
    }
    if (this._myLeftFifthButtonEnabled) {
      if (InputUtils.getHandednessByIndex(this._myLeftFifthButtonGamepadHandedness) == Handedness.LEFT) {
        leftGamepadToVirtualGamepadButtonIDMap.set(this._gamepadPropertyButtonIDToEnum(this._myLeftFifthButtonGamepadButtonID), [Handedness.LEFT, VirtualGamepadButtonID.FIFTH_BUTTON]);
      } else {
        rightGamepadToVirtualGamepadButtonIDMap.set(this._gamepadPropertyButtonIDToEnum(this._myLeftFifthButtonGamepadButtonID), [Handedness.LEFT, VirtualGamepadButtonID.FIFTH_BUTTON]);
      }
    }
    if (this._myRightFirstButtonEnabled) {
      if (InputUtils.getHandednessByIndex(this._myRightFirstButtonGamepadHandedness) == Handedness.LEFT) {
        leftGamepadToVirtualGamepadButtonIDMap.set(this._gamepadPropertyButtonIDToEnum(this._myRightFirstButtonGamepadButtonID), [Handedness.RIGHT, VirtualGamepadButtonID.FIRST_BUTTON]);
      } else {
        rightGamepadToVirtualGamepadButtonIDMap.set(this._gamepadPropertyButtonIDToEnum(this._myRightFirstButtonGamepadButtonID), [Handedness.RIGHT, VirtualGamepadButtonID.FIRST_BUTTON]);
      }
    }
    if (this._myRightSecondButtonEnabled) {
      if (InputUtils.getHandednessByIndex(this._myRightSecondButtonGamepadHandedness) == Handedness.LEFT) {
        leftGamepadToVirtualGamepadButtonIDMap.set(this._gamepadPropertyButtonIDToEnum(this._myRightSecondButtonGamepadButtonID), [Handedness.RIGHT, VirtualGamepadButtonID.SECOND_BUTTON]);
      } else {
        rightGamepadToVirtualGamepadButtonIDMap.set(this._gamepadPropertyButtonIDToEnum(this._myRightSecondButtonGamepadButtonID), [Handedness.RIGHT, VirtualGamepadButtonID.SECOND_BUTTON]);
      }
    }
    if (this._myRightThirdButtonEnabled) {
      if (InputUtils.getHandednessByIndex(this._myRightThirdButtonGamepadHandedness) == Handedness.LEFT) {
        leftGamepadToVirtualGamepadButtonIDMap.set(this._gamepadPropertyButtonIDToEnum(this._myRightThirdButtonGamepadButtonID), [Handedness.RIGHT, VirtualGamepadButtonID.THIRD_BUTTON]);
      } else {
        rightGamepadToVirtualGamepadButtonIDMap.set(this._gamepadPropertyButtonIDToEnum(this._myRightThirdButtonGamepadButtonID), [Handedness.RIGHT, VirtualGamepadButtonID.THIRD_BUTTON]);
      }
    }
    if (this._myRightFourthButtonEnabled) {
      if (InputUtils.getHandednessByIndex(this._myRightFourthButtonGamepadHandedness) == Handedness.LEFT) {
        leftGamepadToVirtualGamepadButtonIDMap.set(this._gamepadPropertyButtonIDToEnum(this._myRightFourthButtonGamepadButtonID), [Handedness.RIGHT, VirtualGamepadButtonID.FOURTH_BUTTON]);
      } else {
        rightGamepadToVirtualGamepadButtonIDMap.set(this._gamepadPropertyButtonIDToEnum(this._myRightFourthButtonGamepadButtonID), [Handedness.RIGHT, VirtualGamepadButtonID.FOURTH_BUTTON]);
      }
    }
    if (this._myRightFifthButtonEnabled) {
      if (InputUtils.getHandednessByIndex(this._myRightFifthButtonGamepadHandedness) == Handedness.LEFT) {
        leftGamepadToVirtualGamepadButtonIDMap.set(this._gamepadPropertyButtonIDToEnum(this._myRightFifthButtonGamepadButtonID), [Handedness.RIGHT, VirtualGamepadButtonID.FIFTH_BUTTON]);
      } else {
        rightGamepadToVirtualGamepadButtonIDMap.set(this._gamepadPropertyButtonIDToEnum(this._myRightFifthButtonGamepadButtonID), [Handedness.RIGHT, VirtualGamepadButtonID.FIFTH_BUTTON]);
      }
    }
    const leftGamepadToVirtualGamepadAxesIDMap = /* @__PURE__ */ new Map();
    const rightGamepadToVirtualGamepadAxesIDMap = /* @__PURE__ */ new Map();
    if (this._myLeftThumbstickEnabled) {
      if (InputUtils.getHandednessByIndex(this._myLeftThumbstickGamepadHandedness) == Handedness.LEFT) {
        leftGamepadToVirtualGamepadAxesIDMap.set(GamepadAxesID.THUMBSTICK, [Handedness.LEFT, VirtualGamepadAxesID.FIRST_AXES]);
      } else {
        rightGamepadToVirtualGamepadAxesIDMap.set(GamepadAxesID.THUMBSTICK, [Handedness.LEFT, VirtualGamepadAxesID.FIRST_AXES]);
      }
    }
    if (this._myRightThumbstickEnabled) {
      if (InputUtils.getHandednessByIndex(this._myRightThumbstickGamepadHandedness) == Handedness.LEFT) {
        leftGamepadToVirtualGamepadAxesIDMap.set(GamepadAxesID.THUMBSTICK, [Handedness.RIGHT, VirtualGamepadAxesID.FIRST_AXES]);
      } else {
        rightGamepadToVirtualGamepadAxesIDMap.set(GamepadAxesID.THUMBSTICK, [Handedness.RIGHT, VirtualGamepadAxesID.FIRST_AXES]);
      }
    }
    const leftHandPose = Globals.getLeftGamepad(this.engine).getGamepadCore("pp_left_xr_gamepad").getHandPose();
    const rightHandPose = Globals.getRightGamepad(this.engine).getGamepadCore("pp_right_xr_gamepad").getHandPose();
    this._myLeftVirtualGamepadGamepadCore = new VirtualGamepadGamepadCore(this._myVirtualGamepad, leftHandPose, leftGamepadToVirtualGamepadButtonIDMap, leftGamepadToVirtualGamepadAxesIDMap);
    this._myRightVirtualGamepadGamepadCore = new VirtualGamepadGamepadCore(this._myVirtualGamepad, rightHandPose, rightGamepadToVirtualGamepadButtonIDMap, rightGamepadToVirtualGamepadAxesIDMap);
    Globals.getLeftGamepad(this.engine).addGamepadCore("pp_left_virtual_gamepad", this._myLeftVirtualGamepadGamepadCore);
    Globals.getRightGamepad(this.engine).addGamepadCore("pp_right_virtual_gamepad", this._myRightVirtualGamepadGamepadCore);
  }
  _gamepadPropertyButtonIDToEnum(propertyButtonID) {
    let buttonID = null;
    switch (propertyButtonID) {
      case 0:
        buttonID = GamepadButtonID.SELECT;
        break;
      case 1:
        buttonID = GamepadButtonID.SQUEEZE;
        break;
      case 2:
        buttonID = GamepadButtonID.THUMBSTICK;
        break;
      case 3:
        buttonID = GamepadButtonID.TOP_BUTTON;
        break;
      case 4:
        buttonID = GamepadButtonID.BOTTOM_BUTTON;
        break;
      case 5:
        buttonID = GamepadButtonID.LEFT_BUTTON;
        break;
      case 6:
        buttonID = GamepadButtonID.RIGHT_BUTTON;
        break;
      case 7:
        buttonID = GamepadButtonID.MENU;
        break;
      case 8:
        buttonID = GamepadButtonID.TOUCHPAD;
        break;
      case 9:
        buttonID = GamepadButtonID.THUMB_REST;
        break;
    }
    return buttonID;
  }
  onActivate() {
    this._myActivateOnNextUpdate = true;
  }
  _onActivate() {
    if (!this._myFirstUpdate && this._myAddToUniversalGamepad) {
      Globals.getLeftGamepad(this.engine).addGamepadCore("pp_left_virtual_gamepad", this._myLeftVirtualGamepadGamepadCore);
      Globals.getRightGamepad(this.engine).addGamepadCore("pp_right_virtual_gamepad", this._myRightVirtualGamepadGamepadCore);
    }
  }
  onDeactivate() {
    this._myVirtualGamepad?.setVisible(false);
    if (!this._myFirstUpdate && this._myAddToUniversalGamepad) {
      Globals.getLeftGamepad(this.engine)?.removeGamepadCore("pp_left_virtual_gamepad");
      Globals.getRightGamepad(this.engine)?.removeGamepadCore("pp_right_virtual_gamepad");
      this._myLeftVirtualGamepadGamepadCore.setActive(false);
      this._myRightVirtualGamepadGamepadCore.setActive(false);
    }
  }
  onDestroy() {
    this._myLeftVirtualGamepadGamepadCore?.destroy();
    this._myRightVirtualGamepadGamepadCore?.destroy();
    this._myVirtualGamepad?.destroy();
  }
};

// dist/pp/input/pose/components/set_player_height_component.js
import { Component as Component54, Property as Property37 } from "@wonderlandengine/api";
var SetPlayerHeightComponent = class extends Component54 {
  static TypeName = "pp-set-player-height";
  static Properties = {
    _myEyesHeight: Property37.float(1.65),
    _mySetOnlyOnStart: Property37.bool(false)
  };
  start() {
    let localPosition = this.object.pp_getPositionLocal();
    this.object.pp_setPositionLocal(vec3_create(localPosition[0], this._myEyesHeight, localPosition[2]));
    this._myHeightSetOnce = false;
  }
  onActivate() {
    XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this.engine);
  }
  onDeactivate() {
    XRUtils.unregisterSessionStartEndEventListeners(this, this.engine);
  }
  _onXRSessionStart() {
    if (this.active && (!this._mySetOnlyOnStart || !this._myHeightSetOnce)) {
      let localPosition = this.object.pp_getPositionLocal();
      if (XRUtils.isReferenceSpaceFloorBased(this.engine)) {
        this.object.pp_setPositionLocal(vec3_create(localPosition[0], 0, localPosition[2]));
      } else {
        this.object.pp_setPositionLocal(vec3_create(localPosition[0], this._myEyesHeight, localPosition[2]));
      }
      this._myHeightSetOnce = true;
    }
  }
  _onXRSessionEnd() {
    if (this.active && !this._mySetOnlyOnStart) {
      let localPosition = this.object.pp_getPositionLocal();
      this.object.pp_setPositionLocal(vec3_create(localPosition[0], this._myEyesHeight, localPosition[2]));
    }
  }
};

// dist/pp/input/pose/components/set_hand_local_transform_component.js
import { Component as Component55, Property as Property38 } from "@wonderlandengine/api";
var SetHandLocalTransformComponent = class extends Component55 {
  static TypeName = "pp-set-hand-local-transform";
  static Properties = {
    _myHandedness: Property38.enum(["Left", "Right"], "Left")
  };
  start() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myActivateOnNextUpdate = false;
  }
  update(dt) {
    if (this._myActivateOnNextUpdate) {
      this._onActivate();
      this._myActivateOnNextUpdate = false;
    }
  }
  _onPoseUpdated(dt, pose) {
  }
  onActivate() {
    this._myActivateOnNextUpdate = true;
  }
  _onActivate() {
    Globals.getHandPose(this._myHandednessType, this.engine).registerPoseUpdatedEventListener(this, this._onPoseUpdated.bind(this));
  }
  onDeactivate() {
    Globals.getHandPose(this._myHandednessType, this.engine)?.unregisterPoseUpdatedEventListener(this);
  }
};
SetHandLocalTransformComponent.prototype._onPoseUpdated = function() {
  let handPoseTransform = quat2_create();
  return function _onPoseUpdated(dt, pose) {
    if (!this.active || this._myActivateOnNextUpdate) {
      this.onDeactivate();
      return;
    }
    if (XRUtils.isSessionActive(this.engine)) {
      if (pose.isValid()) {
        this.object.pp_setTransformLocalQuat(pose.getTransformQuat(handPoseTransform, null));
      }
    }
  };
}();

// dist/pp/input/pose/components/set_hand_ray_local_transform_component.js
import { Component as Component56, Property as Property39 } from "@wonderlandengine/api";
var SetHandRayLocalTransformComponent = class extends Component56 {
  static TypeName = "pp-set-hand-ray-local-transform";
  static Properties = {
    _myHandedness: Property39.enum(["Left", "Right"], "Left")
  };
  start() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myActivateOnNextUpdate = false;
  }
  update(dt) {
    if (this._myActivateOnNextUpdate) {
      this._onActivate();
      this._myActivateOnNextUpdate = false;
    }
  }
  _onPoseUpdated(dt, pose) {
  }
  onActivate() {
    this._myActivateOnNextUpdate = true;
  }
  _onActivate() {
    Globals.getHandRayPose(this._myHandednessType, this.engine).registerPoseUpdatedEventListener(this, this._onPoseUpdated.bind(this));
  }
  onDeactivate() {
    Globals.getHandRayPose(this._myHandednessType, this.engine)?.unregisterPoseUpdatedEventListener(this);
  }
};
SetHandRayLocalTransformComponent.prototype._onPoseUpdated = function() {
  let handPoseTransform = quat2_create();
  return function _onPoseUpdated(dt, pose) {
    if (!this.active || this._myActivateOnNextUpdate) {
      this.onDeactivate();
      return;
    }
    if (XRUtils.isSessionActive(this.engine)) {
      if (pose.isValid()) {
        this.object.pp_setTransformLocalQuat(pose.getTransformQuat(handPoseTransform, null));
      }
    }
  };
}();

// dist/pp/input/pose/components/set_head_local_transform_component.js
import { Component as Component57 } from "@wonderlandengine/api";
var SetHeadLocalTransformComponent = class _SetHeadLocalTransformComponent extends Component57 {
  static TypeName = "pp-set-head-local-transform";
  _myActivateOnNextUpdate = false;
  update(dt) {
    if (this._myActivateOnNextUpdate) {
      this._onActivate();
      this._myActivateOnNextUpdate = false;
    }
  }
  static _onPoseUpdatedSV = {
    cameraNonXRRotation: quat_create(),
    cameraNonXRUp: vec3_create(),
    cameraNonXRPosition: vec3_create(),
    headPoseTransform: quat2_create()
  };
  _onPoseUpdated(dt, pose) {
    if (!this.active || this._myActivateOnNextUpdate) {
      this.onDeactivate();
      return;
    }
    if (!XRUtils.isSessionActive(this.engine)) {
      const cameraNonXR = Globals.getPlayerObjects(this.engine).myCameraNonXR;
      const cameraNonXRRotation = _SetHeadLocalTransformComponent._onPoseUpdatedSV.cameraNonXRRotation;
      cameraNonXR.pp_getRotationLocalQuat(cameraNonXRRotation);
      if (Globals.isPoseForwardFixed(this.engine)) {
        const cameraNonXRUp = _SetHeadLocalTransformComponent._onPoseUpdatedSV.cameraNonXRUp;
        cameraNonXRRotation.quat_rotateAxisRadians(Math.PI, cameraNonXRRotation.quat_getUp(cameraNonXRUp), cameraNonXRRotation);
      }
      const cameraNonXRPosition = _SetHeadLocalTransformComponent._onPoseUpdatedSV.cameraNonXRPosition;
      this.object.pp_setPositionLocal(cameraNonXR.pp_getPositionLocal(cameraNonXRPosition));
      this.object.pp_setRotationLocalQuat(cameraNonXRRotation);
    } else {
      if (pose.isValid()) {
        const headPoseTransform = _SetHeadLocalTransformComponent._onPoseUpdatedSV.headPoseTransform;
        this.object.pp_setTransformLocalQuat(pose.getTransformQuat(headPoseTransform, null));
      }
    }
  }
  onActivate() {
    this._myActivateOnNextUpdate = true;
  }
  _onActivate() {
    Globals.getHeadPose(this.engine).registerPoseUpdatedEventListener(this, this._onPoseUpdated.bind(this));
  }
  onDeactivate() {
    Globals.getHeadPose(this.engine)?.unregisterPoseUpdatedEventListener(this);
  }
};

// dist/pp/input/pose/components/set_tracked_hand_joint_local_transform_component.js
import { Component as Component58, Property as Property40 } from "@wonderlandengine/api";
var SetTrackedHandJointLocalTransformComponent = class extends Component58 {
  static TypeName = "pp-set-tracked-hand-joint-local-transform";
  static Properties = {
    _myHandedness: Property40.enum(["Left", "Right"], "Left"),
    _mySetLocalScaleAsJointRadius: Property40.bool(false),
    _myJointID: Property40.enum([
      "Wrist",
      "Thumb Metacarpal",
      "Thumb Phalanx Proximal",
      "Thumb Phalanx Distal",
      "Thumb Tip",
      "Index Metacarpal",
      "Index Phalanx Proximal",
      "Index Phalanx Intermediate",
      "Index Phalanx Distal",
      "Index Tip",
      "Middle Metacarpal",
      "Middle Phalanx Proximal",
      "Middle Phalanx Intermediate",
      "Middle Phalanx Distal",
      "Middle Tip",
      "Ring Metacarpal",
      "Ring Phalanx Proximal",
      "Ring Phalanx Intermediate",
      "Ring Phalanx Distal",
      "Ring Tip",
      "Pinky Metacarpal",
      "Pinky Phalanx Proximal",
      "Pinky Phalanx Intermediate",
      "Pinky Phalanx Distal",
      "Pinky Tip"
    ], "Wrist")
  };
  start() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myJointIDType = InputUtils.getJointIDByIndex(this._myJointID);
    this._myActivateOnNextUpdate = false;
  }
  update(dt) {
    if (this._myActivateOnNextUpdate) {
      this._onActivate();
      this._myActivateOnNextUpdate = false;
    }
  }
  _onPoseUpdated(dt, pose) {
  }
  onActivate() {
    this._myActivateOnNextUpdate = true;
  }
  _onActivate() {
    Globals.getTrackedHandPose(this._myHandednessType, this.engine).getJointPose(this._myJointIDType).registerPoseUpdatedEventListener(this, this._onPoseUpdated.bind(this));
  }
  onDeactivate() {
    Globals.getTrackedHandPose(this._myHandednessType, this.engine)?.getJointPose(this._myJointIDType)?.unregisterPoseUpdatedEventListener(this);
  }
};
SetTrackedHandJointLocalTransformComponent.prototype._onPoseUpdated = function() {
  let jointPoseTransform = quat2_create();
  return function _onPoseUpdated(dt, pose) {
    if (!this.active || this._myActivateOnNextUpdate) {
      this.onDeactivate();
      return;
    }
    if (XRUtils.isSessionActive(this.engine)) {
      if (pose.isValid()) {
        this.object.pp_setTransformLocalQuat(pose.getTransformQuat(jointPoseTransform, null));
        if (this._mySetLocalScaleAsJointRadius) {
          this.object.pp_setScaleLocal(pose.getJointRadius());
        }
      }
    }
  };
}();

// dist/pp/input/pose/components/copy_hand_transform_component.js
import { Component as Component59, Property as Property41 } from "@wonderlandengine/api";
var CopyHandTransformComponent = class extends Component59 {
  static TypeName = "pp-copy-hand-transform";
  static Properties = {
    _myHandedness: Property41.enum(["Left", "Right"], "Left")
  };
  init() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
  }
  update(dt) {
    let hand = Globals.getPlayerObjects(this.engine).myHands[this._myHandednessType];
    this.object.pp_setTransformQuat(hand.pp_getTransformQuat());
    this.object.pp_setScale(hand.pp_getScale());
  }
};

// dist/pp/input/pose/components/copy_head_transform_component.js
import { Component as Component60 } from "@wonderlandengine/api";
var CopyHeadTransformComponent = class extends Component60 {
  static TypeName = "pp-copy-head-transform";
  update(dt) {
    let head = Globals.getPlayerObjects(this.engine).myHead;
    this.object.pp_setTransformQuat(head.pp_getTransformQuat());
    this.object.pp_setScale(head.pp_getScale());
  }
};

// dist/pp/input/pose/components/copy_player_transform_component.js
import { Component as Component61 } from "@wonderlandengine/api";
var CopyPlayerTransformComponent = class extends Component61 {
  static TypeName = "pp-copy-player-transform";
  update(dt) {
    let player = Globals.getPlayerObjects(this.engine).myPlayer;
    this.object.pp_setTransformQuat(player.pp_getTransformQuat());
    this.object.pp_setScale(player.pp_getScale());
  }
};

// dist/pp/input/pose/components/copy_reference_space_transform_component.js
import { Component as Component62 } from "@wonderlandengine/api";
var CopyReferenceSpaceTransformComponent = class extends Component62 {
  static TypeName = "pp-copy-reference-space-transform";
  update(dt) {
    let referenceSpace = Globals.getPlayerObjects(this.engine).myReferenceSpace;
    this.object.pp_setTransformQuat(referenceSpace.pp_getTransformQuat());
    this.object.pp_setScale(referenceSpace.pp_getScale());
  }
};

// dist/pp/tool/cauldron/tool_types.js
var ToolHandedness = {
  NONE: null,
  LEFT: "left",
  RIGHT: "right"
};
var ToolInputSourceType = {
  NONE: null,
  GAMEPAD: 0,
  TRACKED_HAND: 1
};

// dist/pp/tool/cauldron/components/tool_cursor_component.js
import { Component as Component63, MeshComponent as MeshComponent14, Property as Property42, ViewComponent as ViewComponent5 } from "@wonderlandengine/api";
import { Cursor as Cursor5, CursorTarget as CursorTarget8 } from "@wonderlandengine/components";
var ToolCursorComponent = class extends Component63 {
  static TypeName = "pp-tool-cursor";
  static Properties = {
    _myHandedness: Property42.enum(["Left", "Right"], "Left"),
    _myApplyDefaultCursorOffset: Property42.bool(true),
    _myPulseOnHover: Property42.bool(false),
    _myShowFingerCursor: Property42.bool(false),
    _myUpdatePointerCursorStyle: Property42.bool(true)
  };
  init() {
    this._myHandednessType = InputUtils.getHandednessByIndex(this._myHandedness);
    this._myCursorPositionDefaultOffset = vec3_create(0, -0.035, 0.05);
    this._myCursorRotationDefaultOffset = vec3_create(30, 0, 0);
    this._myCursorMeshScale = vec3_create(25e-4, 25e-4, 25e-4);
    this._myCursorColor = vec4_create(255 / 255, 255 / 255, 255 / 255, 1);
    this._myCursorTargetCollisionGroup = 7;
    this._myStarted = false;
  }
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      this._myToolCursorObject = this.object.pp_addChild();
      this._myCursorObjectXR = this._myToolCursorObject.pp_addChild();
      if (this._myApplyDefaultCursorOffset) {
        this._myCursorObjectXR.pp_setPositionLocal(this._myCursorPositionDefaultOffset);
        this._myCursorObjectXR.pp_rotateObject(this._myCursorRotationDefaultOffset);
      }
      {
        this._myCursorMeshobject = this._myCursorObjectXR.pp_addChild();
        this._myCursorMeshobject.pp_setScale(this._myCursorMeshScale);
        let cursorMeshComponent = this._myCursorMeshobject.pp_addComponent(MeshComponent14);
        cursorMeshComponent.mesh = Globals.getDefaultMeshes(this.engine).mySphere;
        cursorMeshComponent.material = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
        cursorMeshComponent.material.color = this._myCursorColor;
        this._myCursorComponentXR = this._myCursorObjectXR.pp_addComponent(Cursor5, {
          "collisionGroup": this._myCursorTargetCollisionGroup,
          "handedness": this._myHandedness + 1,
          "cursorObject": this._myCursorMeshobject,
          "styleCursor": false
        });
        this._myCursorComponentXR.rayCastMode = 0;
      }
      this._myCursorObjectNonXR = this._myToolCursorObject.pp_addChild();
      {
        this._myCursorComponentNonXR = this._myCursorObjectNonXR.pp_addComponent(Cursor5, {
          "collisionGroup": this._myCursorTargetCollisionGroup,
          "handedness": this._myHandedness + 1,
          "styleCursor": this._myUpdatePointerCursorStyle
        });
        this._myCursorComponentNonXR.rayCastMode = 0;
        this._myCursorComponentNonXR.pp_setViewComponent(Globals.getPlayerObjects(this.engine).myCameraNonXR.pp_getComponent(ViewComponent5));
      }
      let fingerCursorMeshObject = null;
      let fingerCollisionSize = 0.0125;
      if (this._myShowFingerCursor) {
        fingerCursorMeshObject = this._myToolCursorObject.pp_addChild();
        let meshComponent = fingerCursorMeshObject.pp_addComponent(MeshComponent14);
        meshComponent.mesh = Globals.getDefaultMeshes(this.engine).mySphere;
        meshComponent.material = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
        meshComponent.material.color = this._myCursorColor;
        fingerCursorMeshObject.pp_setScale(fingerCollisionSize);
      }
      let collisionFlags = "";
      for (let i = 0; i < PhysicsUtils.getLayerFlagsNames().length; i++) {
        if (i == this._myCursorTargetCollisionGroup) {
          collisionFlags += "1";
        } else {
          collisionFlags += "0";
        }
        if (i != PhysicsUtils.getLayerFlagsNames().length - 1) {
          collisionFlags += ", ";
        }
      }
      this._myFingerCursorObject = this._myToolCursorObject.pp_addChild();
      this._myFingerCursorComponent = this._myFingerCursorObject.pp_addComponent(FingerCursorComponent, {
        "_myHandedness": this._myHandedness,
        "_myDisableDefaultCursorOnTrackedHandDetected": false,
        "_myMultipleClicksEnabled": true,
        "_myCollisionMode": 1,
        "_myCollisionFlags": collisionFlags,
        "_myCollisionSize": fingerCollisionSize,
        "_myCursorPointerObject": fingerCursorMeshObject
      });
      this._myCursorComponentXR.active = false;
      this._myCursorComponentNonXR.active = false;
      this._myFingerCursorComponent.active = false;
      this._myStarted = true;
    }
  }
  update(dt) {
  }
  _isUsingHand() {
    let usingHand = false;
    if (XRUtils.getSession(this.engine) && XRUtils.getSession(this.engine).inputSources != null) {
      for (let i = 0; i < XRUtils.getSession(this.engine).inputSources.length; i++) {
        let input = XRUtils.getSession(this.engine).inputSources[i];
        if (input.hand && input.handedness == this._myHandednessType) {
          usingHand = true;
          break;
        }
      }
    }
    return usingHand;
  }
  _pulseOnHover(object) {
    let targetComponent = object.pp_getComponent(CursorTarget8);
    if (targetComponent && !targetComponent.isSurface) {
      if (this._myHandedness == 0) {
        if (Globals.getLeftGamepad(this.engine) != null) {
          Globals.getLeftGamepad(this.engine).pulse(0.4, 0);
        }
      } else {
        if (Globals.getRightGamepad(this.engine) != null) {
          Globals.getRightGamepad(this.engine).pulse(0.4, 0);
        }
      }
    }
  }
  onActivate() {
    if (this._myStarted && this._myPulseOnHover) {
      this._myCursorComponentXR.globalTarget.onHover.add(this._pulseOnHover.bind(this), { id: this });
      this._myCursorComponentNonXR.globalTarget.onHover.add(this._pulseOnHover.bind(this), { id: this });
    }
  }
  onDeactivate() {
    if (this._myStarted) {
      this._myCursorComponentXR.globalTarget.onHover.remove(this);
      this._myCursorComponentNonXR.globalTarget.onHover.remove(this);
    }
  }
};
ToolCursorComponent.prototype.update = function() {
  let transformQuat2 = quat2_create();
  return function update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myStarted) {
        let usingHand = this._isUsingHand();
        this._myFingerCursorComponent.active = usingHand;
        if (usingHand) {
          this._myCursorComponentXR.active = false;
          this._myCursorComponentNonXR.active = false;
        } else {
          if (XRUtils.isSessionActive(this.engine)) {
            this._myCursorComponentXR.active = !usingHand;
            this._myCursorComponentNonXR.active = false;
          } else {
            this._myCursorComponentNonXR.active = !usingHand;
            this._myCursorComponentXR.active = false;
            this._myCursorObjectNonXR.pp_setTransformQuat(Globals.getPlayerObjects(this.engine).myCameraNonXR.pp_getTransformQuat(transformQuat2));
          }
        }
      }
    }
  };
}();

// dist/pp/tool/console_vr/console_vr_widget_config.js
import { Alignment as Alignment6, Collider as Collider2, VerticalAlignment as VerticalAlignment6 } from "@wonderlandengine/api";

// dist/pp/tool/console_vr/console_vr_types.js
var ConsoleVRWidgetConsoleFunction = {
  DEBUG: 0,
  WARN: 1,
  ERROR: 2,
  LOG: 3,
  INFO: 4,
  ASSERT: 5
};
var ConsoleVRWidgetSender = {
  BROWSER_CONSOLE: 0,
  CONSOLE_VR: 1,
  WINDOW: 2
};
var ConsoleVRWidgetPulseOnNewMessage = {
  NEVER: 0,
  ALWAYS: 1,
  WHEN_HIDDEN: 2
};
var ConsoleVRWidgetMessageType = {
  DEBUG: 0,
  WARN: 1,
  ERROR: 2,
  LOG: 3
};
var OverrideBrowserConsoleFunctions = {
  NONE: 0,
  ALL: 1,
  ERRORS_AND_WARNS: 2
};

// dist/pp/tool/console_vr/console_vr_widget_config.js
var ConsoleVRWidgetConfig = class {
  constructor() {
    this._setupBuildConfig();
    this._setupRuntimeConfig();
  }
  _setupBuildConfig() {
    this.myBackgroundColor = vec4_create(46 / 255, 46 / 255, 46 / 255, 1);
    this.myCursorTargetCollisionCollider = Collider2.Box;
    this.myCursorTargetCollisionGroup = 7;
    this.myCursorTargetCollisionThickness = 1e-3;
    this.myDefaultTextColor = vec4_create(255 / 255, 255 / 255, 255 / 255, 1);
    this.myTextAlignment = Alignment6.Center;
    this.myTextVerticalAlignment = VerticalAlignment6.Middle;
    this.myTextColor = this.myDefaultTextColor;
    this.myMessageTypeColors = [];
    this.myMessageTypeColors[ConsoleVRWidgetMessageType.LOG] = this.myDefaultTextColor;
    this.myMessageTypeColors[ConsoleVRWidgetMessageType.ERROR] = vec4_create(255 / 255, 40 / 255, 40 / 255, 1);
    this.myMessageTypeColors[ConsoleVRWidgetMessageType.WARN] = vec4_create(250 / 255, 220 / 255, 40 / 255, 1);
    this.myMessageTypeColors[ConsoleVRWidgetMessageType.DEBUG] = vec4_create(60 / 255, 200 / 255, 255 / 255, 1);
    this.myMessagesPanelPosition = vec3_create(0, 0.075, 0);
    this.myMessagesBackgroundScale = vec3_create(0.34, 0.15, 1);
    {
      let xPaddingPercentage = 0.03;
      let yPaddingPercentage = xPaddingPercentage * this.myMessagesBackgroundScale[0] / this.myMessagesBackgroundScale[1] * 0.8;
      let xPosition = -this.myMessagesBackgroundScale[0] + this.myMessagesBackgroundScale[0] * xPaddingPercentage;
      let yPosition = this.myMessagesBackgroundScale[1] - this.myMessagesBackgroundScale[1] * yPaddingPercentage;
      this.myMessagesTextsPanelPosition = vec3_create(xPosition, yPosition, 7e-3);
    }
    this.myMessagesTextsPanelScale = vec3_create(0.1, 0.1, 0.1);
    this.myMessagesTextStartString = ".\n";
    this.myMessagesTextAlignment = Alignment6.Left;
    this.myMessagesTextVerticalAlignment = VerticalAlignment6.Top;
    this.myMessagesTextPositions = [];
    this.myMessagesTextPositions[ConsoleVRWidgetMessageType.LOG] = vec3_create(0, 0, 2e-4);
    this.myMessagesTextPositions[ConsoleVRWidgetMessageType.ERROR] = vec3_create(0, 0, 0);
    this.myMessagesTextPositions[ConsoleVRWidgetMessageType.WARN] = vec3_create(0, 0, 0);
    this.myMessagesTextPositions[ConsoleVRWidgetMessageType.DEBUG] = vec3_create(0, 0, 0);
    this.myMessagesTextColors = [];
    this.myMessagesTextColors[ConsoleVRWidgetMessageType.LOG] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.LOG];
    this.myMessagesTextColors[ConsoleVRWidgetMessageType.ERROR] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.ERROR];
    this.myMessagesTextColors[ConsoleVRWidgetMessageType.WARN] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.WARN];
    this.myMessagesTextColors[ConsoleVRWidgetMessageType.DEBUG] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.DEBUG];
    this.myButtonsPanelPosition = vec3_create(0, -0.11, 0.015);
    this.myButtonBackgroundScale = vec3_create(0.04, 0.02, 1);
    this.myButtonTextPosition = vec3_create(0, 0, 7e-3);
    this.myButtonTextScale = vec3_create(0.18, 0.18, 0.18);
    this.myButtonCursorTargetPosition = vec3_create(0, 0, 0);
    this.myButtonCursorTargetPosition[2] = this.myButtonTextPosition[2];
    this.myButtonsCollisionCollider = this.myCursorTargetCollisionCollider;
    this.myButtonsCollisionGroup = this.myCursorTargetCollisionGroup;
    this.myButtonsCollisionExtents = this.myButtonBackgroundScale.pp_clone();
    this.myButtonsCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myClearButtonTextLabel = "clear";
    this.myUpButtonTextLabel = "up";
    this.myDownButtonTextLabel = "down";
    this.myFilterButtonsTextColors = [];
    this.myFilterButtonsTextColors[ConsoleVRWidgetMessageType.LOG] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.LOG];
    this.myFilterButtonsTextColors[ConsoleVRWidgetMessageType.ERROR] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.ERROR];
    this.myFilterButtonsTextColors[ConsoleVRWidgetMessageType.WARN] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.WARN];
    this.myFilterButtonsTextColors[ConsoleVRWidgetMessageType.DEBUG] = this.myMessageTypeColors[ConsoleVRWidgetMessageType.DEBUG];
    this.myFilterButtonsTextLabel = [];
    this.myFilterButtonsTextLabel[ConsoleVRWidgetMessageType.LOG] = "log";
    this.myFilterButtonsTextLabel[ConsoleVRWidgetMessageType.ERROR] = "error";
    this.myFilterButtonsTextLabel[ConsoleVRWidgetMessageType.WARN] = "warn";
    this.myFilterButtonsTextLabel[ConsoleVRWidgetMessageType.DEBUG] = "debug";
    {
      let numberOfButtons = 7;
      let buttonsHorizontalSpace = Math.max(0.68, this.myButtonBackgroundScale[0] * numberOfButtons);
      let numberOfSpacesBetweenButtons = 2 + 3 + 4 + 4 + 1 + 2;
      let spaceWidth = Math.max((buttonsHorizontalSpace - numberOfButtons * this.myButtonBackgroundScale[0] * 2) / numberOfSpacesBetweenButtons, 0);
      let halfButtonWidth = this.myButtonBackgroundScale[0];
      let initialPosition = -buttonsHorizontalSpace / 2;
      this.myFilterButtonsPositions = [];
      this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.LOG] = [initialPosition + spaceWidth * 2 + halfButtonWidth, 0, 0];
      this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.ERROR] = [this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.LOG][0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
      this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.WARN] = [this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.ERROR][0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
      this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.DEBUG] = [this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.WARN][0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
      this.myClearButtonPosition = [this.myFilterButtonsPositions[ConsoleVRWidgetMessageType.DEBUG][0] + halfButtonWidth + spaceWidth * 4 + halfButtonWidth, 0, 0];
      this.myUpButtonPosition = [this.myClearButtonPosition[0] + halfButtonWidth + spaceWidth * 4 + halfButtonWidth, 0, 0];
      this.myDownButtonPosition = [this.myUpButtonPosition[0] + halfButtonWidth + spaceWidth + halfButtonWidth, 0, 0];
    }
    this.myNotifyIconBackgroundScale = vec3_create(0.01, 0.01, 1);
    this.myNotifyIconPanelPositions = [];
    this.myNotifyIconPanelPositions[ToolHandedness.NONE] = vec3_create(0, 0, 0);
    this.myNotifyIconPanelPositions[ToolHandedness.NONE][0] = -this.myMessagesBackgroundScale[0] + this.myNotifyIconBackgroundScale[0] + 0.01;
    this.myNotifyIconPanelPositions[ToolHandedness.NONE][1] = -this.myMessagesBackgroundScale[1] + this.myNotifyIconBackgroundScale[1] + 0.01;
    this.myNotifyIconPanelPositions[ToolHandedness.NONE][2] = this.myMessagesTextsPanelPosition[2] - 1e-5;
    this.myNotifyIconPanelPositions[ToolHandedness.LEFT] = this.myNotifyIconPanelPositions[ToolHandedness.NONE];
    this.myNotifyIconPanelPositions[ToolHandedness.RIGHT] = this.myNotifyIconPanelPositions[ToolHandedness.NONE];
    this.myNotifyIconCursorTargetPosition = vec3_create(0, 0, 0);
    this.myNotifyIconCursorTargetPosition[2] = this.myButtonsPanelPosition[2] + this.myButtonTextPosition[2] - this.myMessagesTextsPanelPosition[2];
    this.myNotifyIconCollisionExtents = this.myNotifyIconBackgroundScale.pp_clone();
    this.myNotifyIconCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myNotifyIconColor = vec4_create(210 / 255, 210 / 255, 210 / 255, 1);
    this.myPointerCollisionCollider = this.myCursorTargetCollisionCollider;
    this.myPointerCollisionGroup = this.myCursorTargetCollisionGroup;
    {
      let spaceBetweenMessagesAndButtons = Math.abs(this.myMessagesPanelPosition[1] - this.myMessagesBackgroundScale[1] - (this.myButtonsPanelPosition[1] + this.myButtonBackgroundScale[1]));
      let pointerCollisionHalfHeight = this.myMessagesBackgroundScale[1] + this.myButtonBackgroundScale[1] + spaceBetweenMessagesAndButtons / 2;
      this.myPointerCollisionExtents = vec3_create(this.myMessagesBackgroundScale[0], pointerCollisionHalfHeight, this.myCursorTargetCollisionThickness);
    }
    this.myPointerCursorTargetPosition = vec3_create(0, 0, 0);
    this.myPointerCursorTargetPosition[1] = this.myMessagesPanelPosition[1] + this.myMessagesBackgroundScale[1] - this.myPointerCollisionExtents[1];
    this.myPointerCursorTargetPosition[2] = this.myButtonsPanelPosition[2] + this.myButtonTextPosition[2] - 2e-4;
  }
  _setupRuntimeConfig() {
    this.myTabString = "     ";
    this.myAssertStartString = "Assertion failed:";
    this.myMaxCharactersPerLine = 100;
    this.myMaxLineSplits = 500;
    this.myMaxLines = 22;
    this.myMaxMessages = 2e3;
    this.myMaxMessagesDeletePad = 2e3;
    this.myLinesBetweenMessages = 1;
    this.myButtonHoverColor = vec4_create(150 / 255, 150 / 255, 150 / 255, 1);
    this.myButtonDisabledTextColor = this.myBackgroundColor;
    this.myButtonDisabledBackgroundColor = vec4_create(110 / 255, 110 / 255, 110 / 255, 1);
    this.myFilterButtonDisabledTextColor = this.myButtonDisabledTextColor;
    this.myFilterButtonDisabledBackgroundColor = this.myButtonDisabledBackgroundColor;
    this.myScrollDelay = 0.1;
    this.myScrollAmount = 1;
    this.myScrollThumbstickHandedness = ToolHandedness.RIGHT;
    this.myScrollThumbstickDelay = 0.1;
    this.myScrollThumbstickMinThreshold = 0.2;
    this.myScrollThumbstickAmount = 3;
    this.myPulseDelay = 5;
    this.myPulseIntensity = 0.3;
    this.myPulseDuration = 0.085;
    this.myClearBrowserConsoleWhenClearPressed = false;
    this.myGamepadScrollOnlyOnHover = true;
  }
};

// dist/pp/tool/console_vr/console_vr_widget_ui.js
import { CollisionComponent as CollisionComponent5, MeshComponent as MeshComponent15, TextComponent as TextComponent11 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget9 } from "@wonderlandengine/components";
var ConsoleVRWidgetUI = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myActive = false;
    this._myDestroyed = false;
  }
  build(parentObject, config, params) {
    this._myParentObject = parentObject;
    this._myConfig = config;
    this._myParams = params;
    this._myPlaneMesh = Globals.getDefaultMeshes(this._myEngine).myDoubleSidedPlane;
    this._createSkeleton();
    this._setTransforms();
    this._addComponents();
    this._setTransformForNonXR();
    this.setActive(true);
  }
  setVisible(visible) {
    this.myPivotObject.pp_setActive(visible);
  }
  // Skeleton
  _createSkeleton() {
    this.myPivotObject = this._myParentObject.pp_addChild();
    this._createMessagesSkeleton();
    this._createButtonsSkeleton();
    this._createPointerSkeleton();
  }
  _createMessagesSkeleton() {
    this.myMessagesPanel = this.myPivotObject.pp_addChild();
    this.myMessagesBackground = this.myMessagesPanel.pp_addChild();
    this.myMessagesTextsPanel = this.myMessagesPanel.pp_addChild();
    this.myMessagesTexts = [];
    for (let key in ConsoleVRWidgetMessageType) {
      this.myMessagesTexts[ConsoleVRWidgetMessageType[key]] = this.myMessagesTextsPanel.pp_addChild();
    }
    this.myNotifyIconPanel = this.myMessagesPanel.pp_addChild();
    this.myNotifyIconBackground = this.myNotifyIconPanel.pp_addChild();
    this.myNotifyIconCursorTarget = this.myNotifyIconPanel.pp_addChild();
  }
  _createButtonsSkeleton() {
    this.myButtonsPanel = this.myPivotObject.pp_addChild();
    this.myFilterButtonsPanels = [];
    this.myFilterButtonsBackgrounds = [];
    this.myFilterButtonsTexts = [];
    this.myFilterButtonsCursorTargets = [];
    for (let key in ConsoleVRWidgetMessageType) {
      this.myFilterButtonsPanels[ConsoleVRWidgetMessageType[key]] = this.myButtonsPanel.pp_addChild();
      this.myFilterButtonsBackgrounds[ConsoleVRWidgetMessageType[key]] = this.myFilterButtonsPanels[ConsoleVRWidgetMessageType[key]].pp_addChild();
      this.myFilterButtonsTexts[ConsoleVRWidgetMessageType[key]] = this.myFilterButtonsPanels[ConsoleVRWidgetMessageType[key]].pp_addChild();
      this.myFilterButtonsCursorTargets[ConsoleVRWidgetMessageType[key]] = this.myFilterButtonsPanels[ConsoleVRWidgetMessageType[key]].pp_addChild();
    }
    this.myClearButtonPanel = this.myButtonsPanel.pp_addChild();
    this.myClearButtonBackground = this.myClearButtonPanel.pp_addChild();
    this.myClearButtonText = this.myClearButtonPanel.pp_addChild();
    this.myClearButtonCursorTarget = this.myClearButtonPanel.pp_addChild();
    this.myUpButtonPanel = this.myButtonsPanel.pp_addChild();
    this.myUpButtonBackground = this.myUpButtonPanel.pp_addChild();
    this.myUpButtonText = this.myUpButtonPanel.pp_addChild();
    this.myUpButtonCursorTarget = this.myUpButtonPanel.pp_addChild();
    this.myDownButtonPanel = this.myButtonsPanel.pp_addChild();
    this.myDownButtonBackground = this.myDownButtonPanel.pp_addChild();
    this.myDownButtonText = this.myDownButtonPanel.pp_addChild();
    this.myDownButtonCursorTarget = this.myDownButtonPanel.pp_addChild();
  }
  _createPointerSkeleton() {
    this.myPointerCursorTarget = this.myPivotObject.pp_addChild();
  }
  // Transforms
  _setTransforms() {
    this.myPivotObject.pp_markDirty();
    this._setMessagesTransforms();
    this._setButtonsTransforms();
    this._setPointerTransform();
  }
  _setMessagesTransforms() {
    this.myMessagesPanel.pp_setPositionLocal(this._myConfig.myMessagesPanelPosition);
    this.myMessagesBackground.pp_scaleObject(this._myConfig.myMessagesBackgroundScale);
    this.myMessagesTextsPanel.pp_setPositionLocal(this._myConfig.myMessagesTextsPanelPosition);
    this.myMessagesTextsPanel.pp_scaleObject(this._myConfig.myMessagesTextsPanelScale);
    for (let key in ConsoleVRWidgetMessageType) {
      this.myMessagesTexts[ConsoleVRWidgetMessageType[key]].pp_setPositionLocal(this._myConfig.myMessagesTextPositions[ConsoleVRWidgetMessageType[key]]);
    }
    this.myNotifyIconPanel.pp_setPositionLocal(this._myConfig.myNotifyIconPanelPositions[this._myParams.myHandedness]);
    this.myNotifyIconBackground.pp_scaleObject(this._myConfig.myNotifyIconBackgroundScale);
    this.myNotifyIconCursorTarget.pp_setPositionLocal(this._myConfig.myNotifyIconCursorTargetPosition);
  }
  _setButtonsTransforms() {
    this.myButtonsPanel.pp_setPositionLocal(this._myConfig.myButtonsPanelPosition);
    for (let key in ConsoleVRWidgetMessageType) {
      this.myFilterButtonsPanels[ConsoleVRWidgetMessageType[key]].pp_setPositionLocal(this._myConfig.myFilterButtonsPositions[ConsoleVRWidgetMessageType[key]]);
      this.myFilterButtonsBackgrounds[ConsoleVRWidgetMessageType[key]].pp_scaleObject(this._myConfig.myButtonBackgroundScale);
      this.myFilterButtonsTexts[ConsoleVRWidgetMessageType[key]].pp_setPositionLocal(this._myConfig.myButtonTextPosition);
      this.myFilterButtonsTexts[ConsoleVRWidgetMessageType[key]].pp_scaleObject(this._myConfig.myButtonTextScale);
      this.myFilterButtonsCursorTargets[ConsoleVRWidgetMessageType[key]].pp_setPositionLocal(this._myConfig.myButtonCursorTargetPosition);
    }
    {
      this.myClearButtonPanel.pp_setPositionLocal(this._myConfig.myClearButtonPosition);
      this.myClearButtonBackground.pp_scaleObject(this._myConfig.myButtonBackgroundScale);
      this.myClearButtonText.pp_setPositionLocal(this._myConfig.myButtonTextPosition);
      this.myClearButtonText.pp_scaleObject(this._myConfig.myButtonTextScale);
      this.myClearButtonCursorTarget.pp_setPositionLocal(this._myConfig.myButtonCursorTargetPosition);
    }
    {
      this.myUpButtonPanel.pp_setPositionLocal(this._myConfig.myUpButtonPosition);
      this.myUpButtonBackground.pp_scaleObject(this._myConfig.myButtonBackgroundScale);
      this.myUpButtonText.pp_setPositionLocal(this._myConfig.myButtonTextPosition);
      this.myUpButtonText.pp_scaleObject(this._myConfig.myButtonTextScale);
      this.myUpButtonCursorTarget.pp_setPositionLocal(this._myConfig.myButtonCursorTargetPosition);
    }
    {
      this.myDownButtonPanel.pp_setPositionLocal(this._myConfig.myDownButtonPosition);
      this.myDownButtonBackground.pp_scaleObject(this._myConfig.myButtonBackgroundScale);
      this.myDownButtonText.pp_setPositionLocal(this._myConfig.myButtonTextPosition);
      this.myDownButtonText.pp_scaleObject(this._myConfig.myButtonTextScale);
      this.myDownButtonCursorTarget.pp_setPositionLocal(this._myConfig.myButtonCursorTargetPosition);
    }
  }
  _setPointerTransform() {
    this.myPointerCursorTarget.pp_setPositionLocal(this._myConfig.myPointerCursorTargetPosition);
  }
  // Components
  _addComponents() {
    this._addMessagesComponents();
    this._addButtonsComponents();
    this._addPointerComponents();
  }
  _addMessagesComponents() {
    let messagesBackgroundMeshComp = this.myMessagesBackground.pp_addComponent(MeshComponent15);
    messagesBackgroundMeshComp.mesh = this._myPlaneMesh;
    messagesBackgroundMeshComp.material = this._myParams.myPlaneMaterial.clone();
    messagesBackgroundMeshComp.material.color = this._myConfig.myBackgroundColor;
    this.myMessagesTextComponents = [];
    for (let key in ConsoleVRWidgetMessageType) {
      let textComp = this.myMessagesTexts[ConsoleVRWidgetMessageType[key]].pp_addComponent(TextComponent11);
      textComp.alignment = this._myConfig.myMessagesTextAlignment;
      textComp.verticalAlignment = this._myConfig.myMessagesTextVerticalAlignment;
      textComp.material = this._myParams.myTextMaterial.clone();
      textComp.material.color = this._myConfig.myMessagesTextColors[ConsoleVRWidgetMessageType[key]];
      textComp.lineSpacing = 1.2;
      textComp.text = this._myConfig.myMessagesTextStartString;
      this.myMessagesTextComponents[ConsoleVRWidgetMessageType[key]] = textComp;
    }
    this.myNotifyIconBackgroundComponent = this.myNotifyIconBackground.pp_addComponent(MeshComponent15);
    this.myNotifyIconBackgroundComponent.mesh = this._myPlaneMesh;
    this.myNotifyIconBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myNotifyIconBackgroundComponent.material.color = this._myConfig.myNotifyIconColor;
    this.myNotifyIconCursorTargetComponent = this.myNotifyIconCursorTarget.pp_addComponent(CursorTarget9);
    this.myNotifyIconCollisionComponent = this.myNotifyIconCursorTarget.pp_addComponent(CollisionComponent5);
    this.myNotifyIconCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myNotifyIconCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myNotifyIconCollisionComponent.extents = this._myConfig.myNotifyIconCollisionExtents;
  }
  _addButtonsComponents() {
    this.myFilterButtonsBackgroundComponents = [];
    this.myFilterButtonsTextComponents = [];
    this.myFilterButtonsCursorTargetComponents = [];
    this.myFilterButtonsCollisionComponents = [];
    for (let key in ConsoleVRWidgetMessageType) {
      let buttonBackgroundMeshComp = this.myFilterButtonsBackgrounds[ConsoleVRWidgetMessageType[key]].pp_addComponent(MeshComponent15);
      buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
      buttonBackgroundMeshComp.material = this._myParams.myPlaneMaterial.clone();
      buttonBackgroundMeshComp.material.color = this._myConfig.myBackgroundColor;
      let buttonTextComp = this.myFilterButtonsTexts[ConsoleVRWidgetMessageType[key]].pp_addComponent(TextComponent11);
      this._setupButtonTextComponent(buttonTextComp);
      buttonTextComp.material.color = this._myConfig.myFilterButtonsTextColors[ConsoleVRWidgetMessageType[key]];
      buttonTextComp.text = this._myConfig.myFilterButtonsTextLabel[ConsoleVRWidgetMessageType[key]];
      let buttonCursorTargetComp = this.myFilterButtonsCursorTargets[ConsoleVRWidgetMessageType[key]].pp_addComponent(CursorTarget9);
      let buttonCollisionComp = this.myFilterButtonsCursorTargets[ConsoleVRWidgetMessageType[key]].pp_addComponent(CollisionComponent5);
      buttonCollisionComp.collider = this._myConfig.myButtonsCollisionCollider;
      buttonCollisionComp.group = 1 << this._myConfig.myButtonsCollisionGroup;
      buttonCollisionComp.extents = this._myConfig.myButtonsCollisionExtents;
      this.myFilterButtonsBackgroundComponents[ConsoleVRWidgetMessageType[key]] = buttonBackgroundMeshComp;
      this.myFilterButtonsTextComponents[ConsoleVRWidgetMessageType[key]] = buttonTextComp;
      this.myFilterButtonsCursorTargetComponents[ConsoleVRWidgetMessageType[key]] = buttonCursorTargetComp;
      this.myFilterButtonsCollisionComponents[ConsoleVRWidgetMessageType[key]] = buttonCollisionComp;
    }
    {
      let buttonBackgroundMeshComp = this.myClearButtonBackground.pp_addComponent(MeshComponent15);
      buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
      buttonBackgroundMeshComp.material = this._myParams.myPlaneMaterial.clone();
      buttonBackgroundMeshComp.material.color = this._myConfig.myBackgroundColor;
      let buttonTextComp = this.myClearButtonText.pp_addComponent(TextComponent11);
      this._setupButtonTextComponent(buttonTextComp);
      buttonTextComp.text = this._myConfig.myClearButtonTextLabel;
      let buttonCursorTargetComp = this.myClearButtonCursorTarget.pp_addComponent(CursorTarget9);
      let buttonCollisionComp = this.myClearButtonCursorTarget.pp_addComponent(CollisionComponent5);
      buttonCollisionComp.collider = this._myConfig.myButtonsCollisionCollider;
      buttonCollisionComp.group = 1 << this._myConfig.myButtonsCollisionGroup;
      buttonCollisionComp.extents = this._myConfig.myButtonsCollisionExtents;
      this.myClearButtonBackgroundComponent = buttonBackgroundMeshComp;
      this.myClearButtonTextComponent = buttonTextComp;
      this.myClearButtonCursorTargetComponent = buttonCursorTargetComp;
      this.myClearButtonCollisionComponent = buttonCollisionComp;
    }
    {
      let buttonBackgroundMeshComp = this.myUpButtonBackground.pp_addComponent(MeshComponent15);
      buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
      buttonBackgroundMeshComp.material = this._myParams.myPlaneMaterial.clone();
      buttonBackgroundMeshComp.material.color = this._myConfig.myBackgroundColor;
      let buttonTextComp = this.myUpButtonText.pp_addComponent(TextComponent11);
      this._setupButtonTextComponent(buttonTextComp);
      buttonTextComp.text = this._myConfig.myUpButtonTextLabel;
      let buttonCursorTargetComp = this.myUpButtonCursorTarget.pp_addComponent(CursorTarget9);
      let buttonCollisionComp = this.myUpButtonCursorTarget.pp_addComponent(CollisionComponent5);
      buttonCollisionComp.collider = this._myConfig.myButtonsCollisionCollider;
      buttonCollisionComp.group = 1 << this._myConfig.myButtonsCollisionGroup;
      buttonCollisionComp.extents = this._myConfig.myButtonsCollisionExtents;
      this.myUpButtonBackgroundComponent = buttonBackgroundMeshComp;
      this.myUpButtonTextComponent = buttonTextComp;
      this.myUpButtonCursorTargetComponent = buttonCursorTargetComp;
      this.myUpButtonCollisionComponent = buttonCollisionComp;
    }
    {
      let buttonBackgroundMeshComp = this.myDownButtonBackground.pp_addComponent(MeshComponent15);
      buttonBackgroundMeshComp.mesh = this._myPlaneMesh;
      buttonBackgroundMeshComp.material = this._myParams.myPlaneMaterial.clone();
      buttonBackgroundMeshComp.material.color = this._myConfig.myBackgroundColor;
      let buttonTextComp = this.myDownButtonText.pp_addComponent(TextComponent11);
      this._setupButtonTextComponent(buttonTextComp);
      buttonTextComp.text = this._myConfig.myDownButtonTextLabel;
      let buttonCursorTargetComp = this.myDownButtonCursorTarget.pp_addComponent(CursorTarget9);
      let buttonCollisionComp = this.myDownButtonCursorTarget.pp_addComponent(CollisionComponent5);
      buttonCollisionComp.collider = this._myConfig.myButtonsCollisionCollider;
      buttonCollisionComp.group = 1 << this._myConfig.myButtonsCollisionGroup;
      buttonCollisionComp.extents = this._myConfig.myButtonsCollisionExtents;
      this.myDownButtonBackgroundComponent = buttonBackgroundMeshComp;
      this.myDownButtonTextComponent = buttonTextComp;
      this.myDownButtonCursorTargetComponent = buttonCursorTargetComp;
      this.myDownButtonCollisionComponent = buttonCollisionComp;
    }
  }
  _addPointerComponents() {
    this.myPointerCursorTargetComponent = this.myPointerCursorTarget.pp_addComponent(CursorTarget9);
    this.myPointerCursorTargetComponent.isSurface = true;
    let collisionComp = this.myPointerCursorTarget.pp_addComponent(CollisionComponent5);
    collisionComp.collider = this._myConfig.myPointerCollisionCollider;
    collisionComp.group = 1 << this._myConfig.myPointerCollisionGroup;
    collisionComp.extents = this._myConfig.myPointerCollisionExtents;
    this.myPointerCollisionComponent = collisionComp;
  }
  _setupButtonTextComponent(textComponent) {
    textComponent.alignment = this._myConfig.myTextAlignment;
    textComponent.verticalAlignment = this._myConfig.myTextVerticalAlignment;
    textComponent.material = this._myParams.myTextMaterial.clone();
    textComponent.material.color = this._myConfig.myTextColor;
    textComponent.text = "";
  }
  _onXRSessionStart() {
    this._setTransformForXR();
  }
  _onXRSessionEnd() {
    this._setTransformForNonXR();
  }
  _setTransformForXR() {
    this.myNotifyIconPanel.pp_setPositionLocal(this._myConfig.myNotifyIconPanelPositions[this._myParams.myHandedness]);
  }
  _setTransformForNonXR() {
    this.myNotifyIconPanel.pp_setPositionLocal(this._myConfig.myNotifyIconPanelPositions[ToolHandedness.NONE]);
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      if (this._myActive) {
        XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myEngine);
      } else {
        XRUtils.unregisterSessionStartEndEventListeners(this, this._myEngine);
      }
    }
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/tool/widget_frame/widget_frame.js
import { Emitter as Emitter14 } from "@wonderlandengine/api";

// dist/pp/tool/widget_frame/widget_frame_config.js
import { Alignment as Alignment7, Collider as Collider3, VerticalAlignment as VerticalAlignment7 } from "@wonderlandengine/api";
var WidgetFrameConfig = class {
  constructor(widgetLetterID, buttonsColumnIndex) {
    this._setupBuildConfig(widgetLetterID, buttonsColumnIndex);
    this._setupRuntimeConfig();
  }
  _setupBuildConfig(widgetLetterID, buttonsColumnIndex) {
    this.myBackgroundColor = vec4_create(46 / 255, 46 / 255, 46 / 255, 1);
    this.myCursorTargetCollisionCollider = Collider3.Box;
    this.myCursorTargetCollisionGroup = 7;
    this.myCursorTargetCollisionThickness = 1e-3;
    this.myDefaultTextColor = vec4_create(255 / 255, 255 / 255, 255 / 255, 1);
    this.myTextAlignment = Alignment7.Center;
    this.myTextVerticalAlignment = VerticalAlignment7.Middle;
    this.myTextColor = this.myDefaultTextColor;
    this.myButtonTextScale = vec3_create(0.18, 0.18, 0.18);
    this.myVisibilityButtonBackgroundScale = vec3_create(0.015, 0.015, 1);
    this.myVisibilityButtonTextPosition = vec3_create(0, 0, 7e-3);
    this.myVisibilityButtonTextScale = this.myButtonTextScale;
    let distanceBetweenToolsVisibilityButtons = 0.01;
    let buttonXOffset = this.myVisibilityButtonBackgroundScale[0] * (2 * buttonsColumnIndex) + distanceBetweenToolsVisibilityButtons * buttonsColumnIndex;
    this.myVisibilityButtonPosition = [];
    this.myVisibilityButtonPosition[ToolHandedness.NONE] = {};
    this.myVisibilityButtonPosition[ToolHandedness.NONE].myPosition = vec3_create(-0.3 + buttonXOffset, -0.205, 0.035);
    this.myVisibilityButtonPosition[ToolHandedness.LEFT] = {};
    this.myVisibilityButtonPosition[ToolHandedness.LEFT].myPosition = vec3_create(-0.2 + buttonXOffset, 0.025, 0.015);
    this.myVisibilityButtonPosition[ToolHandedness.RIGHT] = {};
    this.myVisibilityButtonPosition[ToolHandedness.RIGHT].myPosition = vec3_create(0.2 - buttonXOffset, 0.025, 0.015);
    this.myVisibilityButtonText = widgetLetterID;
    this.myVisibilityButtonCursorTargetPosition = vec3_create(0, 0, 0);
    this.myVisibilityButtonCursorTargetPosition[2] = this.myVisibilityButtonTextPosition[2];
    this.myVisibilityButtonCollisionExtents = this.myVisibilityButtonBackgroundScale.pp_clone();
    this.myVisibilityButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myFlagButtonBackgroundScale = vec3_create(0.0125, 0.0125, 1);
    this.myFlagButtonTextPosition = vec3_create(0, 0, 7e-3);
    this.myFlagButtonTextScale = vec3_create(0.15, 0.15, 0.15);
    let distanceBetweenFlagButtons = 75e-4;
    let pinFlagIndex = 0;
    let pinButtonYOffset = this.myVisibilityButtonBackgroundScale[1] + this.myFlagButtonBackgroundScale[1] + distanceBetweenFlagButtons + this.myFlagButtonBackgroundScale[1] * (2 * pinFlagIndex) + distanceBetweenFlagButtons * pinFlagIndex;
    this.myPinButtonPosition = [];
    this.myPinButtonPosition[ToolHandedness.NONE] = {};
    this.myPinButtonPosition[ToolHandedness.NONE].myPosition = this.myVisibilityButtonPosition[ToolHandedness.NONE].myPosition.pp_clone();
    this.myPinButtonPosition[ToolHandedness.NONE].myPosition[1] += pinButtonYOffset;
    this.myPinButtonPosition[ToolHandedness.LEFT] = {};
    this.myPinButtonPosition[ToolHandedness.LEFT].myPosition = this.myVisibilityButtonPosition[ToolHandedness.LEFT].myPosition.pp_clone();
    this.myPinButtonPosition[ToolHandedness.LEFT].myPosition[1] += pinButtonYOffset;
    this.myPinButtonPosition[ToolHandedness.RIGHT] = {};
    this.myPinButtonPosition[ToolHandedness.RIGHT].myPosition = this.myVisibilityButtonPosition[ToolHandedness.RIGHT].myPosition.pp_clone();
    this.myPinButtonPosition[ToolHandedness.RIGHT].myPosition[1] += pinButtonYOffset;
    this.myPinButtonText = "P";
    this.myPinButtonCursorTargetPosition = vec3_create(0, 0, 0);
    this.myPinButtonCursorTargetPosition[2] = this.myFlagButtonTextPosition[2];
    this.myPinButtonCollisionExtents = this.myFlagButtonBackgroundScale.pp_clone();
    this.myPinButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
  }
  _setupRuntimeConfig() {
    this._initializeObjectsTransforms();
    this.myButtonHoverColor = vec4_create(150 / 255, 150 / 255, 150 / 255, 1);
    this.myButtonDisabledTextColor = this.myBackgroundColor;
    this.myButtonDisabledBackgroundColor = vec4_create(110 / 255, 110 / 255, 110 / 255, 1);
  }
  _initializeObjectsTransforms() {
    this.myPivotObjectTransforms = this._createDefaultObjectTransforms();
    this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.LEFT].myRotation = quat_create(-0.645, 0.425, 0.25, 0.584);
    this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.LEFT].myRotation.quat_normalize(this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.LEFT].myRotation);
    this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.RIGHT].myRotation = quat_create(-0.645, -0.425, -0.25, 0.584);
    this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.RIGHT].myRotation.quat_normalize(this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.RIGHT].myRotation);
    this.myPivotObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.LEFT].myRotation = quat_create(-0.645, 0.425, 0.25, 0.584);
    this.myPivotObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.LEFT].myRotation.quat_normalize(this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.LEFT].myRotation);
    this.myPivotObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.RIGHT].myRotation = quat_create(-0.645, -0.425, -0.25, 0.584);
    this.myPivotObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.RIGHT].myRotation.quat_normalize(this.myPivotObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.RIGHT].myRotation);
    this.myWidgetObjectTransforms = this._createDefaultObjectTransforms();
    this.myWidgetObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.LEFT].myPosition = vec3_create(0.1, 0.23, -0.02);
    this.myWidgetObjectTransforms[ToolInputSourceType.GAMEPAD][ToolHandedness.RIGHT].myPosition = vec3_create(0.07, 0.23, -0.02);
    this.myWidgetObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.LEFT].myPosition = vec3_create(0.1, 0.23, -0.02);
    this.myWidgetObjectTransforms[ToolInputSourceType.TRACKED_HAND][ToolHandedness.RIGHT].myPosition = vec3_create(0.07, 0.23, -0.02);
    this._myPivotObjectDistanceFromHeadNonXR = 0.6;
  }
  _createDefaultObjectTransforms() {
    let defaultObjectTransforms = [];
    for (let inputSourceTypeKey in ToolInputSourceType) {
      let inputSourceType = ToolInputSourceType[inputSourceTypeKey];
      defaultObjectTransforms[inputSourceType] = [];
      for (let handednessKey in ToolHandedness) {
        let handedness = ToolHandedness[handednessKey];
        defaultObjectTransforms[inputSourceType][handedness] = {};
        defaultObjectTransforms[inputSourceType][handedness].myPosition = vec3_create(0, 0, 0);
        defaultObjectTransforms[inputSourceType][handedness].myRotation = quat_create(0, 0, 0, 1);
      }
    }
    return defaultObjectTransforms;
  }
};

// dist/pp/tool/widget_frame/widget_frame_ui.js
import { CollisionComponent as CollisionComponent6, MeshComponent as MeshComponent16, TextComponent as TextComponent12 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget10 } from "@wonderlandengine/components";
var WidgetFrameUI = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myInputSourceType = null;
    this._myParentObject = null;
    this._myPinned = false;
    this._myWidgetVisible = true;
    this._myVisibilityButtonVisible = true;
    this._myEngine = engine;
    this._myActive = false;
    this._myDestroyed = false;
  }
  build(parentObject, config, params) {
    this._myParentObject = parentObject;
    this._myConfig = config;
    this._myParams = params;
    this._myPlaneMesh = Globals.getDefaultMeshes(this._myEngine).myDoubleSidedPlane;
    this._createSkeleton();
    this._setTransforms();
    this._addComponents();
    this._setTransformForNonXR();
    this.setActive(true);
  }
  setWidgetVisible(visible) {
    this._myWidgetVisible = visible;
    this.myFlagsButtonPanel.pp_setActive(visible);
    if (visible) {
      this._updateObjectsTransforms(true);
    }
  }
  setVisibilityButtonVisible(visible) {
    this._myVisibilityButtonVisible = visible;
    this.myVisibilityButtonPanel.pp_setActive(visible);
  }
  setPinned(pinned) {
    if (pinned != this._myPinned) {
      this._myPinned = pinned;
      if (this._myPinned) {
        this.myPivotObject.pp_setParent(Globals.getSceneObjects(this._myEngine).myTools);
      } else {
        this.myPivotObject.pp_setParent(this.myFixForwardObject);
        if (!XRUtils.isSessionActive(this._myEngine)) {
          this._setTransformForNonXR();
        }
        this._updateObjectsTransforms(true);
      }
    }
  }
  update(dt) {
    this._updateObjectsTransforms(false);
  }
  _updateObjectsTransforms(forceRefreshObjectsTransforms) {
    if (XRUtils.isSessionActive(this._myEngine)) {
      let inputSourceType = Globals.getHandPoses(this._myEngine)[this._myParams.myHandedness].getInputSourceType();
      if (inputSourceType != this._myInputSourceType || forceRefreshObjectsTransforms) {
        this._myInputSourceType = inputSourceType;
        if (!this._myPinned) {
          this.myPivotObject.pp_setPositionLocal(this._myConfig.myPivotObjectTransforms[this._myInputSourceType][this._myParams.myHandedness].myPosition);
          this.myPivotObject.pp_resetRotationLocal();
          this.myPivotObject.pp_rotateObjectQuat(this._myConfig.myPivotObjectTransforms[this._myInputSourceType][this._myParams.myHandedness].myRotation);
          this.myWidgetObject.pp_setPositionLocal(this._myConfig.myWidgetObjectTransforms[this._myInputSourceType][this._myParams.myHandedness].myPosition);
          this.myWidgetObject.pp_resetRotationLocal();
          this.myWidgetObject.pp_rotateObjectQuat(this._myConfig.myWidgetObjectTransforms[this._myInputSourceType][this._myParams.myHandedness].myRotation);
          this.myVisibilityButtonPanel.pp_setPositionLocal(this._myConfig.myVisibilityButtonPosition[this._myParams.myHandedness].myPosition);
          this.myPinButtonPanel.pp_setPositionLocal(this._myConfig.myPinButtonPosition[this._myParams.myHandedness].myPosition);
        }
      }
    } else {
      this.myVisibilityButtonPanel.pp_setActive(this._myWidgetVisible || this._myVisibilityButtonVisible);
    }
  }
  // Skeleton
  _createSkeleton() {
    this.myFixForwardObject = this._myParentObject.pp_addChild();
    if (Globals.isPoseForwardFixed(this._myEngine)) {
      this.myFixForwardObject.pp_rotateObject(vec3_create(0, 180, 0));
    }
    this.myPivotObject = this.myFixForwardObject.pp_addChild();
    this.myWidgetObject = this.myPivotObject.pp_addChild();
    this.myVisibilityButtonPanel = this.myPivotObject.pp_addChild();
    this.myVisibilityButtonBackground = this.myVisibilityButtonPanel.pp_addChild();
    this.myVisibilityButtonText = this.myVisibilityButtonPanel.pp_addChild();
    this.myVisibilityButtonCursorTarget = this.myVisibilityButtonPanel.pp_addChild();
    this.myFlagsButtonPanel = this.myPivotObject.pp_addChild();
    this.myPinButtonPanel = this.myFlagsButtonPanel.pp_addChild();
    this.myPinButtonBackground = this.myPinButtonPanel.pp_addChild();
    this.myPinButtonText = this.myPinButtonPanel.pp_addChild();
    this.myPinButtonCursorTarget = this.myPinButtonPanel.pp_addChild();
    this.myNonXRParentObject = Globals.getPlayerObjects(this._myEngine).myCameraNonXR.pp_addChild();
    this.myNonXRParentObject.pp_translateLocal(vec3_create(0, 0, -this._myConfig._myPivotObjectDistanceFromHeadNonXR));
    this.myNonXRParentObject.pp_lookToLocal(vec3_create(0, 0, 1), vec3_create(0, 1, 0));
  }
  // Transforms
  _setTransforms() {
    this.myPivotObject.pp_markDirty();
    this.myVisibilityButtonPanel.pp_setPositionLocal(this._myConfig.myVisibilityButtonPosition[this._myParams.myHandedness].myPosition);
    this.myVisibilityButtonBackground.pp_scaleObject(this._myConfig.myVisibilityButtonBackgroundScale);
    this.myVisibilityButtonText.pp_setPositionLocal(this._myConfig.myVisibilityButtonTextPosition);
    this.myVisibilityButtonText.pp_scaleObject(this._myConfig.myVisibilityButtonTextScale);
    this.myVisibilityButtonCursorTarget.pp_setPositionLocal(this._myConfig.myVisibilityButtonCursorTargetPosition);
    this.myPinButtonPanel.pp_setPositionLocal(this._myConfig.myPinButtonPosition[this._myParams.myHandedness].myPosition);
    this.myPinButtonBackground.pp_scaleObject(this._myConfig.myFlagButtonBackgroundScale);
    this.myPinButtonText.pp_setPositionLocal(this._myConfig.myFlagButtonTextPosition);
    this.myPinButtonText.pp_scaleObject(this._myConfig.myFlagButtonTextScale);
    this.myPinButtonCursorTarget.pp_setPositionLocal(this._myConfig.myPinButtonCursorTargetPosition);
  }
  // Components
  _addComponents() {
    this.myVisibilityButtonBackgroundComponent = this.myVisibilityButtonBackground.pp_addComponent(MeshComponent16);
    this.myVisibilityButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myVisibilityButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myVisibilityButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myVisibilityButtonTextComponent = this.myVisibilityButtonText.pp_addComponent(TextComponent12);
    this._setupButtonTextComponent(this.myVisibilityButtonTextComponent);
    this.myVisibilityButtonTextComponent.text = this._myConfig.myVisibilityButtonText;
    this.myVisibilityButtonCursorTargetComponent = this.myVisibilityButtonCursorTarget.pp_addComponent(CursorTarget10);
    this.myVisibilityButtonCollisionComponent = this.myVisibilityButtonCursorTarget.pp_addComponent(CollisionComponent6);
    this.myVisibilityButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myVisibilityButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myVisibilityButtonCollisionComponent.extents = this._myConfig.myVisibilityButtonCollisionExtents;
    this.myPinButtonBackgroundComponent = this.myPinButtonBackground.pp_addComponent(MeshComponent16);
    this.myPinButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPinButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myPinButtonBackgroundComponent.material.color = this._myConfig.myButtonDisabledBackgroundColor;
    this.myPinButtonTextComponent = this.myPinButtonText.pp_addComponent(TextComponent12);
    this._setupButtonTextComponent(this.myPinButtonTextComponent);
    this.myPinButtonTextComponent.material.color = this._myConfig.myButtonDisabledTextColor;
    this.myPinButtonTextComponent.text = this._myConfig.myPinButtonText;
    this.myPinButtonCursorTargetComponent = this.myPinButtonCursorTarget.pp_addComponent(CursorTarget10);
    this.myPinButtonCollisionComponent = this.myPinButtonCursorTarget.pp_addComponent(CollisionComponent6);
    this.myPinButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPinButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPinButtonCollisionComponent.extents = this._myConfig.myPinButtonCollisionExtents;
  }
  _setupButtonTextComponent(textComponent) {
    textComponent.alignment = this._myConfig.myTextAlignment;
    textComponent.verticalAlignment = this._myConfig.myTextVerticalAlignment;
    textComponent.material = this._myParams.myTextMaterial.clone();
    textComponent.material.color = this._myConfig.myTextColor;
    textComponent.text = "";
  }
  _onXRSessionStart() {
    this.myVisibilityButtonPanel.pp_setActive(this._myVisibilityButtonVisible);
    this._setTransformForXR();
  }
  _onXRSessionEnd() {
    this._setTransformForNonXR();
  }
  _setTransformForXR() {
    this.myFixForwardObject.pp_setParent(this._myParentObject);
    this.myFixForwardObject.pp_resetTransformLocal();
    if (Globals.isPoseForwardFixed(this._myEngine)) {
      this.myFixForwardObject.pp_rotateObject(vec3_create(0, 180, 0));
    }
    this._updateObjectsTransforms(true);
  }
  _setTransformForNonXR() {
    if (!this._myPinned) {
      this.myFixForwardObject.pp_setParent(this.myNonXRParentObject);
      this.myFixForwardObject.pp_resetTransformLocal();
      this.myPivotObject.pp_setPositionLocal(this._myConfig.myPivotObjectTransforms[ToolInputSourceType.NONE][ToolHandedness.NONE].myPosition);
      this.myPivotObject.pp_resetRotationLocal();
      this.myPivotObject.pp_rotateObjectQuat(this._myConfig.myPivotObjectTransforms[ToolInputSourceType.NONE][ToolHandedness.NONE].myRotation);
      this.myWidgetObject.pp_setPositionLocal(this._myConfig.myWidgetObjectTransforms[ToolInputSourceType.NONE][ToolHandedness.NONE].myPosition);
      this.myWidgetObject.pp_resetRotationLocal();
      this.myWidgetObject.pp_rotateObjectQuat(this._myConfig.myWidgetObjectTransforms[ToolInputSourceType.NONE][ToolHandedness.NONE].myRotation);
      this.myVisibilityButtonPanel.pp_setPositionLocal(this._myConfig.myVisibilityButtonPosition[ToolHandedness.NONE].myPosition);
      this.myPinButtonPanel.pp_setPositionLocal(this._myConfig.myPinButtonPosition[ToolHandedness.NONE].myPosition);
    }
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      if (this._myActive) {
        XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myEngine);
      } else {
        XRUtils.unregisterSessionStartEndEventListeners(this, this._myEngine);
      }
    }
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/tool/widget_frame/widget_frame.js
var WidgetParams = class {
  constructor() {
    this.myHandedness = ToolHandedness.NONE;
    this.myPlaneMaterial = null;
    this.myTextMaterial = null;
  }
};
var WidgetFrame = class {
  constructor(widgetLetterID, buttonsColumnIndex, engine = Globals.getMainEngine()) {
    this._myWidgetVisible = true;
    this._myPinned = false;
    this._myConfig = new WidgetFrameConfig(widgetLetterID, buttonsColumnIndex);
    this._myParams = null;
    this._myUI = new WidgetFrameUI(engine);
    this._myShowVisibilityButton = false;
    this._myWidgetVisibleChangedEmitter = new Emitter14();
    this._myPinChangedEmitter = new Emitter14();
    this._myUnhoverCallbacks = [];
    this._myDestroyed = false;
  }
  getWidgetObject() {
    return this._myUI.myWidgetObject;
  }
  setVisible(visible) {
    this._myWidgetVisible = !visible;
    this._toggleVisibility(false, true);
  }
  isVisible() {
    return this._myWidgetVisible;
  }
  toggleVisibility() {
    this._toggleVisibility(false, true);
  }
  togglePin() {
    this._togglePin(false);
  }
  registerWidgetVisibleChangedEventListener(id, listener) {
    this._myWidgetVisibleChangedEmitter.add(listener, { id });
  }
  unregisterWidgetVisibleChangedEventListener(id) {
    this._myWidgetVisibleChangedEmitter.remove(id);
  }
  registerPinChangedEventListener(id, listener) {
    this._myPinChangedEmitter.add(listener, { id });
  }
  unregisterPinChangedEventListener(id) {
    this._myPinChangedEmitter.remove(id);
  }
  start(parentObject, params) {
    this._myParams = params;
    this._myUI.build(parentObject, this._myConfig, params);
    this._myUI.setVisibilityButtonVisible(params.myShowVisibilityButton);
    this._myShowVisibilityButton = params.myShowVisibilityButton;
    if (!params.myShowOnStart) {
      this._toggleVisibility(false, false);
    }
    this._addListeners();
  }
  update(dt) {
    this._myUI.update(dt);
  }
  _addListeners() {
    let ui = this._myUI;
    this._myUnhoverCallbacks = [];
    ui.myPinButtonCursorTargetComponent.onClick.add(this._togglePin.bind(this, true));
    ui.myPinButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myPinButtonBackgroundComponent.material));
    ui.myPinButtonCursorTargetComponent.onUnhover.add(this._pinUnhover.bind(this, ui.myPinButtonBackgroundComponent.material));
    this._myUnhoverCallbacks.push(this._pinUnhover.bind(this, ui.myPinButtonBackgroundComponent.material));
    ui.myVisibilityButtonCursorTargetComponent.onClick.add(this._toggleVisibility.bind(this, true, true));
    ui.myVisibilityButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myVisibilityButtonBackgroundComponent.material));
    ui.myVisibilityButtonCursorTargetComponent.onUnhover.add(this._visibilityUnhover.bind(this, ui.myVisibilityButtonBackgroundComponent.material));
    this._myUnhoverCallbacks.push(this._visibilityUnhover.bind(this, ui.myVisibilityButtonBackgroundComponent.material));
  }
  _toggleVisibility(isButton, notify) {
    this._myWidgetVisible = !this._myWidgetVisible;
    this._myUI.setWidgetVisible(this._myWidgetVisible);
    for (const unhoverCallback of this._myUnhoverCallbacks) {
      unhoverCallback();
    }
    let textMaterial = this._myUI.myVisibilityButtonTextComponent.material;
    let backgroundMaterial = this._myUI.myVisibilityButtonBackgroundComponent.material;
    if (this._myWidgetVisible) {
      textMaterial.color = this._myConfig.myDefaultTextColor;
      if (!isButton) {
        backgroundMaterial.color = this._myConfig.myBackgroundColor;
      }
    } else {
      textMaterial.color = this._myConfig.myButtonDisabledTextColor;
      if (!isButton) {
        backgroundMaterial.color = this._myConfig.myButtonDisabledBackgroundColor;
      }
    }
    if (notify) {
      this._myWidgetVisibleChangedEmitter.notify(this._myWidgetVisible);
    }
    this._myUI.setVisibilityButtonVisible(this._myShowVisibilityButton);
  }
  _togglePin(isButton) {
    if (this._myWidgetVisible) {
      this._myPinned = !this._myPinned;
      this._myUI.setPinned(this._myPinned);
      let textMaterial = this._myUI.myPinButtonTextComponent.material;
      let backgroundMaterial = this._myUI.myPinButtonBackgroundComponent.material;
      if (this._myPinned) {
        textMaterial.color = this._myConfig.myDefaultTextColor;
        if (!isButton) {
          backgroundMaterial.color = this._myConfig.myBackgroundColor;
        }
      } else {
        textMaterial.color = this._myConfig.myButtonDisabledTextColor;
        if (!isButton) {
          backgroundMaterial.color = this._myConfig.myButtonDisabledBackgroundColor;
        }
      }
      this._myPinChangedEmitter.notify(this._myPinned);
    }
  }
  _genericHover(material) {
    material.color = this._myConfig.myButtonHoverColor;
  }
  _visibilityUnhover(material) {
    if (this._myWidgetVisible) {
      material.color = this._myConfig.myBackgroundColor;
    } else {
      material.color = this._myConfig.myButtonDisabledBackgroundColor;
    }
  }
  _pinUnhover(material) {
    if (this._myPinned) {
      material.color = this._myConfig.myBackgroundColor;
    } else {
      material.color = this._myConfig.myButtonDisabledBackgroundColor;
    }
  }
  setActive(active) {
    this._myUI.setActive(active);
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
    if (this._myUI != null) {
      this._myUI.destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/tool/console_vr/console_vr_widget.js
var ConsoleVRWidgetParams = class extends WidgetParams {
  constructor() {
    super();
    this.myOverrideBrowserConsoleFunctions = false;
    this.myShowOnStart = false;
    this.myShowVisibilityButton = false;
    this.myFilterByError = false;
    this.myPulseOnNewMessage = ConsoleVRWidgetPulseOnNewMessage.NEVER;
    this.myResetToOverwrittenConsoleFunctionsOnDeactivate = false;
    this.myResetToConsoleOriginalFunctionsOnDeactivate = true;
    this.myResetToOverwrittenConsoleFunctionsOnDestroy = false;
    this.myResetToConsoleOriginalFunctionsOnDestroy = false;
  }
};
var ConsoleVRWidgetMessage = class {
  constructor(messageType, messageLines) {
    this.myType = messageType;
    this.myLines = messageLines;
    this._myOriginalText = messageLines.join("\n");
    this._myMessagesCount = 1;
  }
  hasSameInfo(message) {
    return this._myOriginalText == message._myOriginalText && this.myType == message.myType;
  }
  increaseCount() {
    this._myMessagesCount += 1;
    let countString = "(x".concat(this._myMessagesCount).concat(") ");
    let text = this._myOriginalText;
    text = countString.concat(text);
    this.myLines = text.split("\n");
  }
};
var ConsoleVRWidget = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myWidgetFrame = new WidgetFrame("C", 0, engine);
    this._myWidgetFrame.registerWidgetVisibleChangedEventListener(this, this._widgetVisibleChanged.bind(this));
    this._myConfig = new ConsoleVRWidgetConfig();
    this._myParams = null;
    this._myUI = new ConsoleVRWidgetUI(engine);
    this._myMessages = [];
    this._myOldBrowserConsole = [];
    this._myOldConsoleVR = [];
    this._myTypeFilters = [];
    for (let key in ConsoleVRWidgetMessageType) {
      this._myTypeFilters[ConsoleVRWidgetMessageType[key]] = false;
    }
    this._myScrollUp = false;
    this._myScrollDown = false;
    this._myScrollOffset = 0;
    this._myScrollTimer = 0;
    this._myScrollThumbstickTimer = 0;
    this._myPulseTimer = 0;
    this._myGamepadScrollEnabled = true;
    if (this._myConfig.myGamepadScrollOnlyOnHover) {
      this._myGamepadScrollEnabled = false;
    }
    this._myErrorEventListener = null;
    this._myUnhandledRejectionEventListener = null;
    this._myConsolePrintAddMessageEnabled = true;
    this._myConsolePrintAddMessageEnabledReset = false;
    this._myTextDirty = false;
    this._myEngine = engine;
    this._myStarted = false;
    this._myActive = true;
    this._myVisibleBackup = null;
    this._myUnhoverCallbacks = [];
    this._myDestroyed = false;
  }
  setVisible(visible) {
    if (this._myActive) {
      this._myWidgetFrame.setVisible(visible);
    } else {
      this._myVisibleBackup = visible;
    }
  }
  isVisible() {
    return this._myWidgetFrame.isVisible();
  }
  start(parentObject, params) {
    this._myLeftGamepad = Globals.getLeftGamepad(this._myEngine);
    this._myRightGamepad = Globals.getRightGamepad(this._myEngine);
    this._myParams = params;
    this._myWidgetFrame.start(parentObject, params);
    this._myUI.build(this._myWidgetFrame.getWidgetObject(), this._myConfig, params);
    this._myUI.setVisible(this._myWidgetFrame.isVisible());
    this._setNotifyIconActive(false);
    this._addListeners();
    if (this._myParams.myFilterByError) {
      this._filterAllButOne(ConsoleVRWidgetMessageType.ERROR, true);
    }
    this._overrideConsolesFunctions();
    this._myStarted = true;
  }
  update(dt) {
    if (!this._myActive)
      return;
    if (this._myConsolePrintAddMessageEnabledReset) {
      this._myConsolePrintAddMessageEnabledReset = false;
      this._myConsolePrintAddMessageEnabled = true;
    }
    this._myWidgetFrame.update(dt);
    if (this._myWidgetFrame.isVisible()) {
      if (this._myTextDirty) {
        this._updateAllTexts();
      }
      this._updateScroll(dt);
    }
    this._updateGamepadsExtraActions(dt);
  }
  isActive() {
    return this._myActive;
  }
  setActive(active) {
    if (!this._myStarted)
      return;
    this._myUI.setActive(active);
    this._myWidgetFrame.setActive(active);
    if (this._myActive != active) {
      if (active) {
        this._myActive = active;
        if (this._myVisibleBackup != null) {
          this.setVisible(false);
          this.setVisible(this._myVisibleBackup);
          this._myVisibleBackup = null;
        }
      } else {
        if (this._myVisibleBackup == null) {
          this._myVisibleBackup = this.isVisible();
        }
        if (this.isVisible()) {
          this.setVisible(false);
        }
        this._myActive = active;
      }
      if (active) {
        if (this._myParams.myResetToConsoleOriginalFunctionsOnDeactivate || this._myParams.myResetToOverwrittenConsoleFunctionsOnDeactivate) {
          this._overrideConsolesFunctions();
        } else {
          if (this._myParams.myOverrideBrowserConsoleFunctions != OverrideBrowserConsoleFunctions.NONE) {
            window.addEventListener("error", this._myErrorEventListener);
            window.addEventListener("unhandledrejection", this._myUnhandledRejectionEventListener);
          }
        }
      } else {
        window.removeEventListener("error", this._myErrorEventListener);
        window.removeEventListener("unhandledrejection", this._myUnhandledRejectionEventListener);
        if (this._myParams.myResetToConsoleOriginalFunctionsOnDeactivate) {
          console.log = ConsoleOriginalFunctions.getLog(this._myEngine);
          console.error = ConsoleOriginalFunctions.getError(this._myEngine);
          console.warn = ConsoleOriginalFunctions.getWarn(this._myEngine);
          console.info = ConsoleOriginalFunctions.getInfo(this._myEngine);
          console.debug = ConsoleOriginalFunctions.getDebug(this._myEngine);
          console.assert = ConsoleOriginalFunctions.getAssert(this._myEngine);
          console.clear = ConsoleOriginalFunctions.getClear(this._myEngine);
          if (Globals.getConsoleVR(this._myEngine) != null) {
            Globals.getConsoleVR(this._myEngine).log = ConsoleVR.myOriginalLog;
            Globals.getConsoleVR(this._myEngine).error = ConsoleVR.myOriginalError;
            Globals.getConsoleVR(this._myEngine).warn = ConsoleVR.myOriginalWarn;
            Globals.getConsoleVR(this._myEngine).info = ConsoleVR.myOriginalInfo;
            Globals.getConsoleVR(this._myEngine).debug = ConsoleVR.myOriginalDebug;
            Globals.getConsoleVR(this._myEngine).assert = ConsoleVR.myOriginalAssert;
            Globals.getConsoleVR(this._myEngine).clear = ConsoleVR.myOriginalClear;
          }
        } else if (this._myParams.myResetToOverwrittenConsoleFunctionsOnDeactivate) {
          console.log = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.LOG];
          console.error = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.ERROR];
          console.warn = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.WARN];
          console.info = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.INFO];
          console.debug = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.DEBUG];
          console.assert = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.ASSERT];
          console.clear = this._myOldBrowserConsoleClear;
          if (Globals.getConsoleVR(this._myEngine) != null) {
            Globals.getConsoleVR(this._myEngine).log = this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.LOG];
            Globals.getConsoleVR(this._myEngine).error = this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.ERROR];
            Globals.getConsoleVR(this._myEngine).warn = this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.WARN];
            Globals.getConsoleVR(this._myEngine).info = this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.INFO];
            Globals.getConsoleVR(this._myEngine).debug = this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.DEBUG];
            Globals.getConsoleVR(this._myEngine).assert = this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.ASSERT];
            Globals.getConsoleVR(this._myEngine).clear = this._myOldConsoleVRClear;
          }
        }
      }
    }
  }
  // This must be done only when all the setup is complete, to avoid issues with other part of the code calling the console and then triggering the console vr while not ready yet
  _overrideConsolesFunctions() {
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.LOG] = console.log;
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.ERROR] = console.error;
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.WARN] = console.warn;
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.INFO] = console.info;
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.DEBUG] = console.debug;
    this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.ASSERT] = console.assert;
    this._myOldBrowserConsoleClear = console.clear;
    if (this._myParams.myOverrideBrowserConsoleFunctions != OverrideBrowserConsoleFunctions.NONE) {
      if (this._myParams.myOverrideBrowserConsoleFunctions == OverrideBrowserConsoleFunctions.ALL) {
        console.log = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.LOG, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      }
      console.error = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.ERROR, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      console.warn = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.WARN, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      if (this._myParams.myOverrideBrowserConsoleFunctions == OverrideBrowserConsoleFunctions.ALL) {
        console.info = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.INFO, ConsoleVRWidgetSender.BROWSER_CONSOLE);
        console.debug = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.DEBUG, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      }
      console.assert = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.ASSERT, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      console.clear = this._clearConsole.bind(this, true, ConsoleVRWidgetSender.BROWSER_CONSOLE);
      this._myErrorEventListener = function(errorEvent) {
        if (errorEvent.error != null) {
          this._consolePrint(ConsoleVRWidgetConsoleFunction.ERROR, ConsoleVRWidgetSender.WINDOW, "Uncaught", errorEvent.error.stack);
        } else {
          this._consolePrint(ConsoleVRWidgetConsoleFunction.ERROR, ConsoleVRWidgetSender.WINDOW, "Uncaught", errorEvent.message);
        }
      }.bind(this);
      this._myUnhandledRejectionEventListener = function(errorEvent) {
        this._consolePrint(ConsoleVRWidgetConsoleFunction.ERROR, ConsoleVRWidgetSender.WINDOW, "Uncaught (in promise)", errorEvent.reason);
      }.bind(this);
      window.addEventListener("error", this._myErrorEventListener);
      window.addEventListener("unhandledrejection", this._myUnhandledRejectionEventListener);
    }
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.LOG] = Globals.getConsoleVR(this._myEngine).log;
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.ERROR] = Globals.getConsoleVR(this._myEngine).error;
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.WARN] = Globals.getConsoleVR(this._myEngine).warn;
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.INFO] = Globals.getConsoleVR(this._myEngine).info;
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.DEBUG] = Globals.getConsoleVR(this._myEngine).debug;
    this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.ASSERT] = Globals.getConsoleVR(this._myEngine).assert;
    this._myOldConsoleVRClear = Globals.getConsoleVR(this._myEngine).clear;
    Globals.getConsoleVR(this._myEngine).log = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.LOG, ConsoleVRWidgetSender.CONSOLE_VR);
    Globals.getConsoleVR(this._myEngine).error = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.ERROR, ConsoleVRWidgetSender.CONSOLE_VR);
    Globals.getConsoleVR(this._myEngine).warn = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.WARN, ConsoleVRWidgetSender.CONSOLE_VR);
    Globals.getConsoleVR(this._myEngine).info = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.INFO, ConsoleVRWidgetSender.CONSOLE_VR);
    Globals.getConsoleVR(this._myEngine).debug = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.DEBUG, ConsoleVRWidgetSender.CONSOLE_VR);
    Globals.getConsoleVR(this._myEngine).assert = this._consolePrint.bind(this, ConsoleVRWidgetConsoleFunction.ASSERT, ConsoleVRWidgetSender.CONSOLE_VR);
    Globals.getConsoleVR(this._myEngine).clear = this._clearConsole.bind(this, true, ConsoleVRWidgetSender.CONSOLE_VR);
  }
  // Text section
  _updateText(messageType) {
    let consoleText = "";
    if (!this._myTypeFilters[messageType]) {
      let linesCount = 0;
      let i = this._myMessages.length - 1;
      let scrollLinesToSkip = Math.round(this._myScrollOffset);
      while (i >= 0 && linesCount < this._myConfig.myMaxLines) {
        let message = this._myMessages[i];
        if (this._myTypeFilters[message.myType]) {
          i -= 1;
          continue;
        }
        let messageLines = message.myLines.length;
        let linesToSkip = 0;
        if (scrollLinesToSkip > 0) {
          let additionalEmptyLines = 0;
          if (i != this._myMessages.length - 1) {
            additionalEmptyLines = this._myConfig.myLinesBetweenMessages;
          }
          if (scrollLinesToSkip >= messageLines + additionalEmptyLines) {
            scrollLinesToSkip -= messageLines + additionalEmptyLines;
            linesToSkip = messageLines + additionalEmptyLines;
          } else {
            linesToSkip = scrollLinesToSkip;
            scrollLinesToSkip = 0;
          }
        }
        if (i != this._myMessages.length - 1) {
          let emptyLinesToSkip = this._myConfig.myLinesBetweenMessages - Math.max(this._myConfig.myLinesBetweenMessages - linesToSkip, 0);
          let emptyLinesToShow = this._myConfig.myLinesBetweenMessages - emptyLinesToSkip;
          if (linesCount + emptyLinesToShow > this._myConfig.myMaxLines) {
            emptyLinesToShow = this._myMaxLines - linesCount;
          }
          for (let j = 0; j < emptyLinesToShow; j++) {
            consoleText = "\n".concat(consoleText);
          }
          linesCount += emptyLinesToShow;
          linesToSkip -= emptyLinesToSkip;
        }
        let linesToShow = messageLines - linesToSkip;
        if (linesCount + linesToShow > this._myConfig.myMaxLines) {
          linesToShow = this._myConfig.myMaxLines - linesCount;
        }
        if (linesToShow > 0) {
          if (message.myType == messageType) {
            let linesToPrint = message.myLines.slice(messageLines - linesToShow - linesToSkip, messageLines - linesToSkip);
            let text = linesToPrint.join("\n");
            consoleText = text.concat("\n").concat(consoleText);
            linesCount += linesToShow;
          } else {
            for (let j = 0; j < linesToShow; j++) {
              consoleText = "\n".concat(consoleText);
            }
            linesCount += linesToShow;
          }
        }
        i -= 1;
      }
    }
    consoleText = this._myConfig.myMessagesTextStartString.concat(consoleText);
    this._myUI.myMessagesTextComponents[messageType].text = consoleText;
  }
  _consolePrint(consoleFunction, sender, ...args) {
    if (!this._myActive && sender == ConsoleVRWidgetSender.CONSOLE_VR) {
      this._deactivateFix();
    }
    switch (sender) {
      case ConsoleVRWidgetSender.BROWSER_CONSOLE:
        this._myOldBrowserConsole[consoleFunction].apply(console, args);
        break;
      case ConsoleVRWidgetSender.CONSOLE_VR:
        this._myOldConsoleVR[consoleFunction].apply(Globals.getConsoleVR(this._myEngine), args);
        break;
      default:
        this._myOldBrowserConsole[consoleFunction].apply(console, args);
        break;
    }
    if (this._myActive && this._myConsolePrintAddMessageEnabled && (consoleFunction != ConsoleVRWidgetConsoleFunction.ASSERT || args.length > 0 && !args[0])) {
      this._myTextDirty = true;
      this._pulseGamepad();
      try {
        let message = this._argsToMessage(consoleFunction, ...args);
        this._addMessage(message);
        if (this._myMessages.length >= this._myConfig.myMaxMessages + this._myConfig.myMaxMessagesDeletePad) {
          this._myMessages = this._myMessages.slice(this._myMessages.length - this._myConfig.myMaxMessages);
          this._clampScrollOffset();
        }
      } catch (error4) {
        this._myConsolePrintAddMessageEnabled = false;
        this._myConsolePrintAddMessageEnabledReset = true;
        try {
          let errorMessage = "An error occurred while trying to add a new message to the Console VR Widget";
          let message = new ConsoleVRWidgetMessage(ConsoleVRWidgetMessageType.ERROR, [errorMessage]);
          this._myMessages.push(message);
          ConsoleOriginalFunctions.error(this._myEngine, errorMessage);
        } catch (anotherError) {
        }
        throw error4;
      }
    }
  }
  _argsToMessage(consoleFunction, ...args) {
    if (consoleFunction == ConsoleVRWidgetConsoleFunction.ASSERT) {
      args = args.slice(1);
      args.splice(0, 0, this._myConfig.myAssertStartString);
    }
    let messageType = this._consoleFunctionToMessageType(consoleFunction);
    let formattedText = this._formatArgs(...args);
    let lines = this._splitLongLines(formattedText);
    if (messageType == ConsoleVRWidgetMessageType.INFO) {
      messageType = ConsoleVRWidgetMessageType.LOG;
    } else if (messageType == ConsoleVRWidgetMessageType.EXCEPTION || messageType == ConsoleVRWidgetMessageType.ASSERT) {
      messageType = ConsoleVRWidgetMessageType.ERROR;
    }
    let message = new ConsoleVRWidgetMessage(messageType, lines);
    return message;
  }
  _consoleFunctionToMessageType(consoleFunction) {
    let messageType = ConsoleVRWidgetMessageType.LOG;
    if (consoleFunction < ConsoleVRWidgetConsoleFunction.INFO) {
      messageType = consoleFunction;
    } else if (consoleFunction == ConsoleVRWidgetConsoleFunction.INFO) {
      messageType = ConsoleVRWidgetMessageType.LOG;
    } else {
      messageType = ConsoleVRWidgetMessageType.ERROR;
    }
    return messageType;
  }
  // Here the formatting using placeholder like %d could be implemented in the future
  _formatArgs(...args) {
    let stringifiedArgs = [];
    for (let i = 0; i < args.length; i++) {
      if (args[i] === void 0) {
        stringifiedArgs.push("undefined");
      } else {
        stringifiedArgs.push(this._stringifyItem(args[i]));
      }
    }
    let formattedString = stringifiedArgs.join(" ");
    return formattedString;
  }
  _stringifyItem(item) {
    let stringifiedItem = null;
    if (item instanceof Error) {
      stringifiedItem = item.stack;
    } else if (typeof item == "object") {
      let linesBetweenItems = 2;
      try {
        stringifiedItem = JSON.stringify(item, this._jsonReplacer.bind(this), linesBetweenItems);
      } catch (error4) {
        let cache = /* @__PURE__ */ new WeakSet();
        stringifiedItem = JSON.stringify(item, function(key, value) {
          if (value != null && typeof value == "object") {
            if (cache.has(value)) {
              return "<stringify error: object already stringified>";
            }
            cache.add(value);
          }
          return this._jsonReplacer(key, value);
        }.bind(this), linesBetweenItems);
      }
      stringifiedItem = stringifiedItem.replaceAll('"[', "[");
      stringifiedItem = stringifiedItem.replaceAll("'[", "[");
      stringifiedItem = stringifiedItem.replaceAll(']"', "]");
      stringifiedItem = stringifiedItem.replaceAll("]'", "]");
    } else {
      stringifiedItem = item;
    }
    return stringifiedItem;
  }
  _splitLongLines(messageText) {
    let linesToSplit = messageText.split("\n");
    let lines = [];
    for (let i = 0; i < linesToSplit.length; i++) {
      let lineToSplit = linesToSplit[i];
      if (lineToSplit.length > this._myConfig.myMaxCharactersPerLine) {
        let spacesAtStart = this._getSpacesAtStart(lineToSplit);
        let spaceToAdd = this._myConfig.myTabString.concat(spacesAtStart);
        let lineSplits = 0;
        while (lineToSplit.length > this._myConfig.myMaxCharactersPerLine && lineSplits < this._myConfig.myMaxLineSplits) {
          let firstSub = lineToSplit.substr(0, this._myConfig.myMaxCharactersPerLine - 1);
          let secondSub = lineToSplit.substr(this._myConfig.myMaxCharactersPerLine - 1);
          secondSub = spaceToAdd.concat(secondSub);
          lines.push(firstSub);
          lineToSplit = secondSub;
          lineSplits++;
        }
        lines.push(lineToSplit);
      } else {
        lines.push(lineToSplit);
      }
    }
    return lines;
  }
  _getSpacesAtStart(text) {
    let spaces = "";
    let i = 0;
    while (i < text.length && text[i] == " ") {
      spaces = spaces.concat(" ");
      i++;
    }
    return spaces;
  }
  _addMessage(message) {
    let hasSameInfoAsPrev = false;
    if (this._myMessages.length > 0) {
      let lastMessage = this._myMessages[this._myMessages.length - 1];
      if (lastMessage.hasSameInfo(message)) {
        lastMessage.increaseCount();
        hasSameInfoAsPrev = true;
      }
    }
    if (!hasSameInfoAsPrev) {
      this._myMessages.push(message);
    }
    this._adjustScrollOffsetAfterMessageAdded(message, hasSameInfoAsPrev);
    this._updateNotifyIcon(message);
  }
  // If you have scrolled, new messages does not move the scroll position
  _adjustScrollOffsetAfterMessageAdded(message, hasSameInfoAsPrev) {
    if (!hasSameInfoAsPrev && !this._myTypeFilters[message.myType] && this._myScrollOffset > 0) {
      this._myScrollOffset += message.myLines.length + this._myConfig.myLinesBetweenMessages;
    }
  }
  _updateAllTexts() {
    if (this._myWidgetFrame.isVisible()) {
      for (let key in ConsoleVRWidgetMessageType) {
        this._updateText(ConsoleVRWidgetMessageType[key]);
      }
      this._myTextDirty = false;
    }
  }
  _updateNotifyIcon(message) {
    if (!this._myTypeFilters[message.myType] && this._myScrollOffset > 0) {
      this._setNotifyIconActive(true);
    }
  }
  _updateScroll(dt) {
    if (this._myScrollUp) {
      this._myScrollTimer += dt;
      while (this._myScrollTimer > this._myConfig.myScrollDelay) {
        this._myScrollTimer -= this._myConfig.myScrollDelay;
        this._myScrollOffset += this._myConfig.myScrollAmount;
      }
    } else if (this._myScrollDown) {
      this._myScrollTimer += dt;
      while (this._myScrollTimer > this._myConfig.myScrollDelay) {
        this._myScrollTimer -= this._myConfig.myScrollDelay;
        this._myScrollOffset -= this._myConfig.myScrollAmount;
      }
    }
    this._clampScrollOffset();
    if (this._myScrollUp || this._myScrollDown) {
      this._updateAllTexts();
    }
    if (this._myScrollOffset == 0) {
      this._setNotifyIconActive(false);
    }
  }
  _clampScrollOffset() {
    let maxScroll = this._getMaxScrollOffset();
    this._myScrollOffset = Math.pp_clamp(this._myScrollOffset, 0, maxScroll);
  }
  _getMaxScrollOffset() {
    return Math.max(this._getLinesCount() - this._myConfig.myMaxLines, 0);
  }
  _getLinesCount() {
    let linesCount = 0;
    for (let message of this._myMessages) {
      if (!this._myTypeFilters[message.myType]) {
        linesCount += message.myLines.length + this._myConfig.myLinesBetweenMessages;
      }
    }
    linesCount -= this._myConfig.myLinesBetweenMessages;
    linesCount = Math.max(linesCount, 0);
    return linesCount;
  }
  // Listener section
  _addListeners() {
    let ui = this._myUI;
    for (let key in ConsoleVRWidgetMessageType) {
      let cursorTarget = ui.myFilterButtonsCursorTargetComponents[ConsoleVRWidgetMessageType[key]];
      let backgroundMaterial = ui.myFilterButtonsBackgroundComponents[ConsoleVRWidgetMessageType[key]].material;
      let textMaterial = ui.myFilterButtonsTextComponents[ConsoleVRWidgetMessageType[key]].material;
      cursorTarget.onSingleClick.add(this._toggleFilter.bind(this, ConsoleVRWidgetMessageType[key], textMaterial), { id: this });
      cursorTarget.onDoubleClick.add(this._filterAllButOne.bind(this, ConsoleVRWidgetMessageType[key], textMaterial), { id: this });
      cursorTarget.onTripleClick.add(this._resetFilters.bind(this, ConsoleVRWidgetMessageType[key]), { id: this });
      cursorTarget.onHover.add(this._filterHover.bind(this, ConsoleVRWidgetMessageType[key], backgroundMaterial), { id: this });
      cursorTarget.onUnhover.add(this._filterUnhover.bind(this, ConsoleVRWidgetMessageType[key], backgroundMaterial), { id: this });
      this._myUnhoverCallbacks.push(this._filterUnhover.bind(this, ConsoleVRWidgetMessageType[key], backgroundMaterial));
    }
    {
      let cursorTarget = ui.myClearButtonCursorTargetComponent;
      let backgroundMaterial = ui.myClearButtonBackgroundComponent.material;
      cursorTarget.onClick.add(this._clearConsole.bind(this, false, null), { id: this });
      cursorTarget.onHover.add(this._genericHover.bind(this, backgroundMaterial), { id: this });
      cursorTarget.onUnhover.add(this._genericUnhover.bind(this, backgroundMaterial), { id: this });
      this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, backgroundMaterial));
    }
    {
      let cursorTarget = ui.myUpButtonCursorTargetComponent;
      let backgroundMaterial = ui.myUpButtonBackgroundComponent.material;
      cursorTarget.onDoubleClick.add(this._instantScrollUp.bind(this, true), { id: this });
      cursorTarget.onDown.add(this._setScrollUp.bind(this, true), { id: this });
      cursorTarget.onDownOnHover.add(this._setScrollUp.bind(this, true), { id: this });
      cursorTarget.onUp.add(this._setScrollUp.bind(this, false), { id: this });
      cursorTarget.onUnhover.add(() => {
        this._setScrollUp(false);
        this._genericUnhover(backgroundMaterial);
      }, { id: this });
      cursorTarget.onHover.add(this._genericHover.bind(this, backgroundMaterial), { id: this });
      this._myUnhoverCallbacks.push(() => {
        this._setScrollUp(false);
        this._genericUnhover(backgroundMaterial);
      });
    }
    {
      let cursorTarget = ui.myDownButtonCursorTargetComponent;
      let backgroundMaterial = ui.myDownButtonBackgroundComponent.material;
      cursorTarget.onDoubleClick.add(this._instantScrollDown.bind(this), { id: this });
      cursorTarget.onDown.add(this._setScrollDown.bind(this, true), { id: this });
      cursorTarget.onDownOnHover.add(this._setScrollDown.bind(this, true), { id: this });
      cursorTarget.onUp.add(this._setScrollDown.bind(this, false), { id: this });
      cursorTarget.onUnhover.add(() => {
        this._setScrollDown(false);
        this._genericUnhover(backgroundMaterial);
      }, { id: this });
      cursorTarget.onHover.add(this._genericHover.bind(this, backgroundMaterial), { id: this });
      this._myUnhoverCallbacks.push(() => {
        this._setScrollDown(false);
        this._genericUnhover(backgroundMaterial);
      });
    }
    {
      let cursorTarget = ui.myNotifyIconCursorTargetComponent;
      let backgroundMaterial = ui.myNotifyIconBackgroundComponent.material;
      cursorTarget.onClick.add(this._instantScrollDown.bind(this), { id: this });
      cursorTarget.onHover.add(this._genericHover.bind(this, backgroundMaterial), { id: this });
      cursorTarget.onUnhover.add(this._notifyIconUnhover.bind(this), { id: this });
      this._myUnhoverCallbacks.push(this._notifyIconUnhover.bind(this));
    }
    ui.myPointerCursorTargetComponent.onHover.add(this._setGamepadScrollEnabled.bind(this, true), { id: this });
    ui.myPointerCursorTargetComponent.onUnhover.add(this._setGamepadScrollEnabled.bind(this, false), { id: this });
    this._myUnhoverCallbacks.push(this._setGamepadScrollEnabled.bind(this, false));
  }
  _resetFilters(messageType) {
    if (this._myWidgetFrame.isVisible()) {
      for (let key in ConsoleVRWidgetMessageType) {
        let backgroundMaterial = this._myUI.myFilterButtonsBackgroundComponents[ConsoleVRWidgetMessageType[key]].material;
        let filterTextMaterial = this._myUI.myFilterButtonsTextComponents[ConsoleVRWidgetMessageType[key]].material;
        this._myTypeFilters[ConsoleVRWidgetMessageType[key]] = false;
        filterTextMaterial.color = this._myConfig.myMessageTypeColors[ConsoleVRWidgetMessageType[key]];
        if (ConsoleVRWidgetMessageType[key] != messageType) {
          backgroundMaterial.color = this._myConfig.myBackgroundColor;
        }
      }
      this._clampScrollOffset();
      this._updateAllTexts();
    }
  }
  _filterAllButOne(messageType, forceFilter = false) {
    if (this._myWidgetFrame.isVisible() || forceFilter) {
      for (let key in ConsoleVRWidgetMessageType) {
        let backgroundMaterial = this._myUI.myFilterButtonsBackgroundComponents[ConsoleVRWidgetMessageType[key]].material;
        let filterTextMaterial = this._myUI.myFilterButtonsTextComponents[ConsoleVRWidgetMessageType[key]].material;
        if (ConsoleVRWidgetMessageType[key] != messageType) {
          this._myTypeFilters[ConsoleVRWidgetMessageType[key]] = true;
          backgroundMaterial.color = this._myConfig.myFilterButtonDisabledBackgroundColor;
          filterTextMaterial.color = this._myConfig.myFilterButtonDisabledTextColor;
        } else {
          this._myTypeFilters[ConsoleVRWidgetMessageType[key]] = false;
          filterTextMaterial.color = this._myConfig.myMessageTypeColors[messageType];
        }
      }
      this._clampScrollOffset();
      this._updateAllTexts();
    }
  }
  _toggleFilter(messageType, textMaterial) {
    if (this._myWidgetFrame.isVisible()) {
      this._myTypeFilters[messageType] = !this._myTypeFilters[messageType];
      if (this._myTypeFilters[messageType]) {
        textMaterial.color = this._myConfig.myFilterButtonDisabledTextColor;
      } else {
        textMaterial.color = this._myConfig.myMessageTypeColors[messageType];
      }
      this._clampScrollOffset();
      this._updateAllTexts();
    }
  }
  _clearConsole(codeDrivenClear = false, sender = null) {
    if (this._myWidgetFrame.isVisible() || codeDrivenClear) {
      this._myMessages = [];
      this._clampScrollOffset();
      this._updateAllTexts();
      if (codeDrivenClear) {
        switch (sender) {
          case ConsoleVRWidgetSender.BROWSER_CONSOLE:
            this._myOldBrowserConsoleClear.apply(console);
            break;
          case ConsoleVRWidgetSender.CONSOLE_VR:
            this._myOldConsoleVRClear.apply(Globals.getConsoleVR(this._myEngine));
            break;
          default:
            break;
        }
      } else if (this._myConfig.myClearBrowserConsoleWhenClearPressed) {
        ConsoleOriginalFunctions.clear(this._myEngine);
      }
    }
  }
  _setScrollUp(value) {
    if (this._myWidgetFrame.isVisible() || !value) {
      if (value) {
        this._myScrollTimer = 0;
      }
      this._myScrollUp = value;
    }
  }
  _setScrollDown(value) {
    if (this._myWidgetFrame.isVisible() || !value) {
      if (value) {
        this._myScrollTimer = 0;
      }
      this._myScrollDown = value;
    }
  }
  _instantScrollUp() {
    if (this._myWidgetFrame.isVisible()) {
      this._myScrollOffset = this._getMaxScrollOffset();
      this._updateAllTexts();
    }
  }
  _instantScrollDown() {
    if (this._myWidgetFrame.isVisible()) {
      this._myScrollOffset = 0;
      this._setNotifyIconActive(false);
      this._updateAllTexts();
    }
  }
  _setNotifyIconActive(active) {
    this._myUI.myNotifyIconPanel.pp_setActive(active && this._myWidgetFrame.isVisible());
  }
  _notifyIconUnhover() {
    let material = this._myUI.myNotifyIconBackgroundComponent.material;
    material.color = this._myConfig.myNotifyIconColor;
  }
  _filterHover(messageType, material) {
    this._genericHover(material);
  }
  _filterUnhover(messageType, material) {
    if (this._myTypeFilters[messageType]) {
      material.color = this._myConfig.myFilterButtonDisabledBackgroundColor;
    } else {
      material.color = this._myConfig.myBackgroundColor;
    }
  }
  _genericHover(material) {
    material.color = this._myConfig.myButtonHoverColor;
  }
  _genericUnhover(material) {
    material.color = this._myConfig.myBackgroundColor;
  }
  // Gamepad section
  _updateGamepadsExtraActions(dt) {
    if (this._myLeftGamepad && this._myRightGamepad) {
      if (this._myLeftGamepad.getButtonInfo(GamepadButtonID.THUMBSTICK).isPressStart() && this._myRightGamepad.getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed() || this._myRightGamepad.getButtonInfo(GamepadButtonID.THUMBSTICK).isPressStart() && this._myLeftGamepad.getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed()) {
        this._toggleVisibility();
      }
      this._myPulseTimer = Math.max(this._myPulseTimer - dt, 0);
      this._updateScrollWithThumbstick(dt);
    }
  }
  _toggleVisibility() {
    this._myWidgetFrame.toggleVisibility();
  }
  _widgetVisibleChanged(visible) {
    this._myUI.setVisible(visible);
    for (const unhoverCallback of this._myUnhoverCallbacks) {
      unhoverCallback();
    }
    if (visible) {
      this._updateAllTexts();
    }
  }
  _updateScrollWithThumbstick(dt) {
    if (this._myWidgetFrame.isVisible() && this._myGamepadScrollEnabled) {
      let axes = vec2_create(0, 0);
      if (this._myConfig.myScrollThumbstickHandedness == ToolHandedness.LEFT) {
        axes = this._myLeftGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes;
      } else if (this._myConfig.myScrollThumbstickHandedness == ToolHandedness.RIGHT) {
        axes = this._myRightGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes;
      }
      if (Math.abs(axes[1]) > this._myConfig.myScrollThumbstickMinThreshold) {
        this._myScrollThumbstickTimer += dt;
        while (this._myScrollThumbstickTimer > this._myConfig.myScrollThumbstickDelay) {
          this._myScrollThumbstickTimer -= this._myConfig.myScrollThumbstickDelay;
          let normalizedScrollAmount = (Math.abs(axes[1]) - this._myConfig.myScrollThumbstickMinThreshold) / (1 - this._myConfig.myScrollThumbstickMinThreshold);
          this._myScrollOffset += Math.sign(axes[1]) * normalizedScrollAmount * this._myConfig.myScrollThumbstickAmount;
        }
        this._clampScrollOffset();
        this._updateAllTexts();
      } else {
        this._myScrollThumbstickTimer = 0;
      }
    }
  }
  _pulseGamepad() {
    if (this._myLeftGamepad && this._myRightGamepad) {
      let pulseType = this._myParams.myPulseOnNewMessage;
      let pulseEnabled = pulseType == ConsoleVRWidgetPulseOnNewMessage.ALWAYS || !this._myWidgetFrame.isVisible() && pulseType == ConsoleVRWidgetPulseOnNewMessage.WHEN_HIDDEN;
      if (pulseEnabled && this._myPulseTimer == 0) {
        if (this._myParams.myHandedness == ToolHandedness.RIGHT) {
          this._myRightGamepad.pulse(this._myConfig.myPulseIntensity, this._myConfig.myPulseDuration);
        } else {
          this._myLeftGamepad.pulse(this._myConfig.myPulseIntensity, this._myConfig.myPulseDuration);
        }
        this._myPulseTimer = this._myConfig.myPulseDelay;
      }
    }
  }
  _isSimpleArray(array) {
    if (this._isSpecialSimpleArray(array)) {
      return true;
    } else if (Array.isArray(array)) {
      let builtInArray = true;
      for (let element of array) {
        if (element instanceof Object) {
          builtInArray = false;
          break;
        }
      }
      return builtInArray;
    }
    return false;
  }
  _isSpecialSimpleArray(item) {
    return item && item.constructor && (item.constructor.name == "Uint8ClampedArray" || item.constructor.name == "Uint8Array" || item.constructor.name == "Uint16Array" || item.constructor.name == "Uint32Array" || item.constructor.name == "Int8Array" || item.constructor.name == "Int16Array" || item.constructor.name == "Int32Array" || item.constructor.name == "Float32Array" || item.constructor.name == "Float64Array");
  }
  _setGamepadScrollEnabled(enabled) {
    this._myGamepadScrollEnabled = enabled;
    if (!this._myConfig.myGamepadScrollOnlyOnHover) {
      this._myGamepadScrollEnabled = true;
    }
  }
  _jsonReplacer(key, value) {
    if (value instanceof Map) {
      return Array.from(value.entries());
    } else if (this._isSimpleArray(value)) {
      let array = value;
      if (this._isSpecialSimpleArray(array)) {
        let arrayCopy = [];
        for (let i = 0; i < array.length; i++) {
          arrayCopy[i] = array[i];
        }
        array = arrayCopy;
      }
      let stringifiedArray = JSON.stringify(array);
      stringifiedArray = stringifiedArray.split(",").join(", ");
      return stringifiedArray;
    } else {
      return value;
    }
  }
  _deactivateFix() {
    if (this._myParams.myResetToConsoleOriginalFunctionsOnDeactivate || this._myParams.myResetToOverwrittenConsoleFunctionsOnDeactivate) {
      if (this._myParams.myResetToConsoleOriginalFunctionsOnDeactivate) {
        Globals.getConsoleVR(this._myEngine).log = ConsoleVR.myOriginalLog;
        Globals.getConsoleVR(this._myEngine).error = ConsoleVR.myOriginalError;
        Globals.getConsoleVR(this._myEngine).warn = ConsoleVR.myOriginalWarn;
        Globals.getConsoleVR(this._myEngine).info = ConsoleVR.myOriginalInfo;
        Globals.getConsoleVR(this._myEngine).debug = ConsoleVR.myOriginalDebug;
        Globals.getConsoleVR(this._myEngine).assert = ConsoleVR.myOriginalAssert;
        Globals.getConsoleVR(this._myEngine).clear = ConsoleVR.myOriginalClear;
      } else if (this._myParams.myResetToOverwrittenConsoleFunctionsOnDeactivate) {
        Globals.getConsoleVR(this._myEngine).log = this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.LOG];
        Globals.getConsoleVR(this._myEngine).error = this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.ERROR];
        Globals.getConsoleVR(this._myEngine).warn = this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.WARN];
        Globals.getConsoleVR(this._myEngine).info = this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.INFO];
        Globals.getConsoleVR(this._myEngine).debug = this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.DEBUG];
        Globals.getConsoleVR(this._myEngine).assert = this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.ASSERT];
        Globals.getConsoleVR(this._myEngine).clear = this._myOldConsoleVRClear;
      }
      this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.LOG] = Globals.getConsoleVR(this._myEngine).log;
      this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.ERROR] = Globals.getConsoleVR(this._myEngine).error;
      this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.WARN] = Globals.getConsoleVR(this._myEngine).warn;
      this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.INFO] = Globals.getConsoleVR(this._myEngine).info;
      this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.DEBUG] = Globals.getConsoleVR(this._myEngine).debug;
      this._myOldConsoleVR[ConsoleVRWidgetConsoleFunction.ASSERT] = Globals.getConsoleVR(this._myEngine).assert;
      this._myOldConsoleVRClear = Globals.getConsoleVR(this._myEngine).clear;
    }
  }
  destroy() {
    this._myDestroyed = true;
    this._myUI.destroy();
    this._myWidgetFrame.destroy();
    if (this._myParams.myResetToConsoleOriginalFunctionsOnDestroy) {
      console.log = ConsoleOriginalFunctions.getLog(this._myEngine);
      console.error = ConsoleOriginalFunctions.getError(this._myEngine);
      console.warn = ConsoleOriginalFunctions.getWarn(this._myEngine);
      console.info = ConsoleOriginalFunctions.getInfo(this._myEngine);
      console.debug = ConsoleOriginalFunctions.getDebug(this._myEngine);
      console.assert = ConsoleOriginalFunctions.getAssert(this._myEngine);
      console.clear = ConsoleOriginalFunctions.getClear(this._myEngine);
      Globals.getConsoleVR(this._myEngine).log = ConsoleVR.myOriginalLog;
      Globals.getConsoleVR(this._myEngine).error = ConsoleVR.myOriginalError;
      Globals.getConsoleVR(this._myEngine).warn = ConsoleVR.myOriginalWarn;
      Globals.getConsoleVR(this._myEngine).info = ConsoleVR.myOriginalInfo;
      Globals.getConsoleVR(this._myEngine).debug = ConsoleVR.myOriginalDebug;
      Globals.getConsoleVR(this._myEngine).assert = ConsoleVR.myOriginalAssert;
      Globals.getConsoleVR(this._myEngine).clear = ConsoleVR.myOriginalClear;
    } else if (this._myParams.myResetToOverwrittenConsoleFunctionsOnDestroy) {
      console.log = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.LOG];
      console.error = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.ERROR];
      console.warn = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.WARN];
      console.info = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.INFO];
      console.debug = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.DEBUG];
      console.assert = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.ASSERT];
      console.clear = this._myOldBrowserConsoleClear;
      Globals.getConsoleVR(this._myEngine).log = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.LOG];
      Globals.getConsoleVR(this._myEngine).error = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.ERROR];
      Globals.getConsoleVR(this._myEngine).warn = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.WARN];
      Globals.getConsoleVR(this._myEngine).info = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.INFO];
      Globals.getConsoleVR(this._myEngine).debug = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.DEBUG];
      Globals.getConsoleVR(this._myEngine).assert = this._myOldBrowserConsole[ConsoleVRWidgetConsoleFunction.ASSERT];
      Globals.getConsoleVR(this._myEngine).clear = this._myOldConsoleVRClear;
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/tool/console_vr/components/console_vr_tool_component.js
import { Component as Component64, Property as Property43 } from "@wonderlandengine/api";
var ConsoleVRToolComponent = class extends Component64 {
  static TypeName = "pp-console-vr-tool";
  static Properties = {
    _myHandedness: Property43.enum(["None", "Left", "Right"], "None"),
    _myOverrideBrowserConsoleFunctions: Property43.enum(["None", "All", "Errors & Warns"], "All"),
    _myEnableOnlyForVR: Property43.bool(true),
    _myShowOnStart: Property43.bool(false),
    _myShowVisibilityButton: Property43.bool(false),
    _myFilterByError: Property43.bool(false),
    _myPulseOnNewMessage: Property43.enum(["Never", "Always", "When Hidden"], "Never")
  };
  _start() {
    this._myWidget = new ConsoleVRWidget(this.engine);
    let params = new ConsoleVRWidgetParams(this.engine);
    params.myHandedness = [null, "left", "right"][this._myHandedness];
    params.myOverrideBrowserConsoleFunctions = this._myOverrideBrowserConsoleFunctions;
    params.myShowOnStart = this._myShowOnStart;
    params.myShowVisibilityButton = this._myShowVisibilityButton;
    params.myFilterByError = this._myFilterByError;
    params.myPulseOnNewMessage = this._myPulseOnNewMessage;
    params.myPlaneMaterial = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
    params.myTextMaterial = Globals.getDefaultMaterials(this.engine).myText.clone();
    this._myWidget.start(this.object, params);
    this._myStarted = true;
    if (!Globals.hasConsoleVRWidget(this.engine)) {
      Globals.setConsoleVRWidget(this._myWidget, this.engine);
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine) && (!Globals.hasConsoleVRWidget(this.engine) || Globals.getConsoleVRWidget(this.engine) == this._myWidget)) {
      if (!this._myStarted) {
        this._start();
      }
      if (!this._myEnableOnlyForVR || XRUtils.isSessionActive(this.engine)) {
        this._myWidget.setActive(true);
        this._myWidget.update(dt);
      } else {
        this._myWidget.setActive(false);
      }
    } else if (this._myStarted) {
      this._myWidget.setActive(false);
    }
  }
  onActivate() {
    if (this._myStarted) {
      if (!Globals.hasConsoleVRWidget(this.engine)) {
        Globals.setConsoleVRWidget(this._myWidget, this.engine);
      }
    }
  }
  onDeactivate() {
    if (this._myStarted) {
      this._myWidget.setActive(false);
      if (Globals.getConsoleVRWidget(this.engine) == this._myWidget) {
        Globals.removeConsoleVRWidget(this.engine);
      }
    }
  }
  onDestroy() {
    if (this._myStarted) {
      this._myWidget.destroy();
    }
  }
};

// dist/pp/tool/easy_tune/components/easy_tune_tool_component.js
import { Component as Component65, property as property12 } from "@wonderlandengine/api";

// dist/pp/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_widget.js
import { Emitter as Emitter15 } from "@wonderlandengine/api";
var EasyTuneBaseWidgetParams = class {
  constructor() {
    this.myVariablesImportCallback = null;
    this.myVariablesExportCallback = null;
  }
};
var EasyTuneBaseWidget = class {
  constructor(params) {
    this._myConfig = null;
    this._myUI = null;
    this._myParams = params;
    this._myVariable = null;
    this._myVisible = true;
    this._myScrollVariableRequestEmitter = new Emitter15();
    this._myAppendToVariableName = "";
    this._myScrollVariableActive = false;
    this._myScrollDirection = 0;
    this._myScrollVariableTimer = 0;
    this._myHasScrolled = false;
    this._myResetImportLabelTimer = new Timer(0, false);
    this._myResetExportLabelTimer = new Timer(0, false);
    this._myUnhoverCallbacks = [];
    this._myDestroyed = false;
  }
  setVisible(visible) {
    if (visible) {
      this._refreshUI();
    }
    this._myUI.setVisible(visible);
    if (this._myVisible != visible) {
      for (const unhoverCallback of this._myUnhoverCallbacks) {
        unhoverCallback();
      }
    }
    this._myVisible = visible;
  }
  setEasyTuneVariable(variable, appendToVariableName) {
    if (this._myVariable != variable || this._myAppendToVariableName != appendToVariableName) {
      this._myVariable = variable;
      if (appendToVariableName != null) {
        this._myAppendToVariableName = appendToVariableName;
      } else {
        this._myAppendToVariableName = "";
      }
      this._setEasyTuneVariableHook();
      this._refreshUI();
    }
  }
  isScrollVariableActive() {
    return this._myScrollVariableActive;
  }
  getScrollVariableDirection() {
    return this._myScrollDirection;
  }
  setScrollVariableActive(active, scrollDirection) {
    this._myScrollVariableActive = active;
    this._myScrollDirection = scrollDirection;
    this._myScrollVariableTimer = this._myConfig.myScrollVariableDelay;
    this._myHasScrolled = false;
  }
  getWidget() {
    return this;
  }
  syncWidget(otherEasyTuneWidget) {
    if (otherEasyTuneWidget != null) {
      if (otherEasyTuneWidget._myResetImportLabelTimer.isRunning()) {
        this._myResetImportLabelTimer.start(otherEasyTuneWidget._myResetImportLabelTimer.getTimeLeft());
      } else {
        this._myResetImportLabelTimer.reset();
      }
      if (otherEasyTuneWidget._myResetExportLabelTimer.isRunning()) {
        this._myResetExportLabelTimer.start(otherEasyTuneWidget._myResetExportLabelTimer.getTimeLeft());
      } else {
        this._myResetExportLabelTimer.reset();
      }
      this._myUI.myImportButtonTextComponent.text = otherEasyTuneWidget._myUI.myImportButtonTextComponent.text;
      this._myUI.myExportButtonTextComponent.text = otherEasyTuneWidget._myUI.myExportButtonTextComponent.text;
      this.setScrollVariableActive(otherEasyTuneWidget.isScrollVariableActive(), otherEasyTuneWidget.getScrollVariableDirection());
    } else {
      this._myResetImportLabelTimer.reset();
      this._myUI.myImportButtonTextComponent.text = this._myConfig.myImportButtonText;
      this._myResetExportLabelTimer.reset();
      this._myUI.myExportButtonTextComponent.text = this._myConfig.myExportButtonText;
    }
  }
  onImportSuccess() {
    this._myUI.myImportButtonTextComponent.text = this._myConfig.myImportSuccessButtonText;
    this._myResetImportLabelTimer.start(this._myConfig.myImportExportResetLabelSeconds);
  }
  onImportFailure() {
    this._myUI.myImportButtonTextComponent.text = this._myConfig.myImportFailureButtonText;
    this._myResetImportLabelTimer.start(this._myConfig.myImportExportResetLabelSeconds);
  }
  onExportSuccess() {
    this._myUI.myExportButtonTextComponent.text = this._myConfig.myExportSuccessButtonText;
    this._myResetExportLabelTimer.start(this._myConfig.myImportExportResetLabelSeconds);
  }
  onExportFailure() {
    this._myUI.myExportButtonTextComponent.text = this._myConfig.myExportFailureButtonText;
    this._myResetExportLabelTimer.start(this._myConfig.myImportExportResetLabelSeconds);
  }
  registerScrollVariableRequestEventListener(id, listener) {
    this._myScrollVariableRequestEmitter.add(listener, { id });
  }
  unregisterScrollVariableRequestEventListener(id) {
    this._myScrollVariableRequestEmitter.remove(id);
  }
  start(parentObject, easyTuneParams) {
    this._myConfig.build();
    this._myResetImportLabelTimer.reset(this._myConfig.myImportExportResetLabelSeconds);
    this._myResetExportLabelTimer.reset(this._myConfig.myImportExportResetLabelSeconds);
    this._myUI.build(parentObject, this._myConfig, easyTuneParams);
    this._myUI.setImportExportButtonsVisible(easyTuneParams.myShowVariablesImportExportButtons);
    this._startHook(parentObject, easyTuneParams);
    this._addListeners();
  }
  update(dt) {
    if (this._isActive()) {
      this._updateHook(dt);
      this._updateScrollVariable(dt);
      this._updateImportExportLabel(dt);
    }
  }
  // Hooks
  _setEasyTuneVariableHook() {
  }
  _refreshUIHook() {
  }
  _startHook(parentObject, easyTuneParams) {
  }
  _addListenersHook() {
  }
  _updateHook(dt) {
  }
  // Hooks end
  _refreshUI() {
    if (this._myVariable) {
      if (this._myVariable.getName() != null) {
        this._myUI.myVariableLabelTextComponent.text = this._myVariable.getName().concat(this._myAppendToVariableName);
      } else {
        let name = "Unknown";
        this._myUI.myVariableLabelTextComponent.text = name.concat(this._myAppendToVariableName);
      }
      this._refreshUIHook();
    }
  }
  _updateScrollVariable(dt) {
    if (this._myScrollVariableActive) {
      if (this._myScrollVariableTimer <= 0) {
        this._scrollVariableRequest(this._myScrollDirection);
        this._myScrollVariableTimer = this._myConfig.myScrollVariableDelay;
        this._myHasScrolled = true;
      } else {
        this._myScrollVariableTimer -= dt;
      }
    }
  }
  _updateImportExportLabel(dt) {
    if (this._myResetImportLabelTimer.isRunning(dt)) {
      this._myResetImportLabelTimer.update(dt);
      if (this._myResetImportLabelTimer.isDone()) {
        this._myResetImportLabelTimer.reset();
        this._myUI.myImportButtonTextComponent.text = this._myConfig.myImportButtonText;
      }
    }
    if (this._myResetExportLabelTimer.isRunning(dt)) {
      this._myResetExportLabelTimer.update(dt);
      if (this._myResetExportLabelTimer.isDone()) {
        this._myResetExportLabelTimer.reset();
        this._myUI.myExportButtonTextComponent.text = this._myConfig.myExportButtonText;
      }
    }
  }
  _isActive() {
    return this._myVisible && this._myVariable;
  }
  _addListeners() {
    let ui = this._myUI;
    this._myUnhoverCallbacks = [];
    ui.myNextButtonCursorTargetComponent.onDown.add(this._setScrollVariableActive.bind(this, true, 1, false));
    ui.myNextButtonCursorTargetComponent.onDownOnHover.add(this._setScrollVariableActive.bind(this, true, 1, false));
    ui.myNextButtonCursorTargetComponent.onUpWithDown.add(this._setScrollVariableActive.bind(this, false, 0, false));
    ui.myNextButtonCursorTargetComponent.onUpWithNoDown.add(this._setScrollVariableActive.bind(this, false, 0, true));
    ui.myNextButtonCursorTargetComponent.onUnhover.add(this._setScrollVariableActive.bind(this, false, 0, true));
    ui.myNextButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myNextButtonBackgroundComponent.material));
    ui.myNextButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myNextButtonBackgroundComponent.material));
    this._myUnhoverCallbacks.push(this._setScrollVariableActive.bind(this, false, 0, true));
    this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myNextButtonBackgroundComponent.material));
    ui.myPreviousButtonCursorTargetComponent.onDown.add(this._setScrollVariableActive.bind(this, true, -1, false));
    ui.myPreviousButtonCursorTargetComponent.onDownOnHover.add(this._setScrollVariableActive.bind(this, true, -1, false));
    ui.myPreviousButtonCursorTargetComponent.onUpWithDown.add(this._setScrollVariableActive.bind(this, false, 0, false));
    ui.myPreviousButtonCursorTargetComponent.onUpWithNoDown.add(this._setScrollVariableActive.bind(this, false, 0, true));
    ui.myPreviousButtonCursorTargetComponent.onUnhover.add(this._setScrollVariableActive.bind(this, false, 0, true));
    ui.myPreviousButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myPreviousButtonBackgroundComponent.material));
    ui.myPreviousButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myPreviousButtonBackgroundComponent.material));
    this._myUnhoverCallbacks.push(this._setScrollVariableActive.bind(this, false, 0, true));
    this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myPreviousButtonBackgroundComponent.material));
    ui.myImportButtonCursorTargetComponent.onUpWithDown.add(this._importVariables.bind(this));
    ui.myImportButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myImportButtonBackgroundComponent.material));
    ui.myImportButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myImportButtonBackgroundComponent.material));
    this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myImportButtonBackgroundComponent.material));
    ui.myExportButtonCursorTargetComponent.onUpWithDown.add(this._exportVariables.bind(this));
    ui.myExportButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myExportButtonBackgroundComponent.material));
    ui.myExportButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myExportButtonBackgroundComponent.material));
    this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myExportButtonBackgroundComponent.material));
    this._addListenersHook();
  }
  _setScrollVariableActive(active, scrollDirection, skipForceScroll) {
    if (this._isActive() || !active) {
      let forceScroll = !active && !this._myHasScrolled && !skipForceScroll;
      let oldScrollDirection = this._myScrollDirection;
      this.setScrollVariableActive(active, scrollDirection);
      if (forceScroll) {
        this._scrollVariableRequest(oldScrollDirection);
      }
    }
  }
  _scrollVariableRequest(amount) {
    if (this._isActive() && amount != 0) {
      this._myScrollVariableRequestEmitter.notify(amount);
    }
  }
  _genericHover(material) {
    material.color = this._myConfig.myButtonHoverColor;
  }
  _genericUnhover(material) {
    material.color = this._myConfig.myBackgroundColor;
  }
  _importVariables() {
    if (this._myUI.myImportButtonTextComponent.text == this._myConfig.myImportButtonText) {
      this._myUI.myImportButtonTextComponent.text = this._myConfig.myImportingButtonText;
      this._myResetImportLabelTimer.reset();
      this._myParams.myVariablesImportCallback();
    }
  }
  _exportVariables() {
    if (this._myUI.myExportButtonTextComponent.text == this._myConfig.myExportButtonText) {
      this._myUI.myExportButtonTextComponent.text = this._myConfig.myExportingButtonText;
      this._myResetExportLabelTimer.reset();
      this._myParams.myVariablesExportCallback();
    }
  }
  setActive(active) {
    this._myUI.setActive(active);
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
    if (this._myUI != null) {
      this._myUI.destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_array_widget_selector.js
import { Emitter as Emitter16 } from "@wonderlandengine/api";
var EasyTuneBaseArrayWidgetSelector = class {
  constructor(params, gamepad, engine = Globals.getMainEngine()) {
    this._myGamepad = gamepad;
    this._myParentObject = null;
    this._myParams = params;
    this._myEasyTuneParams = null;
    this._myWidgets = /* @__PURE__ */ new Map();
    this._myVariable = null;
    this._myVisible = true;
    this._myAppendToVariableName = null;
    this._myScrollVariableRequestEmitter = new Emitter16();
    this._myCurrentArraySize = null;
    this._myEngine = engine;
    this._myActive = true;
    this._myDestroyed = false;
  }
  setEasyTuneVariable(variable, appendToVariableName, skipSetVisible = false) {
    this._myVariable = variable;
    this._myCurrentArraySize = this._myVariable.getValue().length;
    this._myAppendToVariableName = appendToVariableName;
    if (!this._myWidgets.has(this._myCurrentArraySize)) {
      this._createWidget(this._myCurrentArraySize);
    }
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.setEasyTuneVariable(variable, appendToVariableName);
    }
    if (!skipSetVisible) {
      this.setVisible(this._myVisible);
    }
  }
  setVisible(visible) {
    if (this._myVariable) {
      this._sizeChangedCheck(true);
      let currentWidget = this._myWidgets.get(this._myCurrentArraySize);
      for (let widget of this._myWidgets.values()) {
        if (currentWidget != widget) {
          widget.setVisible(false);
        }
      }
      if (currentWidget) {
        currentWidget.setVisible(visible);
      }
    } else {
      for (let widget of this._myWidgets.values()) {
        widget.setVisible(false);
      }
    }
    this._myVisible = visible;
  }
  isScrollVariableActive() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      return widget.isScrollVariableActive();
    }
    return false;
  }
  getScrollVariableDirection() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      return widget.getScrollVariableDirection();
    }
    return 0;
  }
  setScrollVariableActive(active, scrollDirection) {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.setScrollVariableActive(active, scrollDirection);
    }
  }
  getWidget() {
    return this._myWidgets.get(this._myCurrentArraySize);
  }
  registerScrollVariableRequestEventListener(id, listener) {
    this._myScrollVariableRequestEmitter.add(listener, { id });
  }
  unregisterScrollVariableRequestEventListener(id) {
    this._myScrollVariableRequestEmitter.remove(id);
  }
  start(parentObject, easyTuneParams) {
    this._myParentObject = parentObject;
    this._myEasyTuneParams = easyTuneParams;
    this._createWidget(1);
    if (this._myVariable) {
      this.setEasyTuneVariable(this._myVariable, this._myAppendToVariableName);
    }
  }
  update(dt) {
    if (this._isActive()) {
      this._sizeChangedCheck();
      let widget = this._myWidgets.get(this._myCurrentArraySize);
      if (widget) {
        widget.update(dt);
      }
    }
  }
  onImportSuccess() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.onImportSuccess();
    }
  }
  onImportFailure() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.onImportFailure();
    }
  }
  onExportSuccess() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.onExportSuccess();
    }
  }
  onExportFailure() {
    let widget = this._myWidgets.get(this._myCurrentArraySize);
    if (widget) {
      widget.onExportFailure();
    }
  }
  _isActive() {
    return this._myVisible && this._myVariable;
  }
  _scrollVariableRequest(amount) {
    this._myScrollVariableRequestEmitter.notify(amount);
  }
  _createWidget(arraySize) {
    this._myWidgets.set(arraySize, this._getEasyTuneArrayWidget(arraySize));
    this._myWidgets.get(arraySize).start(this._myParentObject, this._myEasyTuneParams);
    this._myWidgets.get(arraySize).setVisible(false);
    this._myWidgets.get(arraySize).registerScrollVariableRequestEventListener(this, this._scrollVariableRequest.bind(this));
    this._myWidgets.get(arraySize).setActive(this._myActive);
  }
  _sizeChangedCheck(skipSetVisible = false) {
    if (this._myVariable.getValue().length != this._myCurrentArraySize) {
      this.setEasyTuneVariable(this._myVariable, this._myAppendToVariableName, skipSetVisible);
    }
  }
  /**
   * TS type inference helper
   *
   * @returns {any}
   */
  _getEasyTuneArrayWidget(arraySize) {
    return null;
  }
  setActive(active) {
    this._myActive = active;
    for (let widget of this._myWidgets.values()) {
      widget.setActive(active);
    }
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
    for (let widget of this._myWidgets.values()) {
      widget.destroy();
    }
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_widget_config.js
import { Alignment as Alignment8, Collider as Collider4, VerticalAlignment as VerticalAlignment8 } from "@wonderlandengine/api";
var EasyTuneBaseWidgetConfig = class {
  constructor() {
  }
  build() {
    this._setupBuildConfig();
    this._setupRuntimeConfig();
  }
  // Hooks
  _getBackPanelMaxY() {
    return this.myDisplayPanelPosition[1] + this.myVariableLabelPanelPosition[1] + this.mySideButtonBackgroundScale[1] + this._mySideButtonDistanceFromBorder * 1.25;
  }
  _getBackPanelMinY() {
    return this.myDisplayPanelPosition[1] - this._mySideButtonDistanceFromBorder * 1.25 - this.mySideButtonBackgroundScale[1];
  }
  _getBackPanelMaxX() {
    return this._mySideButtonPanelHalfWidth;
  }
  _getBackPanelMinX() {
    return -this._mySideButtonPanelHalfWidth;
  }
  // Small Z offset to avoid glitching with other widgets
  _getPivotZOffset() {
    return 0;
  }
  _setupBuildConfigHook() {
  }
  _setupRuntimeConfigHook() {
  }
  // Hooks end
  _setupBuildConfig() {
    this.myBackgroundColor = vec4_create(46 / 255, 46 / 255, 46 / 255, 1);
    this.myCursorTargetCollisionCollider = Collider4.Box;
    this.myCursorTargetCollisionGroup = 7;
    this.myCursorTargetCollisionThickness = 1e-3;
    this.myDefaultTextColor = vec4_create(255 / 255, 255 / 255, 255 / 255, 1);
    this.myTextAlignment = Alignment8.Center;
    this.myTextVerticalAlignment = VerticalAlignment8.Middle;
    this.myTextColor = this.myDefaultTextColor;
    this.myLabelTextScale = vec3_create(0.18, 0.18, 0.18);
    this.myButtonTextScale = vec3_create(0.18, 0.18, 0.18);
    this._myPanelZOffset = 0.01;
    this._myColliderZOffset = 0.017;
    this._mySideButtonDistanceFromBorder = 0.0125;
    this._mySideButtonPanelHalfWidth = 0.2;
    this.myPivotObjectPositions = [];
    this.myPivotObjectPositions[ToolHandedness.NONE] = vec3_create(0, 0, this._getPivotZOffset());
    this.myPivotObjectPositions[ToolHandedness.LEFT] = vec3_create(-0.04, 0.02, this._getPivotZOffset());
    this.myPivotObjectPositions[ToolHandedness.RIGHT] = vec3_create(-0.08, 0.02, this._getPivotZOffset());
    this.mySideButtonBackgroundScale = vec3_create(0.015, 0.015, 1);
    this.mySideButtonTextScale = this.myButtonTextScale;
    this.mySideButtonTextPosition = vec3_create(0, 0, 7e-3);
    this.mySideButtonCursorTargetPosition = vec3_create(0, 0, 0);
    this.mySideButtonCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.mySideButtonCollisionExtents = this.mySideButtonBackgroundScale.pp_clone();
    this.mySideButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myLeftSideButtonPosition = vec3_create(0, 0, -1e-5);
    this.myLeftSideButtonPosition[0] = -this._mySideButtonPanelHalfWidth + this.mySideButtonBackgroundScale[0] + this._mySideButtonDistanceFromBorder;
    this.myRightSideButtonPosition = vec3_create(0, 0, -1e-5);
    this.myRightSideButtonPosition[0] = -this.myLeftSideButtonPosition[0];
    this.myDisplayPanelPosition = vec3_create(0, 0.1, 0);
    this.myVariableLabelPanelPosition = vec3_create(0, 0.025, this._myPanelZOffset);
    this.myVariableLabelTextScale = this.myLabelTextScale;
    this.myVariableLabelCursorTargetPosition = vec3_create(0, 0, 0);
    this.myVariableLabelCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myVariableLabelCollisionExtents = vec3_create(0.065, 0.0175, 1);
    this.myVariableLabelCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myNextButtonText = ">";
    this.myPreviousButtonText = "<";
    this._setupBuildConfigHook();
    {
      let maxX = this._getBackPanelMaxX();
      let minX = this._getBackPanelMinX();
      let maxY = this._getBackPanelMaxY();
      let minY = this._getBackPanelMinY();
      this.myBackPanelPosition = [(maxX + minX) / 2, (maxY + minY) / 2, 0];
      this.myBackBackgroundScale = [(maxX - minX) / 2, (maxY - minY) / 2, 1];
      this.myBackBackgroundColor = vec4_create(70 / 255, 70 / 255, 70 / 255, 1);
    }
    this.myImportExportButtonBackgroundScale = vec3_create(0.04, 0.02, 1);
    this.myImportExportButtonTextScale = this.myButtonTextScale;
    this.myImportExportButtonTextPosition = vec3_create(0, 0, 7e-3);
    this.myImportExportPanelPosition = [0, this._getBackPanelMaxY() + this._mySideButtonDistanceFromBorder + this.myImportExportButtonBackgroundScale[1], this._myPanelZOffset];
    this.myImportExportButtonCursorTargetPosition = vec3_create(0, 0, 0);
    this.myImportExportButtonCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myImportExportButtonCollisionExtents = this.myImportExportButtonBackgroundScale.pp_clone();
    this.myImportExportButtonCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myImportButtonText = "Import";
    this.myExportButtonText = "Export";
    this.myImportExportResetLabelSeconds = 2;
    this.myImportingButtonText = "...";
    this.myImportSuccessButtonText = "Done";
    this.myImportFailureButtonText = "Error";
    this.myExportingButtonText = "...";
    this.myExportSuccessButtonText = "Done";
    this.myExportFailureButtonText = "Error";
    this.myImportButtonPosition = vec3_create(0, 0, -1e-5);
    this.myImportButtonPosition[0] = -this.myImportExportButtonBackgroundScale[0] - this._mySideButtonDistanceFromBorder / 2;
    this.myExportButtonPosition = vec3_create(0, 0, -1e-5);
    this.myExportButtonPosition[0] = -this.myImportButtonPosition[0];
    this.myPointerCollisionExtents = this.myBackBackgroundScale.pp_clone();
    this.myPointerCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myPointerCursorTargetPosition = this.myBackPanelPosition.pp_clone();
    this.myPointerCursorTargetPosition[2] = this._myColliderZOffset - 2e-4;
  }
  _setupRuntimeConfig() {
    this.myButtonHoverColor = vec4_create(150 / 255, 150 / 255, 150 / 255, 1);
    this.myScrollVariableDelay = 0.5;
    this._setupRuntimeConfigHook();
  }
};

// dist/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_config.js
var EasyTuneBoolArrayWidgetConfig = class extends EasyTuneBaseWidgetConfig {
  constructor(arraySize) {
    super();
    this.myArraySize = arraySize;
  }
  _getBackPanelMinY() {
    let valuePanelLastPosition = this.myValuePanelsPositions[this.myArraySize - 1] ? this.myValuePanelsPositions[this.myArraySize - 1][1] : 0;
    return super._getBackPanelMinY() + this.myValuesPanelPosition[1] + valuePanelLastPosition;
  }
  _getPivotZOffset() {
    return 802713e-8;
  }
  _setupBuildConfigHook() {
    this.myIncreaseButtonText = "+";
    this.myDecreaseButtonText = "-";
    this._myValuePanelDistanceFromVariableLabelPanel = 0.055;
    this._myDistanceBetweenValues = this.mySideButtonBackgroundScale[1] * 2 + 0.015;
    this.myValuesPanelPosition = [0, this.myVariableLabelPanelPosition[1] - this._myValuePanelDistanceFromVariableLabelPanel, this._myPanelZOffset];
    this.myValueTextScale = vec3_create(0.4, 0.4, 0.4);
    this.myValueCursorTargetPosition = vec3_create(0, 0, 0);
    this.myValueCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myValueCollisionExtents = vec3_create(0.065, 0.02, 1);
    this.myValueCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myValuePanelsPositions = [];
    this.myValuePanelsPositions[0] = vec3_create(0, 0, 0);
    for (let i = 1; i < this.myArraySize; i++) {
      this.myValuePanelsPositions[i] = this.myValuePanelsPositions[i - 1].pp_clone();
      this.myValuePanelsPositions[i][1] -= this._myDistanceBetweenValues;
    }
  }
  _setupRuntimeConfigHook() {
    this.myTextHoverScaleMultiplier = vec3_create(1.1, 1.1, 1.1);
    this.myThumbstickToggleThreshold = 0.6;
    this.myButtonEditDelay = 0;
  }
};

// dist/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_ui.js
import { CollisionComponent as CollisionComponent8, MeshComponent as MeshComponent18, TextComponent as TextComponent14 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget12 } from "@wonderlandengine/components";

// dist/pp/tool/easy_tune/easy_tune_widgets/base/easy_tune_base_widget_ui.js
import { CollisionComponent as CollisionComponent7, MeshComponent as MeshComponent17, TextComponent as TextComponent13 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget11 } from "@wonderlandengine/components";
var EasyTuneBaseWidgetUI = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myEngine = engine;
    this._myActive = false;
    this._myDestroyed = false;
  }
  build(parentObject, config, params) {
    this._myParentObject = parentObject;
    this._myConfig = config;
    this._myParams = params;
    this._myImportExportButtonsVisible = true;
    this._myPlaneMesh = Globals.getDefaultMeshes(this._myEngine).myDoubleSidedPlane;
    this._buildHook();
    this._createSkeleton();
    this._setTransforms();
    this._addComponents();
    this._setTransformForNonXR();
    this.setActive(true);
  }
  setVisible(visible) {
    this.myPivotObject.pp_setActive(visible);
    if (visible) {
      this.setImportExportButtonsVisible(this._myImportExportButtonsVisible);
    }
    this._setVisibleHook(visible);
  }
  setImportExportButtonsVisible(visible) {
    this._myImportExportButtonsVisible = visible;
    this.myImportExportPanel.pp_setActive(this._myImportExportButtonsVisible);
  }
  // Hooks
  _buildHook() {
  }
  _setVisibleHook(visible) {
  }
  _createSkeletonHook() {
  }
  _setTransformHook() {
  }
  _addComponentsHook() {
  }
  // Hooks end
  // Skeleton
  _createSkeleton() {
    this.myPivotObject = this._myParentObject.pp_addChild();
    this.myBackPanel = this.myPivotObject.pp_addChild();
    this.myBackBackground = this.myBackPanel.pp_addChild();
    this.myDisplayPanel = this.myPivotObject.pp_addChild();
    this.myVariableLabelPanel = this.myDisplayPanel.pp_addChild();
    this.myVariableLabelText = this.myVariableLabelPanel.pp_addChild();
    this.myVariableLabelCursorTarget = this.myVariableLabelPanel.pp_addChild();
    this.myNextButtonPanel = this.myVariableLabelPanel.pp_addChild();
    this.myNextButtonBackground = this.myNextButtonPanel.pp_addChild();
    this.myNextButtonText = this.myNextButtonPanel.pp_addChild();
    this.myNextButtonCursorTarget = this.myNextButtonPanel.pp_addChild();
    this.myPreviousButtonPanel = this.myVariableLabelPanel.pp_addChild();
    this.myPreviousButtonBackground = this.myPreviousButtonPanel.pp_addChild();
    this.myPreviousButtonText = this.myPreviousButtonPanel.pp_addChild();
    this.myPreviousButtonCursorTarget = this.myPreviousButtonPanel.pp_addChild();
    this.myImportExportPanel = this.myPivotObject.pp_addChild();
    this.myImportButtonPanel = this.myImportExportPanel.pp_addChild();
    this.myImportButtonBackground = this.myImportButtonPanel.pp_addChild();
    this.myImportButtonText = this.myImportButtonPanel.pp_addChild();
    this.myImportButtonCursorTarget = this.myImportButtonPanel.pp_addChild();
    this.myExportButtonPanel = this.myImportExportPanel.pp_addChild();
    this.myExportButtonBackground = this.myExportButtonPanel.pp_addChild();
    this.myExportButtonText = this.myExportButtonPanel.pp_addChild();
    this.myExportButtonCursorTarget = this.myExportButtonPanel.pp_addChild();
    this.myPointerCursorTarget = this.myPivotObject.pp_addChild();
    this._createSkeletonHook();
  }
  // Transforms
  _setTransforms() {
    this.myPivotObject.pp_setPositionLocal(this._myConfig.myPivotObjectPositions[this._myParams.myHandedness]);
    this.myBackPanel.pp_setPositionLocal(this._myConfig.myBackPanelPosition);
    this.myBackBackground.pp_scaleObject(this._myConfig.myBackBackgroundScale);
    this.myDisplayPanel.pp_setPositionLocal(this._myConfig.myDisplayPanelPosition);
    this.myVariableLabelPanel.pp_setPositionLocal(this._myConfig.myVariableLabelPanelPosition);
    this.myVariableLabelText.pp_scaleObject(this._myConfig.myVariableLabelTextScale);
    this.myVariableLabelCursorTarget.pp_setPositionLocal(this._myConfig.myVariableLabelCursorTargetPosition);
    this.myNextButtonPanel.pp_setPositionLocal(this._myConfig.myRightSideButtonPosition);
    this.myNextButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myNextButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myNextButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myNextButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myPreviousButtonPanel.pp_setPositionLocal(this._myConfig.myLeftSideButtonPosition);
    this.myPreviousButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myPreviousButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myPreviousButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myPreviousButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myImportExportPanel.pp_setPositionLocal(this._myConfig.myImportExportPanelPosition);
    this.myImportButtonPanel.pp_setPositionLocal(this._myConfig.myImportButtonPosition);
    this.myImportButtonBackground.pp_scaleObject(this._myConfig.myImportExportButtonBackgroundScale);
    this.myImportButtonText.pp_setPositionLocal(this._myConfig.myImportExportButtonTextPosition);
    this.myImportButtonText.pp_scaleObject(this._myConfig.myImportExportButtonTextScale);
    this.myImportButtonCursorTarget.pp_setPositionLocal(this._myConfig.myImportExportButtonCursorTargetPosition);
    this.myExportButtonPanel.pp_setPositionLocal(this._myConfig.myExportButtonPosition);
    this.myExportButtonBackground.pp_scaleObject(this._myConfig.myImportExportButtonBackgroundScale);
    this.myExportButtonText.pp_setPositionLocal(this._myConfig.myImportExportButtonTextPosition);
    this.myExportButtonText.pp_scaleObject(this._myConfig.myImportExportButtonTextScale);
    this.myExportButtonCursorTarget.pp_setPositionLocal(this._myConfig.myImportExportButtonCursorTargetPosition);
    this.myPointerCursorTarget.pp_setPositionLocal(this._myConfig.myPointerCursorTargetPosition);
    this._setTransformHook();
  }
  // Components
  _addComponents() {
    this.myBackBackgroundComponent = this.myBackBackground.pp_addComponent(MeshComponent17);
    this.myBackBackgroundComponent.mesh = this._myPlaneMesh;
    this.myBackBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myBackBackgroundComponent.material.color = this._myConfig.myBackBackgroundColor;
    this.myVariableLabelTextComponent = this.myVariableLabelText.pp_addComponent(TextComponent13);
    this._setupTextComponent(this.myVariableLabelTextComponent);
    this.myVariableLabelTextComponent.text = " ";
    this.myVariableLabelCursorTargetComponent = this.myVariableLabelCursorTarget.pp_addComponent(CursorTarget11);
    this.myVariableLabelCollisionComponent = this.myVariableLabelCursorTarget.pp_addComponent(CollisionComponent7);
    this.myVariableLabelCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myVariableLabelCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myVariableLabelCollisionComponent.extents = this._myConfig.myVariableLabelCollisionExtents;
    this.myNextButtonBackgroundComponent = this.myNextButtonBackground.pp_addComponent(MeshComponent17);
    this.myNextButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myNextButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myNextButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myNextButtonTextComponent = this.myNextButtonText.pp_addComponent(TextComponent13);
    this._setupTextComponent(this.myNextButtonTextComponent);
    this.myNextButtonTextComponent.text = this._myConfig.myNextButtonText;
    this.myNextButtonCursorTargetComponent = this.myNextButtonCursorTarget.pp_addComponent(CursorTarget11);
    this.myNextButtonCollisionComponent = this.myNextButtonCursorTarget.pp_addComponent(CollisionComponent7);
    this.myNextButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myNextButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myNextButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myPreviousButtonBackgroundComponent = this.myPreviousButtonBackground.pp_addComponent(MeshComponent17);
    this.myPreviousButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPreviousButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myPreviousButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myPreviousButtonTextComponent = this.myPreviousButtonText.pp_addComponent(TextComponent13);
    this._setupTextComponent(this.myPreviousButtonTextComponent);
    this.myPreviousButtonTextComponent.text = this._myConfig.myPreviousButtonText;
    this.myPreviousButtonCursorTargetComponent = this.myPreviousButtonCursorTarget.pp_addComponent(CursorTarget11);
    this.myPreviousButtonCollisionComponent = this.myPreviousButtonCursorTarget.pp_addComponent(CollisionComponent7);
    this.myPreviousButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPreviousButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPreviousButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myImportButtonBackgroundComponent = this.myImportButtonBackground.pp_addComponent(MeshComponent17);
    this.myImportButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myImportButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myImportButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myImportButtonTextComponent = this.myImportButtonText.pp_addComponent(TextComponent13);
    this._setupTextComponent(this.myImportButtonTextComponent);
    this.myImportButtonTextComponent.text = this._myConfig.myImportButtonText;
    this.myImportButtonCursorTargetComponent = this.myImportButtonCursorTarget.pp_addComponent(CursorTarget11);
    this.myImportButtonCollisionComponent = this.myImportButtonCursorTarget.pp_addComponent(CollisionComponent7);
    this.myImportButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myImportButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myImportButtonCollisionComponent.extents = this._myConfig.myImportExportButtonCollisionExtents;
    this.myExportButtonBackgroundComponent = this.myExportButtonBackground.pp_addComponent(MeshComponent17);
    this.myExportButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myExportButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myExportButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myExportButtonTextComponent = this.myExportButtonText.pp_addComponent(TextComponent13);
    this._setupTextComponent(this.myExportButtonTextComponent);
    this.myExportButtonTextComponent.text = this._myConfig.myExportButtonText;
    this.myExportButtonCursorTargetComponent = this.myExportButtonCursorTarget.pp_addComponent(CursorTarget11);
    this.myExportButtonCollisionComponent = this.myExportButtonCursorTarget.pp_addComponent(CollisionComponent7);
    this.myExportButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myExportButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myExportButtonCollisionComponent.extents = this._myConfig.myImportExportButtonCollisionExtents;
    this.myPointerCursorTargetComponent = this.myPointerCursorTarget.pp_addComponent(CursorTarget11);
    this.myPointerCursorTargetComponent.isSurface = true;
    this.myPointerCollisionComponent = this.myPointerCursorTarget.pp_addComponent(CollisionComponent7);
    this.myPointerCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPointerCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPointerCollisionComponent.extents = this._myConfig.myPointerCollisionExtents;
    this._addComponentsHook();
  }
  _setupTextComponent(textComponent) {
    textComponent.alignment = this._myConfig.myTextAlignment;
    textComponent.verticalAlignment = this._myConfig.myTextVerticalAlignment;
    textComponent.material = this._myParams.myTextMaterial.clone();
    textComponent.material.color = this._myConfig.myTextColor;
    textComponent.text = "";
  }
  _onXRSessionStart() {
    this._setTransformForXR();
  }
  _onXRSessionEnd() {
    this._setTransformForNonXR();
  }
  _setTransformForXR() {
    this.myPivotObject.pp_setPositionLocal(this._myConfig.myPivotObjectPositions[this._myParams.myHandedness]);
  }
  _setTransformForNonXR() {
    this.myPivotObject.pp_setPositionLocal(this._myConfig.myPivotObjectPositions[ToolHandedness.NONE]);
  }
  setActive(active) {
    if (this._myActive != active) {
      this._myActive = active;
      if (this._myActive) {
        XRUtils.registerSessionStartEndEventListeners(this, this._onXRSessionStart.bind(this), this._onXRSessionEnd.bind(this), true, false, this._myEngine);
      } else {
        XRUtils.unregisterSessionStartEndEventListeners(this, this._myEngine);
      }
    }
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
  }
  isDestroyed() {
    return this._myDestroyed;
  }
};

// dist/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_ui.js
var EasyTuneBoolArrayWidgetUI = class extends EasyTuneBaseWidgetUI {
  constructor(engine) {
    super(engine);
  }
  setAdditionalButtonsVisible(visible) {
    this._myAdditionalButtonsVisible = visible;
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValueIncreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
      this.myValueDecreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
    }
  }
  _buildHook() {
    this._myAdditionalButtonsVisible = true;
  }
  _createSkeletonHook() {
    this.myValuesPanel = this.myDisplayPanel.pp_addChild();
    this.myValuePanels = [];
    this.myValueTexts = [];
    this.myValueCursorTargets = [];
    this.myValueIncreaseButtonPanels = [];
    this.myValueIncreaseButtonBackgrounds = [];
    this.myValueIncreaseButtonTexts = [];
    this.myValueIncreaseButtonCursorTargets = [];
    this.myValueDecreaseButtonPanels = [];
    this.myValueDecreaseButtonBackgrounds = [];
    this.myValueDecreaseButtonTexts = [];
    this.myValueDecreaseButtonCursorTargets = [];
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValuePanels[i] = this.myValuesPanel.pp_addChild();
      this.myValueTexts[i] = this.myValuePanels[i].pp_addChild();
      this.myValueCursorTargets[i] = this.myValuePanels[i].pp_addChild();
      this.myValueIncreaseButtonPanels[i] = this.myValuePanels[i].pp_addChild();
      this.myValueIncreaseButtonBackgrounds[i] = this.myValueIncreaseButtonPanels[i].pp_addChild();
      this.myValueIncreaseButtonTexts[i] = this.myValueIncreaseButtonPanels[i].pp_addChild();
      this.myValueIncreaseButtonCursorTargets[i] = this.myValueIncreaseButtonPanels[i].pp_addChild();
      this.myValueDecreaseButtonPanels[i] = this.myValuePanels[i].pp_addChild();
      this.myValueDecreaseButtonBackgrounds[i] = this.myValueDecreaseButtonPanels[i].pp_addChild();
      this.myValueDecreaseButtonTexts[i] = this.myValueDecreaseButtonPanels[i].pp_addChild();
      this.myValueDecreaseButtonCursorTargets[i] = this.myValueDecreaseButtonPanels[i].pp_addChild();
    }
  }
  _setTransformHook() {
    this.myValuesPanel.pp_setPositionLocal(this._myConfig.myValuesPanelPosition);
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValuePanels[i].pp_setPositionLocal(this._myConfig.myValuePanelsPositions[i]);
      this.myValueTexts[i].pp_scaleObject(this._myConfig.myValueTextScale);
      this.myValueCursorTargets[i].pp_setPositionLocal(this._myConfig.myValueCursorTargetPosition);
      this.myValueIncreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myRightSideButtonPosition);
      this.myValueIncreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myValueIncreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myValueIncreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myValueIncreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
      this.myValueDecreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myLeftSideButtonPosition);
      this.myValueDecreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myValueDecreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myValueDecreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myValueDecreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    }
  }
  _addComponentsHook() {
    this.myValueTextComponents = [];
    this.myValueCursorTargetComponents = [];
    this.myValueCollisionComponents = [];
    this.myValueIncreaseButtonBackgroundComponents = [];
    this.myValueIncreaseButtonTextComponents = [];
    this.myValueIncreaseButtonCursorTargetComponents = [];
    this.myValueIncreaseButtonCollisionComponents = [];
    this.myValueDecreaseButtonBackgroundComponents = [];
    this.myValueDecreaseButtonTextComponents = [];
    this.myValueDecreaseButtonCursorTargetComponents = [];
    this.myValueDecreaseButtonCollisionComponents = [];
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValueTextComponents[i] = this.myValueTexts[i].pp_addComponent(TextComponent14);
      this._setupTextComponent(this.myValueTextComponents[i]);
      this.myValueTextComponents[i].text = " ";
      this.myValueCursorTargetComponents[i] = this.myValueCursorTargets[i].pp_addComponent(CursorTarget12);
      this.myValueCollisionComponents[i] = this.myValueCursorTargets[i].pp_addComponent(CollisionComponent8);
      this.myValueCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myValueCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myValueCollisionComponents[i].extents = this._myConfig.myValueCollisionExtents;
      this.myValueIncreaseButtonBackgroundComponents[i] = this.myValueIncreaseButtonBackgrounds[i].pp_addComponent(MeshComponent18);
      this.myValueIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myValueIncreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myValueIncreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myValueIncreaseButtonTextComponents[i] = this.myValueIncreaseButtonTexts[i].pp_addComponent(TextComponent14);
      this._setupTextComponent(this.myValueIncreaseButtonTextComponents[i]);
      this.myValueIncreaseButtonTextComponents[i].text = this._myConfig.myIncreaseButtonText;
      this.myValueIncreaseButtonCursorTargetComponents[i] = this.myValueIncreaseButtonCursorTargets[i].pp_addComponent(CursorTarget12);
      this.myValueIncreaseButtonCollisionComponents[i] = this.myValueIncreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent8);
      this.myValueIncreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myValueIncreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myValueIncreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
      this.myValueDecreaseButtonBackgroundComponents[i] = this.myValueDecreaseButtonBackgrounds[i].pp_addComponent(MeshComponent18);
      this.myValueDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myValueDecreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myValueDecreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myValueDecreaseButtonTextComponents[i] = this.myValueDecreaseButtonTexts[i].pp_addComponent(TextComponent14);
      this._setupTextComponent(this.myValueDecreaseButtonTextComponents[i]);
      this.myValueDecreaseButtonTextComponents[i].text = this._myConfig.myDecreaseButtonText;
      this.myValueDecreaseButtonCursorTargetComponents[i] = this.myValueDecreaseButtonCursorTargets[i].pp_addComponent(CursorTarget12);
      this.myValueDecreaseButtonCollisionComponents[i] = this.myValueDecreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent8);
      this.myValueDecreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myValueDecreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myValueDecreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
    }
  }
  _setVisibleHook(visible) {
    if (visible) {
      this.setAdditionalButtonsVisible(this._myAdditionalButtonsVisible);
    }
  }
};

// dist/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget.js
var EasyTuneBoolArrayWidget = class extends EasyTuneBaseWidget {
  constructor(params, arraySize, gamepad, engine = Globals.getMainEngine()) {
    super(params);
    this._myNonArray = arraySize == null;
    this._myArraySize = this._myNonArray ? 1 : arraySize;
    this._myConfig = new EasyTuneBoolArrayWidgetConfig(this._myArraySize);
    this._myUI = new EasyTuneBoolArrayWidgetUI(engine);
    this._myGamepad = gamepad;
    this._myValueEditIndex = 0;
    this._myValueButtonEditIntensity = 0;
    this._myValueButtonEditIntensityTimer = 0;
    this._myValueEditEnabled = false;
    this._myTempValue = [];
    this._myTempNonArrayValue = [0];
    this._myTempNonArrayDefaultValue = [0];
  }
  _refreshUIHook() {
    for (let i = 0; i < this._myArraySize; i++) {
      this._myUI.myValueTextComponents[i].text = this._getVariableValue()[i] ? "true" : "false";
    }
  }
  _startHook(parentObject, easyTuneParams) {
    this._myUI.setAdditionalButtonsVisible(easyTuneParams.myShowAdditionalButtons);
  }
  _setEasyTuneVariableHook() {
    if (this._myVariable != null) {
      this._myTempValue.pp_copy(this._getVariableValue());
    }
  }
  _updateHook(dt) {
    this._updateValue(dt);
  }
  _updateValue(dt) {
    let stickVariableIntensity = 0;
    if (this._myGamepad) {
      stickVariableIntensity = this._myGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes[1];
    }
    let valueIntensity = 0;
    if (this._myValueEditEnabled) {
      valueIntensity = stickVariableIntensity;
    } else if (this._myValueButtonEditIntensity != 0) {
      if (this._myValueButtonEditIntensityTimer <= 0) {
        valueIntensity = this._myValueButtonEditIntensity;
      } else {
        this._myValueButtonEditIntensityTimer -= dt;
      }
    }
    if (this._myValueEditIndex >= 0 && this._myValueEditIndex < this._getVariableValue().length) {
      if (Math.abs(valueIntensity) > this._myConfig.myThumbstickToggleThreshold) {
        this._myTempValue.pp_copy(this._getVariableValue());
        this._myTempValue[this._myValueEditIndex] = valueIntensity > 0;
        this._setVariableValue(this._myTempValue);
        this._refreshUI();
      }
    }
  }
  _addListenersHook() {
    let ui = this._myUI;
    ui.myVariableLabelCursorTargetComponent.onClick.add(this._resetAllValues.bind(this));
    ui.myVariableLabelCursorTargetComponent.onHover.add(this._genericTextHover.bind(this, ui.myVariableLabelText));
    ui.myVariableLabelCursorTargetComponent.onUnhover.add(this._genericTextUnhover.bind(this, ui.myVariableLabelText, this._myConfig.myVariableLabelTextScale));
    this._myUnhoverCallbacks.push(this._genericTextUnhover.bind(this, ui.myVariableLabelText, this._myConfig.myVariableLabelTextScale));
    for (let i = 0; i < this._myArraySize; i++) {
      ui.myValueIncreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, i, 1));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, i, 1));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, i, -1));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, i, -1));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, i, 0));
      this._myUnhoverCallbacks.push(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
      this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
      this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
      ui.myValueCursorTargetComponents[i].onClick.add(this._resetValue.bind(this, i));
      ui.myValueCursorTargetComponents[i].onHover.add(this._setValueEditEnabled.bind(this, i, ui.myValueTexts[i], true));
      ui.myValueCursorTargetComponents[i].onUnhover.add(this._setValueEditEnabled.bind(this, i, ui.myValueTexts[i], false));
      this._myUnhoverCallbacks.push(this._setValueEditEnabled.bind(this, i, ui.myValueTexts[i], false));
    }
  }
  _setValueEditIntensity(index, value) {
    if (this._isActive() || value == 0) {
      if (value != 0) {
        this._myValueButtonEditIntensityTimer = this._myConfig.myButtonEditDelay;
        this._myValueEditIndex = index;
      }
      this._myValueButtonEditIntensity = value;
    }
  }
  _setValueEditEnabled(index, text, enabled) {
    if (this._isActive() || !enabled) {
      if (enabled) {
        this._myValueEditIndex = index;
        text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
      } else {
        text.pp_setScaleLocal(this._myConfig.myValueTextScale);
      }
      this._myValueEditEnabled = enabled;
    }
  }
  _resetValue(index) {
    if (this._isActive()) {
      this._myTempValue.pp_copy(this._getVariableValue());
      this._myTempValue[index] = this._getVariableDefaultValue()[index];
      this._setVariableValue(this._myTempValue);
      this._myUI.myValueTextComponents[index].text = this._getVariableValue()[index] ? "true" : "false";
    }
  }
  _resetAllValues() {
    for (let i = 0; i < this._myArraySize; i++) {
      this._resetValue(i);
    }
  }
  _genericTextHover(text) {
    text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
  }
  _genericTextUnhover(text, originalScale) {
    text.pp_setScaleLocal(originalScale);
  }
  _getVariableValue() {
    if (this._myNonArray) {
      this._myTempNonArrayValue[0] = this._myVariable.getValue();
      return this._myTempNonArrayValue;
    }
    return this._myVariable.getValue();
  }
  _getVariableDefaultValue() {
    if (this._myNonArray) {
      this._myTempNonArrayDefaultValue[0] = this._myVariable.getDefaultValue();
      return this._myTempNonArrayDefaultValue;
    }
    return this._myVariable.getDefaultValue();
  }
  _setVariableValue(value) {
    if (this._myNonArray) {
      this._myVariable.setValue(value[0]);
    } else {
      this._myVariable.setValue(this._myTempValue);
    }
  }
};

// dist/pp/tool/easy_tune/easy_tune_widgets/bool/easy_tune_bool_array_widget_selector.js
var EasyTuneBoolArrayWidgetSelector = class extends EasyTuneBaseArrayWidgetSelector {
  _getEasyTuneArrayWidget(arraySize) {
    return new EasyTuneBoolArrayWidget(this._myParams, arraySize, this._myGamepad, this._myEngine);
  }
};

// dist/pp/tool/easy_tune/easy_tune_widgets/easy_tune_widget_config.js
var EasyTuneWidgetConfig = class {
  constructor() {
    this._setupRuntimeConfig();
  }
  _setupRuntimeConfig() {
    this.myGamepadHandedness = ToolHandedness.RIGHT;
    this.myScrollVariableDelay = 0.5;
    this.myScrollVariableMinXThreshold = 0.6;
    this.myScrollVariableMaxYThreshold = 0.25;
    this.myScrollVariableButtonID = null;
    this.myRefreshVariablesDelay = null;
  }
};

// dist/pp/tool/easy_tune/easy_tune_widgets/none/easy_tune_none_widget_config.js
var EasyTuneNoneWidgetConfig = class extends EasyTuneBaseWidgetConfig {
  _getBackPanelMinY() {
    return super._getBackPanelMinY() + this.myTypeNotSupportedPanelPosition[1];
  }
  _getPivotZOffset() {
    return 804713e-8;
  }
  _setupBuildConfigHook() {
    this.myTypeNotSupportedPanelPosition = vec3_create(0, -0.03, this._myPanelZOffset);
    this.myTypeNotSupportedTextScale = vec3_create(0.275, 0.275, 0.275);
    this.myTypeNotSupportedText = "Type Not Supported";
  }
};

// dist/pp/tool/easy_tune/easy_tune_widgets/none/easy_tune_none_widget_ui.js
import { TextComponent as TextComponent15 } from "@wonderlandengine/api";
var EasyTuneNoneWidgetUI = class extends EasyTuneBaseWidgetUI {
  constructor(engine) {
    super(engine);
  }
  _createSkeletonHook() {
    this.myTypeNotSupportedPanel = this.myDisplayPanel.pp_addChild();
    this.myTypeNotSupportedText = this.myTypeNotSupportedPanel.pp_addChild();
    this.myTypeNotSupportedCursorTarget = this.myTypeNotSupportedPanel.pp_addChild();
  }
  _setTransformHook() {
    this.myTypeNotSupportedPanel.pp_setPositionLocal(this._myConfig.myTypeNotSupportedPanelPosition);
    this.myTypeNotSupportedText.pp_scaleObject(this._myConfig.myTypeNotSupportedTextScale);
  }
  _addComponentsHook() {
    this.myTypeNotSupportedTextComponent = this.myTypeNotSupportedText.pp_addComponent(TextComponent15);
    this._setupTextComponent(this.myTypeNotSupportedTextComponent);
    this.myTypeNotSupportedTextComponent.text = this._myConfig.myTypeNotSupportedText;
  }
};

// dist/pp/tool/easy_tune/easy_tune_widgets/none/easy_tune_none_widget.js
var EasyTuneNoneWidget = class extends EasyTuneBaseWidget {
  constructor(params, engine = Globals.getMainEngine()) {
    super(params);
    this._myConfig = new EasyTuneNoneWidgetConfig();
    this._myUI = new EasyTuneNoneWidgetUI(engine);
  }
};

// dist/pp/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_array_widget_config.js
var EasyTuneNumberArrayWidgetConfig = class extends EasyTuneBaseWidgetConfig {
  constructor(arraySize) {
    super();
    this.myArraySize = arraySize;
  }
  _getBackPanelMinY() {
    return this.myStepPanelPosition[1] - this._mySideButtonDistanceFromBorder * 1.25 - this.mySideButtonBackgroundScale[1];
  }
  _getPivotZOffset() {
    return 803713e-8;
  }
  _setupBuildConfigHook() {
    this.myIncreaseButtonText = "+";
    this.myDecreaseButtonText = "-";
    this._myValuePanelDistanceFromVariableLabelPanel = 0.055;
    this._myDistanceBetweenValues = this.mySideButtonBackgroundScale[1] * 2 + 0.015;
    this.myValuesPanelPosition = [0, this.myVariableLabelPanelPosition[1] - this._myValuePanelDistanceFromVariableLabelPanel, this._myPanelZOffset];
    this.myValueTextScale = vec3_create(0.4, 0.4, 0.4);
    this.myValueCursorTargetPosition = vec3_create(0, 0, 0);
    this.myValueCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myValueCollisionExtents = vec3_create(0.065, 0.02, 1);
    this.myValueCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myValuePanelsPositions = [];
    this.myValuePanelsPositions[0] = vec3_create(0, 0, 0);
    for (let i = 1; i < this.myArraySize; i++) {
      this.myValuePanelsPositions[i] = this.myValuePanelsPositions[i - 1].pp_clone();
      this.myValuePanelsPositions[i][1] -= this._myDistanceBetweenValues;
    }
    let valuePanelLastPosition = this.myValuePanelsPositions[this.myArraySize - 1] ? this.myValuePanelsPositions[this.myArraySize - 1][1] : 0;
    this.myStepPanelPosition = [0, this.myDisplayPanelPosition[1] + this.myValuesPanelPosition[1] + valuePanelLastPosition - this._myValuePanelDistanceFromVariableLabelPanel, this._myPanelZOffset];
    this.myStepTextScale = this.myLabelTextScale;
    this.myStepStartString = "Step: ";
    this.myStepCursorTargetPosition = vec3_create(0, 0, 0);
    this.myStepCursorTargetPosition[2] = this._myColliderZOffset - this.myStepPanelPosition[2];
    this.myStepCollisionExtents = vec3_create(0.065, 0.0175, 1);
    this.myStepCollisionExtents[2] = this.myCursorTargetCollisionThickness;
  }
  _setupRuntimeConfigHook() {
    this.myTextHoverScaleMultiplier = vec3_create(1.1, 1.1, 1.1);
    this.myEditThumbstickMinThreshold = 0.35;
    this.myStepMultiplierStepPerSecond = 2.25;
    this.myButtonEditDelay = 0;
  }
};

// dist/pp/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_array_widget_ui.js
import { CollisionComponent as CollisionComponent9, MeshComponent as MeshComponent19, TextComponent as TextComponent16 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget13 } from "@wonderlandengine/components";
var EasyTuneNumberArrayWidgetUI = class extends EasyTuneBaseWidgetUI {
  constructor(engine) {
    super(engine);
  }
  setAdditionalButtonsVisible(visible) {
    this._myAdditionalButtonsVisible = visible;
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValueIncreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
      this.myValueDecreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
    }
    this.myStepIncreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
    this.myStepDecreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
  }
  _buildHook() {
    this._myAdditionalButtonsVisible = true;
  }
  _createSkeletonHook() {
    this.myValuesPanel = this.myDisplayPanel.pp_addChild();
    this.myValuePanels = [];
    this.myValueTexts = [];
    this.myValueCursorTargets = [];
    this.myValueIncreaseButtonPanels = [];
    this.myValueIncreaseButtonBackgrounds = [];
    this.myValueIncreaseButtonTexts = [];
    this.myValueIncreaseButtonCursorTargets = [];
    this.myValueDecreaseButtonPanels = [];
    this.myValueDecreaseButtonBackgrounds = [];
    this.myValueDecreaseButtonTexts = [];
    this.myValueDecreaseButtonCursorTargets = [];
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValuePanels[i] = this.myValuesPanel.pp_addChild();
      this.myValueTexts[i] = this.myValuePanels[i].pp_addChild();
      this.myValueCursorTargets[i] = this.myValuePanels[i].pp_addChild();
      this.myValueIncreaseButtonPanels[i] = this.myValuePanels[i].pp_addChild();
      this.myValueIncreaseButtonBackgrounds[i] = this.myValueIncreaseButtonPanels[i].pp_addChild();
      this.myValueIncreaseButtonTexts[i] = this.myValueIncreaseButtonPanels[i].pp_addChild();
      this.myValueIncreaseButtonCursorTargets[i] = this.myValueIncreaseButtonPanels[i].pp_addChild();
      this.myValueDecreaseButtonPanels[i] = this.myValuePanels[i].pp_addChild();
      this.myValueDecreaseButtonBackgrounds[i] = this.myValueDecreaseButtonPanels[i].pp_addChild();
      this.myValueDecreaseButtonTexts[i] = this.myValueDecreaseButtonPanels[i].pp_addChild();
      this.myValueDecreaseButtonCursorTargets[i] = this.myValueDecreaseButtonPanels[i].pp_addChild();
    }
    this.myStepPanel = this.myPivotObject.pp_addChild();
    this.myStepText = this.myStepPanel.pp_addChild();
    this.myStepCursorTarget = this.myStepPanel.pp_addChild();
    this.myStepIncreaseButtonPanel = this.myStepPanel.pp_addChild();
    this.myStepIncreaseButtonBackground = this.myStepIncreaseButtonPanel.pp_addChild();
    this.myStepIncreaseButtonText = this.myStepIncreaseButtonPanel.pp_addChild();
    this.myStepIncreaseButtonCursorTarget = this.myStepIncreaseButtonPanel.pp_addChild();
    this.myStepDecreaseButtonPanel = this.myStepPanel.pp_addChild();
    this.myStepDecreaseButtonBackground = this.myStepDecreaseButtonPanel.pp_addChild();
    this.myStepDecreaseButtonText = this.myStepDecreaseButtonPanel.pp_addChild();
    this.myStepDecreaseButtonCursorTarget = this.myStepDecreaseButtonPanel.pp_addChild();
  }
  _setTransformHook() {
    this.myValuesPanel.pp_setPositionLocal(this._myConfig.myValuesPanelPosition);
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValuePanels[i].pp_setPositionLocal(this._myConfig.myValuePanelsPositions[i]);
      this.myValueTexts[i].pp_scaleObject(this._myConfig.myValueTextScale);
      this.myValueCursorTargets[i].pp_setPositionLocal(this._myConfig.myValueCursorTargetPosition);
      this.myValueIncreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myRightSideButtonPosition);
      this.myValueIncreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myValueIncreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myValueIncreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myValueIncreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
      this.myValueDecreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myLeftSideButtonPosition);
      this.myValueDecreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myValueDecreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myValueDecreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myValueDecreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    }
    this.myStepPanel.pp_setPositionLocal(this._myConfig.myStepPanelPosition);
    this.myStepText.pp_scaleObject(this._myConfig.myStepTextScale);
    this.myStepCursorTarget.pp_setPositionLocal(this._myConfig.myStepCursorTargetPosition);
    this.myStepIncreaseButtonPanel.pp_setPositionLocal(this._myConfig.myRightSideButtonPosition);
    this.myStepIncreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myStepIncreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myStepIncreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myStepIncreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myStepDecreaseButtonPanel.pp_setPositionLocal(this._myConfig.myLeftSideButtonPosition);
    this.myStepDecreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myStepDecreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myStepDecreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myStepDecreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
  }
  _addComponentsHook() {
    this.myValueTextComponents = [];
    this.myValueCursorTargetComponents = [];
    this.myValueCollisionComponents = [];
    this.myValueIncreaseButtonBackgroundComponents = [];
    this.myValueIncreaseButtonTextComponents = [];
    this.myValueIncreaseButtonCursorTargetComponents = [];
    this.myValueIncreaseButtonCollisionComponents = [];
    this.myValueDecreaseButtonBackgroundComponents = [];
    this.myValueDecreaseButtonTextComponents = [];
    this.myValueDecreaseButtonCursorTargetComponents = [];
    this.myValueDecreaseButtonCollisionComponents = [];
    for (let i = 0; i < this._myConfig.myArraySize; i++) {
      this.myValueTextComponents[i] = this.myValueTexts[i].pp_addComponent(TextComponent16);
      this._setupTextComponent(this.myValueTextComponents[i]);
      this.myValueTextComponents[i].text = " ";
      this.myValueCursorTargetComponents[i] = this.myValueCursorTargets[i].pp_addComponent(CursorTarget13);
      this.myValueCollisionComponents[i] = this.myValueCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myValueCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myValueCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myValueCollisionComponents[i].extents = this._myConfig.myValueCollisionExtents;
      this.myValueIncreaseButtonBackgroundComponents[i] = this.myValueIncreaseButtonBackgrounds[i].pp_addComponent(MeshComponent19);
      this.myValueIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myValueIncreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myValueIncreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myValueIncreaseButtonTextComponents[i] = this.myValueIncreaseButtonTexts[i].pp_addComponent(TextComponent16);
      this._setupTextComponent(this.myValueIncreaseButtonTextComponents[i]);
      this.myValueIncreaseButtonTextComponents[i].text = this._myConfig.myIncreaseButtonText;
      this.myValueIncreaseButtonCursorTargetComponents[i] = this.myValueIncreaseButtonCursorTargets[i].pp_addComponent(CursorTarget13);
      this.myValueIncreaseButtonCollisionComponents[i] = this.myValueIncreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myValueIncreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myValueIncreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myValueIncreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
      this.myValueDecreaseButtonBackgroundComponents[i] = this.myValueDecreaseButtonBackgrounds[i].pp_addComponent(MeshComponent19);
      this.myValueDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myValueDecreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myValueDecreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myValueDecreaseButtonTextComponents[i] = this.myValueDecreaseButtonTexts[i].pp_addComponent(TextComponent16);
      this._setupTextComponent(this.myValueDecreaseButtonTextComponents[i]);
      this.myValueDecreaseButtonTextComponents[i].text = this._myConfig.myDecreaseButtonText;
      this.myValueDecreaseButtonCursorTargetComponents[i] = this.myValueDecreaseButtonCursorTargets[i].pp_addComponent(CursorTarget13);
      this.myValueDecreaseButtonCollisionComponents[i] = this.myValueDecreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent9);
      this.myValueDecreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myValueDecreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myValueDecreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
    }
    this.myStepTextComponent = this.myStepText.pp_addComponent(TextComponent16);
    this._setupTextComponent(this.myStepTextComponent);
    this.myStepTextComponent.text = " ";
    this.myStepCursorTargetComponent = this.myStepCursorTarget.pp_addComponent(CursorTarget13);
    this.myStepCollisionComponent = this.myStepCursorTarget.pp_addComponent(CollisionComponent9);
    this.myStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myStepIncreaseButtonBackgroundComponent = this.myStepIncreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myStepIncreaseButtonTextComponent = this.myStepIncreaseButtonText.pp_addComponent(TextComponent16);
    this._setupTextComponent(this.myStepIncreaseButtonTextComponent);
    this.myStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myStepIncreaseButtonCursorTargetComponent = this.myStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget13);
    this.myStepIncreaseButtonCollisionComponent = this.myStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myStepDecreaseButtonBackgroundComponent = this.myStepDecreaseButtonBackground.pp_addComponent(MeshComponent19);
    this.myStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myStepDecreaseButtonTextComponent = this.myStepDecreaseButtonText.pp_addComponent(TextComponent16);
    this._setupTextComponent(this.myStepDecreaseButtonTextComponent);
    this.myStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myStepDecreaseButtonCursorTargetComponent = this.myStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget13);
    this.myStepDecreaseButtonCollisionComponent = this.myStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent9);
    this.myStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
  }
  _setVisibleHook(visible) {
    if (visible) {
      this.setAdditionalButtonsVisible(this._myAdditionalButtonsVisible);
    }
  }
};

// dist/pp/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_array_widget.js
var EasyTuneNumberArrayWidget = class extends EasyTuneBaseWidget {
  constructor(params, arraySize, gamepad, engine = Globals.getMainEngine()) {
    super(params);
    this._myGamepad = gamepad;
    this._myNonArray = arraySize == null;
    this._myArraySize = this._myNonArray ? 1 : arraySize;
    this._myConfig = new EasyTuneNumberArrayWidgetConfig(this._myArraySize);
    this._myUI = new EasyTuneNumberArrayWidgetUI(engine);
    this._myValueEditIndex = -1;
    this._myValueButtonEditIntensity = 0;
    this._myValueButtonEditIntensityTimer = 0;
    this._myStepButtonEditIntensity = 0;
    this._myStepButtonEditIntensityTimer = 0;
    this._myValueEditEnabled = false;
    this._myStepEditEnabled = false;
    this._myValueRealValue = 0;
    this._myStepMultiplierValue = 0;
    this._myStepFastEdit = false;
    this._myTempValue = [];
    this._myTempNonArrayValue = [0];
    this._myTempNonArrayDefaultValue = [0];
  }
  _refreshUIHook() {
    for (let i = 0; i < this._myArraySize; i++) {
      this._myUI.myValueTextComponents[i].text = this._getVariableValue()[i].toFixed(this._myVariable._myDecimalPlaces);
    }
    this._myUI.myStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myStepPerSecond);
  }
  _startHook(parentObject, easyTuneParams) {
    this._myUI.setAdditionalButtonsVisible(easyTuneParams.myShowAdditionalButtons);
  }
  _setEasyTuneVariableHook() {
    if (this._myVariable != null) {
      if (this._myValueEditIndex >= 0 && this._myValueEditIndex < this._getVariableValue().length) {
        this._myValueRealValue = this._getVariableValue()[this._myValueEditIndex];
      } else {
        this._myValueRealValue = 0;
      }
      this._myTempValue.pp_copy(this._getVariableValue());
      this._myStepMultiplierValue = 0;
      this._myStepFastEdit = false;
    }
  }
  _updateHook(dt) {
    this._updateValue(dt);
  }
  _updateValue(dt) {
    let stickVariableIntensity = 0;
    if (this._myGamepad) {
      let y = this._myGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes[1];
      if (Math.abs(y) > this._myConfig.myEditThumbstickMinThreshold) {
        let normalizedEditAmount = (Math.abs(y) - this._myConfig.myEditThumbstickMinThreshold) / (1 - this._myConfig.myEditThumbstickMinThreshold);
        stickVariableIntensity = Math.sign(y) * normalizedEditAmount;
      }
    }
    let valueIntensity = 0;
    if (this._myValueEditEnabled) {
      valueIntensity = stickVariableIntensity;
    } else if (this._myValueButtonEditIntensity != 0) {
      if (this._myValueButtonEditIntensityTimer <= 0) {
        valueIntensity = this._myValueButtonEditIntensity;
      } else {
        this._myValueButtonEditIntensityTimer -= dt;
      }
    }
    if (this._myValueEditIndex >= 0 && this._myValueEditIndex < this._getVariableValue().length) {
      if (valueIntensity != 0) {
        let amountToAdd = valueIntensity * this._myVariable._myStepPerSecond * dt;
        this._myValueRealValue += amountToAdd;
        if (this._myVariable._myMin != null && this._myVariable._myMax != null) {
          this._myValueRealValue = Math.pp_clamp(this._myValueRealValue, this._myVariable._myMin, this._myVariable._myMax);
        } else if (this._myVariable._myMin != null) {
          this._myValueRealValue = Math.max(this._myValueRealValue, this._myVariable._myMin);
        } else if (this._myVariable._myMax != null) {
          this._myValueRealValue = Math.min(this._myValueRealValue, this._myVariable._myMax);
        }
        let decimalPlacesMultiplier = Math.pow(10, this._myVariable._myDecimalPlaces);
        this._myTempValue.pp_copy(this._getVariableValue());
        if (!this._myNonArray && this._myVariable._myEditAllValuesTogether) {
          let newValue = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
          let difference = newValue - this._myTempValue[this._myValueEditIndex];
          for (let i = 0; i < this._myArraySize; i++) {
            this._myTempValue[i] = Math.round((this._myTempValue[i] + difference) * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
            if (this._myVariable._myMin != null && this._myVariable._myMax != null) {
              this._myTempValue[i] = Math.pp_clamp(this._myTempValue[i], this._myVariable._myMin, this._myVariable._myMax);
            } else if (this._myVariable._myMin != null) {
              this._myTempValue[i] = Math.max(this._myTempValue[i], this._myVariable._myMin);
            } else if (this._myVariable._myMax != null) {
              this._myTempValue[i] = Math.min(this._myTempValue[i], this._myVariable._myMax);
            }
            this._myUI.myValueTextComponents[i].text = this._myTempValue[i].toFixed(this._myVariable._myDecimalPlaces);
          }
        } else {
          this._myTempValue[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
          if (this._myVariable._myMin != null && this._myVariable._myMax != null) {
            this._myTempValue[this._myValueEditIndex] = Math.pp_clamp(this._myTempValue[this._myValueEditIndex], this._myVariable._myMin, this._myVariable._myMax);
          } else if (this._myVariable._myMin != null) {
            this._myTempValue[this._myValueEditIndex] = Math.max(this._myTempValue[this._myValueEditIndex], this._myVariable._myMin);
          } else if (this._myVariable._myMax != null) {
            this._myTempValue[this._myValueEditIndex] = Math.min(this._myTempValue[this._myValueEditIndex], this._myVariable._myMax);
          }
          this._myUI.myValueTextComponents[this._myValueEditIndex].text = this._myTempValue[this._myValueEditIndex].toFixed(this._myVariable._myDecimalPlaces);
        }
        this._setVariableValue(this._myTempValue);
      } else {
        this._myValueRealValue = this._getVariableValue()[this._myValueEditIndex];
      }
    }
    let stepIntensity = 0;
    if (this._myStepEditEnabled) {
      stepIntensity = stickVariableIntensity;
    } else if (this._myStepButtonEditIntensity != 0) {
      if (this._myStepButtonEditIntensityTimer <= 0) {
        stepIntensity = this._myStepButtonEditIntensity;
      } else {
        this._myStepButtonEditIntensityTimer -= dt;
      }
    }
    if (stepIntensity != 0) {
      let amountToAdd = 0;
      if (this._myStepFastEdit) {
        amountToAdd = Math.sign(stepIntensity) * 1;
        this._myStepFastEdit = false;
      } else {
        amountToAdd = stepIntensity * this._myConfig.myStepMultiplierStepPerSecond * dt;
      }
      this._myStepMultiplierValue += amountToAdd;
      if (Math.abs(this._myStepMultiplierValue) >= 1) {
        if (Math.sign(this._myStepMultiplierValue) > 0) {
          this._myStepMultiplierValue -= 1;
          this._changeStep(this._myVariable._myStepPerSecond * 10);
        } else {
          this._myStepMultiplierValue += 1;
          this._changeStep(this._myVariable._myStepPerSecond * 0.1);
        }
      }
    } else {
      this._myStepMultiplierValue = 0;
      this._myStepFastEdit = true;
    }
  }
  _addListenersHook() {
    let ui = this._myUI;
    ui.myVariableLabelCursorTargetComponent.onClick.add(this._resetAllValues.bind(this));
    ui.myVariableLabelCursorTargetComponent.onHover.add(this._genericTextHover.bind(this, ui.myVariableLabelText));
    ui.myVariableLabelCursorTargetComponent.onUnhover.add(this._genericTextUnhover.bind(this, ui.myVariableLabelText, this._myConfig.myVariableLabelTextScale));
    this._myUnhoverCallbacks.push(this._genericTextUnhover.bind(this, ui.myVariableLabelText, this._myConfig.myVariableLabelTextScale));
    for (let i = 0; i < this._myArraySize; i++) {
      ui.myValueIncreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, i, 1));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, i, 1));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, i, -1));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, i, -1));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, i, 0));
      this._myUnhoverCallbacks.push(this._setValueEditIntensity.bind(this, i, 0));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
      ui.myValueIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
      ui.myValueDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
      this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myValueIncreaseButtonBackgroundComponents[i].material));
      this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myValueDecreaseButtonBackgroundComponents[i].material));
      ui.myValueCursorTargetComponents[i].onClick.add(this._resetValue.bind(this, i));
      ui.myValueCursorTargetComponents[i].onHover.add(this._setValueEditEnabled.bind(this, i, ui.myValueTexts[i], true));
      ui.myValueCursorTargetComponents[i].onUnhover.add(this._setValueEditEnabled.bind(this, i, ui.myValueTexts[i], false));
      this._myUnhoverCallbacks.push(this._setValueEditEnabled.bind(this, i, ui.myValueTexts[i], false));
    }
    ui.myStepCursorTargetComponent.onClick.add(this._resetStep.bind(this));
    ui.myStepCursorTargetComponent.onHover.add(this._setStepEditEnabled.bind(this, ui.myStepText, true));
    ui.myStepCursorTargetComponent.onUnhover.add(this._setStepEditEnabled.bind(this, ui.myStepText, false));
    this._myUnhoverCallbacks.push(this._setStepEditEnabled.bind(this, ui.myStepText, false));
    ui.myStepIncreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 1));
    ui.myStepIncreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 1));
    ui.myStepIncreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 0));
    ui.myStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 0));
    ui.myStepDecreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, -1));
    ui.myStepDecreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, -1));
    ui.myStepDecreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 0));
    ui.myStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 0));
    this._myUnhoverCallbacks.push(this._setStepEditIntensity.bind(this, 0));
    ui.myStepIncreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myStepIncreaseButtonBackgroundComponent.material));
    ui.myStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myStepIncreaseButtonBackgroundComponent.material));
    ui.myStepDecreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myStepDecreaseButtonBackgroundComponent.material));
    ui.myStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myStepDecreaseButtonBackgroundComponent.material));
    this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myStepIncreaseButtonBackgroundComponent.material));
    this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myStepDecreaseButtonBackgroundComponent.material));
  }
  _setValueEditIntensity(index, value) {
    if (this._isActive() || value == 0) {
      if (value != 0) {
        this._myValueButtonEditIntensityTimer = this._myConfig.myButtonEditDelay;
        this._myValueRealValue = this._getVariableValue()[index];
        this._myValueEditIndex = index;
      }
      this._myValueButtonEditIntensity = value;
    }
  }
  _setStepEditIntensity(value) {
    if (this._isActive() || value == 0) {
      if (value != 0) {
        this._myStepButtonEditIntensityTimer = this._myConfig.myButtonEditDelay;
      }
      this._myStepButtonEditIntensity = value;
    }
  }
  _setValueEditEnabled(index, text, enabled) {
    if (this._isActive() || !enabled) {
      if (enabled) {
        this._myValueRealValue = this._getVariableValue()[index];
        this._myValueEditIndex = index;
        text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
      } else {
        text.pp_setScaleLocal(this._myConfig.myValueTextScale);
      }
      this._myValueEditEnabled = enabled;
    }
  }
  _setStepEditEnabled(text, enabled) {
    if (this._isActive() || !enabled) {
      if (enabled) {
        text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
      } else {
        text.pp_setScaleLocal(this._myConfig.myStepTextScale);
      }
      this._myStepEditEnabled = enabled;
    }
  }
  _resetValue(index) {
    if (this._isActive()) {
      this._myTempValue.pp_copy(this._getVariableValue());
      this._myTempValue[index] = this._getVariableDefaultValue()[index];
      this._setVariableValue(this._myTempValue);
      this._myUI.myValueTextComponents[index].text = this._getVariableValue()[index].toFixed(this._myVariable._myDecimalPlaces);
    }
  }
  _resetAllValues() {
    for (let i = 0; i < this._myArraySize; i++) {
      this._resetValue(i);
    }
  }
  _resetStep() {
    if (this._isActive()) {
      this._changeStep(this._myVariable._myDefaultStepPerSecond);
    }
  }
  _changeStep(step) {
    step = Math.pp_roundDecimal(step, 10);
    this._myVariable._myStepPerSecond = step;
    this._myUI.myStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myStepPerSecond);
  }
  _genericTextHover(text) {
    text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
  }
  _genericTextUnhover(text, originalScale) {
    text.pp_setScaleLocal(originalScale);
  }
  _getVariableValue() {
    if (this._myNonArray) {
      this._myTempNonArrayValue[0] = this._myVariable.getValue();
      return this._myTempNonArrayValue;
    }
    return this._myVariable.getValue();
  }
  _getVariableDefaultValue() {
    if (this._myNonArray) {
      this._myTempNonArrayDefaultValue[0] = this._myVariable.getDefaultValue();
      return this._myTempNonArrayDefaultValue;
    }
    return this._myVariable.getDefaultValue();
  }
  _setVariableValue(value) {
    if (this._myNonArray) {
      this._myVariable.setValue(value[0]);
    } else {
      this._myVariable.setValue(this._myTempValue);
    }
  }
};

// dist/pp/tool/easy_tune/easy_tune_widgets/number/easy_tune_number_widget_selector.js
var EasyTuneNumberArrayWidgetSelector = class extends EasyTuneBaseArrayWidgetSelector {
  _getEasyTuneArrayWidget(arraySize) {
    return new EasyTuneNumberArrayWidget(this._myParams, arraySize, this._myGamepad, this._myEngine);
  }
};

// dist/pp/tool/easy_tune/easy_tune_widgets/transform/easy_tune_transform_widget_config.js
var EasyTuneTransformWidgetConfig = class extends EasyTuneBaseWidgetConfig {
  _getBackPanelMinY() {
    return super._getBackPanelMinY() + this.myPositionPanelPosition[1] + this.myStepPanelPosition[1];
  }
  _getBackPanelMaxX() {
    return this.myDisplayPanelPosition[0] + this.myRotationPanelPosition[0] + this.myIncreaseButtonPosition[0] + this.mySideButtonBackgroundScale[0] + this._mySideButtonDistanceFromBorder;
  }
  _getBackPanelMinX() {
    return this.myDisplayPanelPosition[0] + this.myScalePanelPosition[0] + this.myDecreaseButtonPosition[0] - this.mySideButtonBackgroundScale[0] - this._mySideButtonDistanceFromBorder;
  }
  _getPivotZOffset() {
    return 805713e-8;
  }
  _setupBuildConfigHook() {
    this.myIncreaseButtonText = "+";
    this.myDecreaseButtonText = "-";
    this.myDecreaseButtonPosition = vec3_create(-0.13, 0, -1e-5);
    this.myIncreaseButtonPosition = vec3_create(-this.myDecreaseButtonPosition[0], 0, -1e-5);
    let distanceBetweenComponents = Math.abs(this.myIncreaseButtonPosition[0]) + Math.abs(this.myRightSideButtonPosition[0]);
    let distanceFromVariableLabel = 0.045;
    this.myPositionPanelPosition = [0, this.myVariableLabelPanelPosition[1] - distanceFromVariableLabel, this._myPanelZOffset];
    this.myRotationPanelPosition = [this.myPositionPanelPosition[0] + distanceBetweenComponents, this.myVariableLabelPanelPosition[1] - distanceFromVariableLabel, this._myPanelZOffset];
    this.myScalePanelPosition = [this.myPositionPanelPosition[0] - distanceBetweenComponents, this.myVariableLabelPanelPosition[1] - distanceFromVariableLabel, this._myPanelZOffset];
    this.myPositionText = "Position";
    this.myRotationText = "Rotation";
    this.myScaleText = "Scale";
    this.myComponentLabelTextScale = this.myLabelTextScale;
    this.myComponentLabelCursorTargetPosition = vec3_create(0, 0, 0);
    this.myComponentLabelCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myComponentLabelCollisionExtents = vec3_create(0.065, 0.0175, 1);
    this.myComponentLabelCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this._myValuePanelDistanceFromVariableLabelPanel = 0.055;
    this._myDistanceBetweenValues = this.mySideButtonBackgroundScale[1] * 2 + 0.015;
    this.myValueTextScale = vec3_create(0.4, 0.4, 0.4);
    this.myValueCursorTargetPosition = vec3_create(0, 0, 0);
    this.myValueCursorTargetPosition[2] = this._myColliderZOffset - this._myPanelZOffset;
    this.myValueCollisionExtents = vec3_create(0.065, 0.02, 1);
    this.myValueCollisionExtents[2] = this.myCursorTargetCollisionThickness;
    this.myValuePanelsPositions = [];
    this.myValuePanelsPositions[0] = vec3_create(0, -this._myValuePanelDistanceFromVariableLabelPanel, 0);
    for (let i = 1; i < 3; i++) {
      this.myValuePanelsPositions[i] = this.myValuePanelsPositions[i - 1].pp_clone();
      this.myValuePanelsPositions[i][1] -= this._myDistanceBetweenValues;
    }
    let valuePanelLastPosition = this.myValuePanelsPositions[2][1];
    this.myStepPanelPosition = [0, valuePanelLastPosition - this._myValuePanelDistanceFromVariableLabelPanel, 0];
    this.myStepTextScale = this.myLabelTextScale;
    this.myStepStartString = "Step: ";
    this.myStepCursorTargetPosition = vec3_create(0, 0, 0);
    this.myStepCursorTargetPosition[2] = this._myColliderZOffset - this.myStepPanelPosition[2];
    this.myStepCollisionExtents = vec3_create(0.065, 0.0175, 1);
    this.myStepCollisionExtents[2] = this.myCursorTargetCollisionThickness;
  }
  _setupRuntimeConfigHook() {
    this.myTextHoverScaleMultiplier = vec3_create(1.1, 1.1, 1.1);
    this.myEditThumbstickMinThreshold = 0.35;
    this.myStepMultiplierStepPerSecond = 2.25;
    this.myButtonEditDelay = 0;
  }
};

// dist/pp/tool/easy_tune/easy_tune_widgets/transform/easy_tune_transform_widget_ui.js
import { CollisionComponent as CollisionComponent10, MeshComponent as MeshComponent20, TextComponent as TextComponent17 } from "@wonderlandengine/api";
import { CursorTarget as CursorTarget14 } from "@wonderlandengine/components";
var EasyTuneTransformWidgetUI = class extends EasyTuneBaseWidgetUI {
  constructor(engine) {
    super(engine);
  }
  setAdditionalButtonsVisible(visible) {
    this._myAdditionalButtonsVisible = visible;
    for (let i = 0; i < 3; i++) {
      this.myPositionIncreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
      this.myPositionDecreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
    }
    this.myPositionStepIncreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
    this.myPositionStepDecreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
    for (let i = 0; i < 3; i++) {
      this.myRotationIncreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
      this.myRotationDecreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
    }
    this.myRotationStepIncreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
    this.myRotationStepDecreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
    for (let i = 0; i < 3; i++) {
      this.myScaleIncreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
      this.myScaleDecreaseButtonPanels[i].pp_setActive(this._myAdditionalButtonsVisible);
    }
    this.myScaleStepIncreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
    this.myScaleStepDecreaseButtonPanel.pp_setActive(this._myAdditionalButtonsVisible);
  }
  _buildHook() {
    this._myAdditionalButtonsVisible = true;
  }
  _createSkeletonHook() {
    this.myPositionPanel = this.myDisplayPanel.pp_addChild();
    this.myPositionLabelText = this.myPositionPanel.pp_addChild();
    this.myPositionLabelCursorTarget = this.myPositionPanel.pp_addChild();
    this.myPositionPanels = [];
    this.myPositionTexts = [];
    this.myPositionCursorTargets = [];
    this.myPositionIncreaseButtonPanels = [];
    this.myPositionIncreaseButtonBackgrounds = [];
    this.myPositionIncreaseButtonTexts = [];
    this.myPositionIncreaseButtonCursorTargets = [];
    this.myPositionDecreaseButtonPanels = [];
    this.myPositionDecreaseButtonBackgrounds = [];
    this.myPositionDecreaseButtonTexts = [];
    this.myPositionDecreaseButtonCursorTargets = [];
    for (let i = 0; i < 3; i++) {
      this.myPositionPanels[i] = this.myPositionPanel.pp_addChild();
      this.myPositionTexts[i] = this.myPositionPanels[i].pp_addChild();
      this.myPositionCursorTargets[i] = this.myPositionPanels[i].pp_addChild();
      this.myPositionIncreaseButtonPanels[i] = this.myPositionPanels[i].pp_addChild();
      this.myPositionIncreaseButtonBackgrounds[i] = this.myPositionIncreaseButtonPanels[i].pp_addChild();
      this.myPositionIncreaseButtonTexts[i] = this.myPositionIncreaseButtonPanels[i].pp_addChild();
      this.myPositionIncreaseButtonCursorTargets[i] = this.myPositionIncreaseButtonPanels[i].pp_addChild();
      this.myPositionDecreaseButtonPanels[i] = this.myPositionPanels[i].pp_addChild();
      this.myPositionDecreaseButtonBackgrounds[i] = this.myPositionDecreaseButtonPanels[i].pp_addChild();
      this.myPositionDecreaseButtonTexts[i] = this.myPositionDecreaseButtonPanels[i].pp_addChild();
      this.myPositionDecreaseButtonCursorTargets[i] = this.myPositionDecreaseButtonPanels[i].pp_addChild();
    }
    this.myRotationPanel = this.myDisplayPanel.pp_addChild();
    this.myRotationLabelText = this.myRotationPanel.pp_addChild();
    this.myRotationLabelCursorTarget = this.myRotationPanel.pp_addChild();
    this.myRotationPanels = [];
    this.myRotationTexts = [];
    this.myRotationCursorTargets = [];
    this.myRotationIncreaseButtonPanels = [];
    this.myRotationIncreaseButtonBackgrounds = [];
    this.myRotationIncreaseButtonTexts = [];
    this.myRotationIncreaseButtonCursorTargets = [];
    this.myRotationDecreaseButtonPanels = [];
    this.myRotationDecreaseButtonBackgrounds = [];
    this.myRotationDecreaseButtonTexts = [];
    this.myRotationDecreaseButtonCursorTargets = [];
    for (let i = 0; i < 3; i++) {
      this.myRotationPanels[i] = this.myRotationPanel.pp_addChild();
      this.myRotationTexts[i] = this.myRotationPanels[i].pp_addChild();
      this.myRotationCursorTargets[i] = this.myRotationPanels[i].pp_addChild();
      this.myRotationIncreaseButtonPanels[i] = this.myRotationPanels[i].pp_addChild();
      this.myRotationIncreaseButtonBackgrounds[i] = this.myRotationIncreaseButtonPanels[i].pp_addChild();
      this.myRotationIncreaseButtonTexts[i] = this.myRotationIncreaseButtonPanels[i].pp_addChild();
      this.myRotationIncreaseButtonCursorTargets[i] = this.myRotationIncreaseButtonPanels[i].pp_addChild();
      this.myRotationDecreaseButtonPanels[i] = this.myRotationPanels[i].pp_addChild();
      this.myRotationDecreaseButtonBackgrounds[i] = this.myRotationDecreaseButtonPanels[i].pp_addChild();
      this.myRotationDecreaseButtonTexts[i] = this.myRotationDecreaseButtonPanels[i].pp_addChild();
      this.myRotationDecreaseButtonCursorTargets[i] = this.myRotationDecreaseButtonPanels[i].pp_addChild();
    }
    this.myScalePanel = this.myDisplayPanel.pp_addChild();
    this.myScaleLabelText = this.myScalePanel.pp_addChild();
    this.myScaleLabelCursorTarget = this.myScalePanel.pp_addChild();
    this.myScalePanels = [];
    this.myScaleTexts = [];
    this.myScaleCursorTargets = [];
    this.myScaleIncreaseButtonPanels = [];
    this.myScaleIncreaseButtonBackgrounds = [];
    this.myScaleIncreaseButtonTexts = [];
    this.myScaleIncreaseButtonCursorTargets = [];
    this.myScaleDecreaseButtonPanels = [];
    this.myScaleDecreaseButtonBackgrounds = [];
    this.myScaleDecreaseButtonTexts = [];
    this.myScaleDecreaseButtonCursorTargets = [];
    for (let i = 0; i < 3; i++) {
      this.myScalePanels[i] = this.myScalePanel.pp_addChild();
      this.myScaleTexts[i] = this.myScalePanels[i].pp_addChild();
      this.myScaleCursorTargets[i] = this.myScalePanels[i].pp_addChild();
      this.myScaleIncreaseButtonPanels[i] = this.myScalePanels[i].pp_addChild();
      this.myScaleIncreaseButtonBackgrounds[i] = this.myScaleIncreaseButtonPanels[i].pp_addChild();
      this.myScaleIncreaseButtonTexts[i] = this.myScaleIncreaseButtonPanels[i].pp_addChild();
      this.myScaleIncreaseButtonCursorTargets[i] = this.myScaleIncreaseButtonPanels[i].pp_addChild();
      this.myScaleDecreaseButtonPanels[i] = this.myScalePanels[i].pp_addChild();
      this.myScaleDecreaseButtonBackgrounds[i] = this.myScaleDecreaseButtonPanels[i].pp_addChild();
      this.myScaleDecreaseButtonTexts[i] = this.myScaleDecreaseButtonPanels[i].pp_addChild();
      this.myScaleDecreaseButtonCursorTargets[i] = this.myScaleDecreaseButtonPanels[i].pp_addChild();
    }
    this.myPositionStepPanel = this.myPositionPanel.pp_addChild();
    this.myPositionStepText = this.myPositionStepPanel.pp_addChild();
    this.myPositionStepCursorTarget = this.myPositionStepPanel.pp_addChild();
    this.myPositionStepIncreaseButtonPanel = this.myPositionStepPanel.pp_addChild();
    this.myPositionStepIncreaseButtonBackground = this.myPositionStepIncreaseButtonPanel.pp_addChild();
    this.myPositionStepIncreaseButtonText = this.myPositionStepIncreaseButtonPanel.pp_addChild();
    this.myPositionStepIncreaseButtonCursorTarget = this.myPositionStepIncreaseButtonPanel.pp_addChild();
    this.myPositionStepDecreaseButtonPanel = this.myPositionStepPanel.pp_addChild();
    this.myPositionStepDecreaseButtonBackground = this.myPositionStepDecreaseButtonPanel.pp_addChild();
    this.myPositionStepDecreaseButtonText = this.myPositionStepDecreaseButtonPanel.pp_addChild();
    this.myPositionStepDecreaseButtonCursorTarget = this.myPositionStepDecreaseButtonPanel.pp_addChild();
    this.myRotationStepPanel = this.myRotationPanel.pp_addChild();
    this.myRotationStepText = this.myRotationStepPanel.pp_addChild();
    this.myRotationStepCursorTarget = this.myRotationStepPanel.pp_addChild();
    this.myRotationStepIncreaseButtonPanel = this.myRotationStepPanel.pp_addChild();
    this.myRotationStepIncreaseButtonBackground = this.myRotationStepIncreaseButtonPanel.pp_addChild();
    this.myRotationStepIncreaseButtonText = this.myRotationStepIncreaseButtonPanel.pp_addChild();
    this.myRotationStepIncreaseButtonCursorTarget = this.myRotationStepIncreaseButtonPanel.pp_addChild();
    this.myRotationStepDecreaseButtonPanel = this.myRotationStepPanel.pp_addChild();
    this.myRotationStepDecreaseButtonBackground = this.myRotationStepDecreaseButtonPanel.pp_addChild();
    this.myRotationStepDecreaseButtonText = this.myRotationStepDecreaseButtonPanel.pp_addChild();
    this.myRotationStepDecreaseButtonCursorTarget = this.myRotationStepDecreaseButtonPanel.pp_addChild();
    this.myScaleStepPanel = this.myScalePanel.pp_addChild();
    this.myScaleStepText = this.myScaleStepPanel.pp_addChild();
    this.myScaleStepCursorTarget = this.myScaleStepPanel.pp_addChild();
    this.myScaleStepIncreaseButtonPanel = this.myScaleStepPanel.pp_addChild();
    this.myScaleStepIncreaseButtonBackground = this.myScaleStepIncreaseButtonPanel.pp_addChild();
    this.myScaleStepIncreaseButtonText = this.myScaleStepIncreaseButtonPanel.pp_addChild();
    this.myScaleStepIncreaseButtonCursorTarget = this.myScaleStepIncreaseButtonPanel.pp_addChild();
    this.myScaleStepDecreaseButtonPanel = this.myScaleStepPanel.pp_addChild();
    this.myScaleStepDecreaseButtonBackground = this.myScaleStepDecreaseButtonPanel.pp_addChild();
    this.myScaleStepDecreaseButtonText = this.myScaleStepDecreaseButtonPanel.pp_addChild();
    this.myScaleStepDecreaseButtonCursorTarget = this.myScaleStepDecreaseButtonPanel.pp_addChild();
  }
  _setTransformHook() {
    this.myPositionPanel.pp_setPositionLocal(this._myConfig.myPositionPanelPosition);
    this.myPositionLabelText.pp_scaleObject(this._myConfig.myComponentLabelTextScale);
    this.myPositionLabelCursorTarget.pp_setPositionLocal(this._myConfig.myComponentLabelCursorTargetPosition);
    for (let i = 0; i < 3; i++) {
      this.myPositionPanels[i].pp_setPositionLocal(this._myConfig.myValuePanelsPositions[i]);
      this.myPositionTexts[i].pp_scaleObject(this._myConfig.myValueTextScale);
      this.myPositionCursorTargets[i].pp_setPositionLocal(this._myConfig.myValueCursorTargetPosition);
      this.myPositionIncreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myIncreaseButtonPosition);
      this.myPositionIncreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myPositionIncreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myPositionIncreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myPositionIncreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
      this.myPositionDecreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myDecreaseButtonPosition);
      this.myPositionDecreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myPositionDecreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myPositionDecreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myPositionDecreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    }
    this.myRotationPanel.pp_setPositionLocal(this._myConfig.myRotationPanelPosition);
    this.myRotationLabelText.pp_scaleObject(this._myConfig.myComponentLabelTextScale);
    this.myRotationLabelCursorTarget.pp_setPositionLocal(this._myConfig.myComponentLabelCursorTargetPosition);
    for (let i = 0; i < 3; i++) {
      this.myRotationPanels[i].pp_setPositionLocal(this._myConfig.myValuePanelsPositions[i]);
      this.myRotationTexts[i].pp_scaleObject(this._myConfig.myValueTextScale);
      this.myRotationCursorTargets[i].pp_setPositionLocal(this._myConfig.myValueCursorTargetPosition);
      this.myRotationIncreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myIncreaseButtonPosition);
      this.myRotationIncreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myRotationIncreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myRotationIncreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myRotationIncreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
      this.myRotationDecreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myDecreaseButtonPosition);
      this.myRotationDecreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myRotationDecreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myRotationDecreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myRotationDecreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    }
    this.myScalePanel.pp_setPositionLocal(this._myConfig.myScalePanelPosition);
    this.myScaleLabelText.pp_scaleObject(this._myConfig.myComponentLabelTextScale);
    this.myScaleLabelCursorTarget.pp_setPositionLocal(this._myConfig.myComponentLabelCursorTargetPosition);
    for (let i = 0; i < 3; i++) {
      this.myScalePanels[i].pp_setPositionLocal(this._myConfig.myValuePanelsPositions[i]);
      this.myScaleTexts[i].pp_scaleObject(this._myConfig.myValueTextScale);
      this.myScaleCursorTargets[i].pp_setPositionLocal(this._myConfig.myValueCursorTargetPosition);
      this.myScaleIncreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myIncreaseButtonPosition);
      this.myScaleIncreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myScaleIncreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myScaleIncreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myScaleIncreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
      this.myScaleDecreaseButtonPanels[i].pp_setPositionLocal(this._myConfig.myDecreaseButtonPosition);
      this.myScaleDecreaseButtonBackgrounds[i].pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
      this.myScaleDecreaseButtonTexts[i].pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
      this.myScaleDecreaseButtonTexts[i].pp_scaleObject(this._myConfig.mySideButtonTextScale);
      this.myScaleDecreaseButtonCursorTargets[i].pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    }
    this.myPositionStepPanel.pp_setPositionLocal(this._myConfig.myStepPanelPosition);
    this.myPositionStepText.pp_scaleObject(this._myConfig.myStepTextScale);
    this.myPositionStepCursorTarget.pp_setPositionLocal(this._myConfig.myStepCursorTargetPosition);
    this.myPositionStepIncreaseButtonPanel.pp_setPositionLocal(this._myConfig.myIncreaseButtonPosition);
    this.myPositionStepIncreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myPositionStepIncreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myPositionStepIncreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myPositionStepIncreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myPositionStepDecreaseButtonPanel.pp_setPositionLocal(this._myConfig.myDecreaseButtonPosition);
    this.myPositionStepDecreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myPositionStepDecreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myPositionStepDecreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myPositionStepDecreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myRotationStepPanel.pp_setPositionLocal(this._myConfig.myStepPanelPosition);
    this.myRotationStepText.pp_scaleObject(this._myConfig.myStepTextScale);
    this.myRotationStepCursorTarget.pp_setPositionLocal(this._myConfig.myStepCursorTargetPosition);
    this.myRotationStepIncreaseButtonPanel.pp_setPositionLocal(this._myConfig.myIncreaseButtonPosition);
    this.myRotationStepIncreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myRotationStepIncreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myRotationStepIncreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myRotationStepIncreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myRotationStepDecreaseButtonPanel.pp_setPositionLocal(this._myConfig.myDecreaseButtonPosition);
    this.myRotationStepDecreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myRotationStepDecreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myRotationStepDecreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myRotationStepDecreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myScaleStepPanel.pp_setPositionLocal(this._myConfig.myStepPanelPosition);
    this.myScaleStepText.pp_scaleObject(this._myConfig.myStepTextScale);
    this.myScaleStepCursorTarget.pp_setPositionLocal(this._myConfig.myStepCursorTargetPosition);
    this.myScaleStepIncreaseButtonPanel.pp_setPositionLocal(this._myConfig.myIncreaseButtonPosition);
    this.myScaleStepIncreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myScaleStepIncreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myScaleStepIncreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myScaleStepIncreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
    this.myScaleStepDecreaseButtonPanel.pp_setPositionLocal(this._myConfig.myDecreaseButtonPosition);
    this.myScaleStepDecreaseButtonBackground.pp_scaleObject(this._myConfig.mySideButtonBackgroundScale);
    this.myScaleStepDecreaseButtonText.pp_setPositionLocal(this._myConfig.mySideButtonTextPosition);
    this.myScaleStepDecreaseButtonText.pp_scaleObject(this._myConfig.mySideButtonTextScale);
    this.myScaleStepDecreaseButtonCursorTarget.pp_setPositionLocal(this._myConfig.mySideButtonCursorTargetPosition);
  }
  _addComponentsHook() {
    this.myPositionLabelTextComponent = this.myPositionLabelText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myPositionLabelTextComponent);
    this.myPositionLabelTextComponent.text = this._myConfig.myPositionText;
    this.myPositionLabelCursorTargetComponent = this.myPositionLabelCursorTarget.pp_addComponent(CursorTarget14);
    this.myPositionLabelCollisionComponent = this.myPositionLabelCursorTarget.pp_addComponent(CollisionComponent10);
    this.myPositionLabelCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionLabelCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionLabelCollisionComponent.extents = this._myConfig.myComponentLabelCollisionExtents;
    this.myPositionTextComponents = [];
    this.myPositionCursorTargetComponents = [];
    this.myPositionCollisionComponents = [];
    this.myPositionIncreaseButtonBackgroundComponents = [];
    this.myPositionIncreaseButtonTextComponents = [];
    this.myPositionIncreaseButtonCursorTargetComponents = [];
    this.myPositionIncreaseButtonCollisionComponents = [];
    this.myPositionDecreaseButtonBackgroundComponents = [];
    this.myPositionDecreaseButtonTextComponents = [];
    this.myPositionDecreaseButtonCursorTargetComponents = [];
    this.myPositionDecreaseButtonCollisionComponents = [];
    for (let i = 0; i < 3; i++) {
      this.myPositionTextComponents[i] = this.myPositionTexts[i].pp_addComponent(TextComponent17);
      this._setupTextComponent(this.myPositionTextComponents[i]);
      this.myPositionTextComponents[i].text = " ";
      this.myPositionCursorTargetComponents[i] = this.myPositionCursorTargets[i].pp_addComponent(CursorTarget14);
      this.myPositionCollisionComponents[i] = this.myPositionCursorTargets[i].pp_addComponent(CollisionComponent10);
      this.myPositionCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myPositionCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myPositionCollisionComponents[i].extents = this._myConfig.myValueCollisionExtents;
      this.myPositionIncreaseButtonBackgroundComponents[i] = this.myPositionIncreaseButtonBackgrounds[i].pp_addComponent(MeshComponent20);
      this.myPositionIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myPositionIncreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myPositionIncreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myPositionIncreaseButtonTextComponents[i] = this.myPositionIncreaseButtonTexts[i].pp_addComponent(TextComponent17);
      this._setupTextComponent(this.myPositionIncreaseButtonTextComponents[i]);
      this.myPositionIncreaseButtonTextComponents[i].text = this._myConfig.myIncreaseButtonText;
      this.myPositionIncreaseButtonCursorTargetComponents[i] = this.myPositionIncreaseButtonCursorTargets[i].pp_addComponent(CursorTarget14);
      this.myPositionIncreaseButtonCollisionComponents[i] = this.myPositionIncreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent10);
      this.myPositionIncreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myPositionIncreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myPositionIncreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
      this.myPositionDecreaseButtonBackgroundComponents[i] = this.myPositionDecreaseButtonBackgrounds[i].pp_addComponent(MeshComponent20);
      this.myPositionDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myPositionDecreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myPositionDecreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myPositionDecreaseButtonTextComponents[i] = this.myPositionDecreaseButtonTexts[i].pp_addComponent(TextComponent17);
      this._setupTextComponent(this.myPositionDecreaseButtonTextComponents[i]);
      this.myPositionDecreaseButtonTextComponents[i].text = this._myConfig.myDecreaseButtonText;
      this.myPositionDecreaseButtonCursorTargetComponents[i] = this.myPositionDecreaseButtonCursorTargets[i].pp_addComponent(CursorTarget14);
      this.myPositionDecreaseButtonCollisionComponents[i] = this.myPositionDecreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent10);
      this.myPositionDecreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myPositionDecreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myPositionDecreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
    }
    this.myRotationLabelTextComponent = this.myRotationLabelText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myRotationLabelTextComponent);
    this.myRotationLabelTextComponent.text = this._myConfig.myRotationText;
    this.myRotationLabelCursorTargetComponent = this.myRotationLabelCursorTarget.pp_addComponent(CursorTarget14);
    this.myRotationLabelCollisionComponent = this.myRotationLabelCursorTarget.pp_addComponent(CollisionComponent10);
    this.myRotationLabelCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationLabelCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationLabelCollisionComponent.extents = this._myConfig.myComponentLabelCollisionExtents;
    this.myRotationTextComponents = [];
    this.myRotationCursorTargetComponents = [];
    this.myRotationCollisionComponents = [];
    this.myRotationIncreaseButtonBackgroundComponents = [];
    this.myRotationIncreaseButtonTextComponents = [];
    this.myRotationIncreaseButtonCursorTargetComponents = [];
    this.myRotationIncreaseButtonCollisionComponents = [];
    this.myRotationDecreaseButtonBackgroundComponents = [];
    this.myRotationDecreaseButtonTextComponents = [];
    this.myRotationDecreaseButtonCursorTargetComponents = [];
    this.myRotationDecreaseButtonCollisionComponents = [];
    for (let i = 0; i < 3; i++) {
      this.myRotationTextComponents[i] = this.myRotationTexts[i].pp_addComponent(TextComponent17);
      this._setupTextComponent(this.myRotationTextComponents[i]);
      this.myRotationTextComponents[i].text = " ";
      this.myRotationCursorTargetComponents[i] = this.myRotationCursorTargets[i].pp_addComponent(CursorTarget14);
      this.myRotationCollisionComponents[i] = this.myRotationCursorTargets[i].pp_addComponent(CollisionComponent10);
      this.myRotationCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myRotationCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myRotationCollisionComponents[i].extents = this._myConfig.myValueCollisionExtents;
      this.myRotationIncreaseButtonBackgroundComponents[i] = this.myRotationIncreaseButtonBackgrounds[i].pp_addComponent(MeshComponent20);
      this.myRotationIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myRotationIncreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myRotationIncreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myRotationIncreaseButtonTextComponents[i] = this.myRotationIncreaseButtonTexts[i].pp_addComponent(TextComponent17);
      this._setupTextComponent(this.myRotationIncreaseButtonTextComponents[i]);
      this.myRotationIncreaseButtonTextComponents[i].text = this._myConfig.myIncreaseButtonText;
      this.myRotationIncreaseButtonCursorTargetComponents[i] = this.myRotationIncreaseButtonCursorTargets[i].pp_addComponent(CursorTarget14);
      this.myRotationIncreaseButtonCollisionComponents[i] = this.myRotationIncreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent10);
      this.myRotationIncreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myRotationIncreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myRotationIncreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
      this.myRotationDecreaseButtonBackgroundComponents[i] = this.myRotationDecreaseButtonBackgrounds[i].pp_addComponent(MeshComponent20);
      this.myRotationDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myRotationDecreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myRotationDecreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myRotationDecreaseButtonTextComponents[i] = this.myRotationDecreaseButtonTexts[i].pp_addComponent(TextComponent17);
      this._setupTextComponent(this.myRotationDecreaseButtonTextComponents[i]);
      this.myRotationDecreaseButtonTextComponents[i].text = this._myConfig.myDecreaseButtonText;
      this.myRotationDecreaseButtonCursorTargetComponents[i] = this.myRotationDecreaseButtonCursorTargets[i].pp_addComponent(CursorTarget14);
      this.myRotationDecreaseButtonCollisionComponents[i] = this.myRotationDecreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent10);
      this.myRotationDecreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myRotationDecreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myRotationDecreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
    }
    this.myScaleLabelTextComponent = this.myScaleLabelText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myScaleLabelTextComponent);
    this.myScaleLabelTextComponent.text = this._myConfig.myScaleText;
    this.myScaleLabelCursorTargetComponent = this.myScaleLabelCursorTarget.pp_addComponent(CursorTarget14);
    this.myScaleLabelCollisionComponent = this.myScaleLabelCursorTarget.pp_addComponent(CollisionComponent10);
    this.myScaleLabelCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleLabelCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleLabelCollisionComponent.extents = this._myConfig.myComponentLabelCollisionExtents;
    this.myScaleTextComponents = [];
    this.myScaleCursorTargetComponents = [];
    this.myScaleCollisionComponents = [];
    this.myScaleIncreaseButtonBackgroundComponents = [];
    this.myScaleIncreaseButtonTextComponents = [];
    this.myScaleIncreaseButtonCursorTargetComponents = [];
    this.myScaleIncreaseButtonCollisionComponents = [];
    this.myScaleDecreaseButtonBackgroundComponents = [];
    this.myScaleDecreaseButtonTextComponents = [];
    this.myScaleDecreaseButtonCursorTargetComponents = [];
    this.myScaleDecreaseButtonCollisionComponents = [];
    for (let i = 0; i < 3; i++) {
      this.myScaleTextComponents[i] = this.myScaleTexts[i].pp_addComponent(TextComponent17);
      this._setupTextComponent(this.myScaleTextComponents[i]);
      this.myScaleTextComponents[i].text = " ";
      this.myScaleCursorTargetComponents[i] = this.myScaleCursorTargets[i].pp_addComponent(CursorTarget14);
      this.myScaleCollisionComponents[i] = this.myScaleCursorTargets[i].pp_addComponent(CollisionComponent10);
      this.myScaleCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myScaleCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myScaleCollisionComponents[i].extents = this._myConfig.myValueCollisionExtents;
      this.myScaleIncreaseButtonBackgroundComponents[i] = this.myScaleIncreaseButtonBackgrounds[i].pp_addComponent(MeshComponent20);
      this.myScaleIncreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myScaleIncreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myScaleIncreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myScaleIncreaseButtonTextComponents[i] = this.myScaleIncreaseButtonTexts[i].pp_addComponent(TextComponent17);
      this._setupTextComponent(this.myScaleIncreaseButtonTextComponents[i]);
      this.myScaleIncreaseButtonTextComponents[i].text = this._myConfig.myIncreaseButtonText;
      this.myScaleIncreaseButtonCursorTargetComponents[i] = this.myScaleIncreaseButtonCursorTargets[i].pp_addComponent(CursorTarget14);
      this.myScaleIncreaseButtonCollisionComponents[i] = this.myScaleIncreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent10);
      this.myScaleIncreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myScaleIncreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myScaleIncreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
      this.myScaleDecreaseButtonBackgroundComponents[i] = this.myScaleDecreaseButtonBackgrounds[i].pp_addComponent(MeshComponent20);
      this.myScaleDecreaseButtonBackgroundComponents[i].mesh = this._myPlaneMesh;
      this.myScaleDecreaseButtonBackgroundComponents[i].material = this._myParams.myPlaneMaterial.clone();
      this.myScaleDecreaseButtonBackgroundComponents[i].material.color = this._myConfig.myBackgroundColor;
      this.myScaleDecreaseButtonTextComponents[i] = this.myScaleDecreaseButtonTexts[i].pp_addComponent(TextComponent17);
      this._setupTextComponent(this.myScaleDecreaseButtonTextComponents[i]);
      this.myScaleDecreaseButtonTextComponents[i].text = this._myConfig.myDecreaseButtonText;
      this.myScaleDecreaseButtonCursorTargetComponents[i] = this.myScaleDecreaseButtonCursorTargets[i].pp_addComponent(CursorTarget14);
      this.myScaleDecreaseButtonCollisionComponents[i] = this.myScaleDecreaseButtonCursorTargets[i].pp_addComponent(CollisionComponent10);
      this.myScaleDecreaseButtonCollisionComponents[i].collider = this._myConfig.myCursorTargetCollisionCollider;
      this.myScaleDecreaseButtonCollisionComponents[i].group = 1 << this._myConfig.myCursorTargetCollisionGroup;
      this.myScaleDecreaseButtonCollisionComponents[i].extents = this._myConfig.mySideButtonCollisionExtents;
    }
    this.myPositionStepTextComponent = this.myPositionStepText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myPositionStepTextComponent);
    this.myPositionStepTextComponent.text = " ";
    this.myPositionStepCursorTargetComponent = this.myPositionStepCursorTarget.pp_addComponent(CursorTarget14);
    this.myPositionStepCollisionComponent = this.myPositionStepCursorTarget.pp_addComponent(CollisionComponent10);
    this.myPositionStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myPositionStepIncreaseButtonBackgroundComponent = this.myPositionStepIncreaseButtonBackground.pp_addComponent(MeshComponent20);
    this.myPositionStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPositionStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myPositionStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myPositionStepIncreaseButtonTextComponent = this.myPositionStepIncreaseButtonText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myPositionStepIncreaseButtonTextComponent);
    this.myPositionStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myPositionStepIncreaseButtonCursorTargetComponent = this.myPositionStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget14);
    this.myPositionStepIncreaseButtonCollisionComponent = this.myPositionStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent10);
    this.myPositionStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myPositionStepDecreaseButtonBackgroundComponent = this.myPositionStepDecreaseButtonBackground.pp_addComponent(MeshComponent20);
    this.myPositionStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPositionStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myPositionStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myPositionStepDecreaseButtonTextComponent = this.myPositionStepDecreaseButtonText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myPositionStepDecreaseButtonTextComponent);
    this.myPositionStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myPositionStepDecreaseButtonCursorTargetComponent = this.myPositionStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget14);
    this.myPositionStepDecreaseButtonCollisionComponent = this.myPositionStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent10);
    this.myPositionStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myRotationStepTextComponent = this.myRotationStepText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myRotationStepTextComponent);
    this.myRotationStepTextComponent.text = " ";
    this.myRotationStepCursorTargetComponent = this.myRotationStepCursorTarget.pp_addComponent(CursorTarget14);
    this.myRotationStepCollisionComponent = this.myRotationStepCursorTarget.pp_addComponent(CollisionComponent10);
    this.myRotationStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myRotationStepIncreaseButtonBackgroundComponent = this.myRotationStepIncreaseButtonBackground.pp_addComponent(MeshComponent20);
    this.myRotationStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myRotationStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myRotationStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myRotationStepIncreaseButtonTextComponent = this.myRotationStepIncreaseButtonText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myRotationStepIncreaseButtonTextComponent);
    this.myRotationStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myRotationStepIncreaseButtonCursorTargetComponent = this.myRotationStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget14);
    this.myRotationStepIncreaseButtonCollisionComponent = this.myRotationStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent10);
    this.myRotationStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myRotationStepDecreaseButtonBackgroundComponent = this.myRotationStepDecreaseButtonBackground.pp_addComponent(MeshComponent20);
    this.myRotationStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myRotationStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myRotationStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myRotationStepDecreaseButtonTextComponent = this.myRotationStepDecreaseButtonText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myRotationStepDecreaseButtonTextComponent);
    this.myRotationStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myRotationStepDecreaseButtonCursorTargetComponent = this.myRotationStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget14);
    this.myRotationStepDecreaseButtonCollisionComponent = this.myRotationStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent10);
    this.myRotationStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myScaleStepTextComponent = this.myScaleStepText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myScaleStepTextComponent);
    this.myScaleStepTextComponent.text = " ";
    this.myScaleStepCursorTargetComponent = this.myScaleStepCursorTarget.pp_addComponent(CursorTarget14);
    this.myScaleStepCollisionComponent = this.myScaleStepCursorTarget.pp_addComponent(CollisionComponent10);
    this.myScaleStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myScaleStepIncreaseButtonBackgroundComponent = this.myScaleStepIncreaseButtonBackground.pp_addComponent(MeshComponent20);
    this.myScaleStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myScaleStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myScaleStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myScaleStepIncreaseButtonTextComponent = this.myScaleStepIncreaseButtonText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myScaleStepIncreaseButtonTextComponent);
    this.myScaleStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myScaleStepIncreaseButtonCursorTargetComponent = this.myScaleStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget14);
    this.myScaleStepIncreaseButtonCollisionComponent = this.myScaleStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent10);
    this.myScaleStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myScaleStepDecreaseButtonBackgroundComponent = this.myScaleStepDecreaseButtonBackground.pp_addComponent(MeshComponent20);
    this.myScaleStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myScaleStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myScaleStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myScaleStepDecreaseButtonTextComponent = this.myScaleStepDecreaseButtonText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myScaleStepDecreaseButtonTextComponent);
    this.myScaleStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myScaleStepDecreaseButtonCursorTargetComponent = this.myScaleStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget14);
    this.myScaleStepDecreaseButtonCollisionComponent = this.myScaleStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent10);
    this.myScaleStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
  }
  _addStepComponents() {
    this.myPositionStepTextComponent = this.myPositionStepText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myPositionStepTextComponent);
    this.myPositionStepTextComponent.text = " ";
    this.myPositionStepCursorTargetComponent = this.myPositionStepCursorTarget.pp_addComponent(CursorTarget14);
    this.myPositionStepCollisionComponent = this.myPositionStepCursorTarget.pp_addComponent(CollisionComponent10);
    this.myPositionStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myPositionStepIncreaseButtonBackgroundComponent = this.myPositionStepIncreaseButtonBackground.pp_addComponent(MeshComponent20);
    this.myPositionStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPositionStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myPositionStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myPositionStepIncreaseButtonTextComponent = this.myPositionStepIncreaseButtonText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myPositionStepIncreaseButtonTextComponent);
    this.myPositionStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myPositionStepIncreaseButtonCursorTargetComponent = this.myPositionStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget14);
    this.myPositionStepIncreaseButtonCollisionComponent = this.myPositionStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent10);
    this.myPositionStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myPositionStepDecreaseButtonBackgroundComponent = this.myPositionStepDecreaseButtonBackground.pp_addComponent(MeshComponent20);
    this.myPositionStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myPositionStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myPositionStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myPositionStepDecreaseButtonTextComponent = this.myPositionStepDecreaseButtonText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myPositionStepDecreaseButtonTextComponent);
    this.myPositionStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myPositionStepDecreaseButtonCursorTargetComponent = this.myPositionStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget14);
    this.myPositionStepDecreaseButtonCollisionComponent = this.myPositionStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent10);
    this.myPositionStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myPositionStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myPositionStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myRotationStepTextComponent = this.myRotationStepText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myRotationStepTextComponent);
    this.myRotationStepTextComponent.text = " ";
    this.myRotationStepCursorTargetComponent = this.myRotationStepCursorTarget.pp_addComponent(CursorTarget14);
    this.myRotationStepCollisionComponent = this.myRotationStepCursorTarget.pp_addComponent(CollisionComponent10);
    this.myRotationStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myRotationStepIncreaseButtonBackgroundComponent = this.myRotationStepIncreaseButtonBackground.pp_addComponent(MeshComponent20);
    this.myRotationStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myRotationStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myRotationStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myRotationStepIncreaseButtonTextComponent = this.myRotationStepIncreaseButtonText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myRotationStepIncreaseButtonTextComponent);
    this.myRotationStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myRotationStepIncreaseButtonCursorTargetComponent = this.myRotationStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget14);
    this.myRotationStepIncreaseButtonCollisionComponent = this.myRotationStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent10);
    this.myRotationStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myRotationStepDecreaseButtonBackgroundComponent = this.myRotationStepDecreaseButtonBackground.pp_addComponent(MeshComponent20);
    this.myRotationStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myRotationStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myRotationStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myRotationStepDecreaseButtonTextComponent = this.myRotationStepDecreaseButtonText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myRotationStepDecreaseButtonTextComponent);
    this.myRotationStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myRotationStepDecreaseButtonCursorTargetComponent = this.myRotationStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget14);
    this.myRotationStepDecreaseButtonCollisionComponent = this.myRotationStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent10);
    this.myRotationStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myRotationStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myRotationStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myScaleStepTextComponent = this.myScaleStepText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myScaleStepTextComponent);
    this.myScaleStepTextComponent.text = " ";
    this.myScaleStepCursorTargetComponent = this.myScaleStepCursorTarget.pp_addComponent(CursorTarget14);
    this.myScaleStepCollisionComponent = this.myScaleStepCursorTarget.pp_addComponent(CollisionComponent10);
    this.myScaleStepCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleStepCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleStepCollisionComponent.extents = this._myConfig.myStepCollisionExtents;
    this.myScaleStepIncreaseButtonBackgroundComponent = this.myScaleStepIncreaseButtonBackground.pp_addComponent(MeshComponent20);
    this.myScaleStepIncreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myScaleStepIncreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myScaleStepIncreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myScaleStepIncreaseButtonTextComponent = this.myScaleStepIncreaseButtonText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myScaleStepIncreaseButtonTextComponent);
    this.myScaleStepIncreaseButtonTextComponent.text = this._myConfig.myIncreaseButtonText;
    this.myScaleStepIncreaseButtonCursorTargetComponent = this.myScaleStepIncreaseButtonCursorTarget.pp_addComponent(CursorTarget14);
    this.myScaleStepIncreaseButtonCollisionComponent = this.myScaleStepIncreaseButtonCursorTarget.pp_addComponent(CollisionComponent10);
    this.myScaleStepIncreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleStepIncreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleStepIncreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
    this.myScaleStepDecreaseButtonBackgroundComponent = this.myScaleStepDecreaseButtonBackground.pp_addComponent(MeshComponent20);
    this.myScaleStepDecreaseButtonBackgroundComponent.mesh = this._myPlaneMesh;
    this.myScaleStepDecreaseButtonBackgroundComponent.material = this._myParams.myPlaneMaterial.clone();
    this.myScaleStepDecreaseButtonBackgroundComponent.material.color = this._myConfig.myBackgroundColor;
    this.myScaleStepDecreaseButtonTextComponent = this.myScaleStepDecreaseButtonText.pp_addComponent(TextComponent17);
    this._setupTextComponent(this.myScaleStepDecreaseButtonTextComponent);
    this.myScaleStepDecreaseButtonTextComponent.text = this._myConfig.myDecreaseButtonText;
    this.myScaleStepDecreaseButtonCursorTargetComponent = this.myScaleStepDecreaseButtonCursorTarget.pp_addComponent(CursorTarget14);
    this.myScaleStepDecreaseButtonCollisionComponent = this.myScaleStepDecreaseButtonCursorTarget.pp_addComponent(CollisionComponent10);
    this.myScaleStepDecreaseButtonCollisionComponent.collider = this._myConfig.myCursorTargetCollisionCollider;
    this.myScaleStepDecreaseButtonCollisionComponent.group = 1 << this._myConfig.myCursorTargetCollisionGroup;
    this.myScaleStepDecreaseButtonCollisionComponent.extents = this._myConfig.mySideButtonCollisionExtents;
  }
};

// dist/pp/tool/easy_tune/easy_tune_widgets/transform/easy_tune_transform_widget.js
var EasyTuneTransformWidget = class extends EasyTuneBaseWidget {
  constructor(params, gamepad, engine = Globals.getMainEngine()) {
    super(params);
    this._myGamepad = gamepad;
    this._myConfig = new EasyTuneTransformWidgetConfig();
    this._myUI = new EasyTuneTransformWidgetUI(engine);
    this._myValueButtonEditIntensity = 0;
    this._myValueButtonEditIntensityTimer = 0;
    this._myStepButtonEditIntensity = 0;
    this._myStepButtonEditIntensityTimer = 0;
    this._myValueEditEnabled = false;
    this._myStepEditEnabled = false;
    this._myValueRealValue = 0;
    this._myComponentStepValue = 0;
    this._myStepMultiplierValue = 0;
    this._myStepFastEdit = false;
    this._myValueEditIndex = -1;
    this._myComponentIndex = 0;
    this._myStepIndex = 0;
    this._myTempTransformValue = mat4_create();
    this._myTempPositionValue = vec3_create();
    this._myTempRotationValue = vec3_create();
    this._myTempScaleValue = vec3_create();
  }
  _refreshUIHook() {
    for (let i = 0; i < 3; i++) {
      this._myUI.myPositionTextComponents[i].text = this._myVariable._myPosition[i].toFixed(this._myVariable._myDecimalPlaces);
    }
    this._myUI.myPositionStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myPositionStepPerSecond);
    for (let i = 0; i < 3; i++) {
      this._myUI.myRotationTextComponents[i].text = this._myVariable._myRotation[i].toFixed(this._myVariable._myDecimalPlaces);
    }
    this._myUI.myRotationStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myRotationStepPerSecond);
    for (let i = 0; i < 3; i++) {
      this._myUI.myScaleTextComponents[i].text = this._myVariable._myScale[i].toFixed(this._myVariable._myDecimalPlaces);
    }
    this._myUI.myScaleStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myScaleStepPerSecond);
  }
  _startHook(parentObject, easyTuneParams) {
    this._myUI.setAdditionalButtonsVisible(easyTuneParams.myShowAdditionalButtons);
  }
  _setEasyTuneVariableHook() {
    if (this._myVariable != null) {
      if (this._myValueEditIndex >= 0 && this._myValueEditIndex < 3) {
        switch (this._myComponentIndex) {
          case 0:
            this._myValueRealValue = this._myVariable._myPosition[this._myValueEditIndex];
            this._myComponentStepValue = this._myVariable._myPositionStepPerSecond;
            break;
          case 1:
            this._myValueRealValue = this._myVariable._myRotation[this._myValueEditIndex];
            this._myComponentStepValue = this._myVariable._myRotationStepPerSecond;
            break;
          case 2:
            this._myValueRealValue = this._myVariable._myScale[this._myValueEditIndex];
            this._myComponentStepValue = this._myVariable._myScaleStepPerSecond;
            break;
        }
      }
      this._myTempPositionValue.pp_copy(this._myVariable._myPosition);
      this._myTempRotationValue.pp_copy(this._myVariable._myRotation);
      this._myTempScaleValue.pp_copy(this._myVariable._myScale);
      this._myStepMultiplierValue = 0;
      this._myStepFastEdit = false;
    }
  }
  _updateHook(dt) {
    this._updateValue(dt);
  }
  _updateValue(dt) {
    let stickVariableIntensity = 0;
    if (this._myGamepad) {
      let y = this._myGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes[1];
      if (Math.abs(y) > this._myConfig.myEditThumbstickMinThreshold) {
        let normalizedEditAmount = (Math.abs(y) - this._myConfig.myEditThumbstickMinThreshold) / (1 - this._myConfig.myEditThumbstickMinThreshold);
        stickVariableIntensity = Math.sign(y) * normalizedEditAmount;
      }
    }
    let valueIntensity = 0;
    if (this._myValueEditEnabled) {
      valueIntensity = stickVariableIntensity;
    } else if (this._myValueButtonEditIntensity != 0) {
      if (this._myValueButtonEditIntensityTimer <= 0) {
        valueIntensity = this._myValueButtonEditIntensity;
      } else {
        this._myValueButtonEditIntensityTimer -= dt;
      }
    }
    if (this._myValueEditIndex >= 0 && this._myValueEditIndex < 3) {
      if (valueIntensity != 0) {
        this._myTempPositionValue.pp_copy(this._myVariable._myPosition);
        this._myTempRotationValue.pp_copy(this._myVariable._myRotation);
        this._myTempScaleValue.pp_copy(this._myVariable._myScale);
        let amountToAdd = valueIntensity * this._myComponentStepValue * dt;
        this._myValueRealValue += amountToAdd;
        let decimalPlacesMultiplier = Math.pow(10, this._myVariable._myDecimalPlaces);
        switch (this._myComponentIndex) {
          case 0:
            this._myTempPositionValue[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
            this._myUI.myPositionTextComponents[this._myValueEditIndex].text = this._myTempPositionValue[this._myValueEditIndex].toFixed(this._myVariable._myDecimalPlaces);
            break;
          case 1:
            if (this._myValueRealValue > 180) {
              while (this._myValueRealValue > 180) {
                this._myValueRealValue -= 180;
              }
              this._myValueRealValue = -180 + this._myValueRealValue;
            }
            if (this._myValueRealValue < -180) {
              while (this._myValueRealValue < -180) {
                this._myValueRealValue += 180;
              }
              this._myValueRealValue = 180 - this._myValueRealValue;
            }
            this._myTempRotationValue[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
            this._myUI.myRotationTextComponents[this._myValueEditIndex].text = this._myTempRotationValue[this._myValueEditIndex].toFixed(this._myVariable._myDecimalPlaces);
            break;
          case 2:
            if (this._myValueRealValue <= 0) {
              this._myValueRealValue = 1 / decimalPlacesMultiplier;
            }
            if (this._myVariable._myScaleAsOne) {
              let newValue = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
              let difference = newValue - this._myTempScaleValue[this._myValueEditIndex];
              for (let i = 0; i < 3; i++) {
                this._myTempScaleValue[i] = Math.round((this._myTempScaleValue[i] + difference) * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
                this._myTempScaleValue[i] = Math.max(this._myTempScaleValue[i], 1 / decimalPlacesMultiplier);
                this._myUI.myScaleTextComponents[i].text = this._myTempScaleValue[i].toFixed(this._myVariable._myDecimalPlaces);
              }
            } else {
              this._myTempScaleValue[this._myValueEditIndex] = Math.round(this._myValueRealValue * decimalPlacesMultiplier + Number.EPSILON) / decimalPlacesMultiplier;
              this._myTempScaleValue[this._myValueEditIndex] = Math.max(this._myTempScaleValue[this._myValueEditIndex], 1 / decimalPlacesMultiplier);
              this._myUI.myScaleTextComponents[this._myValueEditIndex].text = this._myTempScaleValue[this._myValueEditIndex].toFixed(this._myVariable._myDecimalPlaces);
            }
            break;
        }
        this._myTempTransformValue.mat4_setPositionRotationDegreesScale(this._myTempPositionValue, this._myTempRotationValue, this._myTempScaleValue);
        this._myVariable.setValue(this._myTempTransformValue);
      } else {
        switch (this._myComponentIndex) {
          case 0:
            this._myValueRealValue = this._myVariable._myPosition[this._myValueEditIndex];
            break;
          case 1:
            this._myValueRealValue = this._myVariable._myRotation[this._myValueEditIndex];
            break;
          case 2:
            this._myValueRealValue = this._myVariable._myScale[this._myValueEditIndex];
            break;
        }
      }
    }
    let stepIntensity = 0;
    if (this._myStepEditEnabled) {
      stepIntensity = stickVariableIntensity;
    } else if (this._myStepButtonEditIntensity != 0) {
      if (this._myStepButtonEditIntensityTimer <= 0) {
        stepIntensity = this._myStepButtonEditIntensity;
      } else {
        this._myStepButtonEditIntensityTimer -= dt;
      }
    }
    if (stepIntensity != 0) {
      let amountToAdd = 0;
      if (this._myStepFastEdit) {
        amountToAdd = Math.sign(stepIntensity) * 1;
        this._myStepFastEdit = false;
      } else {
        amountToAdd = stepIntensity * this._myConfig.myStepMultiplierStepPerSecond * dt;
      }
      this._myStepMultiplierValue += amountToAdd;
      if (Math.abs(this._myStepMultiplierValue) >= 1) {
        let stepValue = 0;
        switch (this._myStepIndex) {
          case 0:
            stepValue = this._myVariable._myPositionStepPerSecond;
            break;
          case 1:
            stepValue = this._myVariable._myRotationStepPerSecond;
            break;
          case 2:
            stepValue = this._myVariable._myScaleStepPerSecond;
            break;
          default:
            stepValue = 0;
        }
        if (Math.sign(this._myStepMultiplierValue) > 0) {
          this._myStepMultiplierValue -= 1;
          this._changeStep(this._myStepIndex, stepValue * 10);
        } else {
          this._myStepMultiplierValue += 1;
          this._changeStep(this._myStepIndex, stepValue * 0.1);
        }
      }
    } else {
      this._myStepMultiplierValue = 0;
      this._myStepFastEdit = true;
    }
  }
  _addListenersHook() {
    let ui = this._myUI;
    ui.myVariableLabelCursorTargetComponent.onClick.add(this._resetAllValues.bind(this));
    ui.myVariableLabelCursorTargetComponent.onHover.add(this._genericTextHover.bind(this, ui.myVariableLabelText));
    ui.myVariableLabelCursorTargetComponent.onUnhover.add(this._genericTextUnhover.bind(this, ui.myVariableLabelText, this._myConfig.myVariableLabelTextScale));
    this._myUnhoverCallbacks.push(this._genericTextUnhover.bind(this, ui.myVariableLabelText, this._myConfig.myVariableLabelTextScale));
    ui.myPositionLabelCursorTargetComponent.onClick.add(this._resetComponentValues.bind(this, 0));
    ui.myPositionLabelCursorTargetComponent.onHover.add(this._genericTextHover.bind(this, ui.myPositionLabelText));
    ui.myPositionLabelCursorTargetComponent.onUnhover.add(this._genericTextUnhover.bind(this, ui.myPositionLabelText, this._myConfig.myComponentLabelTextScale));
    this._myUnhoverCallbacks.push(this._genericTextUnhover.bind(this, ui.myPositionLabelText, this._myConfig.myComponentLabelTextScale));
    for (let i = 0; i < 3; i++) {
      ui.myPositionIncreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, 0, i, 1));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, 0, i, 1));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, 0, i, 0));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, 0, i, 0));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, 0, i, -1));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, 0, i, -1));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, 0, i, 0));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, 0, i, 0));
      this._myUnhoverCallbacks.push(this._setValueEditIntensity.bind(this, 0, i, 0));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myPositionIncreaseButtonBackgroundComponents[i].material));
      ui.myPositionIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myPositionIncreaseButtonBackgroundComponents[i].material));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myPositionDecreaseButtonBackgroundComponents[i].material));
      ui.myPositionDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myPositionDecreaseButtonBackgroundComponents[i].material));
      this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myPositionIncreaseButtonBackgroundComponents[i].material));
      this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myPositionDecreaseButtonBackgroundComponents[i].material));
      ui.myPositionCursorTargetComponents[i].onClick.add(this._resetValue.bind(this, 0, i));
      ui.myPositionCursorTargetComponents[i].onHover.add(this._setValueEditEnabled.bind(this, 0, i, ui.myPositionTexts[i], true));
      ui.myPositionCursorTargetComponents[i].onUnhover.add(this._setValueEditEnabled.bind(this, 0, i, ui.myPositionTexts[i], false));
      this._myUnhoverCallbacks.push(this._setValueEditEnabled.bind(this, 0, i, ui.myPositionTexts[i], false));
    }
    ui.myRotationLabelCursorTargetComponent.onClick.add(this._resetComponentValues.bind(this, 1));
    ui.myRotationLabelCursorTargetComponent.onHover.add(this._genericTextHover.bind(this, ui.myRotationLabelText));
    ui.myRotationLabelCursorTargetComponent.onUnhover.add(this._genericTextUnhover.bind(this, ui.myRotationLabelText, this._myConfig.myComponentLabelTextScale));
    this._myUnhoverCallbacks.push(this._genericTextUnhover.bind(this, ui.myRotationLabelText, this._myConfig.myComponentLabelTextScale));
    for (let i = 0; i < 3; i++) {
      ui.myRotationIncreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, 1, i, 1));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, 1, i, 1));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, 1, i, 0));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, 1, i, 0));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, 1, i, -1));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, 1, i, -1));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, 1, i, 0));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, 1, i, 0));
      this._myUnhoverCallbacks.push(this._setValueEditIntensity.bind(this, 1, i, 0));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myRotationIncreaseButtonBackgroundComponents[i].material));
      ui.myRotationIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myRotationIncreaseButtonBackgroundComponents[i].material));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myRotationDecreaseButtonBackgroundComponents[i].material));
      ui.myRotationDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myRotationDecreaseButtonBackgroundComponents[i].material));
      this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myRotationIncreaseButtonBackgroundComponents[i].material));
      this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myRotationDecreaseButtonBackgroundComponents[i].material));
      ui.myRotationCursorTargetComponents[i].onClick.add(this._resetValue.bind(this, 1, i));
      ui.myRotationCursorTargetComponents[i].onHover.add(this._setValueEditEnabled.bind(this, 1, i, ui.myRotationTexts[i], true));
      ui.myRotationCursorTargetComponents[i].onUnhover.add(this._setValueEditEnabled.bind(this, 1, i, ui.myRotationTexts[i], false));
      this._myUnhoverCallbacks.push(this._setValueEditEnabled.bind(this, 1, i, ui.myRotationTexts[i], false));
    }
    ui.myScaleLabelCursorTargetComponent.onClick.add(this._resetComponentValues.bind(this, 2));
    ui.myScaleLabelCursorTargetComponent.onHover.add(this._genericTextHover.bind(this, ui.myScaleLabelText));
    ui.myScaleLabelCursorTargetComponent.onUnhover.add(this._genericTextUnhover.bind(this, ui.myScaleLabelText, this._myConfig.myComponentLabelTextScale));
    this._myUnhoverCallbacks.push(this._genericTextUnhover.bind(this, ui.myScaleLabelText, this._myConfig.myComponentLabelTextScale));
    for (let i = 0; i < 3; i++) {
      ui.myScaleIncreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, 2, i, 1));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, 2, i, 1));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, 2, i, 0));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, 2, i, 0));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].onDown.add(this._setValueEditIntensity.bind(this, 2, i, -1));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].onDownOnHover.add(this._setValueEditIntensity.bind(this, 2, i, -1));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].onUp.add(this._setValueEditIntensity.bind(this, 2, i, 0));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._setValueEditIntensity.bind(this, 2, i, 0));
      this._myUnhoverCallbacks.push(this._setValueEditIntensity.bind(this, 2, i, 0));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myScaleIncreaseButtonBackgroundComponents[i].material));
      ui.myScaleIncreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myScaleIncreaseButtonBackgroundComponents[i].material));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].onHover.add(this._genericHover.bind(this, ui.myScaleDecreaseButtonBackgroundComponents[i].material));
      ui.myScaleDecreaseButtonCursorTargetComponents[i].onUnhover.add(this._genericUnhover.bind(this, ui.myScaleDecreaseButtonBackgroundComponents[i].material));
      this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myScaleIncreaseButtonBackgroundComponents[i].material));
      this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myScaleDecreaseButtonBackgroundComponents[i].material));
      ui.myScaleCursorTargetComponents[i].onClick.add(this._resetValue.bind(this, 2, i));
      ui.myScaleCursorTargetComponents[i].onHover.add(this._setValueEditEnabled.bind(this, 2, i, ui.myScaleTexts[i], true));
      ui.myScaleCursorTargetComponents[i].onUnhover.add(this._setValueEditEnabled.bind(this, 2, i, ui.myScaleTexts[i], false));
      this._myUnhoverCallbacks.push(this._setValueEditEnabled.bind(this, 2, i, ui.myScaleTexts[i], false));
    }
    ui.myPositionStepCursorTargetComponent.onClick.add(this._resetStep.bind(this, 0));
    ui.myPositionStepCursorTargetComponent.onHover.add(this._setStepEditEnabled.bind(this, 0, ui.myPositionStepText, true));
    ui.myPositionStepCursorTargetComponent.onUnhover.add(this._setStepEditEnabled.bind(this, 0, ui.myPositionStepText, false));
    this._myUnhoverCallbacks.push(this._setStepEditEnabled.bind(this, 0, ui.myPositionStepText, false));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 0, 1));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 0, 1));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 0, 0));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 0, 0));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 0, -1));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 0, -1));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 0, 0));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 0, 0));
    this._myUnhoverCallbacks.push(this._setStepEditIntensity.bind(this, 0, 0));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myPositionStepIncreaseButtonBackgroundComponent.material));
    ui.myPositionStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myPositionStepIncreaseButtonBackgroundComponent.material));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myPositionStepDecreaseButtonBackgroundComponent.material));
    ui.myPositionStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myPositionStepDecreaseButtonBackgroundComponent.material));
    this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myPositionStepIncreaseButtonBackgroundComponent.material));
    this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myPositionStepDecreaseButtonBackgroundComponent.material));
    ui.myRotationStepCursorTargetComponent.onClick.add(this._resetStep.bind(this, 1));
    ui.myRotationStepCursorTargetComponent.onHover.add(this._setStepEditEnabled.bind(this, 1, ui.myRotationStepText, true));
    ui.myRotationStepCursorTargetComponent.onUnhover.add(this._setStepEditEnabled.bind(this, 1, ui.myRotationStepText, false));
    this._myUnhoverCallbacks.push(this._setStepEditEnabled.bind(this, 1, ui.myRotationStepText, false));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 1, 1));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 1, 1));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 1, 0));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 1, 0));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 1, -1));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 1, -1));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 1, 0));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 1, 0));
    this._myUnhoverCallbacks.push(this._setStepEditIntensity.bind(this, 1, 0));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myRotationStepIncreaseButtonBackgroundComponent.material));
    ui.myRotationStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myRotationStepIncreaseButtonBackgroundComponent.material));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myRotationStepDecreaseButtonBackgroundComponent.material));
    ui.myRotationStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myRotationStepDecreaseButtonBackgroundComponent.material));
    this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myRotationStepIncreaseButtonBackgroundComponent.material));
    this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myRotationStepDecreaseButtonBackgroundComponent.material));
    ui.myScaleStepCursorTargetComponent.onClick.add(this._resetStep.bind(this, 2));
    ui.myScaleStepCursorTargetComponent.onHover.add(this._setStepEditEnabled.bind(this, 2, ui.myScaleStepText, true));
    ui.myScaleStepCursorTargetComponent.onUnhover.add(this._setStepEditEnabled.bind(this, 2, ui.myScaleStepText, false));
    this._myUnhoverCallbacks.push(this._setStepEditEnabled.bind(this, 2, ui.myScaleStepText, false));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 2, 1));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 2, 1));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 2, 0));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 2, 0));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.onDown.add(this._setStepEditIntensity.bind(this, 2, -1));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.onDownOnHover.add(this._setStepEditIntensity.bind(this, 2, -1));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.onUp.add(this._setStepEditIntensity.bind(this, 2, 0));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._setStepEditIntensity.bind(this, 2, 0));
    this._myUnhoverCallbacks.push(this._setStepEditIntensity.bind(this, 2, 0));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myScaleStepIncreaseButtonBackgroundComponent.material));
    ui.myScaleStepIncreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myScaleStepIncreaseButtonBackgroundComponent.material));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.onHover.add(this._genericHover.bind(this, ui.myScaleStepDecreaseButtonBackgroundComponent.material));
    ui.myScaleStepDecreaseButtonCursorTargetComponent.onUnhover.add(this._genericUnhover.bind(this, ui.myScaleStepDecreaseButtonBackgroundComponent.material));
    this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myScaleStepIncreaseButtonBackgroundComponent.material));
    this._myUnhoverCallbacks.push(this._genericUnhover.bind(this, ui.myScaleStepDecreaseButtonBackgroundComponent.material));
  }
  _setValueEditIntensity(componentIndex, index, value) {
    if (this._isActive() || value == 0) {
      if (value != 0) {
        switch (componentIndex) {
          case 0:
            this._myValueRealValue = this._myVariable._myPosition[index];
            this._myComponentStepValue = this._myVariable._myPositionStepPerSecond;
            break;
          case 1:
            this._myValueRealValue = this._myVariable._myRotation[index];
            this._myComponentStepValue = this._myVariable._myRotationStepPerSecond;
            break;
          case 2:
            this._myValueRealValue = this._myVariable._myScale[index];
            this._myComponentStepValue = this._myVariable._myScaleStepPerSecond;
            break;
        }
        this._myValueButtonEditIntensityTimer = this._myConfig.myButtonEditDelay;
        this._myValueEditIndex = index;
        this._myComponentIndex = componentIndex;
      }
      this._myValueButtonEditIntensity = value;
    }
  }
  _setStepEditIntensity(index, value) {
    if (this._isActive() || value == 0) {
      if (value != 0) {
        this._myStepButtonEditIntensityTimer = this._myConfig.myButtonEditDelay;
      }
      this._myStepButtonEditIntensity = value;
      this._myStepIndex = index;
    }
  }
  _setValueEditEnabled(componentIndex, index, text, enabled) {
    if (this._isActive() || !enabled) {
      if (enabled) {
        switch (componentIndex) {
          case 0:
            this._myValueRealValue = this._myVariable._myPosition[index];
            this._myComponentStepValue = this._myVariable._myPositionStepPerSecond;
            break;
          case 1:
            this._myValueRealValue = this._myVariable._myRotation[index];
            this._myComponentStepValue = this._myVariable._myRotationStepPerSecond;
            break;
          case 2:
            this._myValueRealValue = this._myVariable._myScale[index];
            this._myComponentStepValue = this._myVariable._myScaleStepPerSecond;
            break;
        }
        this._myValueEditIndex = index;
        this._myComponentIndex = componentIndex;
        text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
      } else {
        text.pp_setScaleLocal(this._myConfig.myValueTextScale);
      }
      this._myValueEditEnabled = enabled;
    }
  }
  _setStepEditEnabled(index, text, enabled) {
    if (this._isActive() || !enabled) {
      if (enabled) {
        text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
      } else {
        text.pp_setScaleLocal(this._myConfig.myStepTextScale);
      }
      this._myStepEditEnabled = enabled;
      this._myStepIndex = index;
    }
  }
  _resetValue(componentIndex, index) {
    if (this._isActive()) {
      this._myTempPositionValue.pp_copy(this._myVariable._myPosition);
      this._myTempRotationValue.pp_copy(this._myVariable._myRotation);
      this._myTempScaleValue.pp_copy(this._myVariable._myScale);
      switch (componentIndex) {
        case 0:
          this._myTempPositionValue[index] = this._myVariable._myDefaultPosition[index];
          this._myUI.myPositionTextComponents[index].text = this._myTempPositionValue[index].toFixed(this._myVariable._myDecimalPlaces);
          break;
        case 1:
          this._myTempRotationValue[index] = this._myVariable._myDefaultRotation[index];
          this._myUI.myRotationTextComponents[index].text = this._myTempRotationValue[index].toFixed(this._myVariable._myDecimalPlaces);
          break;
        case 2:
          this._myTempScaleValue[index] = this._myVariable._myDefaultScale[index];
          this._myUI.myScaleTextComponents[index].text = this._myTempScaleValue[index].toFixed(this._myVariable._myDecimalPlaces);
          break;
      }
      this._myTempTransformValue.mat4_setPositionRotationDegreesScale(this._myTempPositionValue, this._myTempRotationValue, this._myTempScaleValue);
      this._myVariable.setValue(this._myTempTransformValue);
    }
  }
  _resetAllValues() {
    for (let i = 0; i < 3; i++) {
      this._resetComponentValues(i);
    }
  }
  _resetComponentValues(index) {
    for (let i = 0; i < 3; i++) {
      this._resetValue(index, i);
    }
  }
  _resetStep(index) {
    if (this._isActive()) {
      let defaultValue = 0;
      switch (index) {
        case 0:
          defaultValue = this._myVariable._myDefaultPositionStepPerSecond;
          break;
        case 1:
          defaultValue = this._myVariable._myDefaultRotationStepPerSecond;
          break;
        case 2:
          defaultValue = this._myVariable._myDefaultScaleStepPerSecond;
          break;
        default:
          defaultValue = 0;
      }
      this._changeStep(index, defaultValue);
    }
  }
  _changeStep(index, step) {
    step = Math.pp_roundDecimal(step, 10);
    switch (index) {
      case 0:
        this._myVariable._myPositionStepPerSecond = step;
        this._myUI.myPositionStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myPositionStepPerSecond);
        break;
      case 1:
        this._myVariable._myRotationStepPerSecond = step;
        this._myUI.myRotationStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myRotationStepPerSecond);
        break;
      case 2:
        this._myVariable._myScaleStepPerSecond = step;
        this._myUI.myScaleStepTextComponent.text = this._myConfig.myStepStartString.concat(this._myVariable._myScaleStepPerSecond);
        break;
    }
  }
  _genericTextHover(text) {
    text.pp_scaleObject(this._myConfig.myTextHoverScaleMultiplier);
  }
  _genericTextUnhover(text, originalScale) {
    text.pp_setScaleLocal(originalScale);
  }
};

// dist/pp/tool/easy_tune/easy_tune_widgets/easy_tune_widget.js
var EasyTuneWidgetParams = class extends WidgetParams {
  constructor() {
    super();
    this.myShowOnStart = false;
    this.myShowVisibilityButton = false;
    this.myShowAdditionalButtons = false;
    this.myGamepadScrollVariableEnabled = false;
    this.myShowVariablesImportExportButtons = false;
    this.myVariablesImportCallback = null;
    this.myVariablesExportCallback = null;
  }
};
var EasyTuneWidget = class {
  constructor(engine = Globals.getMainEngine()) {
    this._myStarted = false;
    this._myStartVariable = null;
    this._myActive = true;
    this._myVisibleBackup = null;
    this._myWidgetFrame = new WidgetFrame("E", 1, engine);
    this._myWidgetFrame.registerWidgetVisibleChangedEventListener(this, this._widgetVisibleChanged.bind(this));
    this._myConfig = new EasyTuneWidgetConfig();
    this._myParams = null;
    this._myWidgets = [];
    this._myEasyTuneVariables = null;
    this._myEasyTuneLastSize = 0;
    this._myVariableNames = null;
    this._myCurrentWidget = null;
    this._myCurrentVariable = null;
    this._myScrollVariableTimer = 0;
    this._myGamepad = null;
    this._myRefreshVariablesTimer = 0;
    this._myDirty = false;
    this._myEngine = engine;
    this._myDestroyed = false;
  }
  setCurrentVariable(variableName) {
    if (!this._myStarted) {
      this._myStartVariable = variableName;
    } else if (this._myEasyTuneVariables.has(variableName)) {
      this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(variableName);
      this._selectCurrentWidget();
    } else {
      console.warn("Can't change easy tune current variable to inexistent variable:", variableName);
    }
  }
  refresh() {
    if (this._myWidgetFrame.isVisible()) {
      this._myDirty = true;
    }
  }
  setVisible(visible) {
    if (this._myActive) {
      this._myWidgetFrame.setVisible(visible);
    } else {
      this._myVisibleBackup = visible;
    }
  }
  isVisible() {
    return this._myWidgetFrame.isVisible();
  }
  start(parentObject, params, easyTuneVariables) {
    this._myRightGamepad = Globals.getRightGamepad(this._myEngine);
    this._myLeftGamepad = Globals.getLeftGamepad(this._myEngine);
    if (this._myConfig.myGamepadHandedness == ToolHandedness.RIGHT) {
      this._myGamepad = this._myRightGamepad;
    } else if (this._myConfig.myGamepadHandedness == ToolHandedness.LEFT) {
      this._myGamepad = this._myLeftGamepad;
    }
    this._myStarted = true;
    this._myParams = params;
    this._myWidgetFrame.start(parentObject, params);
    this._myEasyTuneVariables = easyTuneVariables;
    this._myEasyTuneLastSize = this.getValidEasyTuneVariablesLength();
    this._myVariableNames = this.getValidEasyTuneVariablesNames();
    if (this.getValidEasyTuneVariablesLength() > 0) {
      this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myVariableNames[0]);
    }
    if (this._myStartVariable != null) {
      if (this._myEasyTuneVariables.has(this._myStartVariable)) {
        this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myStartVariable);
      } else {
        console.warn("Can't change easy tune current variable to inexistent variable:", this._myStartVariable);
      }
    }
    this._initializeWidgets();
  }
  update(dt) {
    if (!this._myActive)
      return;
    this._myWidgetFrame.update(dt);
    if (this.getValidEasyTuneVariablesLength() != this._myEasyTuneLastSize || this._myDirty) {
      this._refreshEasyTuneVariables();
    }
    if (this._myWidgetFrame.isVisible() && this.getValidEasyTuneVariablesLength() > 0) {
      if (this._myConfig.myRefreshVariablesDelay != null) {
        this._myRefreshVariablesTimer += dt;
        if (this._myRefreshVariablesTimer > this._myConfig.myRefreshVariablesDelay) {
          this._myRefreshVariablesTimer = 0;
          this._refreshEasyTuneVariables();
        }
      }
      if (this._myCurrentWidget) {
        this._myCurrentWidget.update(dt);
      }
      if (this._myParams.myGamepadScrollVariableEnabled) {
        this._updateGamepadScrollVariable(dt);
      }
    }
    this._updateGamepadWidgetVisibility();
    this._updateWidgetCurrentVariable();
  }
  isActive() {
    return this._myActive;
  }
  setActive(active) {
    if (!this._myStarted)
      return;
    for (let widget of this._myWidgets) {
      widget.setActive(active);
    }
    this._myWidgetFrame.setActive(active);
    if (this._myActive != active) {
      if (active) {
        this._myActive = active;
        if (this._myVisibleBackup != null) {
          this.setVisible(false);
          this.setVisible(this._myVisibleBackup);
          this._myVisibleBackup = null;
        }
      } else {
        if (this._myVisibleBackup == null) {
          this._myVisibleBackup = this.isVisible();
        }
        if (this.isVisible()) {
          this.setVisible(false);
        }
        this._myActive = active;
      }
    }
  }
  _initializeWidgets() {
    let widgetParams = new EasyTuneBaseWidgetParams();
    widgetParams.myVariablesImportCallback = this._importVariables.bind(this);
    widgetParams.myVariablesExportCallback = this._exportVariables.bind(this);
    this._myWidgets[EasyTuneVariableType.NONE] = new EasyTuneNoneWidget(widgetParams, this._myEngine);
    this._myWidgets[EasyTuneVariableType.NUMBER] = new EasyTuneNumberArrayWidgetSelector(widgetParams, this._myGamepad, this._myEngine);
    this._myWidgets[EasyTuneVariableType.BOOL] = new EasyTuneBoolArrayWidgetSelector(widgetParams, this._myGamepad, this._myEngine);
    this._myWidgets[EasyTuneVariableType.TRANSFORM] = new EasyTuneTransformWidget(widgetParams, this._myGamepad, this._myEngine);
    for (let widget of this._myWidgets) {
      widget.start(this._myWidgetFrame.getWidgetObject(), this._myParams);
      widget.setVisible(false);
      widget.registerScrollVariableRequestEventListener(this, this._scrollVariable.bind(this));
    }
    this._selectCurrentWidget();
  }
  _selectCurrentWidget() {
    if (this.getValidEasyTuneVariablesLength() <= 0) {
      return;
    } else if (this._myCurrentVariable == null) {
      this._myVariableNames = this.getValidEasyTuneVariablesNames();
      this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myVariableNames[0]);
    }
    let prevWidget = null;
    if (this._myCurrentWidget != null) {
      prevWidget = this._myCurrentWidget.getWidget();
    }
    if (this._myCurrentVariable.getType() in this._myWidgets) {
      this._myCurrentWidget = this._myWidgets[this._myCurrentVariable.getType()];
    } else {
      this._myCurrentWidget = this._myWidgets[EasyTuneVariableType.NONE];
    }
    this._myCurrentWidget.setEasyTuneVariable(this._myCurrentVariable, this._createIndexString());
    this._myCurrentWidget.getWidget().syncWidget(prevWidget);
    if (prevWidget != null && this._myCurrentWidget.getWidget() != prevWidget) {
      prevWidget.setVisible(false);
    }
    this._myCurrentWidget.setVisible(this._myWidgetFrame.isVisible());
  }
  _refreshEasyTuneVariables() {
    this._myVariableNames = this.getValidEasyTuneVariablesNames();
    this._myEasyTuneLastSize = this.getValidEasyTuneVariablesLength();
    if (this.getValidEasyTuneVariablesLength() > 0) {
      if (this._myCurrentVariable && this._myVariableNames.pp_hasEqual(this._myCurrentVariable.getName())) {
        this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myCurrentVariable.getName());
      } else {
        this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myVariableNames[0]);
      }
      this._selectCurrentWidget();
    } else {
      this._myCurrentVariable = null;
      if (this._myCurrentWidget) {
        this._myCurrentWidget.setVisible(false);
        this._myCurrentWidget = null;
      }
    }
    this._myDirty = false;
  }
  _updateGamepadWidgetVisibility() {
    if (this._myGamepad) {
      if (this._myGamepad.getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressStart() && this._myGamepad.getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed() || this._myGamepad.getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && this._myGamepad.getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressed()) {
        this._toggleVisibility();
      }
    }
  }
  _toggleVisibility() {
    this._myWidgetFrame.toggleVisibility();
  }
  _widgetVisibleChanged(visible) {
    for (let widget of this._myWidgets) {
      widget.setVisible(false);
    }
    if (this._myCurrentWidget) {
      if (this.getValidEasyTuneVariablesLength() > 0) {
        this._myCurrentWidget.setVisible(visible);
      } else {
        this._myCurrentWidget.setVisible(false);
      }
    }
    if (visible) {
      this._refreshEasyTuneVariables();
    }
  }
  _updateGamepadScrollVariable(dt) {
    if (this._myGamepad && (!this._myConfig.myScrollVariableButtonID || this._myGamepad.getButtonInfo(this._myConfig.myScrollVariableButtonID).isPressed())) {
      let x = this._myGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes[0];
      let y = this._myGamepad.getAxesInfo(GamepadAxesID.THUMBSTICK).myAxes[1];
      if (Math.abs(x) > this._myConfig.myScrollVariableMinXThreshold && Math.abs(y) < this._myConfig.myScrollVariableMaxYThreshold) {
        this._myScrollVariableTimer += dt;
        while (this._myScrollVariableTimer > this._myConfig.myScrollVariableDelay) {
          this._myScrollVariableTimer -= this._myConfig.myScrollVariableDelay;
          this._scrollVariable(Math.sign(x));
        }
      } else {
        this._myScrollVariableTimer = this._myConfig.myScrollVariableDelay;
      }
    } else {
      this._myScrollVariableTimer = this._myConfig.myScrollVariableDelay;
    }
  }
  _scrollVariable(amount) {
    if (this.getValidEasyTuneVariablesLength() <= 0) {
      return;
    }
    let variableIndex = this._getVariableIndex(this._myCurrentVariable);
    if (variableIndex >= 0) {
      let newIndex = ((variableIndex + amount) % this._myVariableNames.length + this._myVariableNames.length) % this._myVariableNames.length;
      if (this._myEasyTuneVariables.has(this._myVariableNames[newIndex])) {
        this._myCurrentVariable = this._myEasyTuneVariables.getEasyTuneVariable(this._myVariableNames[newIndex]);
        this._selectCurrentWidget();
      } else {
        this._refreshEasyTuneVariables();
      }
    } else {
      this._refreshEasyTuneVariables();
    }
  }
  _createIndexString() {
    let indexString = " (";
    let index = (this._getVariableIndex(this._myCurrentVariable) + 1).toString();
    let length6 = this.getValidEasyTuneVariablesLength().toString();
    while (index.length < length6.length) {
      index = "0".concat(index);
    }
    indexString = indexString.concat(index).concat(" - ").concat(length6).concat(")");
    return indexString;
  }
  _getVariableIndex(variable) {
    let variableIndex = this._myVariableNames.indexOf(variable.getName());
    return variableIndex;
  }
  _updateWidgetCurrentVariable() {
    for (let variable of this._myEasyTuneVariables.getEasyTuneVariablesList()) {
      variable.setWidgetCurrentVariable(false);
    }
    if (this._myWidgetFrame.isVisible() && this._myCurrentVariable) {
      this._myCurrentVariable.setWidgetCurrentVariable(true);
    }
  }
  _importVariables() {
    this._myParams.myVariablesImportCallback(this._onImportSuccess.bind(this), this._onImportFailure.bind(this));
  }
  _exportVariables() {
    this._myParams.myVariablesExportCallback(this._onExportSuccess.bind(this), this._onExportFailure.bind(this));
  }
  _onImportSuccess() {
    if (this._myCurrentWidget) {
      this._myCurrentWidget.onImportSuccess();
    }
  }
  _onImportFailure() {
    if (this._myCurrentWidget) {
      this._myCurrentWidget.onImportFailure();
    }
  }
  _onExportSuccess() {
    if (this._myCurrentWidget) {
      this._myCurrentWidget.onExportSuccess();
    }
  }
  _onExportFailure() {
    if (this._myCurrentWidget) {
      this._myCurrentWidget.onExportFailure();
    }
  }
  destroy() {
    this._myDestroyed = true;
    this.setActive(false);
    for (let widget of this._myWidgets) {
      widget.destroy();
    }
    this._myWidgetFrame.destroy();
  }
  isDestroyed() {
    return this._myDestroyed;
  }
  getValidEasyTuneVariablesLength() {
    return this.getValidEasyTuneVariablesNames().length;
  }
  getValidEasyTuneVariablesNames() {
    let names = this._myEasyTuneVariables.getEasyTuneVariablesNames();
    let validNames = [];
    for (let name of names) {
      let variable = this._myEasyTuneVariables.getEasyTuneVariable(name);
      if (variable.isShownOnWidget()) {
        validNames.push(name);
      }
    }
    return validNames;
  }
};

// dist/pp/tool/easy_tune/components/easy_tune_tool_component.js
var __decorate12 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EasyTuneToolComponent = class extends Component65 {
  static TypeName = "pp-easy-tune-tool";
  _myHandedness;
  _myShowOnStart;
  _myShowVisibilityButton;
  _myGamepadScrollVariableEnabled;
  _myShowVariablesImportExportButtons;
  /**
   *  Can contain parameters inside brackets, like `my-url.com/{param}`,
   *  which will be replaced with the same one on the current page url, like `www.currentpage.com/?param=2`
   *  If empty, it will import from the clipboard
   */
  _myVariablesImportURL;
  /**
   *  Can contain parameters inside brackets, like `my-url.com/{param}`,
   *  which will be replaced with the same one on the current page url, like `www.currentpage.com/?param=2`
   *  If empty, it will import from the clipboard
   */
  _myVariablesExportURL;
  _myImportVariablesOnStart;
  _myResetVariablesDefaultValueOnImport;
  _myKeepImportVariablesOnExport;
  _myAvoidExportingVariablesWithValueAsDefault;
  _myWidget;
  _myStarted = false;
  _myFirstUpdate = true;
  _start() {
    this._myWidget = new EasyTuneWidget(this.engine);
    const params = new EasyTuneWidgetParams();
    params.myHandedness = [null, "left", "right"][this._myHandedness];
    params.myShowOnStart = this._myShowOnStart;
    params.myShowVisibilityButton = this._myShowVisibilityButton;
    params.myShowAdditionalButtons = true;
    params.myGamepadScrollVariableEnabled = this._myGamepadScrollVariableEnabled;
    params.myPlaneMaterial = Globals.getDefaultMaterials(this.engine).myFlatOpaque.clone();
    params.myTextMaterial = Globals.getDefaultMaterials(this.engine).myText.clone();
    params.myShowVariablesImportExportButtons = this._myShowVariablesImportExportButtons;
    params.myVariablesImportCallback = function(onSuccessCallback, onFailureCallback) {
      EasyTuneUtils.importVariables(this._myVariablesImportURL, this._myResetVariablesDefaultValueOnImport, false, true, onSuccessCallback, onFailureCallback, this.engine);
    }.bind(this);
    params.myVariablesExportCallback = function(onSuccessCallback, onFailureCallback) {
      if (Globals.getLeftGamepad().getButtonInfo(GamepadButtonID.SELECT).isPressed() && Globals.getLeftGamepad().getButtonInfo(GamepadButtonID.SQUEEZE).isPressed() && Globals.getLeftGamepad().getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed() && Globals.getLeftGamepad().getButtonInfo(GamepadButtonID.BOTTOM_BUTTON).isPressed() && Globals.getLeftGamepad().getButtonInfo(GamepadButtonID.THUMBSTICK).isPressed()) {
        EasyTuneUtils.clearExportedVariables(this._myVariablesExportURL, onSuccessCallback, onFailureCallback, this.engine);
      } else if (this._myKeepImportVariablesOnExport) {
        EasyTuneUtils.getImportVariablesJSON(this._myVariablesImportURL, (variablesToKeepJSON) => {
          let variablesToKeep = null;
          try {
            variablesToKeep = JSON.parse(variablesToKeepJSON);
          } catch (error4) {
          }
          EasyTuneUtils.exportVariables(this._myVariablesExportURL, this._myAvoidExportingVariablesWithValueAsDefault, variablesToKeep, onSuccessCallback, onFailureCallback, this.engine);
        }, () => {
          EasyTuneUtils.exportVariables(this._myVariablesExportURL, this._myAvoidExportingVariablesWithValueAsDefault, void 0, onSuccessCallback, onFailureCallback, this.engine);
        }, this.engine);
      } else {
        EasyTuneUtils.exportVariables(this._myVariablesExportURL, this._myAvoidExportingVariablesWithValueAsDefault, void 0, onSuccessCallback, onFailureCallback, this.engine);
      }
    }.bind(this);
    this._myWidget.start(this.object, params, Globals.getEasyTuneVariables(this.engine));
    EasyTuneUtils.addSetWidgetCurrentVariableCallback(this, (variableName) => {
      this._myWidget.setCurrentVariable(variableName);
    }, this.engine);
    EasyTuneUtils.addRefreshWidgetCallback(this, () => {
      this._myWidget.refresh();
    }, this.engine);
    this._myStarted = true;
    this._myFirstUpdate = true;
    if (!Globals.hasEasyTuneWidget(this.engine)) {
      Globals.setEasyTuneWidget(this._myWidget, this.engine);
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine) && (!Globals.hasEasyTuneWidget(this.engine) || Globals.getEasyTuneWidget(this.engine) == this._myWidget)) {
      if (this._myStarted) {
        if (this._myFirstUpdate) {
          this._myFirstUpdate = false;
          if (this._myImportVariablesOnStart) {
            EasyTuneUtils.importVariables(this._myVariablesImportURL, this._myResetVariablesDefaultValueOnImport, false, false, void 0, void 0, this.engine);
          }
        }
        this._myWidget.setActive(true);
        this._myWidget.update(dt);
      } else {
        this._start();
      }
    } else if (this._myStarted) {
      this._myWidget.setActive(false);
    }
  }
  onActivate() {
    if (this._myStarted) {
      if (!Globals.hasEasyTuneWidget(this.engine)) {
        Globals.setEasyTuneWidget(this._myWidget, this.engine);
      }
      EasyTuneUtils.addSetWidgetCurrentVariableCallback(this, (variableName) => {
        this._myWidget.setCurrentVariable(variableName);
      }, this.engine);
      EasyTuneUtils.addRefreshWidgetCallback(this, () => {
        this._myWidget.refresh();
      }, this.engine);
    }
  }
  onDeactivate() {
    if (this._myStarted) {
      this._myWidget.setActive(false);
      EasyTuneUtils.removeSetWidgetCurrentVariableCallback(this, this.engine);
      EasyTuneUtils.removeRefreshWidgetCallback(this, this.engine);
      if (Globals.getEasyTuneWidget(this.engine) == this._myWidget) {
        Globals.removeEasyTuneWidget(this.engine);
      }
    }
  }
  onDestroy() {
    if (this._myStarted) {
      this._myWidget.destroy();
    }
  }
};
__decorate12([
  property12.enum(["None", "Left", "Right"], "None")
], EasyTuneToolComponent.prototype, "_myHandedness", void 0);
__decorate12([
  property12.bool(false)
], EasyTuneToolComponent.prototype, "_myShowOnStart", void 0);
__decorate12([
  property12.bool(false)
], EasyTuneToolComponent.prototype, "_myShowVisibilityButton", void 0);
__decorate12([
  property12.bool(true)
], EasyTuneToolComponent.prototype, "_myGamepadScrollVariableEnabled", void 0);
__decorate12([
  property12.bool(false)
], EasyTuneToolComponent.prototype, "_myShowVariablesImportExportButtons", void 0);
__decorate12([
  property12.string("")
], EasyTuneToolComponent.prototype, "_myVariablesImportURL", void 0);
__decorate12([
  property12.string("")
], EasyTuneToolComponent.prototype, "_myVariablesExportURL", void 0);
__decorate12([
  property12.bool(false)
], EasyTuneToolComponent.prototype, "_myImportVariablesOnStart", void 0);
__decorate12([
  property12.bool(false)
], EasyTuneToolComponent.prototype, "_myResetVariablesDefaultValueOnImport", void 0);
__decorate12([
  property12.bool(true)
], EasyTuneToolComponent.prototype, "_myKeepImportVariablesOnExport", void 0);
__decorate12([
  property12.bool(true)
], EasyTuneToolComponent.prototype, "_myAvoidExportingVariablesWithValueAsDefault", void 0);

// dist/pp/tool/easy_tune/components/easy_tune_import_variables_component.js
import { Component as Component66, Property as Property44 } from "@wonderlandengine/api";
var EasyTuneImportVariablesComponent = class extends Component66 {
  static TypeName = "pp-easy-tune-import-variables";
  static Properties = {
    _myVariablesImportURL: Property44.string(""),
    _myResetVariablesDefaultValueOnImport: Property44.bool(true)
  };
  start() {
    this._myFirstUpdate = true;
  }
  update(dt) {
    if (this._myFirstUpdate) {
      this._myFirstUpdate = false;
      EasyTuneUtils.importVariables(this._myVariablesImportURL, this._myResetVariablesDefaultValueOnImport, false, false, void 0, void 0, this.engine);
    }
  }
};

// dist/pp/tool/easy_tune/easy_object_tuners/easy_light_attenuation.js
import { LightComponent as LightComponent3 } from "@wonderlandengine/api";
var EasyLightAttenuation = class extends EasyObjectTuner {
  constructor(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine);
  }
  _getVariableNamePrefix() {
    return "Light Attenuation ";
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneNumber(variableName, this._getDefaultValue(), null, true, 3, 0.01, 0, 1, void 0, this._myEngine);
  }
  _getObjectValue(object) {
    let attenuation = this._getDefaultValue();
    const light = object.pp_getComponent(LightComponent3);
    if (light != null) {
      attenuation = light.color[3];
    }
    return attenuation;
  }
  _getDefaultValue() {
    return 0;
  }
  _areValueEqual(first2, second) {
    return first2 == second;
  }
  _updateObjectValue(object, value) {
    const attenuation = value;
    const light = object.pp_getComponent(LightComponent3);
    if (light) {
      light.color[3] = attenuation;
    }
  }
};

// dist/pp/tool/easy_tune/easy_object_tuners/easy_light_color.js
import { LightComponent as LightComponent4 } from "@wonderlandengine/api";
var EasyLightColor = class extends EasyObjectTuner {
  _myColorModel;
  constructor(colorModel, object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine);
    this._myColorModel = colorModel;
  }
  _getVariableNamePrefix() {
    let nameFirstPart = null;
    if (this._myColorModel == ColorModel.RGB) {
      nameFirstPart = "Light RGB ";
    } else {
      nameFirstPart = "Light HSV ";
    }
    return nameFirstPart;
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneIntArray(variableName, this._getDefaultValue(), null, true, 100, 0, 255, false, void 0, this._myEngine);
  }
  _getObjectValue(object) {
    let color = null;
    const lightColor = this._getLightColor(object);
    if (lightColor) {
      if (this._myColorModel == ColorModel.RGB) {
        color = ColorUtils.colorNormalizedToInt(lightColor);
      } else {
        color = ColorUtils.colorNormalizedToInt(ColorUtils.rgbToHSV(lightColor));
      }
    } else {
      color = this._getDefaultValue();
    }
    return color;
  }
  _getDefaultValue() {
    return vec3_create();
  }
  _areValueEqual(first2, second) {
    return first2.vec_equals(second);
  }
  _updateObjectValue(object, value) {
    let color = value;
    if (this._myColorModel == 0) {
      color = ColorUtils.colorIntToNormalized(color);
    } else {
      color = ColorUtils.hsvToRGB(ColorUtils.colorIntToNormalized(color));
    }
    const light = object.pp_getComponent(LightComponent4);
    if (light != null) {
      light.color[0] = color[0];
      light.color[1] = color[1];
      light.color[2] = color[2];
    }
    if (Globals.getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && Globals.getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed() || Globals.getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && Globals.getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed()) {
      const hsvColor = ColorUtils.colorNormalizedToInt(ColorUtils.rgbToHSV(color));
      const rgbColor = ColorUtils.colorNormalizedToInt(color);
      console.log("RGB:", rgbColor.vec_toString(0), "- HSV:", hsvColor.vec_toString(0));
    }
  }
  _getLightColor(object) {
    let color = null;
    const light = object.pp_getComponent(LightComponent4);
    if (light != null) {
      color = light.color.slice();
    }
    return color;
  }
};

// dist/pp/tool/easy_tune/easy_object_tuners/easy_mesh_color.js
import { MeshComponent as MeshComponent21 } from "@wonderlandengine/api";
var EasyMeshColorColorType;
(function(EasyMeshColorColorType2) {
  EasyMeshColorColorType2[EasyMeshColorColorType2["COLOR"] = 0] = "COLOR";
  EasyMeshColorColorType2[EasyMeshColorColorType2["DIFFUSE_COLOR"] = 1] = "DIFFUSE_COLOR";
  EasyMeshColorColorType2[EasyMeshColorColorType2["AMBIENT_COLOR"] = 2] = "AMBIENT_COLOR";
  EasyMeshColorColorType2[EasyMeshColorColorType2["SPECULAR_COLOR"] = 3] = "SPECULAR_COLOR";
  EasyMeshColorColorType2[EasyMeshColorColorType2["EMISSIVE_COLOR"] = 4] = "EMISSIVE_COLOR";
  EasyMeshColorColorType2[EasyMeshColorColorType2["FOG_COLOR"] = 5] = "FOG_COLOR";
})(EasyMeshColorColorType || (EasyMeshColorColorType = {}));
var EasyMeshColor = class _EasyMeshColor extends EasyObjectTuner {
  _myColorModel;
  _myColorType;
  static _myColorVariableNames = {
    [EasyMeshColorColorType.COLOR]: "color",
    [EasyMeshColorColorType.DIFFUSE_COLOR]: "diffuseColor",
    [EasyMeshColorColorType.AMBIENT_COLOR]: "ambientColor",
    [EasyMeshColorColorType.SPECULAR_COLOR]: "specularColor",
    [EasyMeshColorColorType.EMISSIVE_COLOR]: "emissiveColor",
    [EasyMeshColorColorType.FOG_COLOR]: "fogColor"
  };
  constructor(colorModel, colorType, object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine);
    this._myColorModel = colorModel;
    this._myColorType = colorType;
  }
  _getVariableNamePrefix() {
    let nameFirstPart = null;
    if (this._myColorModel == ColorModel.RGB) {
      nameFirstPart = "Mesh RGB ";
    } else {
      nameFirstPart = "Mesh HSV ";
    }
    return nameFirstPart;
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneIntArray(variableName, this._getDefaultValue(), null, true, 100, 0, 255, false, void 0, this._myEngine);
  }
  _getObjectValue(object) {
    let color = null;
    const meshMaterial = this._getMeshMaterial(object);
    if (meshMaterial != null) {
      color = meshMaterial[_EasyMeshColor._myColorVariableNames[this._myColorType]].pp_clone();
      if (this._myColorModel == ColorModel.RGB) {
        color = ColorUtils.colorNormalizedToInt(color);
      } else {
        color = ColorUtils.colorNormalizedToInt(ColorUtils.rgbToHSV(color));
      }
    } else {
      color = this._getDefaultValue();
    }
    return color;
  }
  _getDefaultValue() {
    return vec4_create();
  }
  _areValueEqual(first2, second) {
    return first2.vec_equals(second);
  }
  _updateObjectValue(object, value) {
    let color = value;
    if (this._myColorModel == 0) {
      color = ColorUtils.colorIntToNormalized(color);
    } else {
      color = ColorUtils.hsvToRGB(ColorUtils.colorIntToNormalized(color));
    }
    const meshMaterial = this._getMeshMaterial(object);
    if (meshMaterial) {
      meshMaterial[_EasyMeshColor._myColorVariableNames[this._myColorType]] = color;
    }
    if (Globals.getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && Globals.getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed() || Globals.getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && Globals.getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed()) {
      const hsvColor = ColorUtils.colorNormalizedToInt(ColorUtils.rgbToHSV(color));
      const rgbColor = ColorUtils.colorNormalizedToInt(color);
      console.log("RGB:", rgbColor.vec_toString(0), "- HSV:", hsvColor.vec_toString(0));
    }
  }
  _getMeshMaterial(object) {
    let material = null;
    const mesh = object.pp_getComponent(MeshComponent21);
    if (mesh != null) {
      material = mesh.material;
    }
    return material;
  }
};

// dist/pp/tool/easy_tune/easy_object_tuners/easy_scale.js
var EasyScale = class extends EasyObjectTuner {
  _myLocal;
  _myScaleAsOne;
  _myStepPerSecond;
  constructor(local, scaleAsOne, stepPerSecond, object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine);
    this._myLocal = local;
    this._myScaleAsOne = scaleAsOne;
    this._myStepPerSecond = stepPerSecond;
  }
  _getVariableNamePrefix() {
    return "Scale ";
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneNumberArray(variableName, this._getDefaultValue(), null, true, 3, this._myStepPerSecond, 1e-3, void 0, this._myScaleAsOne, void 0, this._myEngine);
  }
  _getObjectValue(object) {
    return this._myLocal ? object.pp_getScaleLocal() : object.pp_getScale();
  }
  _getDefaultValue() {
    return vec3_create(1, 1, 1);
  }
  _areValueEqual(first2, second) {
    return first2.vec_equals(second);
  }
  _updateObjectValue(object, value) {
    if (this._myLocal) {
      object.pp_setScaleLocal(value);
    } else {
      object.pp_setScale(value);
    }
  }
};

// dist/pp/tool/easy_tune/easy_object_tuners/easy_transform.js
var EasyTransform = class extends EasyObjectTuner {
  _myLocal;
  _myScaleAsOne;
  _myPositionStepPerSecond;
  _myRotationStepPerSecond;
  _myScaleStepPerSecond;
  constructor(local, scaleAsOne, positionStepPerSecond, rotationStepPerSecond, scaleStepPerSecond, object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine);
    this._myLocal = local;
    this._myScaleAsOne = scaleAsOne;
    this._myPositionStepPerSecond = positionStepPerSecond;
    this._myRotationStepPerSecond = rotationStepPerSecond;
    this._myScaleStepPerSecond = scaleStepPerSecond;
  }
  _getVariableNamePrefix() {
    return "Transform ";
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneTransform(variableName, this._getDefaultValue(), null, true, this._myScaleAsOne, 3, this._myPositionStepPerSecond, this._myRotationStepPerSecond, this._myScaleStepPerSecond, void 0, this._myEngine);
  }
  _getObjectValue(object) {
    return this._myLocal ? object.pp_getTransformLocal() : object.pp_getTransform();
  }
  _getDefaultValue() {
    return mat4_create();
  }
  _areValueEqual(first2, second) {
    return first2.vec_equals(second);
  }
  _updateObjectValue(object, value) {
    if (this._myLocal) {
      object.pp_setTransformLocal(value);
    } else {
      object.pp_setTransform(value);
    }
  }
};

// dist/pp/tool/easy_tune/easy_object_tuners/easy_text_color.js
import { TextComponent as TextComponent18 } from "@wonderlandengine/api";
var EasyTextColorColorType;
(function(EasyTextColorColorType2) {
  EasyTextColorColorType2[EasyTextColorColorType2["COLOR"] = 0] = "COLOR";
  EasyTextColorColorType2[EasyTextColorColorType2["EFFECT_COLOR"] = 1] = "EFFECT_COLOR";
})(EasyTextColorColorType || (EasyTextColorColorType = {}));
var EasyTextColor = class _EasyTextColor extends EasyObjectTuner {
  _myColorModel;
  _myColorType;
  static _myColorVariableNames = {
    [EasyTextColorColorType.COLOR]: "color",
    [EasyTextColorColorType.EFFECT_COLOR]: "effectColor"
  };
  constructor(colorModel, colorType, object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine) {
    super(object, variableName, setAsWidgetCurrentVariable, useTuneTarget, engine);
    this._myColorModel = colorModel;
    this._myColorType = colorType;
  }
  _getVariableNamePrefix() {
    let nameFirstPart = null;
    if (this._myColorModel == ColorModel.RGB) {
      nameFirstPart = "Text RGB ";
    } else {
      nameFirstPart = "Text HSV ";
    }
    return nameFirstPart;
  }
  _createEasyTuneVariable(variableName) {
    return new EasyTuneIntArray(variableName, this._getDefaultValue(), null, true, 100, 0, 255, false, void 0, this._myEngine);
  }
  _getObjectValue(object) {
    let color = null;
    const textMaterial = this._getMeshMaterial(object);
    if (textMaterial != null) {
      color = textMaterial[_EasyTextColor._myColorVariableNames[this._myColorType]].pp_clone();
      if (this._myColorModel == 0) {
        color = ColorUtils.colorNormalizedToInt(color);
      } else {
        color = ColorUtils.colorNormalizedToInt(ColorUtils.rgbToHSV(color));
      }
    } else {
      color = this._getDefaultValue();
    }
    return color;
  }
  _getDefaultValue() {
    return vec4_create();
  }
  _areValueEqual(first2, second) {
    return first2.vec_equals(second);
  }
  _updateObjectValue(object, value) {
    let color = value;
    if (this._myColorModel == 0) {
      color = ColorUtils.colorIntToNormalized(color);
    } else {
      color = ColorUtils.hsvToRGB(ColorUtils.colorIntToNormalized(color));
    }
    const textMaterial = this._getMeshMaterial(object);
    if (textMaterial != null) {
      textMaterial[_EasyTextColor._myColorVariableNames[this._myColorType]] = color;
    }
    if (Globals.getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && Globals.getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed() || Globals.getLeftGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressStart() && Globals.getRightGamepad(this._myEngine).getButtonInfo(GamepadButtonID.TOP_BUTTON).isPressed()) {
      const hsvColor = ColorUtils.colorNormalizedToInt(ColorUtils.rgbToHSV(color));
      const rgbColor = ColorUtils.colorNormalizedToInt(color);
      console.log("RGB:", rgbColor.vec_toString(0), "- HSV:", hsvColor.vec_toString(0));
    }
  }
  _getMeshMaterial(object) {
    let material = null;
    const text = object.pp_getComponent(TextComponent18);
    if (text != null) {
      material = text.material;
    }
    return material;
  }
};

// dist/pp/tool/easy_tune/easy_object_tuners/components/easy_light_attenuation_component.js
import { Component as Component67, property as property13 } from "@wonderlandengine/api";
var __decorate13 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EasyLightAttenuationComponent = class extends Component67 {
  static TypeName = "pp-easy-light-attenuation";
  _myVariableName;
  _mySetAsWidgetCurrentVariable;
  _myUseTuneTarget;
  _myEasyObjectTuner = null;
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      } else {
        this._myEasyObjectTuner = new EasyLightAttenuation(this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget);
        this._myEasyObjectTuner.start();
      }
    }
  }
  onActivate() {
    if (this._myEasyObjectTuner != null) {
      this._myEasyObjectTuner.setActive(true);
    }
  }
  onDeactivate() {
    if (this._myEasyObjectTuner != null) {
      this._myEasyObjectTuner.setActive(false);
    }
  }
  getEasyObjectTuner() {
    return this._myEasyObjectTuner;
  }
  pp_clone(targetObject) {
    const clonedComponent = ComponentUtils.cloneDefault(this, targetObject);
    return clonedComponent;
  }
};
__decorate13([
  property13.string("")
], EasyLightAttenuationComponent.prototype, "_myVariableName", void 0);
__decorate13([
  property13.bool(false)
], EasyLightAttenuationComponent.prototype, "_mySetAsWidgetCurrentVariable", void 0);
__decorate13([
  property13.bool(false)
], EasyLightAttenuationComponent.prototype, "_myUseTuneTarget", void 0);

// dist/pp/tool/easy_tune/easy_object_tuners/components/easy_light_color_component.js
import { Component as Component68, property as property14 } from "@wonderlandengine/api";
var __decorate14 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EasyLightColorComponent = class extends Component68 {
  static TypeName = "pp-easy-light-color";
  _myVariableName;
  _mySetAsWidgetCurrentVariable;
  _myUseTuneTarget;
  _myColorModel;
  _myEasyObjectTuner = null;
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      } else {
        this._myEasyObjectTuner = new EasyLightColor(this._myColorModel, this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget, this.engine);
        this._myEasyObjectTuner.start();
      }
    }
  }
  onActivate() {
    if (this._myEasyObjectTuner != null) {
      this._myEasyObjectTuner.setActive(true);
    }
  }
  onDeactivate() {
    if (this._myEasyObjectTuner != null) {
      this._myEasyObjectTuner.setActive(false);
    }
  }
  getEasyObjectTuner() {
    return this._myEasyObjectTuner;
  }
  pp_clone(targetObject) {
    const clonedComponent = ComponentUtils.cloneDefault(this, targetObject);
    return clonedComponent;
  }
};
__decorate14([
  property14.string("")
], EasyLightColorComponent.prototype, "_myVariableName", void 0);
__decorate14([
  property14.bool(false)
], EasyLightColorComponent.prototype, "_mySetAsWidgetCurrentVariable", void 0);
__decorate14([
  property14.bool(false)
], EasyLightColorComponent.prototype, "_myUseTuneTarget", void 0);
__decorate14([
  property14.enum([ColorModel[ColorModel.RGB], ColorModel[ColorModel.HSV]], ColorModel[ColorModel.HSV])
], EasyLightColorComponent.prototype, "_myColorModel", void 0);

// dist/pp/tool/easy_tune/easy_object_tuners/components/easy_mesh_color_component.js
import { Component as Component69, property as property15 } from "@wonderlandengine/api";
var __decorate15 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EasyMeshColorComponent = class extends Component69 {
  static TypeName = "pp-easy-mesh-color";
  _myVariableName;
  _mySetAsWidgetCurrentVariable;
  _myUseTuneTarget;
  _myColorModel;
  _myColorType;
  _myEasyObjectTuner = null;
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      } else {
        this._myEasyObjectTuner = new EasyMeshColor(this._myColorModel, this._myColorType, this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget, this.engine);
        this._myEasyObjectTuner.start();
      }
    }
  }
  onActivate() {
    if (this._myEasyObjectTuner != null) {
      this._myEasyObjectTuner.setActive(true);
    }
  }
  onDeactivate() {
    if (this._myEasyObjectTuner != null) {
      this._myEasyObjectTuner.setActive(false);
    }
  }
  getEasyObjectTuner() {
    return this._myEasyObjectTuner;
  }
  pp_clone(targetObject) {
    const clonedComponent = ComponentUtils.cloneDefault(this, targetObject);
    return clonedComponent;
  }
};
__decorate15([
  property15.string("")
], EasyMeshColorComponent.prototype, "_myVariableName", void 0);
__decorate15([
  property15.bool(false)
], EasyMeshColorComponent.prototype, "_mySetAsWidgetCurrentVariable", void 0);
__decorate15([
  property15.bool(false)
], EasyMeshColorComponent.prototype, "_myUseTuneTarget", void 0);
__decorate15([
  property15.enum([ColorModel[ColorModel.RGB], ColorModel[ColorModel.HSV]], ColorModel[ColorModel.HSV])
], EasyMeshColorComponent.prototype, "_myColorModel", void 0);
__decorate15([
  property15.enum(["Color", "Diffuse Color", "Ambient Color", "Specular Color", "Emissive Color", "Fog Color"], "Color")
], EasyMeshColorComponent.prototype, "_myColorType", void 0);

// dist/pp/tool/easy_tune/easy_object_tuners/components/easy_scale_component.js
import { Component as Component70, property as property16 } from "@wonderlandengine/api";
var __decorate16 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EasyScaleComponent = class extends Component70 {
  static TypeName = "pp-easy-scale";
  _myVariableName;
  _mySetAsWidgetCurrentVariable;
  _myUseTuneTarget;
  _myLocal;
  /** Edit all scale values together */
  _myScaleAsOne;
  _myStepPerSecond;
  _myEasyObjectTuner = null;
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      } else {
        this._myEasyObjectTuner = new EasyScale(this._myLocal, this._myScaleAsOne, this._myStepPerSecond, this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget);
        this._myEasyObjectTuner.start();
      }
    }
  }
  onActivate() {
    if (this._myEasyObjectTuner != null) {
      this._myEasyObjectTuner.setActive(true);
    }
  }
  onDeactivate() {
    if (this._myEasyObjectTuner != null) {
      this._myEasyObjectTuner.setActive(false);
    }
  }
  getEasyObjectTuner() {
    return this._myEasyObjectTuner;
  }
  pp_clone(targetObject) {
    const clonedComponent = ComponentUtils.cloneDefault(this, targetObject);
    return clonedComponent;
  }
};
__decorate16([
  property16.string("")
], EasyScaleComponent.prototype, "_myVariableName", void 0);
__decorate16([
  property16.bool(false)
], EasyScaleComponent.prototype, "_mySetAsWidgetCurrentVariable", void 0);
__decorate16([
  property16.bool(false)
], EasyScaleComponent.prototype, "_myUseTuneTarget", void 0);
__decorate16([
  property16.bool(true)
], EasyScaleComponent.prototype, "_myLocal", void 0);
__decorate16([
  property16.bool(true)
], EasyScaleComponent.prototype, "_myScaleAsOne", void 0);
__decorate16([
  property16.float(1)
], EasyScaleComponent.prototype, "_myStepPerSecond", void 0);

// dist/pp/tool/easy_tune/easy_object_tuners/components/easy_set_tune_target_child_number_component.js
import { Component as Component71, Property as Property45 } from "@wonderlandengine/api";
var EasySetTuneTargetChildNumberComponent = class extends Component71 {
  static TypeName = "pp-easy-set-tune-target-child-number";
  static Properties = {
    _myVariableName: Property45.string(""),
    _mySetAsWidgetCurrentVariable: Property45.bool(false)
  };
  start() {
    if (Globals.isToolEnabled(this.engine)) {
      this._myEasyTuneVariableName = "Target Child ";
      if (this._myVariableName == "") {
        this._myEasyTuneVariableName = this._myEasyTuneVariableName.concat(this.object.pp_getID());
      } else {
        this._myEasyTuneVariableName = this._myEasyTuneVariableName.concat(this._myVariableName);
      }
      let childrenCount = this.object.pp_getChildren().length;
      let min = 1;
      let max = childrenCount;
      if (childrenCount == 0) {
        min = 0;
        max = 0;
      }
      this._mySetupDone = false;
      this._myEasyTuneVariable = new EasyTuneInt(this._myEasyTuneVariableName, 0, null, true, 10, min, max, void 0, this.engine);
      Globals.getEasyTuneVariables(this.engine).add(this._myEasyTuneVariable);
      this._myCurrentChildIndex = -1;
      this._myCurrentChildrenCount = childrenCount;
      this._myEasyTuneTarget = null;
    }
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (!this._mySetupDone) {
        if (Globals.hasEasyTuneWidget()) {
          if (this._mySetAsWidgetCurrentVariable) {
            EasyTuneUtils.setWidgetCurrentVariable(this._myEasyTuneVariableName, this.engine);
          }
          this._mySetupDone = true;
        }
      }
      if (Globals.getEasyTuneVariables(this.engine).isWidgetCurrentVariable(this._myEasyTuneVariable.getName())) {
        let childrenCount = this.object.pp_getChildren().length;
        if (childrenCount != this._myCurrentChildrenCount) {
          this._myCurrentChildrenCount = childrenCount;
          let min = 1;
          let max = childrenCount;
          if (childrenCount == 0) {
            min = 0;
            max = 0;
          }
          this._myEasyTuneVariable.setMin(min);
          this._myEasyTuneVariable.setMax(max);
        }
        let childIndex = this._myEasyTuneVariable.getValue();
        if (childIndex != this._myCurrentChildIndex) {
          if (childIndex == 0 && this._myCurrentChildIndex != -1) {
            if (Globals.getEasyTuneTarget(this.engine) == this._myEasyTuneTarget) {
              Globals.removeEasyTuneTarget(this.engine);
            }
            this._myEasyTuneTarget = null;
          } else if (childIndex > 0) {
            this._myEasyTuneTarget = this.object.pp_getChildren()[childIndex - 1];
            Globals.setEasyTuneTarget(this._myEasyTuneTarget, this.engine);
          }
          this._myCurrentChildIndex = childIndex;
        }
      }
    }
  }
};

// dist/pp/tool/easy_tune/easy_object_tuners/components/easy_set_tune_target_grab_component.js
import { Component as Component72 } from "@wonderlandengine/api";
var EasySetTuneTargeetGrabComponent = class extends Component72 {
  static TypeName = "pp-easy-set-tune-target-grab";
  start() {
    this._myGrabber = null;
    this._myEasyTuneTarget = null;
  }
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myGrabber == null) {
        this._myGrabber = this.object.pp_getComponent(GrabberHandComponent);
        this._myGrabber.registerThrowEventListener(this, this._onRelease.bind(this));
      }
    }
  }
  _onRelease(grabber, grabbable) {
    if (Globals.isToolEnabled(this.engine)) {
      this._myEasyTuneTarget = grabbable.object;
      Globals.setEasyTuneTarget(this._myEasyTuneTarget, this.engine);
    }
  }
  _onGrab(grabber, grabbable) {
    if (Globals.isToolEnabled(this.engine)) {
      if (Globals.getEasyTuneTarget(this.engine) == this._myEasyTuneTarget) {
        Globals.removeEasyTuneTarget(this.engine);
      }
      this._myEasyTuneTarget = null;
    }
  }
  onActivate() {
    if (this._myGrabber != null) {
      this._myGrabber.registerThrowEventListener(this, this._onRelease.bind(this));
    }
  }
  onDeactivate() {
    if (this._myGrabber != null) {
      this._myGrabber.unregisterThrowEventListener(this);
    }
  }
};

// dist/pp/tool/easy_tune/easy_object_tuners/components/easy_text_color_component.js
import { Component as Component73, property as property17 } from "@wonderlandengine/api";
var __decorate17 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EasyTextColorComponent = class extends Component73 {
  static TypeName = "pp-easy-text-color";
  _myVariableName;
  _mySetAsWidgetCurrentVariable;
  _myUseTuneTarget;
  _myColorModel;
  _myColorType;
  _myEasyObjectTuner = null;
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      } else {
        this._myEasyObjectTuner = new EasyTextColor(this._myColorModel, this._myColorType, this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget, this.engine);
        this._myEasyObjectTuner.start();
      }
    }
  }
  onActivate() {
    if (this._myEasyObjectTuner != null) {
      this._myEasyObjectTuner.setActive(true);
    }
  }
  onDeactivate() {
    if (this._myEasyObjectTuner != null) {
      this._myEasyObjectTuner.setActive(false);
    }
  }
  getEasyObjectTuner() {
    return this._myEasyObjectTuner;
  }
  pp_clone(targetObject) {
    const clonedComponent = ComponentUtils.cloneDefault(this, targetObject);
    return clonedComponent;
  }
};
__decorate17([
  property17.string("")
], EasyTextColorComponent.prototype, "_myVariableName", void 0);
__decorate17([
  property17.bool(false)
], EasyTextColorComponent.prototype, "_mySetAsWidgetCurrentVariable", void 0);
__decorate17([
  property17.bool(false)
], EasyTextColorComponent.prototype, "_myUseTuneTarget", void 0);
__decorate17([
  property17.enum([ColorModel[ColorModel.RGB], ColorModel[ColorModel.HSV]], ColorModel[ColorModel.HSV])
], EasyTextColorComponent.prototype, "_myColorModel", void 0);
__decorate17([
  property17.enum(["Color", "Effect Color"], "Color")
], EasyTextColorComponent.prototype, "_myColorType", void 0);

// dist/pp/tool/easy_tune/easy_object_tuners/components/easy_transform_component.js
import { Component as Component74, property as property18 } from "@wonderlandengine/api";
var __decorate18 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var EasyTransformComponent = class extends Component74 {
  static TypeName = "pp-easy-transform";
  _myVariableName;
  _mySetAsWidgetCurrentVariable;
  _myUseTuneTarget;
  _myLocal;
  /** Edit all scale values together */
  _myScaleAsOne;
  _myPositionStepPerSecond;
  _myRotationStepPerSecond;
  _myScaleStepPerSecond;
  _myEasyObjectTuner = null;
  update(dt) {
    if (Globals.isToolEnabled(this.engine)) {
      if (this._myEasyObjectTuner != null) {
        this._myEasyObjectTuner.update(dt);
      } else {
        this._myEasyObjectTuner = new EasyTransform(this._myLocal, this._myScaleAsOne, this._myPositionStepPerSecond, this._myRotationStepPerSecond, this._myScaleStepPerSecond, this.object, this._myVariableName, this._mySetAsWidgetCurrentVariable, this._myUseTuneTarget, this.engine);
        this._myEasyObjectTuner.start();
      }
    }
  }
  onActivate() {
    if (this._myEasyObjectTuner != null) {
      this._myEasyObjectTuner.setActive(true);
    }
  }
  onDeactivate() {
    if (this._myEasyObjectTuner != null) {
      this._myEasyObjectTuner.setActive(false);
    }
  }
  getEasyObjectTuner() {
    return this._myEasyObjectTuner;
  }
  pp_clone(targetObject) {
    const clonedComponent = ComponentUtils.cloneDefault(this, targetObject);
    return clonedComponent;
  }
};
__decorate18([
  property18.string("")
], EasyTransformComponent.prototype, "_myVariableName", void 0);
__decorate18([
  property18.bool(false)
], EasyTransformComponent.prototype, "_mySetAsWidgetCurrentVariable", void 0);
__decorate18([
  property18.bool(false)
], EasyTransformComponent.prototype, "_myUseTuneTarget", void 0);
__decorate18([
  property18.bool(true)
], EasyTransformComponent.prototype, "_myLocal", void 0);
__decorate18([
  property18.bool(true)
], EasyTransformComponent.prototype, "_myScaleAsOne", void 0);
__decorate18([
  property18.float(1)
], EasyTransformComponent.prototype, "_myPositionStepPerSecond", void 0);
__decorate18([
  property18.float(50)
], EasyTransformComponent.prototype, "_myRotationStepPerSecond", void 0);
__decorate18([
  property18.float(1)
], EasyTransformComponent.prototype, "_myScaleStepPerSecond", void 0);
export {
  AddPPToWindowComponent,
  AddWLToWindowComponent,
  AdjustHierarchyPhysXScaleComponent,
  AnalyticsManager,
  AnalyticsManagerComponent,
  AnalyticsUtils,
  AnimatedNumber,
  AnimatedNumberParams,
  ArrayExtensionUtils,
  ArrayUtils,
  AudioEvent,
  AudioManager,
  AudioManagerComponent,
  AudioPlayer,
  AudioSetup,
  AudioUtils,
  BaseConditionState,
  BasePose,
  BasePoseParams,
  BenchmarkMaxPhysXComponent,
  BenchmarkMaxVisibleTrianglesComponent,
  BranchState,
  BrowserUtils,
  CADisplayLeaderboardComponent,
  CADummyServer,
  CAError,
  CAUtils,
  CharacterColliderAdditionalParams,
  CharacterColliderDebugParams,
  CharacterColliderHorizontalCheckParams,
  CharacterColliderHorizontalPositionVerticalCheckDirection,
  CharacterColliderSetup,
  CharacterColliderSetupSimplifiedCreationAccuracyLevel,
  CharacterColliderSetupSimplifiedCreationParams,
  CharacterColliderSetupUtils,
  CharacterColliderSlideFlickerPreventionMode,
  CharacterColliderSplitMovementParams,
  CharacterColliderSurfaceParams,
  CharacterColliderVerticalCheckParams,
  CharacterColliderWallSlideParams,
  CharacterCollisionCheckTransformResults,
  CharacterCollisionCheckType,
  CharacterCollisionDebugResults,
  CharacterCollisionInternalResults,
  CharacterCollisionMovementResults,
  CharacterCollisionResults,
  CharacterCollisionSplitMovementResults,
  CharacterCollisionSurfaceInfo,
  CharacterCollisionSurfaceResults,
  CharacterCollisionSystem,
  CharacterCollisionSystemComponent,
  CharacterCollisionTeleportResults,
  CharacterCollisionTransformResults,
  CharacterCollisionWallSlideResults,
  CharacterControllerUtils,
  ClassicGamepadCore,
  ClearConsoleComponent,
  CollisionCheck,
  CollisionCheckBridge,
  CollisionCheckParams,
  CollisionCheckUtils,
  CollisionRuntimeParams,
  ColorModel,
  ColorUtils,
  ComponentCustomCloneParams,
  ComponentDeepCloneParams,
  ComponentUtils,
  ConditionState,
  ConsoleOriginalFunctions,
  ConsoleVR,
  ConsoleVRToolComponent,
  ConsoleVRWidget,
  ConsoleVRWidgetConfig,
  ConsoleVRWidgetConsoleFunction,
  ConsoleVRWidgetMessage,
  ConsoleVRWidgetMessageType,
  ConsoleVRWidgetParams,
  ConsoleVRWidgetPulseOnNewMessage,
  ConsoleVRWidgetSender,
  ConsoleVRWidgetUI,
  CopyHandTransformComponent,
  CopyHeadTransformComponent,
  CopyPlayerTransformComponent,
  CopyReferenceSpaceTransformComponent,
  CursorButtonComponent,
  DebugArrayFunctionsPerformanceAnalyzerComponent,
  DebugFunctionPerformanceAnalysisResults,
  DebugFunctionsOverwriter,
  DebugFunctionsOverwriterParams,
  DebugFunctionsPerformanceAnalysisResultsLogger,
  DebugFunctionsPerformanceAnalysisResultsLoggerParams,
  DebugFunctionsPerformanceAnalyzer,
  DebugFunctionsPerformanceAnalyzerComponent,
  DebugFunctionsPerformanceAnalyzerParams,
  DebugFunctionsPerformanceAnalyzerSortOrder,
  DebugManager,
  DebugManagerComponent,
  DebugPPArrayCreationPerformanceAnalyzerComponent,
  DebugPPFunctionsPerformanceAnalyzerComponent,
  DebugTransformComponent,
  DebugVisualManager,
  DebugWLComponentsFunctionsPerformanceAnalyzerComponent,
  DebugWLFunctionsPerformanceAnalyzerComponent,
  DefaultResources,
  DefaultResourcesMaterials,
  DefaultResourcesMeshes,
  DelayState,
  Direction2DTo3DConverter,
  Direction2DTo3DConverterParams,
  EasingFunction,
  EasingFunctionName,
  EasyActive,
  EasyActiveComponent,
  EasyLightAttenuation,
  EasyLightAttenuationComponent,
  EasyLightColor,
  EasyLightColorComponent,
  EasyMeshColor,
  EasyMeshColorColorType,
  EasyMeshColorComponent,
  EasyObjectTuner,
  EasyScale,
  EasyScaleComponent,
  EasySetTuneTargeetGrabComponent,
  EasySetTuneTargetChildNumberComponent,
  EasyTextColor,
  EasyTextColorColorType,
  EasyTextColorComponent,
  EasyTransform,
  EasyTransformComponent,
  EasyTuneBaseArrayWidgetSelector,
  EasyTuneBaseWidget,
  EasyTuneBaseWidgetConfig,
  EasyTuneBaseWidgetParams,
  EasyTuneBaseWidgetUI,
  EasyTuneBool,
  EasyTuneBoolArray,
  EasyTuneBoolArrayWidget,
  EasyTuneBoolArrayWidgetConfig,
  EasyTuneBoolArrayWidgetSelector,
  EasyTuneBoolArrayWidgetUI,
  EasyTuneImportVariablesComponent,
  EasyTuneInt,
  EasyTuneIntArray,
  EasyTuneNoneWidget,
  EasyTuneNoneWidgetConfig,
  EasyTuneNoneWidgetUI,
  EasyTuneNumber,
  EasyTuneNumberArray,
  EasyTuneNumberArrayWidget,
  EasyTuneNumberArrayWidgetConfig,
  EasyTuneNumberArrayWidgetSelector,
  EasyTuneNumberArrayWidgetUI,
  EasyTuneToolComponent,
  EasyTuneTransform,
  EasyTuneTransformWidget,
  EasyTuneTransformWidgetConfig,
  EasyTuneTransformWidgetUI,
  EasyTuneUtils,
  EasyTuneVariable,
  EasyTuneVariableArray,
  EasyTuneVariableExtraParams,
  EasyTuneVariableType,
  EasyTuneVariableTyped,
  EasyTuneVariables,
  EasyTuneWidget,
  EasyTuneWidgetConfig,
  EasyTuneWidgetParams,
  EnableDebugComponent,
  EnableToolComponent,
  FSM,
  FingerCursorComponent,
  FramesCountdownState,
  Gamepad,
  GamepadAxesEvent,
  GamepadAxesID,
  GamepadAxesInfo,
  GamepadButtonEvent,
  GamepadButtonID,
  GamepadButtonInfo,
  GamepadControlSchemeComponent,
  GamepadCore,
  GamepadMeshAnimatorComponent,
  GamepadPulseInfo,
  GamepadUtils,
  GamepadsManager,
  GetDefaultResourcesComponent,
  GetSceneObjectsComponent,
  Globals,
  GrabbableComponent,
  GrabberHandComponent,
  HandPose,
  HandPoseParams,
  HandRayPose,
  HandRayPoseParams,
  Handedness,
  HandednessIndex,
  HeadPose,
  HowlerAudioPlayer,
  InitConsoleVRComponent,
  InitEasyTuneVariablesComponent,
  InputManager,
  InputManagerComponent,
  InputSourceType,
  InputUtils,
  IntOverFactor,
  IntRangeOverFactor,
  JSUtils,
  KeyID,
  Keyboard,
  KeyboardGamepadCore,
  Mat3Utils,
  Mat4Utils,
  MaterialUtils,
  MathUtils,
  MeshCreationParams,
  MeshCreationTriangleParams,
  MeshCreationVertexParams,
  MeshUtils,
  Mouse,
  MouseButtonID,
  MuteEverythingComponent,
  NonVRReferenceSpaceMode,
  NumberOverFactor,
  NumberRangeOverFactor,
  ObjectCloneParams,
  ObjectPool,
  ObjectPoolManager,
  ObjectPoolManagerComponent,
  ObjectPoolParams,
  ObjectUtils,
  OverlapCursorComponent,
  OverrideBrowserConsoleFunctions,
  PPGatewayComponent,
  PendingPerform,
  PerformDelayedMode,
  PerformMode,
  PhysicsCollisionCollector,
  PhysicsLayerFlags,
  PhysicsUtils,
  PlayerHeadManager,
  PlayerHeadManagerParams,
  PlayerLocomotion,
  PlayerLocomotionComponent,
  PlayerLocomotionDirectionReferenceType,
  PlayerLocomotionMovement,
  PlayerLocomotionMovementRuntimeParams,
  PlayerLocomotionParams,
  PlayerLocomotionRotate,
  PlayerLocomotionRotateParams,
  PlayerLocomotionSmooth,
  PlayerLocomotionSmoothParams,
  PlayerLocomotionTeleport,
  PlayerLocomotionTeleportDetectionParams,
  PlayerLocomotionTeleportDetectionRuntimeParams,
  PlayerLocomotionTeleportDetectionState,
  PlayerLocomotionTeleportDetectionVisualizer,
  PlayerLocomotionTeleportDetectionVisualizerParams,
  PlayerLocomotionTeleportParable,
  PlayerLocomotionTeleportParams,
  PlayerLocomotionTeleportRuntimeParams,
  PlayerLocomotionTeleportState,
  PlayerLocomotionTeleportTeleportBlinkState,
  PlayerLocomotionTeleportTeleportParams,
  PlayerLocomotionTeleportTeleportShiftState,
  PlayerLocomotionTeleportTeleportState,
  PlayerLocomotionTeleportTeleportType,
  PlayerLocomotionType,
  PlayerObjects,
  PlayerObscureManager,
  PlayerObscureManagerParams,
  PlayerTransformManager,
  PlayerTransformManagerParams,
  PlayerTransformManagerSyncFlag,
  PluginUtils,
  Quat2Utils,
  QuatUtils,
  RaycastBlockColliderType,
  RaycastHit,
  RaycastParams,
  RaycastResults,
  ResetLocalTransformComponent,
  SaveManager,
  SaveManagerComponent,
  SaveUtils,
  ScaleOnSpawnComponent,
  SceneObjects,
  SetActiveComponent,
  SetEngineLogLevelComponent,
  SetHandLocalTransformComponent,
  SetHandRayLocalTransformComponent,
  SetHeadLocalTransformComponent,
  SetPlayerHeightComponent,
  SetTrackedHandJointLocalTransformComponent,
  ShowFPSComponent,
  ShowXRButtonsComponent,
  SkipStateFunction,
  SpatialAudioListenerComponent,
  StateData,
  SwitchHandObjectComponent,
  TextUtils,
  Timer,
  TimerState,
  ToggleActiveOnButtonPressComponent,
  ToolCursorComponent,
  ToolHandedness,
  ToolInputSourceType,
  TrackedHandDrawAllJointsComponent,
  TrackedHandDrawJointComponent,
  TrackedHandDrawSkinComponent,
  TrackedHandJointID,
  TrackedHandJointIDIndex,
  TrackedHandJointPose,
  TrackedHandPose,
  TrackedHandPoseParams,
  TransitionData,
  UniversalGamepad,
  Vec2Utils,
  Vec3Utils,
  Vec4Utils,
  VecAllocationUtils,
  VecUtils,
  VirtualGamepad,
  VirtualGamepadAxesID,
  VirtualGamepadButtonID,
  VirtualGamepadButtonParams,
  VirtualGamepadComponent,
  VirtualGamepadGamepadCore,
  VirtualGamepadIcon,
  VirtualGamepadIconParams,
  VirtualGamepadIconType,
  VirtualGamepadParams,
  VirtualGamepadThumbstickParams,
  VirtualGamepadVirtualButton,
  VirtualGamepadVirtualThumbstick,
  VisualArrow,
  VisualArrowParams,
  VisualElementDefaultType,
  VisualLine,
  VisualLineParams,
  VisualManager,
  VisualManagerComponent,
  VisualMesh,
  VisualMeshParams,
  VisualPoint,
  VisualPointParams,
  VisualRaycast,
  VisualRaycastParams,
  VisualResources,
  VisualResourcesMaterials,
  VisualText,
  VisualTextParams,
  VisualTorus,
  VisualTorusParams,
  VisualTransform,
  VisualTransformParams,
  WLComponentDefaultCloneCallbacks,
  WLCursorTargetWrapperComponent,
  WaveFunction,
  WidgetFrame,
  WidgetFrameConfig,
  WidgetFrameUI,
  WidgetParams,
  XRGamepadCore,
  XRUtils,
  mat3_create,
  mat3_getAllocationFunction,
  mat3_setAllocationFunction,
  mat4_create,
  mat4_getAllocationFunction,
  mat4_setAllocationFunction,
  quat2_create,
  quat2_getAllocationFunction,
  quat2_setAllocationFunction,
  quat_create,
  quat_getAllocationFunction,
  quat_setAllocationFunction,
  registerPPComponents,
  registerWLComponents,
  vec2_create,
  vec2_getAllocationFunction,
  vec2_setAllocationFunction,
  vec3_create,
  vec3_getAllocationFunction,
  vec3_setAllocationFunction,
  vec4_create,
  vec4_getAllocationFunction,
  vec4_setAllocationFunction,
  vec_create,
  vec_getAllocationFunction,
  vec_setAllocationFunction
};
//# sourceMappingURL=bundle.js.map
